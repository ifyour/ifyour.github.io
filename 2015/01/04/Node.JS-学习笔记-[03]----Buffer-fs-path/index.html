<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="theme-color" content="#ffffff"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="apple-mobile-web-app-title" content="Ifyour's Blog"><meta name="msapplication-TileImage" content="/img/webAppIcon-256x256.png"><meta name="msapplication-TileColor" content="#000"><meta property="algolia:search" data-application-id="3XQ5CPDDMK" data-api-key="abe9e26eebcac723f34ade5cf6b97441" data-index-name="prod_blog"><title>Node.JS 学习笔记 [03] -- Buffer fs path · Ifyour's Blog</title><meta name="description" content="Node.JS 学习笔记 [03] -- Buffer fs path - Ifyour"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="manifest" href="/manifest.json"><link rel="icon" type="image/x-icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="apple-touch-icon" size="256x256" href="/img/webAppIcon-256x256.png"><link rel="apple-touch-icon" size="512x512" href="/img/webAppIcon-512x512.png"><link rel="apple-touch-startup-image" href="/img/apple-launch-750x1334.png"><link rel="preload" href="/css/apollo.css" as="style"><link rel="preload" href="/js/main.js" as="script"><link rel="search" type="application/opensearchdescription+xml" href="http://ifyour.github.io/atom.xml" title="Ifyour's Blog"></head><body><div class="search"><a href="javascript:;" target="_self" class="close"><svg id="icon-close" viewbox="0 0 16 16" width="24" height="24" fill="#A4A9AC"><path d="M8,15 C4.13400675,15 1,11.8659932 1,8 C1,4.13400675 4.13400675,1 8,1 C11.8659932,1 15,4.13400675 15,8 C15,11.8659932 11.8659932,15 8,15 Z M10.44352,10.7233105 L10.4528296,10.7326201 L10.7326201,10.4528296 C11.0310632,10.1543865 11.0314986,9.66985171 10.7335912,9.37194437 L9.36507937,8.0034325 L10.7360526,6.63245928 C11.0344957,6.33401613 11.0349311,5.84948135 10.7370237,5.55157401 L10.448426,5.26297627 C10.1505186,4.96506892 9.66598387,4.96550426 9.36754072,5.26394741 L8.00589385,6.62559428 L6.63738198,5.25708241 C6.33947464,4.95917507 5.85493986,4.95961041 5.55649671,5.25805356 L5.26737991,5.54717036 C4.96893676,5.84561351 4.96850142,6.33014829 5.26640876,6.62805563 L6.62561103,7.9872579 L5.25463781,9.35823112 C4.95619466,9.65667427 4.95575932,10.141209 5.25366666,10.4391164 L5.5422644,10.7277141 C5.84017175,11.0256215 6.32470652,11.0251861 6.62314967,10.726743 L7.99412289,9.35576976 L9.36263476,10.7242816 C9.66054211,11.022189 10.1450769,11.0217536 10.44352,10.7233105 Z"/></svg></a><div class="container"><input id="search-input" autocomplete="off" type="text" placeholder="Type to search" class="search-input"><div class="search-by">Search by<a href="https://www.algolia.com/" target="_blank"> algolia</a></div><div class="search-results"><div id="search-articles" class="search-item"></div></div></div><script id="search-tmp" type="text/html">{{if list.length}}
    <h3>ARTICLES</h3>
    <ul>
        {{each list item}}
        <li>
            <div class="search-item-title">
                <a href="{{item.permalink}}">{{@item.title}}</a>
            </div>
            <div class="search-item-summary" style="-webkit-box-orient: vertical;">
                {{@item.summary}}
            </div>
        </li>
        {{/each}}
    </ul>
{{else if list}}
    <h2>
        Oops! no result,
        Try it on <a target="_blank" style="color: #2c3e50; border-bottom: 2px solid #42b983; font-size: 19px;" href="https://www.google.com/search?q=site%3Aifyour.github.io+{{keywords}}">Google: {{keywords}}</a>~ 😱
    </h2>
{{/if}}</script></div><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/docs/" target="_self" class="nav-list-link">DOCS</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="javascript:;" target="_self" id="search" class="nav-list-link">SEARCH</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Node.JS 学习笔记 [03] -- Buffer fs path</h1><div class="post-info">Jan 4, 2015</div><div class="sidebar-toc"><span>Catalog</span><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#缓冲区-Buffer"><span class="toc-text">缓冲区 (Buffer)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#创建-Buffer-类"><span class="toc-text">创建 Buffer 类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#写入缓冲区"><span class="toc-text">写入缓冲区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#缓冲区读取"><span class="toc-text">缓冲区读取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#缓冲区拷贝"><span class="toc-text">缓冲区拷贝</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文件系统-fs"><span class="toc-text">文件系统 (fs)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#文件读写方式"><span class="toc-text">文件读写方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#流读写方式"><span class="toc-text">流读写方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#管道流读写"><span class="toc-text">管道流读写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#链式流读写"><span class="toc-text">链式流读写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#文件、文件夹删除"><span class="toc-text">文件、文件夹删除</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#路径-path"><span class="toc-text">路径 (path)</span></a></li></ol></div><div class="post-content"><p>今天学习了 Node.js 的缓冲区（Buffer）、文件系统（fs）、路径（path）模块，感受了一下 Node.js 作为 JavaScript 的扩展在后台方面的一些功能。给我最多的感受是，大量的异步代码和回调函数，让 Node.js 性能非常出色。来总结下今天学习的内容吧。<br><a id="more"></a></p>
<h3 id="缓冲区-Buffer"><a href="#缓冲区-Buffer" class="headerlink" title="缓冲区 (Buffer)"></a>缓冲区 (Buffer)</h3><p>JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。但在处理像 TCP 流或文件流时，必须使用到二进制数据。因此在 Node.js 中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。按照我的理解，Buffer 类很像我们的整数数组。有对应的索引，存储方式也和数组类似。来看看 Buffer 类是如何创建的。</p>
<h4 id="创建-Buffer-类"><a href="#创建-Buffer-类" class="headerlink" title="创建 Buffer 类"></a>创建 Buffer 类</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法1</span></span><br><span class="line"><span class="comment">// 创建长度为10字节的 Buffer 类</span></span><br><span class="line"><span class="keyword">var</span> buf = <span class="keyword">new</span> Buffer(<span class="number">10</span>); <span class="comment">// 构造函数，注意这种创建形式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2</span></span><br><span class="line"><span class="comment">// 直接通过数组赋值的形式创建</span></span><br><span class="line"><span class="keyword">var</span> buf2 = <span class="keyword">new</span> Buffer([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法3</span></span><br><span class="line"><span class="comment">// 通过字符串来创建</span></span><br><span class="line"><span class="keyword">var</span> buf3 = <span class="keyword">new</span> Buffer(<span class="string">'ifyour'</span>,<span class="string">'utf-8'</span>);<span class="comment">// utf-8 默认编码，可以省略</span></span><br></pre></td></tr></table></figure>
<p>从代码我们可以看出这个 Buffer 类是一个构造函数，通过实例化一个 Buffer 对象，让它具有一些 Buffer 类的方法，总得来说常用的方法有下面三种。</p>
<h4 id="写入缓冲区"><a href="#写入缓冲区" class="headerlink" title="写入缓冲区"></a>写入缓冲区</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法：  buf.write(string[, offset[, length]][, encoding])</span></span><br><span class="line"><span class="comment">// 实例：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b4 = <span class="keyword">new</span> Buffer(<span class="number">14</span>);</span><br><span class="line">len = b4.write(<span class="string">'this is buffer'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Buffer 写入了 '</span> + len + <span class="string">' 字节，内容为：'</span> + b4.toString());</span><br><span class="line"><span class="comment">// Buffer 写入了 14字节，内容为：this is buffer</span></span><br></pre></td></tr></table></figure>
<h4 id="缓冲区读取"><a href="#缓冲区读取" class="headerlink" title="缓冲区读取"></a>缓冲区读取</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法： buf.toString([encoding[, start[, end]]])</span></span><br><span class="line"><span class="comment">// 实例：</span></span><br><span class="line">buf = <span class="keyword">new</span> Buffer(<span class="number">26</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; i++) &#123;</span><br><span class="line">  buf[i] = i + <span class="number">97</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( buf.toString(<span class="string">'ascii'</span>));       <span class="comment">// 输出: abcdefghijklmnopqrstuvwxyz</span></span><br><span class="line"><span class="built_in">console</span>.log( buf.toString(<span class="string">'ascii'</span>,<span class="number">0</span>,<span class="number">5</span>));   <span class="comment">// 输出: abcde</span></span><br><span class="line"><span class="built_in">console</span>.log( buf.toString(<span class="string">'utf8'</span>,<span class="number">0</span>,<span class="number">5</span>));    <span class="comment">// 输出: abcde</span></span><br><span class="line"><span class="built_in">console</span>.log( buf.toString(<span class="literal">undefined</span>,<span class="number">0</span>,<span class="number">5</span>)); <span class="comment">// 使用 'utf8' 编码, 并输出: abcde</span></span><br></pre></td></tr></table></figure>
<h4 id="缓冲区拷贝"><a href="#缓冲区拷贝" class="headerlink" title="缓冲区拷贝"></a>缓冲区拷贝</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法： buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]])</span></span><br><span class="line"><span class="comment">//实例：</span></span><br><span class="line"><span class="keyword">var</span> b5 = <span class="keyword">new</span> Buffer([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]);</span><br><span class="line"><span class="keyword">var</span> b6 = <span class="keyword">new</span>  Buffer(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">b5.copy(b6,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>);<span class="comment">// 把 b5 中的索引 0-2 （不包括2） 的值复制给 b6 的第 1 位置</span></span><br><span class="line"><span class="built_in">console</span>.log(b6);</span><br></pre></td></tr></table></figure>
<h3 id="文件系统-fs"><a href="#文件系统-fs" class="headerlink" title="文件系统 (fs)"></a>文件系统 (fs)</h3><p>Node.js 文件系统（fs 模块）模块中的方法均有异步和同步版本，例如读取文件内容的函数有异步的 <code>fs.readFile()</code> 和同步的 <code>fs.readFileSync()</code>。异步的方法函数最后一个参数为回调函数，回调函数的第一个参数包含了错误信息 (error)。相比同步，异步效率更高，性能更好，没有阻塞，但是在实际使用中，一定要处理好先后顺序。</p>
<h4 id="文件读写方式"><a href="#文件读写方式" class="headerlink" title="文件读写方式"></a>文件读写方式</h4><p>文件读取方式，举个简单例子，好比先把整个数据源完整拿出来放到内存中，再使用 <code>writeFile</code> 方法或 <code>writeFileSync</code> 方法写入文件内容。显然，如果数据源非常大（10GB）使用这种方式，效率就很低了。说不定就死机了。:) 这时候，就需要下一节讲到的 <strong><em>流读取</em></strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// data.txt</span><br><span class="line">Hello,Node.js!</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步读取</span></span><br><span class="line">fs.readFile(<span class="string">'data.txt'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (err) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"异步读取: "</span> + data.toString());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步读取</span></span><br><span class="line"><span class="keyword">var</span> data = fs.readFileSync(<span class="string">'data.txt'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"同步读取: "</span> + data.toString());</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"程序执行完毕。"</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">同步读取: Hello,Node.js!</span><br><span class="line">程序执行完毕。</span><br><span class="line"></span><br><span class="line">异步读取: Hello,Node.js!</span><br></pre></td></tr></table></figure>
<div class="tip"><br>Node.js 中，先执行同步代码，后执行异步代码，异步代码会将回调函数放入调用 <strong><em>队列</em></strong>，以 <strong><em>先进先出</em></strong> 的形式依次调用。<br></div>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="comment">// 异步写入</span></span><br><span class="line">fs.writeFile(<span class="string">'./data/d2.txt'</span>,<span class="string">'我是一条数据'</span>,<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'文件写入成功'</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'写入失败'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步写入</span></span><br><span class="line">fs.writeFileSync(<span class="string">'./data/d3'</span>,<span class="string">'我是一条数据'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data = fs.readFileSync(<span class="string">'./data/d3'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(data.toString());<span class="comment">// 我是一条数据</span></span><br></pre></td></tr></table></figure>
<h4 id="流读写方式"><a href="#流读写方式" class="headerlink" title="流读写方式"></a>流读写方式</h4><p>应用程序中，流是一组有序的、有起点和终点的 <strong><em>字节数据的传输方式</em></strong>。在应用程序中各种对象之间交换与传输数据的时候，总是先将该对象中所包含的数据转换为各种形式的流数据（即字节数据），再通过流的传输，到达目的对象后再将流数据转换为该对象中可以使用的数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> data = <span class="string">''</span>;</span><br><span class="line"><span class="comment">// 流读取</span></span><br><span class="line"><span class="keyword">var</span> stream = fs.createReadStream(<span class="string">'./data/d1.txt'</span>,<span class="string">'utf-8'</span>);</span><br><span class="line">stream.on(<span class="string">'data'</span>,<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    data += result;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// data end 事件表示连贯的行为，字节流需要起点和终点。</span></span><br><span class="line">stream.on(<span class="string">'end'</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">stream.on(<span class="string">'error'</span>,<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err.stack);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 流写入</span></span><br><span class="line"><span class="keyword">var</span> stream = fs.createWriteStream(<span class="string">'./data/123.txt'</span>,<span class="string">'utf-8'</span>);</span><br><span class="line">stream.write(<span class="string">'hello'</span>,<span class="string">'utf-8'</span>);</span><br><span class="line"></span><br><span class="line">stream.end();</span><br><span class="line"></span><br><span class="line">stream.on(<span class="string">'finish'</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="comment">// finish 事件触发，必须等 end 事件结束才可以</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'写入完成！'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">stream.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err.stack);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<div class="tip"><br>流读取会依次触发事件： data -&gt; end -&gt; error ,每个事件发生会有对应的回调函数处理。<br>流写入会依次触发事件： end -&gt; finish -&gt; error ,每个事件发生会有对应的回调函数处理。<br></div>

<h4 id="管道流读写"><a href="#管道流读写" class="headerlink" title="管道流读写"></a>管道流读写</h4><p>管道(pipe) 提供了一个输出流到输入流的机制。通常我们用于从一个流中获取数据并将数据传递到另外一个流中。通过管道，我们就可以实现大文件流入另外一个文件的复制过程。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> readStream = fs.createReadStream(<span class="string">'./data/d1.txt'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> writeStrem = fs.createWriteStream(<span class="string">'./data/d3.txt'</span>);</span><br><span class="line"></span><br><span class="line">readStream.pipe(writeStrem);<span class="comment">// 实现了 d1.txt 到 d3.txt 的传输过程</span></span><br></pre></td></tr></table></figure></p>
<h4 id="链式流读写"><a href="#链式流读写" class="headerlink" title="链式流读写"></a>链式流读写</h4><p>链式是通过连接输出流到另外一个流并创建多个对个流操作链的机制。链式流一般用于管道操作。接下来我们就是用管道和链式来压缩和解压文件。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compress.js</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> zlib = <span class="built_in">require</span>(<span class="string">'zlib'</span>); <span class="comment">// 引入压缩模块</span></span><br><span class="line"></span><br><span class="line">fs.createReadStream(<span class="string">'./data/123.txt'</span>)</span><br><span class="line">    .pipe(zlib.createGzip())</span><br><span class="line">    .pipe(fs.createWriteStream(<span class="string">'./data/123.txt.gz'</span>));<span class="comment">// 链式操作</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'文件压缩完成'</span>);</span><br></pre></td></tr></table></figure></p>
<h4 id="文件、文件夹删除"><a href="#文件、文件夹删除" class="headerlink" title="文件、文件夹删除"></a>文件、文件夹删除</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="comment">// 文件目录读取，返回一个数组，包含文件及文件夹</span></span><br><span class="line">fs.readdir(<span class="string">"./testdir"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,files</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(files);<span class="comment">// [ 'index.html', 'main.css', 'subdir' ]</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件删除</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"准备删除文件！"</span>);</span><br><span class="line">fs.unlink(<span class="string">'./data/123.txt.gz'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"文件删除成功！"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空文件夹删除</span></span><br><span class="line">fs.rmdir(<span class="string">'./data'</span>,<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'删除成功！'</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>一个递归删除的小练习，把前面的综合运用一下。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">delDir(<span class="string">'./testdir'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入一个文件夹路径，删除掉该文件夹所有内容</span></span><br><span class="line"><span class="comment">// @param pathStr string 传入一个路径</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delDir</span>(<span class="params">pathStr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line">    <span class="keyword">if</span> (fs.existsSync(pathStr))&#123;</span><br><span class="line">        <span class="keyword">var</span> files = fs.readdirSync(pathStr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; files.length; i++) &#123;</span><br><span class="line">            <span class="keyword">var</span> curPath = pathStr + <span class="string">'/'</span> + files[i];</span><br><span class="line">            <span class="keyword">var</span> stats = fs.statSync(curPath);</span><br><span class="line">            <span class="keyword">if</span> (stats.isFile())&#123;</span><br><span class="line">                fs.unlink(curPath);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(stats.isDirectory())&#123;</span><br><span class="line">                delDir(curPath);<span class="comment">// 递归调用，最终删除掉所有文件，只剩空目录</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fs.rmdirSync(pathStr);<span class="comment">// 收尾，删掉空目录</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'文件夹不存在'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<div class="tip"><br>文件、文件夹的操作，都有同步和异步的代码，比如 <code>fs.unlink()</code> 和 <code>fs.unlinkSync()</code>,默认都是异步代码，异步代码会调用回调函数进行操作，同步代码会返回一个对象，进行后续的操作，可以认真观察上面代码的区别。使用异步代码的时候，一定注意执行顺序。<br></div>


<h3 id="路径-path"><a href="#路径-path" class="headerlink" title="路径 (path)"></a>路径 (path)</h3><p>path 模块包含一套用于 <strong><em>处理和转换文件路径</em></strong> 的工具集，用于处理目录的对象，提高开发效率。用 Node.js 的 path 命令，与使用 Linux 下的 shell 脚本命令相似。几乎所有的方法仅对字符串进行转换，文件系统是不会检查路径是否真实有效。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入path对象</span></span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 格式化路径  path.normalize(p)</span></span><br><span class="line"><span class="comment">* 特点：将不符合规范的路径格式化，简化开发人员中处理各种复杂的路径判断</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">path.normalize(<span class="string">'/foo/bar//baz/asdf/quux/..'</span>);</span><br><span class="line"><span class="comment">// returns</span></span><br><span class="line"><span class="string">'/foo/bar/baz/asdf'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 路径联合 path.join([path1], [path2], [...])</span></span><br><span class="line"><span class="comment">* 特点：将所有名称用path.seq串联起来，然后用normailze格式化</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">path.join(<span class="string">'///foo'</span>, <span class="string">'bar'</span>, <span class="string">'//baz/asdf'</span>, <span class="string">'quux'</span>, <span class="string">'..'</span>);</span><br><span class="line"><span class="comment">// returns</span></span><br><span class="line"><span class="string">'/foo/bar/baz/asdf'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 路径寻航 path.resolve([from ...], to)</span></span><br><span class="line"><span class="comment">* 特点：相当于不断的调用系统的cd命令</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">path.resolve(<span class="string">'foo/bar'</span>, <span class="string">'/tmp/file/'</span>, <span class="string">'..'</span>, <span class="string">'a/../subfile'</span>);</span><br><span class="line"><span class="comment">// 相当于终端命令：</span></span><br><span class="line"><span class="comment">// cd foo/bar</span></span><br><span class="line"><span class="comment">// cd /tmp/file/</span></span><br><span class="line"><span class="comment">// cd ..</span></span><br><span class="line"><span class="comment">// cd a/../subfile</span></span><br><span class="line"><span class="comment">// pwd</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 相对路径 path.relative(from, to)</span></span><br><span class="line"><span class="comment">* 特点：返回某个路径下相对于另一个路径的相对位置串，</span></span><br><span class="line"><span class="comment">* 相当于：path.resolve(from, path.relative(from, to)) == path.resolve(to)</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="comment">//简单理解： 地址一执行怎样的 shell 命令，到达地址二</span></span><br><span class="line">path.relative(<span class="string">'/data/orandea/test/aaa'</span>, <span class="string">'/data/orandea/impl/bbb'</span>)</span><br><span class="line"><span class="comment">// returns</span></span><br><span class="line"><span class="string">'../../impl/bbb'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 文件夹名称 path.dirname(p)</span></span><br><span class="line"><span class="comment">* 特点：返回路径的上级路径</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">path.dirname(<span class="string">'/foo/bar/baz/asdf/quux'</span>)</span><br><span class="line"><span class="comment">// returns</span></span><br><span class="line"><span class="string">'/foo/bar/baz/asdf'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 文件名称 path.basename(p, [ext])</span></span><br><span class="line"><span class="comment">* 特点：返回指定的文件名，返回结果可去掉[ext]后缀字符串</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">path.basename(<span class="string">'/foo/bar/baz/asdf/quux.html'</span>)</span><br><span class="line"><span class="comment">// returns</span></span><br><span class="line"><span class="string">'quux.html'</span></span><br><span class="line"></span><br><span class="line">path.basename(<span class="string">'/foo/bar/baz/asdf/quux.html'</span>, <span class="string">'.html'</span>)</span><br><span class="line"><span class="comment">// returns</span></span><br><span class="line"><span class="string">'quux'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 扩展名称 path.extname(p)</span></span><br><span class="line"><span class="comment">* 特点：返回指定文件名的扩展名称</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">path.extname(<span class="string">'index.html'</span>)</span><br><span class="line"><span class="comment">// returns</span></span><br><span class="line"><span class="string">'.html'</span></span><br><span class="line"></span><br><span class="line">path.extname(<span class="string">'index.'</span>)</span><br><span class="line"><span class="comment">// returns</span></span><br><span class="line"><span class="string">'.'</span></span><br><span class="line"></span><br><span class="line">path.extname(<span class="string">'index'</span>)</span><br><span class="line"><span class="comment">// returns</span></span><br><span class="line"><span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 路径分隔符 path.sep</span></span><br><span class="line"><span class="comment">* 特点：获取文件路径的分隔符，主要是与操作系统相关</span></span><br><span class="line"><span class="comment">* 注意调用方式</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="string">'foo/bar/baz'</span>.split(path.sep)</span><br><span class="line"><span class="comment">// returns</span></span><br><span class="line">[<span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'baz'</span>]</span><br></pre></td></tr></table></figure></p>
</div></article></div></main><footer><div class="paginator"><a href="/2015/01/05/Node.JS-学习笔记-[04]----HTTP/" class="prev">PREV</a><a href="/2015/01/03/Node.JS-学习笔记-[02]----同步异步/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2019 Made with <span>❤</span> by <a href="https://github.com/ifyour/ifyour.github.io">Ifyour</a></p><p>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div><script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.4.0/lib/darkmode-js.min.js"></script><script>new Darkmode({
    bottom: '1rem',
    right: '1rem',
    left: 'unset',
    time: '0.5s',
    mixColor: '#fff',
    backgroundColor: '#fff',
    buttonColorDark: '#100f2c',
    buttonColorLight: '#fff',
    saveInCookies: true,
    label: '🌓',
    autoMatchOsTheme: true
}).showWidget();
</script><script src="/js/algoliasearch.min.js"></script><script src="/js/template-web.min.js"></script><script src="/js/main.js"></script><script src="https://unpkg.com/medium-zoom@0/dist/medium-zoom.min.js"></script><script>mediumZoom('article img', {margin: 24});
(function(win, targetElem) {
    if (!targetElem) return;
    win.onscroll = (function() {
        if (isElementInViewport(targetElem)) {
            win.onscroll = null;
            return mediumZoom('.gitment-comment-main img', {margin: 24});
        }
        return arguments.callee;
    })();
    function isElementInViewport(el) {
        var rect = el.getBoundingClientRect();
        var winH = win.innerHeight || document.documentElement.clientHeight;
        return rect.top <= winH && rect.bottom >= winH;
    };
})(this, document.querySelector('#gc_container'));
</script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-120929321-1",'auto');ga('send','pageview');</script></footer></div><script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>