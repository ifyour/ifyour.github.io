<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Node.JS 学习笔记 [03] -- Buffer fs path · Ifyour's Blog</title><meta name="description" content="Node.JS 学习笔记 [03] -- Buffer fs path - Ifyour"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://ifyour.github.io/atom.xml" title="Ifyour's Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://twitter.com/JohnWmm/" target="_blank" class="nav-list-link">TWITTER</a></li><li class="nav-list-item"><a href="https://github.com/ifyour/" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Node.JS 学习笔记 [03] -- Buffer fs path</h1><div class="post-info">Dec 30, 2015</div><div class="post-content"><p>今天学习了 Node.js 的缓冲区（Buffer）、文件系统（fs）、路径（path）模块，感受了一下 Node.js 作为 JavaScript 的扩展在后台方面的一些功能。给我最多的感受是，大量的异步代码和回调函数，让 Node.js 性能非常出色。来总结下今天学习的内容吧。<br><a id="more"></a></p>
<h3 id="缓冲区-Buffer"><a href="#缓冲区-Buffer" class="headerlink" title="缓冲区 (Buffer)"></a>缓冲区 (Buffer)</h3><p>JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。但在处理像 TCP 流或文件流时，必须使用到二进制数据。因此在 Node.js 中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。按照我的理解，Buffer 类很像我们的整数数组。有对应的索引，存储方式也和数组类似。来看看 Buffer 类是如何创建的。</p>
<h4 id="创建-Buffer-类"><a href="#创建-Buffer-类" class="headerlink" title="创建 Buffer 类"></a>创建 Buffer 类</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 方法1</span></div><div class="line"><span class="comment">// 创建长度为10字节的 Buffer 类</span></div><div class="line"><span class="keyword">var</span> buf = <span class="keyword">new</span> Buffer(<span class="number">10</span>); <span class="comment">// 构造函数，注意这种创建形式</span></div><div class="line"></div><div class="line"><span class="comment">// 方法2</span></div><div class="line"><span class="comment">// 直接通过数组赋值的形式创建</span></div><div class="line"><span class="keyword">var</span> buf2 = <span class="keyword">new</span> Buffer([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]);</div><div class="line"></div><div class="line"><span class="comment">// 方法3</span></div><div class="line"><span class="comment">// 通过字符串来创建</span></div><div class="line"><span class="keyword">var</span> buf3 = <span class="keyword">new</span> Buffer(<span class="string">'ifyour'</span>,<span class="string">'utf-8'</span>);<span class="comment">// utf-8 默认编码，可以省略</span></div></pre></td></tr></table></figure>
<p>从代码我们可以看出这个 Buffer 类是一个构造函数，通过实例化一个 Buffer 对象，让它具有一些 Buffer 类的方法，总得来说常用的方法有下面三种。</p>
<h4 id="写入缓冲区"><a href="#写入缓冲区" class="headerlink" title="写入缓冲区"></a>写入缓冲区</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 语法：  buf.write(string[, offset[, length]][, encoding])</span></div><div class="line"><span class="comment">// 实例：</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> b4 = <span class="keyword">new</span> Buffer(<span class="number">14</span>);</div><div class="line">len = b4.write(<span class="string">'this is buffer'</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Buffer 写入了 '</span> + len + <span class="string">' 字节，内容为：'</span> + b4.toString());</div><div class="line"><span class="comment">// Buffer 写入了 14字节，内容为：this is buffer</span></div></pre></td></tr></table></figure>
<h4 id="缓冲区读取"><a href="#缓冲区读取" class="headerlink" title="缓冲区读取"></a>缓冲区读取</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 语法： buf.toString([encoding[, start[, end]]])</span></div><div class="line"><span class="comment">// 实例：</span></div><div class="line">buf = <span class="keyword">new</span> Buffer(<span class="number">26</span>);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; i++) &#123;</div><div class="line">  buf[i] = i + <span class="number">97</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log( buf.toString(<span class="string">'ascii'</span>));       <span class="comment">// 输出: abcdefghijklmnopqrstuvwxyz</span></div><div class="line"><span class="built_in">console</span>.log( buf.toString(<span class="string">'ascii'</span>,<span class="number">0</span>,<span class="number">5</span>));   <span class="comment">// 输出: abcde</span></div><div class="line"><span class="built_in">console</span>.log( buf.toString(<span class="string">'utf8'</span>,<span class="number">0</span>,<span class="number">5</span>));    <span class="comment">// 输出: abcde</span></div><div class="line"><span class="built_in">console</span>.log( buf.toString(<span class="literal">undefined</span>,<span class="number">0</span>,<span class="number">5</span>)); <span class="comment">// 使用 'utf8' 编码, 并输出: abcde</span></div></pre></td></tr></table></figure>
<h4 id="缓冲区拷贝"><a href="#缓冲区拷贝" class="headerlink" title="缓冲区拷贝"></a>缓冲区拷贝</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//语法： buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]])</span></div><div class="line"><span class="comment">//实例：</span></div><div class="line"><span class="keyword">var</span> b5 = <span class="keyword">new</span> Buffer([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]);</div><div class="line"><span class="keyword">var</span> b6 = <span class="keyword">new</span>  Buffer(<span class="number">5</span>);</div><div class="line"></div><div class="line">b5.copy(b6,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>);<span class="comment">// 把 b5 中的索引 0-2 （不包括2） 的值复制给 b6 的第 1 位置</span></div><div class="line"><span class="built_in">console</span>.log(b6);</div></pre></td></tr></table></figure>
<h3 id="文件系统-fs"><a href="#文件系统-fs" class="headerlink" title="文件系统 (fs)"></a>文件系统 (fs)</h3><p>Node.js 文件系统（fs 模块）模块中的方法均有异步和同步版本，例如读取文件内容的函数有异步的 <code>fs.readFile()</code> 和同步的 <code>fs.readFileSync()</code>。异步的方法函数最后一个参数为回调函数，回调函数的第一个参数包含了错误信息 (error)。相比同步，异步效率更高，性能更好，没有阻塞，但是在实际使用中，一定要处理好先后顺序。</p>
<h4 id="文件读写方式"><a href="#文件读写方式" class="headerlink" title="文件读写方式"></a>文件读写方式</h4><p>文件读取方式，举个简单例子，好比先把整个数据源完整拿出来放到内存中，再使用 <code>writeFile</code> 方法或 <code>writeFileSync</code> 方法写入文件内容。显然，如果数据源非常大（10GB）使用这种方式，效率就很低了。说不定就死机了。:) 这时候，就需要下一节讲到的 <strong><em>流读取</em></strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// data.txt</div><div class="line">Hello,Node.js!</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</div><div class="line"></div><div class="line"><span class="comment">// 异步读取</span></div><div class="line">fs.readFile(<span class="string">'data.txt'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</div><div class="line">   <span class="keyword">if</span> (err) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</div><div class="line">   &#125;</div><div class="line">   <span class="built_in">console</span>.log(<span class="string">"异步读取: "</span> + data.toString());</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 同步读取</span></div><div class="line"><span class="keyword">var</span> data = fs.readFileSync(<span class="string">'data.txt'</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"同步读取: "</span> + data.toString());</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"程序执行完毕。"</span>);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">同步读取: Hello,Node.js!</div><div class="line">程序执行完毕。</div><div class="line"></div><div class="line">异步读取: Hello,Node.js!</div></pre></td></tr></table></figure>
<div class="tip"><br>Node.js 中，先执行同步代码，后执行异步代码，异步代码会将回调函数放入调用 <strong><em>队列</em></strong>，以 <strong><em>先进先出</em></strong> 的形式依次调用。<br></div>

<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"><span class="comment">// 异步写入</span></div><div class="line">fs.writeFile(<span class="string">'./data/d2.txt'</span>,<span class="string">'我是一条数据'</span>,<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!err)&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'文件写入成功'</span>);</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'写入失败'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 同步写入</span></div><div class="line">fs.writeFileSync(<span class="string">'./data/d3'</span>,<span class="string">'我是一条数据'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> data = fs.readFileSync(<span class="string">'./data/d3'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(data.toString());<span class="comment">// 我是一条数据</span></div></pre></td></tr></table></figure>
<h4 id="流读写方式"><a href="#流读写方式" class="headerlink" title="流读写方式"></a>流读写方式</h4><p>应用程序中，流是一组有序的、有起点和终点的 <strong><em>字节数据的传输方式</em></strong>。在应用程序中各种对象之间交换与传输数据的时候，总是先将该对象中所包含的数据转换为各种形式的流数据（即字节数据），再通过流的传输，到达目的对象后再将流数据转换为该对象中可以使用的数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"><span class="keyword">var</span> data = <span class="string">''</span>;</div><div class="line"><span class="comment">// 流读取</span></div><div class="line"><span class="keyword">var</span> stream = fs.createReadStream(<span class="string">'./data/d1.txt'</span>,<span class="string">'utf-8'</span>);</div><div class="line">stream.on(<span class="string">'data'</span>,<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</div><div class="line">    data += result;</div><div class="line">&#125;);</div><div class="line"><span class="comment">// data end 事件表示连贯的行为，字节流需要起点和终点。</span></div><div class="line">stream.on(<span class="string">'end'</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(data);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">stream.on(<span class="string">'error'</span>,<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(err.stack);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 流写入</span></div><div class="line"><span class="keyword">var</span> stream = fs.createWriteStream(<span class="string">'./data/123.txt'</span>,<span class="string">'utf-8'</span>);</div><div class="line">stream.write(<span class="string">'hello'</span>,<span class="string">'utf-8'</span>);</div><div class="line"></div><div class="line">stream.end();</div><div class="line"></div><div class="line">stream.on(<span class="string">'finish'</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="comment">// finish 事件触发，必须等 end 事件结束才可以</span></div><div class="line">   <span class="built_in">console</span>.log(<span class="string">'写入完成！'</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">stream.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(err.stack);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<div class="tip"><br>流读取会依次触发事件： data -&gt; end -&gt; error ,每个事件发生会有对应的回调函数处理。<br>流写入会依次触发事件： end -&gt; finish -&gt; error ,每个事件发生会有对应的回调函数处理。<br></div>

<h4 id="管道流读写"><a href="#管道流读写" class="headerlink" title="管道流读写"></a>管道流读写</h4><p>管道(pipe) 提供了一个输出流到输入流的机制。通常我们用于从一个流中获取数据并将数据传递到另外一个流中。通过管道，我们就可以实现大文件流入另外一个文件的复制过程。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> readStream = fs.createReadStream(<span class="string">'./data/d1.txt'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> writeStrem = fs.createWriteStream(<span class="string">'./data/d3.txt'</span>);</div><div class="line"></div><div class="line">readStream.pipe(writeStrem);<span class="comment">// 实现了 d1.txt 到 d3.txt 的传输过程</span></div></pre></td></tr></table></figure></p>
<h4 id="链式流读写"><a href="#链式流读写" class="headerlink" title="链式流读写"></a>链式流读写</h4><p>链式是通过连接输出流到另外一个流并创建多个对个流操作链的机制。链式流一般用于管道操作。接下来我们就是用管道和链式来压缩和解压文件。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// compress.js</span></div><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"><span class="keyword">var</span> zlib = <span class="built_in">require</span>(<span class="string">'zlib'</span>); <span class="comment">// 引入压缩模块</span></div><div class="line"></div><div class="line">fs.createReadStream(<span class="string">'./data/123.txt'</span>)</div><div class="line">    .pipe(zlib.createGzip())</div><div class="line">    .pipe(fs.createWriteStream(<span class="string">'./data/123.txt.gz'</span>));<span class="comment">// 链式操作</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'文件压缩完成'</span>);</div></pre></td></tr></table></figure></p>
<h4 id="文件、文件夹删除"><a href="#文件、文件夹删除" class="headerlink" title="文件、文件夹删除"></a>文件、文件夹删除</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</div><div class="line"><span class="comment">// 文件目录读取，返回一个数组，包含文件及文件夹</span></div><div class="line">fs.readdir(<span class="string">"./testdir"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,files</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (!err)&#123;</div><div class="line">        <span class="built_in">console</span>.log(files);<span class="comment">// [ 'index.html', 'main.css', 'subdir' ]</span></div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log(err);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 文件删除</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"准备删除文件！"</span>);</div><div class="line">fs.unlink(<span class="string">'./data/123.txt.gz'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (err) &#123;</div><div class="line">        <span class="keyword">return</span> err;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"文件删除成功！"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 空文件夹删除</span></div><div class="line">fs.rmdir(<span class="string">'./data'</span>,<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!err)&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'删除成功！'</span>);</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log(err);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>一个递归删除的小练习，把前面的综合运用一下。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">delDir(<span class="string">'./testdir'</span>);</div><div class="line"></div><div class="line"><span class="comment">// 传入一个文件夹路径，删除掉该文件夹所有内容</span></div><div class="line"><span class="comment">// @param pathStr string 传入一个路径</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">delDir</span>(<span class="params">pathStr</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line">    <span class="keyword">if</span> (fs.existsSync(pathStr))&#123;</div><div class="line">        <span class="keyword">var</span> files = fs.readdirSync(pathStr);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; files.length; i++) &#123;</div><div class="line">            <span class="keyword">var</span> curPath = pathStr + <span class="string">'/'</span> + files[i];</div><div class="line">            <span class="keyword">var</span> stats = fs.statSync(curPath);</div><div class="line">            <span class="keyword">if</span> (stats.isFile())&#123;</div><div class="line">                fs.unlink(curPath);</div><div class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(stats.isDirectory())&#123;</div><div class="line">                delDir(curPath);<span class="comment">// 递归调用，最终删除掉所有文件，只剩空目录</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        fs.rmdirSync(pathStr);<span class="comment">// 收尾，删掉空目录</span></div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'文件夹不存在'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<div class="tip"><br>文件、文件夹的操作，都有同步和异步的代码，比如 <code>fs.unlink()</code> 和 <code>fs.unlinkSync()</code>,默认都是异步代码，异步代码会调用回调函数进行操作，同步代码会返回一个对象，进行后续的操作，可以认真观察上面代码的区别。使用异步代码的时候，一定注意执行顺序。<br></div>


<h3 id="路径-path"><a href="#路径-path" class="headerlink" title="路径 (path)"></a>路径 (path)</h3><p>path 模块包含一套用于 <strong><em>处理和转换文件路径</em></strong> 的工具集，用于处理目录的对象，提高开发效率。用 Node.js 的 path 命令，与使用 Linux 下的 shell 脚本命令相似。几乎所有的方法仅对字符串进行转换，文件系统是不会检查路径是否真实有效。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 引入path对象</span></div><div class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">* 格式化路径  path.normalize(p)</div><div class="line">* 特点：将不符合规范的路径格式化，简化开发人员中处理各种复杂的路径判断</div><div class="line">* */</div><div class="line">path.normalize(<span class="string">'/foo/bar//baz/asdf/quux/..'</span>);  </div><div class="line"><span class="comment">// returns   </span></div><div class="line"><span class="string">'/foo/bar/baz/asdf'</span></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">* 路径联合 path.join([path1], [path2], [...])</div><div class="line">* 特点：将所有名称用path.seq串联起来，然后用normailze格式化</div><div class="line">* */</div><div class="line">path.join(<span class="string">'///foo'</span>, <span class="string">'bar'</span>, <span class="string">'//baz/asdf'</span>, <span class="string">'quux'</span>, <span class="string">'..'</span>);  </div><div class="line"><span class="comment">// returns   </span></div><div class="line"><span class="string">'/foo/bar/baz/asdf'</span></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">* 路径寻航 path.resolve([from ...], to)</div><div class="line">* 特点：相当于不断的调用系统的cd命令</div><div class="line">* */</div><div class="line">path.resolve(<span class="string">'foo/bar'</span>, <span class="string">'/tmp/file/'</span>, <span class="string">'..'</span>, <span class="string">'a/../subfile'</span>);</div><div class="line"><span class="comment">// 相当于终端命令：</span></div><div class="line"><span class="comment">// cd foo/bar</span></div><div class="line"><span class="comment">// cd /tmp/file/</span></div><div class="line"><span class="comment">// cd ..</span></div><div class="line"><span class="comment">// cd a/../subfile</span></div><div class="line"><span class="comment">// pwd</span></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">* 相对路径 path.relative(from, to)</div><div class="line">* 特点：返回某个路径下相对于另一个路径的相对位置串，</div><div class="line">* 相当于：path.resolve(from, path.relative(from, to)) == path.resolve(to)</div><div class="line">* */</div><div class="line"><span class="comment">//简单理解： 地址一执行怎样的 shell 命令，到达地址二</span></div><div class="line">path.relative(<span class="string">'/data/orandea/test/aaa'</span>, <span class="string">'/data/orandea/impl/bbb'</span>)  </div><div class="line"><span class="comment">// returns  </span></div><div class="line"><span class="string">'../../impl/bbb'</span></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">* 文件夹名称 path.dirname(p)</div><div class="line">* 特点：返回路径的上级路径</div><div class="line">* */</div><div class="line">path.dirname(<span class="string">'/foo/bar/baz/asdf/quux'</span>)  </div><div class="line"><span class="comment">// returns  </span></div><div class="line"><span class="string">'/foo/bar/baz/asdf'</span></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">* 文件名称 path.basename(p, [ext])</div><div class="line">* 特点：返回指定的文件名，返回结果可去掉[ext]后缀字符串</div><div class="line">* */</div><div class="line">path.basename(<span class="string">'/foo/bar/baz/asdf/quux.html'</span>)  </div><div class="line"><span class="comment">// returns  </span></div><div class="line"><span class="string">'quux.html'</span>  </div><div class="line"></div><div class="line">path.basename(<span class="string">'/foo/bar/baz/asdf/quux.html'</span>, <span class="string">'.html'</span>)  </div><div class="line"><span class="comment">// returns  </span></div><div class="line"><span class="string">'quux'</span></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">* 扩展名称 path.extname(p)</div><div class="line">* 特点：返回指定文件名的扩展名称</div><div class="line">* */</div><div class="line">path.extname(<span class="string">'index.html'</span>)  </div><div class="line"><span class="comment">// returns  </span></div><div class="line"><span class="string">'.html'</span>  </div><div class="line"></div><div class="line">path.extname(<span class="string">'index.'</span>)  </div><div class="line"><span class="comment">// returns  </span></div><div class="line"><span class="string">'.'</span>  </div><div class="line"></div><div class="line">path.extname(<span class="string">'index'</span>)  </div><div class="line"><span class="comment">// returns  </span></div><div class="line"><span class="string">''</span></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">* 路径分隔符 path.sep</div><div class="line">* 特点：获取文件路径的分隔符，主要是与操作系统相关</div><div class="line">* 注意调用方式</div><div class="line">* */</div><div class="line"><span class="string">'foo/bar/baz'</span>.split(path.sep)  </div><div class="line"><span class="comment">// returns  </span></div><div class="line">[<span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'baz'</span>]</div></pre></td></tr></table></figure></p>
</div></article></div></main><footer><div class="paginator"><a href="/2016/01/05/Mongodb-学习笔记----增删改查/" class="prev">PREV</a><a href="/2015/11/19/CentOS-6-x86-Node-js-MongoDB-Express-环境配置笔记/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'ifyour';
var disqus_identifier = '2015/12/30/Node.JS-学习笔记-[03]----Buffer-fs-path/';
var disqus_title = 'Node.JS 学习笔记 [03] -- Buffer fs path';
var disqus_url = 'http://ifyour.github.io/2015/12/30/Node.JS-学习笔记-[03]----Buffer-fs-path/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//ifyour.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2017 <a href="http://ifyour.github.io">Ifyour</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>