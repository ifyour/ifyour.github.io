<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Node.JS 学习笔记 [01] · Ifyour's Blog</title><meta name="description" content="Node.JS 学习笔记 [01] - Ifyour"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://ifyour.github.io/atom.xml" title="Ifyour's Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://twitter.com/JohnWmm/" target="_blank" class="nav-list-link">TWITTER</a></li><li class="nav-list-item"><a href="https://github.com/ifyour/" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Node.JS 学习笔记 [01]</h1><div class="post-info">Dec 28, 2016</div><div class="post-content"><p>整理记录 Node.js 学习笔记，作为前端人员，非常有必要了解后端的一些知识，方便与后端的同事协作，提高效率，搞好前端后，也可以尝试往后端发展，成为一名全栈工程师！:P<br><a id="more"></a><br><img src="http://ww4.sinaimg.cn/mw690/6057861cgw1fb6vlzd7i7j20go08cjro.jpg" alt=""></p>
<h3 id="Node-js-介绍"><a href="#Node-js-介绍" class="headerlink" title="Node.js 介绍"></a>Node.js 介绍</h3><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。Node.js 的包管理器 npm，是全球最大的开源库生态系统。</p>
<h4 id="Node-js-和-JavaScript-的区别"><a href="#Node-js-和-JavaScript-的区别" class="headerlink" title="Node.js 和 JavaScript 的区别"></a>Node.js 和 JavaScript 的区别</h4><ul>
<li>Node.js 是一个可以运行 JavaScript 的平台，基于 ChromeV8 引擎，是对 JavaScript 的增强，使 JavaScript 具备了服务器语言的开发能力，比如操作文件、读取系统信息、网络传输等。</li>
<li>JavaScript 是一门编程语言，只要有 JavaScript 引擎就能运行并且如果JavaScript运行在浏览器中，浏览器对JavaScript加入了浏览器和文档操作的接口（方法）。</li>
</ul>
<div class="tip"><br>简单理解：浏览器中 JavaScript 主要是操作 BOM 和 DOM，而 Node.js 则是具有服务端语言处理能力（处理网络请求，保存数据到数据库等）。<br></div>

<h4 id="官方网站"><a href="#官方网站" class="headerlink" title="官方网站"></a>官方网站</h4><ul>
<li>英文社区： <a href="https://www.npmjs.com/" target="_blank" rel="external">https://www.npmjs.com/</a></li>
<li>中文社区：<a href="http://cnodejs.org/" target="_blank" rel="external">http://cnodejs.org/</a></li>
</ul>
<h4 id="Node-js-安装及运行"><a href="#Node-js-安装及运行" class="headerlink" title="Node.js 安装及运行"></a>Node.js 安装及运行</h4><p>在 Node.js 的官方提供的<a href="https://nodejs.org/en/download/" target="_blank" rel="external">下载频道</a>选择对应的平台及安装程序安装即可。Node.js 提供了 <code>REPL（Read-Evaluate-Print-Loop）</code> 模式，即 <strong><em>交互式命令行解析器</em></strong>，可以直接输入命令行，编写 Node.js 代码。安装成功后，我们可以在终端里输入 <code>node -v</code> 获取当前的 Node.js 版本号，能获取表示成功安装。</p>
<h3 id="Node-js-模块"><a href="#Node-js-模块" class="headerlink" title="Node.js 模块"></a>Node.js 模块</h3><p>模块对于 Node.js 来说是一个非常重要的概念，一个特定功能的文件就是一个模块。模块之间可能会存在一定的依赖关系，比如我写了一个 jQuery 轮播的插件，它就依赖 jQuery 库，在 Node.js 中可以非常方便的表示清楚这种依赖关系。说到模块，还需要说一个就是编写模块的规范。</p>
<h4 id="模块规范"><a href="#模块规范" class="headerlink" title="模块规范"></a>模块规范</h4><ul>
<li><strong><em>AMD</em></strong> (Asynchronous Module Definition)，这种规范是异步的加载模块，RequireR.js 应用了这一规范,适合客户端浏览器环境。</li>
<li><strong><em>CMD</em></strong> (Common Module Definition), 是 Sea.js 推崇的规范。</li>
<li><strong><em>CommonJS</em></strong> , 是诞生比较早的。Node.js 就采用了 CommonJS 的规范来定义模块。但是 CommonJs 采用的是同步加载文件方式，只适用于服务端（Node.js平台）。</li>
</ul>
<h4 id="使用模块"><a href="#使用模块" class="headerlink" title="使用模块"></a>使用模块</h4><p>模块定义完成后，就可以使用模块，通过命令行参数传递给 Node.js 以启动程序的模块被称为 <strong><em>主模块</em></strong>。主模块负责调度组成整个程序的其它模块完成工作。其实就类似网站中的 <code>index.html</code>，Node.js 中的主模块通常是 <code>main.js</code> 或者 <code>index.js</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);<span class="comment">// 通过 require 引入 http 模块</span></div></pre></td></tr></table></figure></p>
<h4 id="模块组成"><a href="#模块组成" class="headerlink" title="模块组成"></a>模块组成</h4><p>在上条命令中，我们通过 require 引入了一个 http 模块，实际上作为一个单独的模块文件，Node.js 为我们在外层嵌套了一个函数，正因为有了这个函数，在这个文件中声明的变量就是私有变量啦，那么每个模块之间就不会产生干扰了。那么来看看这个函数长什么样子。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params">exports, require, module, __filename, __dirname</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);<span class="comment">// 通过 require 引入 http 模块</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最外层，Node.js 为我们的代码包裹了这样一个函数，这个函数传入了几个参数，我来解释一下：</p>
<ul>
<li>exports ：用于在当前模块中加载和使用别的模块，传入一个模块名，返回一个模块导出对象。</li>
<li>require：当前模块的导出对象，用于导出模块公有方法和属性。</li>
<li>module：访问到当前模块的一些相关信息，但最多的用途是替换当前模块的导出对象。</li>
<li>__filename：当前模块的文件名</li>
<li>__dirname：当前模块的目录名</li>
</ul>
<h4 id="模块分类"><a href="#模块分类" class="headerlink" title="模块分类"></a>模块分类</h4><p>Node.js 提供两种模块类型：</p>
<ol>
<li>核心模块：是由 Node.js 平台提供的模块，也可以称为“系统模块”。</li>
<li>文件模块：以 <code>..</code> 或 <code>.</code> 和 <code>/</code> 开始的标识符，这里都被当做文件模块来处理。</li>
</ol>
<h4 id="node-modules-文件夹"><a href="#node-modules-文件夹" class="headerlink" title="node_modules 文件夹"></a>node_modules 文件夹</h4><p>该文件夹是 Node.js 中的特殊文件夹，用来存放 node 模块，如果一个模块既不是系统模块，也不是文件模块，那么它会被存放在 node_modules 文件夹中。使用 <code>console.log(module.paths);</code> 可以打印 node_modules 会查找的目录。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[ <span class="string">'/Users/wangmingming/Documents/Projects/JSstudy/12.26/node_modules'</span>,</div><div class="line">  <span class="string">'/Users/wangmingming/Documents/Projects/JSstudy/node_modules'</span>,</div><div class="line">  <span class="string">'/Users/wangmingming/Documents/Projects/node_modules'</span>,</div><div class="line">  <span class="string">'/Users/wangmingming/Documents/node_modules'</span>,</div><div class="line">  <span class="string">'/Users/wangmingming/node_modules'</span>,</div><div class="line">  <span class="string">'/Users/node_modules'</span>,</div><div class="line">  <span class="string">'/node_modules'</span> ]</div></pre></td></tr></table></figure></p>
<div class="tip"><br>在调用一个模块时，Node.js 沿路径向上逐级递归，直到根目录下的 node_modules 目录。CommonJS 模规范也允许在标识符中不包含文件扩展名，这种情况下，Node 会按 js、json、node 的次序补足扩展名，依次尝试。<br></div>

<h3 id="包-Package"><a href="#包-Package" class="headerlink" title="包 (Package)"></a>包 (Package)</h3><p>把由多个子模块组成的大模块称做包，并把所有子模块放在同一个目录里。在一个包中，会用 <code>package.json</code> 文件中的 <code>main</code> 属性用来描述这个包的主文件。</p>
<h4 id="NPM-Node-Package-Manager"><a href="#NPM-Node-Package-Manager" class="headerlink" title="NPM (Node Package Manager)"></a>NPM (Node Package Manager)</h4><p>大名鼎鼎的 NPM 实际上就是用来管理包的一个工具，借助 NPM 我们可以快速的安装和管理依赖包。下面是我整理的 npm 常用命令。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">npm init                   <span class="comment">#  初始化包，要求填入包名等信息</span></div><div class="line">npm install &lt;name&gt;         <span class="comment">#  本地安装一个包</span></div><div class="line">npm install &lt;name&gt; -g      <span class="comment">#  全局安装一个包</span></div><div class="line">npm install &lt;name&gt; --save  <span class="comment">#  本地安装并写入 package.json 依赖中</span></div><div class="line">npm remove &lt;name&gt;          <span class="comment">#  移除</span></div><div class="line">npm update &lt;name&gt;          <span class="comment">#  更新</span></div></pre></td></tr></table></figure></p>
<ul>
<li>本地安装：将安装包放在 <code>./node_modules</code> 下（运行 npm 命令时所在的目录），如果没有 node_modules 目录，会在当前执行 npm 命令的目录下生成 node_modules 目录。可以通过 <code>require()</code> 来引入本地安装的包。</li>
<li>全局安装：将安装包放在 <code>/usr/local</code> 下或者你 node 的安装目录，可以直接在命令行里使用。</li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2016/12/29/Node-js-note-02/" class="prev">PREV</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'ifyour';
var disqus_identifier = '2016/12/28/node-js-note-01/';
var disqus_title = 'Node.JS 学习笔记 [01]';
var disqus_url = 'http://ifyour.github.io/2016/12/28/node-js-note-01/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//ifyour.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2017 <a href="http://ifyour.github.io">Ifyour</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>