<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="theme-color" content="#ffffff"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="apple-mobile-web-app-title" content="Ifyour's Blog"><meta name="msapplication-TileImage" content="/img/webAppIcon-256x256.png"><meta name="msapplication-TileColor" content="#000"><meta property="algolia:search" data-application-id="3XQ5CPDDMK" data-api-key="abe9e26eebcac723f34ade5cf6b97441" data-index-name="prod_blog"><title>如何避免 async/await 地狱 · Ifyour's Blog</title><meta name="description" content="如何避免 async/await 地狱 - Ifyour"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="manifest" href="/manifest.json"><link rel="icon" type="image/x-icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="apple-touch-icon" size="256x256" href="/img/webAppIcon-256x256.png"><link rel="apple-touch-icon" size="512x512" href="/img/webAppIcon-512x512.png"><link rel="apple-touch-startup-image" href="/img/apple-launch-750x1334.png"><link rel="preload" href="/css/apollo.css" as="style"><link rel="preload" href="/js/main.js" as="script"><link rel="search" type="application/opensearchdescription+xml" href="http://ifyour.github.io/atom.xml" title="Ifyour's Blog"></head><body><div class="search"><a href="javascript:;" target="_self" class="close"><svg id="icon-close" viewbox="0 0 16 16" width="24" height="24" fill="#A4A9AC"><path d="M8,15 C4.13400675,15 1,11.8659932 1,8 C1,4.13400675 4.13400675,1 8,1 C11.8659932,1 15,4.13400675 15,8 C15,11.8659932 11.8659932,15 8,15 Z M10.44352,10.7233105 L10.4528296,10.7326201 L10.7326201,10.4528296 C11.0310632,10.1543865 11.0314986,9.66985171 10.7335912,9.37194437 L9.36507937,8.0034325 L10.7360526,6.63245928 C11.0344957,6.33401613 11.0349311,5.84948135 10.7370237,5.55157401 L10.448426,5.26297627 C10.1505186,4.96506892 9.66598387,4.96550426 9.36754072,5.26394741 L8.00589385,6.62559428 L6.63738198,5.25708241 C6.33947464,4.95917507 5.85493986,4.95961041 5.55649671,5.25805356 L5.26737991,5.54717036 C4.96893676,5.84561351 4.96850142,6.33014829 5.26640876,6.62805563 L6.62561103,7.9872579 L5.25463781,9.35823112 C4.95619466,9.65667427 4.95575932,10.141209 5.25366666,10.4391164 L5.5422644,10.7277141 C5.84017175,11.0256215 6.32470652,11.0251861 6.62314967,10.726743 L7.99412289,9.35576976 L9.36263476,10.7242816 C9.66054211,11.022189 10.1450769,11.0217536 10.44352,10.7233105 Z"/></svg></a><div class="container"><input id="search-input" autocomplete="off" type="text" placeholder="Type to search" class="search-input"><div class="search-by">Search by<a href="https://www.algolia.com/" target="_blank"> algolia</a></div><div class="search-results"><div id="search-articles" class="search-item"></div></div></div><script id="search-tmp" type="text/html">{{if list.length}}
    <h3>ARTICLES</h3>
    <ul>
        {{each list item}}
        <li>
            <div class="search-item-title">
                <a href="{{item.permalink}}">{{@item.title}}</a>
            </div>
            <div class="search-item-summary" style="-webkit-box-orient: vertical;">
                {{@item.summary}}
            </div>
        </li>
        {{/each}}
    </ul>
{{else if list}}
    <h2>
        Oops! no result,
        Try it on <a target="_blank" style="color: #2c3e50; border-bottom: 2px solid #42b983; font-size: 19px;" href="https://www.google.com/search?q=site%3Aifyour.github.io+{{keywords}}">Google: {{keywords}}</a>~ 😱
    </h2>
{{/if}}</script></div><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/docs/" target="_self" class="nav-list-link">DOCS</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="javascript:;" target="_self" id="search" class="nav-list-link">SEARCH</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">如何避免 async/await 地狱</h1><div class="post-info">May 20, 2018<a href="https://medium.freecodecamp.org/avoiding-the-async-await-hell-c77a0fb71c4c" target="_blank" title="https://medium.freecodecamp.org/avoiding-the-async-await-hell-c77a0fb71c4c" class="post-from">Translation · Original Link</a></div><div class="sidebar-toc"><span>Catalog</span><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#何为-async-await-地狱"><span class="toc-text">何为 async/await 地狱</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#示例"><span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#更糟糕的例子"><span class="toc-text">更糟糕的例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参考"><span class="toc-text">参考</span></a></li></ol></div><div class="post-content"><p>最近阅读了 Aditya Agarwal 的一篇文章：How to escape async/await hell。这篇文章主要讨论了过度使用 async/await 导致的新的「地狱」问题，其已经在 Medium 上获得了 19k+ 的 Applause。</p>
<a id="more"></a>
<div class="tip"><br>  async/await 是 ES7 的新语法。在 async/await 标准出来之前，JavaScript 的异步编程经历了 callback –&gt; promise –&gt; generator 的演变过程。<br></div>

<p>在 callback 的时代，最让人头疼的问题就是回调地狱 (callback hell)。所以，在 async/await 一经推出，社区就有人认为「这是 JavaScript 异步编程的终极解决方案」。但 async/await 也可能带来新的问题。</p>
<blockquote>
<p>好不容易逃离了一个「地狱」，又马上陷入另一个「地狱」了。</p>
</blockquote>
<h3 id="何为-async-await-地狱"><a href="#何为-async-await-地狱" class="headerlink" title="何为 async/await 地狱"></a>何为 async/await 地狱</h3><p>在编写异步代码时，人们总是喜欢一次写多个语句，并且在一个函数调用之前使用 await 关键字。这可能会导致性能问题，因为很多时候一个语句并不依赖于前一个语句——但使用 await 关键字后，你就需要等待前一个语句完成。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>假设你要写一个订购 pizza 和 drink 的脚本，代码可能是如下这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> pizzaData = <span class="keyword">await</span> getPizzaData(); <span class="comment">// async call</span></span><br><span class="line">  <span class="keyword">const</span> drinkData = <span class="keyword">await</span> getDrinkData(); <span class="comment">// async call</span></span><br><span class="line">  <span class="keyword">const</span> chosenPizza = choosePizza(); <span class="comment">// sync call</span></span><br><span class="line">  <span class="keyword">const</span> chosenDrink = chooseDrink(); <span class="comment">// sync call</span></span><br><span class="line">  <span class="keyword">await</span> addPizzaToCart(chosenPizza); <span class="comment">// async call</span></span><br><span class="line">  <span class="keyword">await</span> addDrinkToCart(chosenDrink); <span class="comment">// async call</span></span><br><span class="line">  orderItems(); <span class="comment">// async call</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>这段代码开起来没什么问题，也能正常的运行。但是，这并不是一个好的实现，因为这把本身可以并行执行的任务变成了串行执行。</p>
<p>选择一个 drink 添加到购物车和选择一个 pizza 添加到购物车可以看作是两个任务，而这两个任务之间并没有相互依赖的关系，也没有特定的顺序执行关系。所以这两个任务是可以并行执行的，这样能提高性能。而上述代码将二者变成了串行执行，显然是降低了程序性能的。</p>
<h3 id="更糟糕的例子"><a href="#更糟糕的例子" class="headerlink" title="更糟糕的例子"></a>更糟糕的例子</h3><p>假设要写一个程序，根据 followers 数用来显示 GitHub 中国区用户的排名情况。</p>
<p>如果只是获取排名，我们可以调用 Github 官方的 <a href="https://developer.github.com/v3/search/#search-users" target="_blank" rel="noopener">Search users</a> 接口，伪代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getUserRank</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> fetch(search_url);</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getUserRank();</span><br></pre></td></tr></table></figure>
<p>调用 getUserRank 函数就能获取到想要的结果。但是，你可能还要想要获取每个用户的 follower 数、email、地区和仓库等数据，而 Search users 接口并没有返回这些数据，你可能需要再去调用 <a href="https://developer.github.com/v3/users/#get-a-single-user" target="_blank" rel="noopener">Single user</a> 接口。</p>
<p>然后上述代码可能被改写为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getUserRank</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> fetch(search_url);</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> item = data[i];</span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">await</span> fetch(user_url);</span><br><span class="line">    res.push(&#123;...item, ...user&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getUserRank();</span><br></pre></td></tr></table></figure>
<p>运行查看结果，自己想要的数据都拿到了。但是，你发现一个问题，程序运行时间有点长，该怎么优化下呢？</p>
<p>其实，铺垫了这么长，就是想说明一个问题：你陷入了 async/await 的地狱。</p>
<p>上述代码的问题在于，获取每个用户资料的请求并不存在依赖性，就类似上文中的选择 pizza 和 drink 一样，这是可以并行执行的请求。而根据上述代码，请求都变成了串行执行，这当然会损耗程序的性能。</p>
<p>按照上述代码，可以看一下其异步请求的动态图：</p>
<p><img src="https://user-images.githubusercontent.com/7871813/40270076-c08ec820-5bb9-11e8-8470-5e716e87dc76.gif" alt="image"></p>
<p>可以看到，获取用户资料的每个请求都需要等到上一个请求完成之后才能执行，Waterfall 处于一个串行的状态。那要怎么改进这个问题呢？</p>
<p>既然获取每个用户资料的请求并不存在依赖性，那么我们可以先触发异步请求，然后延迟处理异步请求的结果，而不是一直等该请求完成。根据这个思路，那可能改进的代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getUserDetails</span> (<span class="params">username</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> user = <span class="keyword">await</span> fetch(user_url);</span><br><span class="line">  <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getUserRank</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> fetch(search_url);</span><br><span class="line">  <span class="keyword">const</span> promises = data.map(<span class="function">(<span class="params">item</span>) =&gt;</span> getUserDetails(item.username));</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.all(promises).then(handleYourData);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getUserRank();</span><br></pre></td></tr></table></figure>
<p>可以看一下异步请求的动态图：</p>
<p><img src="https://user-images.githubusercontent.com/7871813/40270077-c2536602-5bb9-11e8-9438-a15ac05b41e0.gif" alt="image"></p>
<p>可以看到，获取用户资料的异步请求处理不再是串行执行，而是并行执行了，这将大大提高程序的运行效率和性能。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Aditya Agarwal 在其文章中也给出了怎么避免陷入 async/await 地狱的建议：</p>
<ol>
<li>首先找出依赖于其他语句的执行的语句</li>
<li>然后将有依赖关系的一系列语句进行组合，合并成一个异步函数</li>
<li>最后用正确的方式执行这些函数</li>
</ol>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://github.com/dt-fe/weekly/blob/master/55.%E7%B2%BE%E8%AF%BB%E3%80%8Aasync%20await%20%E6%98%AF%E6%8A%8A%E5%8F%8C%E5%88%83%E5%89%91%E3%80%8B.md" target="_blank" rel="noopener">精读《async/await 是把双刃剑》</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/05/async.html" target="_blank" rel="noopener">async 函数的含义和用法</a></li>
<li><a href="https://cnodejs.org/topic/5640b80d3a6aa72c5e0030b6" target="_blank" rel="noopener">体验异步的终极解决方案 - ES7 的 Async/Await</a></li>
<li><a href="https://github.com/dwqs/blog/issues/65" target="_blank" rel="noopener">How to escape async/await hell</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2018/05/29/ES6-Promise-简明指南/" class="prev">PREV</a><a href="/2018/05/14/React-组件模式/" class="next">NEXT</a></div><div id="gc_container"></div><script src="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/gitment.browser.js"></script><script>(new Gitment({
    id: 'aid' + (new Date('Sun May 20 2018 22:11:35 GMT+0800')).getTime()/1000,
    title: '如何避免 async/await 地狱' + ' · 评论',
    link: decodeURI(location.protocol + '//' + location.hostname + location.pathname),
    repo: 'ifyour.github.io',
    owner: 'ifyour',
    oauth: {
        client_id: '576e98d38d4bd19f8a02',
        client_secret: 'ba3616bf2f20c5da947a1fd5c7ef0edff4ffab99',
    }
})).render('gc_container');</script><div class="copyright"><p>© 2015 - 2019 Made with <span>❤</span> by <a href="https://github.com/ifyour/ifyour.github.io">Ifyour</a></p><p>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div><script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.4.0/lib/darkmode-js.min.js"></script><script>new Darkmode({
    bottom: '1rem',
    right: '1rem',
    left: 'unset',
    time: '0.5s',
    mixColor: '#fff',
    backgroundColor: '#fff',
    buttonColorDark: '#100f2c',
    buttonColorLight: '#fff',
    saveInCookies: true,
    label: '🌓',
    autoMatchOsTheme: true
}).showWidget();
</script><script src="/js/algoliasearch.min.js"></script><script src="/js/template-web.min.js"></script><script src="/js/main.js"></script><script src="https://unpkg.com/medium-zoom@0/dist/medium-zoom.min.js"></script><script>mediumZoom('article img', {margin: 24});
(function(win, targetElem) {
    if (!targetElem) return;
    win.onscroll = (function() {
        if (isElementInViewport(targetElem)) {
            win.onscroll = null;
            return mediumZoom('.gitment-comment-main img', {margin: 24});
        }
        return arguments.callee;
    })();
    function isElementInViewport(el) {
        var rect = el.getBoundingClientRect();
        var winH = win.innerHeight || document.documentElement.clientHeight;
        return rect.top <= winH && rect.bottom >= winH;
    };
})(this, document.querySelector('#gc_container'));
</script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-120929321-1",'auto');ga('send','pageview');</script></footer></div><script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>