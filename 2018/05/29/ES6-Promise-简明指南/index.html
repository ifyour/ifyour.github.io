<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="theme-color" content="#ffffff"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="apple-mobile-web-app-title" content="Ifyour's Blog"><meta name="msapplication-TileImage" content="/img/webAppIcon-256x256.png"><meta name="msapplication-TileColor" content="#000"><meta property="algolia:search" data-application-id="3XQ5CPDDMK" data-api-key="abe9e26eebcac723f34ade5cf6b97441" data-index-name="prod_blog"><title>ES6 Promise 简明指南 · Ifyour's Blog</title><meta name="description" content="ES6 Promise 简明指南 - Ifyour"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="manifest" href="/manifest.json"><link rel="icon" type="image/x-icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="apple-touch-icon" size="256x256" href="/img/webAppIcon-256x256.png"><link rel="apple-touch-icon" size="512x512" href="/img/webAppIcon-512x512.png"><link rel="apple-touch-startup-image" href="/img/apple-launch-750x1334.png"><link rel="preload" href="/css/apollo.css" as="style"><link rel="preload" href="/js/main.js" as="script"><link rel="search" type="application/opensearchdescription+xml" href="http://ifyour.github.io/atom.xml" title="Ifyour's Blog"></head><body><div class="search"><a href="javascript:;" target="_self" class="close"><svg id="icon-close" viewbox="0 0 16 16" width="24" height="24" fill="#A4A9AC"><path d="M8,15 C4.13400675,15 1,11.8659932 1,8 C1,4.13400675 4.13400675,1 8,1 C11.8659932,1 15,4.13400675 15,8 C15,11.8659932 11.8659932,15 8,15 Z M10.44352,10.7233105 L10.4528296,10.7326201 L10.7326201,10.4528296 C11.0310632,10.1543865 11.0314986,9.66985171 10.7335912,9.37194437 L9.36507937,8.0034325 L10.7360526,6.63245928 C11.0344957,6.33401613 11.0349311,5.84948135 10.7370237,5.55157401 L10.448426,5.26297627 C10.1505186,4.96506892 9.66598387,4.96550426 9.36754072,5.26394741 L8.00589385,6.62559428 L6.63738198,5.25708241 C6.33947464,4.95917507 5.85493986,4.95961041 5.55649671,5.25805356 L5.26737991,5.54717036 C4.96893676,5.84561351 4.96850142,6.33014829 5.26640876,6.62805563 L6.62561103,7.9872579 L5.25463781,9.35823112 C4.95619466,9.65667427 4.95575932,10.141209 5.25366666,10.4391164 L5.5422644,10.7277141 C5.84017175,11.0256215 6.32470652,11.0251861 6.62314967,10.726743 L7.99412289,9.35576976 L9.36263476,10.7242816 C9.66054211,11.022189 10.1450769,11.0217536 10.44352,10.7233105 Z"/></svg></a><div class="container"><input id="search-input" autocomplete="off" type="text" placeholder="Type to search" class="search-input"><div class="search-by">Search by<a href="https://www.algolia.com/" target="_blank"> algolia</a></div><div class="search-results"><div id="search-articles" class="search-item"></div></div></div><script id="search-tmp" type="text/html">{{if list.length}}
    <h3>ARTICLES</h3>
    <ul>
        {{each list item}}
        <li>
            <div class="search-item-title">
                <a href="{{item.permalink}}">{{@item.title}}</a>
            </div>
            <div class="search-item-summary" style="-webkit-box-orient: vertical;">
                {{@item.summary}}
            </div>
        </li>
        {{/each}}
    </ul>
{{else if list}}
    <h2>
        Oops! no result,
        Try it on <a target="_blank" style="color: #2c3e50; border-bottom: 2px solid #42b983; font-size: 19px;" href="https://www.google.com/search?q=site%3Aifyour.github.io+{{keywords}}">Google: {{keywords}}</a>~ 😱
    </h2>
{{/if}}</script></div><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/docs/" target="_self" class="nav-list-link">DOCS</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="javascript:;" target="_self" id="search" class="nav-list-link">SEARCH</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">ES6 Promise 简明指南</h1><div class="post-info">May 29, 2018<a href="https://codeburst.io/a-simple-guide-to-es6-promises-d71bacd2e13a" target="_blank" title="https://codeburst.io/a-simple-guide-to-es6-promises-d71bacd2e13a" class="post-from">Translation · Original Link</a></div><div class="sidebar-toc"><span>Catalog</span><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是-Promise"><span class="toc-text">什么是 Promise</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#生成一个-Promise"><span class="toc-text">生成一个 Promise</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何使用-Promises"><span class="toc-text">如何使用 Promises</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#捕获-Promise"><span class="toc-text">捕获 Promise</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#链式-Promise"><span class="toc-text">链式 Promise</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参考"><span class="toc-text">参考</span></a></li></ol></div><div class="post-content"><p>Promise 是 JavaScriptES6 中最令人兴奋的新增功能之一. ES5 中使用回调函数来处理异步操作. 过度使用回调则会产生回调地狱和多级嵌套缩带来的问题. Promise 通过将异步代码转化成同步执行的方式, 大大简化了异步编程方式.</p>
<a id="more"></a>
<p>这篇文章中, 我们来学习一下什么是 Promise 以及在开发中的实践.</p>
<h3 id="什么是-Promise"><a href="#什么是-Promise" class="headerlink" title="什么是 Promise"></a>什么是 Promise</h3><p>简单来说 Promise 就是一个存放着未来才会有计算结果的占位符. 稍微想想, 你会发现, 这和我们平常在谈话过程中说的承诺很像. 举个例子: 你准备去印度旅行, 你订了一张去印度的机票. 这个机票上写着多少号, 座位号是多少. 这个场景下, 机票就是航空公司给你许下的承诺: 在你准备出发那天给你预留了一个头等舱！😎</p>
<p>还有一个简单的例子, 你承诺你的朋友, 当你读完《计算机编程艺术》这本书后, 你就把这本书还回去. 在这里, 你所说的话就好比是一个占位符, 需要返回的值就是这本书.</p>
<p>你还可以想到其他一些类似承诺的例子, 比如在医生办公室等着、在餐馆点餐、在图书馆写书等等. 都涉及某种形式的承诺.</p>
<h3 id="生成一个-Promise"><a href="#生成一个-Promise" class="headerlink" title="生成一个 Promise"></a>生成一个 Promise</h3><p>当某项任务的完成时间不确定或太长时, 就可以使用 Promise. 例如, 网络请求可能需要 10ms 到 200ms（或更长）的时间, 具体取决于网速. 我们不想在获取数据时等待. 200 毫秒对你来说可能不太重要, 但对于一台电脑来说, 这是一段很长的时间. Promise 就是要让这种异步变得简单、轻松. 使用 Promise 构造函数, 来实例化一个 myPromise 实例, 像这样:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Math</span>.random() * <span class="number">100</span> &lt;= <span class="number">90</span>) &#123;</span><br><span class="line">    resolve(<span class="string">'Hello, Promises!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'In 10% of the cases, I fail. Miserably.'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>来看一下这个接收两个参数的函数. <code>new Promise()</code> 被称为执行器函数, 它描述了要完成的计算. 它的这两个参数通常被叫做 <code>resolve</code> 和 <code>reject</code>, 可以理解为 <strong>执行</strong> 和 <strong>拒绝</strong>, 它们用来标记执行器函数最终的计算结果. <code>resolve</code> 和 <code>reject</code> 本身是一个函数, 它用来返回一个值给我们的 Promise 实例.</p>
<p>当运算结果成功时, 或者未来着这个值准备就绪时, 我们就使用这个 <code>resolve</code> 函数来返回一个值, 我们就说: 我践行了当初许下的这个承诺.</p>
<p>同理, 当计算结果失败时, 或者计算过程中遇到了错误, 我们就使用 <code>reject</code> 函数, 我们就说: 我拒绝履行这个承诺. <code>reject</code> 函数可以接收任何值来作为参数, 但是比较推荐的是我们可以传递一个 <code>Error</code> 对象, 即: 抛出一个错误, 用来帮助我们调试代码, 这样就可以根据具体的抛出错误信息去解决问题啦.</p>
<p>在上面的这个例子中, <code>Math.random()</code> 用来生成一个随机数, 在 90% 的情况下, 这个 Promise 都应该被执行 (假设等概率分布), 剩余的情况下都是拒绝执行的.</p>
<h3 id="如何使用-Promises"><a href="#如何使用-Promises" class="headerlink" title="如何使用 Promises"></a>如何使用 Promises</h3><p>在上面的代码例子中, 我们生成了一个 Promise 实例 <code>myPromise</code>, 那么如何通过 <code>resolve</code> 和 <code>reject</code> 函数访问计算完成后的值呢? 所有的 <code>Promise</code> 实例都有一个 <code>.then()</code> 方法, 我们来瞧瞧:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Math</span>.random() * <span class="number">100</span> &lt; <span class="number">90</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'resolving the promise ...'</span>);</span><br><span class="line">    resolve(<span class="string">'Hello, Promises!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'In 10% of the cases, I fail. Miserably.'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Two functions</span></span><br><span class="line"><span class="keyword">const</span> onResolved = <span class="function"><span class="params">resolvedValue</span> =&gt;</span> <span class="built_in">console</span>.log(resolvedValue);</span><br><span class="line"><span class="keyword">const</span> onRejected = <span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(error);</span><br><span class="line"></span><br><span class="line">myPromise.then(onResolved, onRejected);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Same as above, written concisely</span></span><br><span class="line">myPromise.then(</span><br><span class="line">  resolvedValue =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(resolvedValue);</span><br><span class="line">  &#125;,</span><br><span class="line">  error =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output (in 90% of the cases)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// resolving the promise ...</span></span><br><span class="line"><span class="comment">// Hello, Promises!</span></span><br><span class="line"><span class="comment">// Hello, Promises!</span></span><br></pre></td></tr></table></figure>
<p><code>.then()</code> 方法接收 2 个回调函数, 第一个回调函数是当我们的 Promise 实例被执行 (resolve) 时调用, 第二个则是被拒绝 (reject) 时调用. 在上面的代码中, 我们使用 <code>onResolved</code> 和 <code>onRejected</code> 定义了这两个函数, 然后把它放到 <code>.then</code> 函数里, 当然, 你也可以按照常规写法, 直接在 <code>.then</code> 函数里写两个函数, 都是一样的.</p>
<p>在这个例子中, 有几点非常重要, 我们来说一下:</p>
<ul>
<li>一个 <code>promise</code> 只能是成功或者失败状态中的一个. 它不能成功或者失败多次. 也不能从成功状态切换到失败状态, 失败反之亦然.</li>
<li>你可以在成功或者失败状态后, 去定义这样一个回调函数. 当他们 <code>resolve</code> 或者 <code>reject</code> 仍然能正确调用.</li>
</ul>
<p>这就说明, <code>Promise</code> 最终只有一个状态, 即使你多次使用 <code>.then</code> 处理函数, 这个状态不能更改 (计算结果也不会重复执行).</p>
<p>为了验证这点, 你可以看到在第 3 行代码中, <code>console.log</code> 语句, 当你多次使用 <code>.then</code> 处理程序运行上述代码时, <code>console.log</code> 的语句只会被打印一次. 这就说明了 Promise 会缓存计算结果的, 当有一些相同的结果时, 缓存结果会被返回.</p>
<p>另一个重要的要注意的是, Promise 是 <a href="https://zh.wikipedia.org/wiki/%E5%8F%8A%E6%97%A9%E6%B1%82%E5%80%BC" target="_blank" rel="noopener">及早求值 (evaluated eagerly)</a> 的: 只要声明并将其赋值到变量上, 它已经开始在内存中执行了. 没有 <code>.start</code> 或 <code>.begin</code> 方法. 就像它在前面的例子中开始的那样.</p>
<p>为了确保 Promise 能被延迟调用, 我们通常还需要在它的外层包裹一个函数, 稍后的例子中我们会解释这个.</p>
<h3 id="捕获-Promise"><a href="#捕获-Promise" class="headerlink" title="捕获 Promise"></a>捕获 Promise</h3><p>到目前为止, 我们已经看到了 <code>resolve</code> 的场景, 那么当执行函数中出现一个错误时, 会发生什么呢? 在 <code>.then()</code> 函数中的第二个参数, 就是上面例子中的 <code>onRejected</code> 会被执行, 来看一个例子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Math</span>.random() * <span class="number">100</span> &lt; <span class="number">90</span>) &#123;</span><br><span class="line">    reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'The promise was rejected by using reject function.'</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'The promise was rejected by throwing an error'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">myPromise.then(</span><br><span class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'resolved'</span>),</span><br><span class="line">  error =&gt; <span class="built_in">console</span>.log(error.message)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output (in 90% of cases)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The promise was rejected by using reject function.</span></span><br></pre></td></tr></table></figure>
<p>和第一个例子一样的, 但是现在 90% 的情况是被 <code>reject</code> 的, 另外 10% 的情况则是抛出一个错误语句.</p>
<p>在第一个例子中, 我们分别定义了 <code>onResolved</code> 和 <code>onRejected</code> 方法, <code>onRejected</code> 方法将在错误发生时被调用, 可以看到 <code>reject</code> 函数的参数可以直接是错误提示, 没必要必须 <code>new Error</code>, 两个写法都一样.</p>
<p>健壮的程序代码离不开错误处理, <code>.then</code> 方法的第二个参数给了我们这样一个捷径. 当需要处理一个错误时, 可以用 <code>.catch(onRejected)</code> 来代替 <code>.then(null, () =&gt; {...})</code>, <code>catch</code> 方法接收一个回调函数 <code>onRejected</code>, 因此, 上面的代码, 可以使用 <code>catch</code> 来简化写法:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myPromise.catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(error.message));</span><br></pre></td></tr></table></figure>
<p>记住: <code>.catch</code> 方法仅仅是 <code>.then(undefined, onRejected)</code> 的语法糖而已.</p>
<h3 id="链式-Promise"><a href="#链式-Promise" class="headerlink" title="链式 Promise"></a>链式 Promise</h3><p><code>.then()</code> 和 <code>.catch()</code> 方法永远会返回一个 Promise 实例, 所以你可以链式使用多个 <code>.then</code> 一起来调用. 让我们来举个例子理解它.</p>
<p>首先, 我们写一个函数, 来延迟返回一个 Promise 实例. 这个返回的 Promise 将在稍后的时间内 <code>resolve</code>. 这里是实现方法:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> delay = <span class="function"><span class="params">ms</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(resolve, ms));</span><br></pre></td></tr></table></figure>
<p>在这个例子中, 我们正在使用一个函数来包裹我们的 Promise 实例, 所以它并不会立即执行. 这个 <code>delay</code> 函数接收一个时间来作为参数. 这个执行函数将接收 <code>ms</code> 作为他的参数, 它还包含一个 <code>setTimeout</code> , 它在 <code>ms</code> 毫秒后调用 <code>resolve</code> 函数, 从而正确执行. 看这个例子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delay(<span class="number">5000</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Resolved after 5 seconds'</span>));</span><br></pre></td></tr></table></figure>
<p><code>.then</code> 中的回调语句将在 <code>delay(5000)</code> 后执行. 当你执行上面的代码 5 秒后, 你就可以在控制台上看到输出结果了.</p>
<p>这里, 我们可以使用多个 <code>.then()</code> 方法来链式调用:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> delay = <span class="function"><span class="params">ms</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(resolve, ms));</span><br><span class="line"></span><br><span class="line">delay(<span class="number">2000</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Resolved after 2 seconds'</span>);</span><br><span class="line">    <span class="keyword">return</span> delay(<span class="number">1500</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Resolved after 1.5 seconds'</span>);</span><br><span class="line">    <span class="keyword">return</span> delay(<span class="number">3000</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Resolved after 3 seconds'</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Caught an error.'</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Done.'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Resolved after 2 seconds</span></span><br><span class="line"><span class="comment">// Resolved after 1.5 seconds</span></span><br><span class="line"><span class="comment">// Resolved after 3 seconds</span></span><br><span class="line"><span class="comment">// Caught an error.</span></span><br><span class="line"><span class="comment">// Done.</span></span><br></pre></td></tr></table></figure>
<p>从第 3 行开始, 它的执行步骤是这样的:</p>
<ul>
<li><code>delay(2000)</code> 函数执行, 它返回一个稍后 2 秒即将执行的 Promise 实例.</li>
<li>第 1 个 <code>.then()</code> 执行, 它输出语句 <code>Resolved after 2 seconds</code>, 然后它执行 <code>delay(1500)</code> 又返回一个 Promise 实例, 如果一个 <code>.then()</code> 返回了一个 Promise 实例, 那么它的 <code>resolve</code> 将被转发给下一个 <code>.then</code> 方法调用, 技术上叫: 沉降 (settlement).</li>
<li>只要像这样继续串联下去, 它会继续执行.</li>
</ul>
<p>注意在第三个 <code>.then()</code> 方法时, 我们在 <code>.then</code> 中抛出了一个错误. 这意味着当前的 Promise 被拒绝. 然后它会在下一个 <code>.catch</code> 语句中被捕获, <code>Caught an error</code> 将会被输出. 然而一个 <code>.catch</code> 语句它自己永远是被 <code>resolve</code> 的, 所以不需要在语句里再写 <code>reject</code> (除非你故意抛出一个错误), 这也是为什么在 <code>.catch</code> 语句后还可以继续写 <code>.then</code> 的原因.</p>
<p>比较推荐的做法是在 <code>.then</code> 方法后执行 <code>.catch</code> 而不是使用 <code>onResolved</code> 和 <code>onRejected</code>, 我们来举个例子说明一下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promiseThatResolves = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Leads to UnhandledPromiseRejection</span></span><br><span class="line">promiseThatResolves().then(</span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">  &#125;,</span><br><span class="line">  err =&gt; <span class="built_in">console</span>.log(err)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Proper error handling</span></span><br><span class="line">promiseThatResolves()</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err));</span><br></pre></td></tr></table></figure>
<p>我们创造一个永远能被 <code>resolve</code> 的 Promise 实例, 当你执行 <code>.then</code> 时, 可以带两个回调函数: <code>onResolved</code> 和 <code>onRejected</code>, 第一种写法, 在 <code>then</code> 种放入两个回调函数, 但是: 如果在第一个回调函数中继续抛出错误, 那么这个错误是不能被捕获的. 😅</p>
<p>第二种写法, 在 <code>.then</code> 语句的后面使用 <code>.catch</code> 捕获, 不光能捕获到执行函数 <code>promiseThatResolves</code> 的错误, 而且在 <code>.then()</code> 中的错误也是能被捕获到. 知道这样写的好处了吧!😁</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>你可以执行上面的所有代码片段来更深入的学习. 一种比较好的实践就是, 把所有基于回调的函数都用 Promise 来重新实现. 如果你写 Node.js 的话, 你会发现 <code>fs</code> 还有其他模块都是基于回调函数来实现的. 所以会存在一些工具库, 它们把所有基于回调的实现方式使用 Promise 来实现了. 比如 Node.js 的 <a href="https://nodejs.org/api/util.html#util_util_promisify_original" target="_blank" rel="noopener">util.promisify</a> 和 <a href="https://github.com/sindresorhus/pify" target="_blank" rel="noopener">pify</a>. 如果你在学习的话, 那么尽可能的尝试自己去实现. 或者说去读这些 Promise 实现库的源代码. 然后你就可以把这些最佳实践用于你的产品中啦!</p>
<p>还有一些关于 Promise 的东西没有完全讲到, 比如 <code>Promise.all</code> 和 <code>Promise.race</code> 方法, 处理 Promise 中的错误, 以及一些常见的反模式和细节等. 你可以参考下面的链接来学习更多关于 Promise 的知识.</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://www.ecma-international.org/ecma-262/6.0/#sec-promise-objects" target="_blank" rel="noopener">ECMA Promise Specification</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">Mozilla Docs</a></li>
<li><a href="https://developers.google.com/web/fundamentals/primers/promises#promise-api-reference" target="_blank" rel="noopener">Google’s Developer’s Guide on Promises written by Jake Archibald</a></li>
<li><a href="http://exploringjs.com/es6/ch_promises.html#sec_first-example-promises" target="_blank" rel="noopener">Exploring JS’s Chapter on Promises</a></li>
<li><a href="http://jamesknelson.com/grokking-es6-promises-the-four-functions-you-need-to-avoid-callback-hell/" target="_blank" rel="noopener">Introduction to Promises</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2018/06/09/给小白读的-WEB-托管服务进化史/" class="prev">PREV</a><a href="/2018/05/20/如何避免-async-await-地狱/" class="next">NEXT</a></div><div id="gc_container"></div><script src="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/gitment.browser.js"></script><script>(new Gitment({
    id: 'aid' + (new Date('Tue May 29 2018 22:28:41 GMT+0800')).getTime()/1000,
    title: 'ES6 Promise 简明指南' + ' · 评论',
    link: decodeURI(location.protocol + '//' + location.hostname + location.pathname),
    repo: 'ifyour.github.io',
    owner: 'ifyour',
    oauth: {
        client_id: '576e98d38d4bd19f8a02',
        client_secret: 'ba3616bf2f20c5da947a1fd5c7ef0edff4ffab99',
    }
})).render('gc_container');</script><div class="copyright"><p>© 2015 - 2019 Made with <span>❤</span> by <a href="https://github.com/ifyour/ifyour.github.io">Ifyour</a></p><p>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div><script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.4.0/lib/darkmode-js.min.js"></script><script>new Darkmode({
    bottom: '1rem',
    right: '1rem',
    left: 'unset',
    time: '0.5s',
    mixColor: '#fff',
    backgroundColor: '#fff',
    buttonColorDark: '#100f2c',
    buttonColorLight: '#fff',
    saveInCookies: true,
    label: '🌓',
    autoMatchOsTheme: true
}).showWidget();
</script><script src="/js/algoliasearch.min.js"></script><script src="/js/template-web.min.js"></script><script src="/js/main.js"></script><script src="https://unpkg.com/medium-zoom@0/dist/medium-zoom.min.js"></script><script>mediumZoom('article img', {margin: 24});
(function(win, targetElem) {
    if (!targetElem) return;
    win.onscroll = (function() {
        if (isElementInViewport(targetElem)) {
            win.onscroll = null;
            return mediumZoom('.gitment-comment-main img', {margin: 24});
        }
        return arguments.callee;
    })();
    function isElementInViewport(el) {
        var rect = el.getBoundingClientRect();
        var winH = win.innerHeight || document.documentElement.clientHeight;
        return rect.top <= winH && rect.bottom >= winH;
    };
})(this, document.querySelector('#gc_container'));
</script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-120929321-1",'auto');ga('send','pageview');</script></footer></div><script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>