<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ifyour&#39;s Blog</title>
  
  <subtitle>Talk is cheap. Show me the code.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ifyour.github.io/"/>
  <updated>2019-12-07T06:07:38.533Z</updated>
  <id>http://ifyour.github.io/</id>
  
  <author>
    <name>Ifyour</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>代码洁癖养成指南</title>
    <link href="http://ifyour.github.io/2018/12/31/%E4%BB%A3%E7%A0%81%E6%B4%81%E7%99%96%E5%85%BB%E6%88%90%E6%8C%87%E5%8D%97/"/>
    <id>http://ifyour.github.io/2018/12/31/代码洁癖养成指南/</id>
    <published>2018-12-31T12:45:31.000Z</published>
    <updated>2019-12-07T06:07:38.533Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章我从几个方面来介绍我是如何配置开发环境的，尽可能使代码编写风格统一。其实不光是代码，包括日常文字，都有很多规范。比如最常见的中英文之间添加空格，可能很多人并没有在意。但是看到别人的文章里出现这样的问题，肯定是要减印象分的。</p><a id="more"></a><p>因为我日常使用 <strong>VSCode</strong>，所以这里相关配置都以这个展开。</p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><ul><li><a href="https://marketplace.visualstudio.com/items?itemName=EditorConfig.EditorConfig" target="_blank" rel="noopener">EditorConfig for VS Code</a></li><li><a href="https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint" target="_blank" rel="noopener">ESLint</a></li><li><a href="https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode" target="_blank" rel="noopener">Prettier - Code formatter</a></li><li><a href="https://marketplace.visualstudio.com/items?itemName=baurine.vscode-pangu" target="_blank" rel="noopener">VSCode-Pangu</a></li><li><a href="https://marketplace.visualstudio.com/items?itemName=streetsidesoftware.code-spell-checker" target="_blank" rel="noopener">Code Spell Checker</a></li><li><a href="https://marketplace.visualstudio.com/items?itemName=oderwat.indent-rainbow" target="_blank" rel="noopener">Indent-Rainbow</a></li></ul><p>下面来我简单介绍一下每个插件的功能。</p><ul><li>EditorConfig：生成 <code>.editorconfig</code> 配置文件，规定当前编辑器的一些设定。</li><li>ESLint：集成 Eslint 到 VSCode，具体看 Eslint 的官方文档。</li><li>Prettier：Eslint 侧重于静态校验，而 Prettier 则负责按照一些规则美化代码。</li><li>VSCode-Pangu：自动在中英文之间添加空格。</li><li>Code Spell Checker：单词拼写检查。</li><li>Indent-Rainbow：彩虹缩进，缩进不规范时会标红提示。</li></ul><h3 id="偏好"><a href="#偏好" class="headerlink" title="偏好"></a>偏好</h3><h4 id="VSCode-Settings"><a href="#VSCode-Settings" class="headerlink" title="VSCode Settings"></a>VSCode Settings</h4><p>安装插件：ESLint、Prettier 后，在 settings 配置下面的选项，即可实现保存时自动格式化：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开启保存自动格式化，调用 Prettier 时自动 eslint -fix</span></span><br><span class="line">  <span class="string">"editor.formatOnSave"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// 不需要 fix 了，Prettier 会自动 fix</span></span><br><span class="line">  <span class="string">"eslint.autoFixOnSave"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">// 告诉 Prettier 使用 `prettier-eslint` 来代替 Prettier</span></span><br><span class="line">  <span class="string">"prettier.eslintIntegration"</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Lint"><a href="#Lint" class="headerlink" title="Lint"></a>Lint</h3><h4 id="使用-Prettier-按照-Eslint-美化代码"><a href="#使用-Prettier-按照-Eslint-美化代码" class="headerlink" title="使用 Prettier 按照 Eslint 美化代码"></a>使用 Prettier 按照 Eslint 美化代码</h4><ul><li>安装 <code>prettier-eslint-cli</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i prettier-eslint-cli --save-dev</span><br></pre></td></tr></table></figure><ul><li>配置 <code>prettier</code>，在 <code>package.json</code> 添加</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"lint"</span>: <span class="string">"eslint *.js"</span>,</span><br><span class="line">    <span class="attr">"format"</span>: <span class="string">"prettier-eslint --write *.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"eslintConfig"</span>: &#123;</span><br><span class="line">    <span class="attr">"extends"</span>: <span class="string">"some-config"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"prettier"</span>: &#123;</span><br><span class="line">    <span class="attr">"singleQuote"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"semi"</span>: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过上面配置后，编辑器就可以在保存文件时，自动按照 Eslint 格式化。</p><h4 id="使用-Standard-规范"><a href="#使用-Standard-规范" class="headerlink" title="使用 Standard 规范"></a>使用 Standard 规范</h4><p><a href="https://github.com/standard" target="_blank" rel="noopener">Standard</a> 其实并不是标准组织出的规范，但是行业内使用的比较多。看来看去，好像各种各样的约定都没有一个标准。我看了一下，目前来说 <code>standard</code> 还算有影响力。打算以后在个人项目中全部采用这种风格，然后把剩下的时间去做点有意义的事。配置一堆 <code>.eslintrc</code> <code>.jscsrc</code> <code>.jshintrc</code> 真的很头疼。</p><p>☝️ <strong>初始化新项目</strong></p><ul><li>安装依赖</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">npm install eslint \</span><br><span class="line">    eslint-config-standard \</span><br><span class="line">    eslint-plugin-standard \</span><br><span class="line">    eslint-plugin-promise \</span><br><span class="line">    eslint-plugin-import \</span><br><span class="line">    eslint-plugin-node \</span><br><span class="line">    eslint-plugin-markdown \</span><br><span class="line">    --save-dev</span><br></pre></td></tr></table></figure><ul><li>添加 <code>.eslintrc</code></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"extends"</span>: <span class="string">"standard"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK，现在让 Eslint 按照 standard 的规则来约束了，还可以使用另外的规则来覆盖。</p><p>☝️ <strong>全局使用</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局安装</span></span><br><span class="line">$ npm i standard -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 校验目录下 *.js/*.jsx</span></span><br><span class="line">$ standard</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修复</span></span><br><span class="line">$ standard --fix</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以后的新项目我会采用 Standard 作为约束规范，对于已有项目我使用 Prettier 自动按照 Eslint 规则自动美化，日常一些代码片段使用 Standard 全局命令，简单实用。</p><p>参考以下文档。</p><ul><li><a href="https://github.com/standard/standard/blob/master/docs/README-zhcn.md" target="_blank" rel="noopener">standard/standard @Github</a></li><li><a href="https://github.com/standard/eslint-config-standard" target="_blank" rel="noopener">standard/eslint-config-standard @Github</a></li><li><a href="https://github.com/expressjs/body-parser" target="_blank" rel="noopener">Standard Style Demo @Github</a></li><li><a href="https://cn.eslint.org/" target="_blank" rel="noopener">ESLint @中文官网</a></li><li><a href="https://egoist.moe/2017/12/11/write-better-code-with-eslint-and-prettier/" target="_blank" rel="noopener">用 ESLint 和 Prettier 写出高质量代码 @EGOIST</a></li></ul><h3 id="附：Eslint-规则"><a href="#附：Eslint-规则" class="headerlink" title="附：Eslint 规则"></a>附：Eslint 规则</h3><h4 id="关闭校验"><a href="#关闭校验" class="headerlink" title="关闭校验"></a>关闭校验</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关闭当前文件</span></span><br><span class="line"><span class="comment">/* eslint-disable */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭当前行校验</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>; <span class="comment">// eslint-disable-line</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭下一行校验</span></span><br><span class="line"><span class="comment">// eslint-disable-next-line</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><h4 id="详细规则"><a href="#详细规则" class="headerlink" title="详细规则"></a>详细规则</h4><ul><li>0：关闭</li><li>1：警告，仅给出警告</li><li>2：错误，停止执行</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 环境定义了预定义的全局变量。</span></span><br><span class="line">    <span class="string">"env"</span>: &#123;</span><br><span class="line">        <span class="comment">// 环境定义了预定义的全局变量。更多在官网查看</span></span><br><span class="line">        <span class="string">"browser"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"node"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"commonjs"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"amd"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"es6"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"mocha"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// JavaScript 语言选项</span></span><br><span class="line">    <span class="string">"parserOptions"</span>: &#123;</span><br><span class="line">        <span class="comment">// ECMAScript 版本</span></span><br><span class="line">        <span class="string">"ecmaVersion"</span>: <span class="number">6</span>,</span><br><span class="line">        <span class="string">"sourceType"</span>: <span class="string">"module"</span>, <span class="comment">// 设置为 "script" (默认) 或 "module"（如果你的代码是 ECMAScript 模块)。</span></span><br><span class="line">        <span class="comment">// 想使用的额外的语言特性:</span></span><br><span class="line">        <span class="string">"ecmaFeatures"</span>: &#123;</span><br><span class="line">            <span class="comment">// 允许在全局作用域下使用 return 语句</span></span><br><span class="line">            <span class="string">"globalReturn"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="comment">// impliedStric</span></span><br><span class="line">            <span class="string">"impliedStrict"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="comment">// 启用 JSX</span></span><br><span class="line">            <span class="string">"jsx"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="string">"modules"</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 让 eslint 支持 JSX start</span></span><br><span class="line">    <span class="string">"plugins"</span>: [</span><br><span class="line">        <span class="string">"react"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"extends"</span>: [</span><br><span class="line">        <span class="string">"eslint:recommended"</span>,</span><br><span class="line">        <span class="string">"plugin:react/recommended"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// 让 eslint 支持 JSX end</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"rules"</span>: &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">////////////////</span></span><br><span class="line">        <span class="comment">// 可能的错误 //</span></span><br><span class="line">        <span class="comment">////////////////</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止条件表达式中出现赋值操作符</span></span><br><span class="line">        <span class="string">"no-cond-assign"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 禁用 console</span></span><br><span class="line">        <span class="string">"no-console"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 禁止在条件中使用常量表达式</span></span><br><span class="line">        <span class="comment">// if (false) &#123;</span></span><br><span class="line">        <span class="comment">// doSomethingUnfinished();</span></span><br><span class="line">        <span class="comment">// &#125; //cuowu</span></span><br><span class="line">        <span class="string">"no-constant-condition"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 禁止在正则表达式中使用控制字符 ：new RegExp("\x1f")</span></span><br><span class="line">        <span class="string">"no-control-regex"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 数组和对象键值对最后一个逗号， never 参数：不能带末尾的逗号, always 参数：必须带末尾的逗号，</span></span><br><span class="line">        <span class="comment">// always-multiline：多行模式必须带逗号，单行模式不能带逗号</span></span><br><span class="line">        <span class="string">"comma-dangle"</span>: [<span class="number">1</span>, <span class="string">"never"</span>],</span><br><span class="line">        <span class="comment">// 禁用 debugger</span></span><br><span class="line">        <span class="string">"no-debugger"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 禁止 function 定义中出现重名参数</span></span><br><span class="line">        <span class="string">"no-dupe-args"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 禁止对象字面量中出现重复的 key</span></span><br><span class="line">        <span class="string">"no-dupe-keys"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 禁止重复的 case 标签</span></span><br><span class="line">        <span class="string">"no-duplicate-case"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 禁止空语句块</span></span><br><span class="line">        <span class="string">"no-empty"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 禁止在正则表达式中使用空字符集 (/^abc[]/)</span></span><br><span class="line">        <span class="string">"no-empty-character-class"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 禁止对 catch 子句的参数重新赋值</span></span><br><span class="line">        <span class="string">"no-ex-assign"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 禁止不必要的布尔转换</span></span><br><span class="line">        <span class="string">"no-extra-boolean-cast"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 禁止不必要的括号 //(a * b) + c;// 报错</span></span><br><span class="line">        <span class="string">"no-extra-parens"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 禁止不必要的分号</span></span><br><span class="line">        <span class="string">"no-extra-semi"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 禁止对 function 声明重新赋值</span></span><br><span class="line">        <span class="string">"no-func-assign"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 禁止在嵌套的块中出现 function 或 var 声明</span></span><br><span class="line">        <span class="string">"no-inner-declarations"</span>: [<span class="number">2</span>, <span class="string">"functions"</span>],</span><br><span class="line">        <span class="comment">// 禁止 RegExp 构造函数中无效的正则表达式字符串</span></span><br><span class="line">        <span class="string">"no-invalid-regexp"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 禁止在字符串和注释之外不规则的空白</span></span><br><span class="line">        <span class="string">"no-irregular-whitespace"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 禁止在 in 表达式中出现否定的左操作数</span></span><br><span class="line">        <span class="string">"no-negated-in-lhs"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 禁止把全局对象 (Math 和 JSON) 作为函数调用 错误：var math = Math();</span></span><br><span class="line">        <span class="string">"no-obj-calls"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 禁止直接使用 Object.prototypes 的内置属性</span></span><br><span class="line">        <span class="string">"no-prototype-builtins"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 禁止正则表达式字面量中出现多个空格</span></span><br><span class="line">        <span class="string">"no-regex-spaces"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 禁用稀疏数组</span></span><br><span class="line">        <span class="string">"no-sparse-arrays"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 禁止出现令人困惑的多行表达式</span></span><br><span class="line">        <span class="string">"no-unexpected-multiline"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 禁止在 return、throw、continue 和 break 语句之后出现不可达代码</span></span><br><span class="line">        <span class="string">"no-unreachable"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 要求使用 isNaN() 检查 NaN</span></span><br><span class="line">        <span class="string">"use-isnan"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 强制使用有效的 JSDoc 注释</span></span><br><span class="line">        <span class="string">"valid-jsdoc"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="comment">// 强制 typeof 表达式与有效的字符串进行比较</span></span><br><span class="line">        <span class="comment">// typeof foo === "undefimed" 错误</span></span><br><span class="line">        <span class="string">"valid-typeof"</span>: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//////////////</span></span><br><span class="line">        <span class="comment">// 最佳实践 //</span></span><br><span class="line">        <span class="comment">//////////////</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义对象的 set 存取器属性时，强制定义 get</span></span><br><span class="line">        <span class="string">"accessor-pairs"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 强制数组方法的回调函数中有 return 语句</span></span><br><span class="line">        <span class="string">"array-callback-return"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 强制把变量的使用限制在其定义的作用域范围内</span></span><br><span class="line">        <span class="string">"block-scoped-var"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 限制圈复杂度，也就是类似 if else 能连续接多少个</span></span><br><span class="line">        <span class="string">"complexity"</span>: [<span class="number">2</span>, <span class="number">9</span>],</span><br><span class="line">        <span class="comment">// 要求 return 语句要么总是指定返回的值，要么不指定</span></span><br><span class="line">        <span class="string">"consistent-return"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 强制所有控制语句使用一致的括号风格</span></span><br><span class="line">        <span class="string">"curly"</span>: [<span class="number">2</span>, <span class="string">"all"</span>],</span><br><span class="line">        <span class="comment">// switch 语句强制 default 分支，也可添加 // no default 注释取消此次警告</span></span><br><span class="line">        <span class="string">"default-case"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 强制 object.key 中 . 的位置，参数:</span></span><br><span class="line">        <span class="comment">// property，'.'号应与属性在同一行</span></span><br><span class="line">        <span class="comment">// object, '.' 号应与对象名在同一行</span></span><br><span class="line">        <span class="string">"dot-location"</span>: [<span class="number">2</span>, <span class="string">"property"</span>],</span><br><span class="line">        <span class="comment">// 强制使用. 号取属性</span></span><br><span class="line">        <span class="comment">// 参数： allowKeywords：true 使用保留字做属性名时，只能使用. 方式取属性</span></span><br><span class="line">        <span class="comment">// false 使用保留字做属性名时, 只能使用 [] 方式取属性 e.g [2, &#123;"allowKeywords": false&#125;]</span></span><br><span class="line">        <span class="comment">// allowPattern: 当属性名匹配提供的正则表达式时，允许使用 [] 方式取值, 否则只能用. 号取值 e.g [2, &#123;"allowPattern": "^[a-z]+(_[a-z]+)+$"&#125;]</span></span><br><span class="line">        <span class="string">"dot-notation"</span>: [<span class="number">2</span>, &#123;</span><br><span class="line">            <span class="string">"allowKeywords"</span>: <span class="literal">false</span></span><br><span class="line">        &#125;],</span><br><span class="line">        <span class="comment">// 使用 === 替代 == allow-null 允许 null 和 undefined==</span></span><br><span class="line">        <span class="string">"eqeqeq"</span>: [<span class="number">2</span>, <span class="string">"allow-null"</span>],</span><br><span class="line">        <span class="comment">// 要求 for-in 循环中有一个 if 语句</span></span><br><span class="line">        <span class="string">"guard-for-in"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 禁用 alert、confirm 和 prompt</span></span><br><span class="line">        <span class="string">"no-alert"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 禁用 arguments.caller 或 arguments.callee</span></span><br><span class="line">        <span class="string">"no-caller"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 不允许在 case 子句中使用词法声明</span></span><br><span class="line">        <span class="string">"no-case-declarations"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 禁止除法操作符显式的出现在正则表达式开始的位置</span></span><br><span class="line">        <span class="string">"no-div-regex"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 禁止 if 语句中有 return 之后有 else</span></span><br><span class="line">        <span class="string">"no-else-return"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 禁止出现空函数. 如果一个函数包含了一条注释，它将不会被认为有问题。</span></span><br><span class="line">        <span class="string">"no-empty-function"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 禁止使用空解构模式 no-empty-pattern</span></span><br><span class="line">        <span class="string">"no-empty-pattern"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 禁止在没有类型检查操作符的情况下与 null 进行比较</span></span><br><span class="line">        <span class="string">"no-eq-null"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="comment">// 禁用 eval()</span></span><br><span class="line">        <span class="string">"no-eval"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 禁止扩展原生类型</span></span><br><span class="line">        <span class="string">"no-extend-native"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 禁止不必要的 .bind() 调用</span></span><br><span class="line">        <span class="string">"no-extra-bind"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 禁用不必要的标签</span></span><br><span class="line">        <span class="string">"no-extra-label:"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 禁止 case 语句落空</span></span><br><span class="line">        <span class="string">"no-fallthrough"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 禁止数字字面量中使用前导和末尾小数点</span></span><br><span class="line">        <span class="string">"no-floating-decimal"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 禁止使用短符号进行类型转换 (!!fOO)</span></span><br><span class="line">        <span class="string">"no-implicit-coercion"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 禁止在全局范围内使用 var 和命名的 function 声明</span></span><br><span class="line">        <span class="string">"no-implicit-globals"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="comment">// 禁止使用类似 eval() 的方法</span></span><br><span class="line">        <span class="string">"no-implied-eval"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 禁止 this 关键字出现在类和类对象之外</span></span><br><span class="line">        <span class="string">"no-invalid-this"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 禁用 __iterator__ 属性</span></span><br><span class="line">        <span class="string">"no-iterator"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 禁用标签语句</span></span><br><span class="line">        <span class="string">"no-labels"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 禁用不必要的嵌套块</span></span><br><span class="line">        <span class="string">"no-lone-blocks"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 禁止在循环中出现 function 声明和表达式</span></span><br><span class="line">        <span class="string">"no-loop-func"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="comment">// 禁用魔术数字 (3.14 什么的用常量代替)</span></span><br><span class="line">        <span class="string">"no-magic-numbers"</span>: [<span class="number">1</span>, &#123;</span><br><span class="line">            <span class="string">"ignore"</span>: [<span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>]</span><br><span class="line">        &#125;],</span><br><span class="line">        <span class="comment">// 禁止使用多个空格</span></span><br><span class="line">        <span class="string">"no-multi-spaces"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 禁止使用多行字符串，在 JavaScript 中，可以在新行之前使用斜线创建多行字符串</span></span><br><span class="line">        <span class="string">"no-multi-str"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 禁止对原生对象赋值</span></span><br><span class="line">        <span class="string">"no-native-reassign"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 禁止在非赋值或条件语句中使用 new 操作符</span></span><br><span class="line">        <span class="string">"no-new"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 禁止对 Function 对象使用 new 操作符</span></span><br><span class="line">        <span class="string">"no-new-func"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 禁止对 String，Number 和 Boolean 使用 new 操作符</span></span><br><span class="line">        <span class="string">"no-new-wrappers"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 禁用八进制字面量</span></span><br><span class="line">        <span class="string">"no-octal"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 禁止在字符串中使用八进制转义序列</span></span><br><span class="line">        <span class="string">"no-octal-escape"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 不允许对 function 的参数进行重新赋值</span></span><br><span class="line">        <span class="string">"no-param-reassign"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 禁用 __proto__ 属性</span></span><br><span class="line">        <span class="string">"no-proto"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 禁止使用 var 多次声明同一变量</span></span><br><span class="line">        <span class="string">"no-redeclare"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 禁用指定的通过 require 加载的模块</span></span><br><span class="line">        <span class="string">"no-return-assign"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 禁止使用 javascript: url</span></span><br><span class="line">        <span class="string">"no-script-url"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 禁止自我赋值</span></span><br><span class="line">        <span class="string">"no-self-assign"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 禁止自身比较</span></span><br><span class="line">        <span class="string">"no-self-compare"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 禁用逗号操作符</span></span><br><span class="line">        <span class="string">"no-sequences"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 禁止抛出非异常字面量</span></span><br><span class="line">        <span class="string">"no-throw-literal"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 禁用一成不变的循环条件</span></span><br><span class="line">        <span class="string">"no-unmodified-loop-condition"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 禁止出现未使用过的表达式</span></span><br><span class="line">        <span class="string">"no-unused-expressions"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 禁用未使用过的标签</span></span><br><span class="line">        <span class="string">"no-unused-labels"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 禁止不必要的 .call() 和 .apply()</span></span><br><span class="line">        <span class="string">"no-useless-call"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 禁止不必要的字符串字面量或模板字面量的连接</span></span><br><span class="line">        <span class="string">"no-useless-concat"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 禁用不必要的转义字符</span></span><br><span class="line">        <span class="string">"no-useless-escape"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 禁用 void 操作符</span></span><br><span class="line">        <span class="string">"no-void"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 禁止在注释中使用特定的警告术语</span></span><br><span class="line">        <span class="string">"no-warning-comments"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 禁用 with 语句</span></span><br><span class="line">        <span class="string">"no-with"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 强制在 parseInt() 使用基数参数</span></span><br><span class="line">        <span class="string">"radix"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 要求所有的 var 声明出现在它们所在的作用域顶部</span></span><br><span class="line">        <span class="string">"vars-on-top"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 要求 IIFE 使用括号括起来</span></span><br><span class="line">        <span class="string">"wrap-iife"</span>: [<span class="number">2</span>, <span class="string">"any"</span>],</span><br><span class="line">        <span class="comment">// 要求或禁止 “Yoda” 条件</span></span><br><span class="line">        <span class="string">"yoda"</span>: [<span class="number">2</span>, <span class="string">"never"</span>],</span><br><span class="line">        <span class="comment">// 要求或禁止使用严格模式指令</span></span><br><span class="line">        <span class="string">"strict"</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//////////////</span></span><br><span class="line">        <span class="comment">// 变量声明 //</span></span><br><span class="line">        <span class="comment">//////////////</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 要求或禁止 var 声明中的初始化 (初值)</span></span><br><span class="line">        <span class="string">"init-declarations"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 不允许 catch 子句的参数与外层作用域中的变量同名</span></span><br><span class="line">        <span class="string">"no-catch-shadow"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 禁止删除变量</span></span><br><span class="line">        <span class="string">"no-delete-var"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 不允许标签与变量同名</span></span><br><span class="line">        <span class="string">"no-label-var"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 禁用特定的全局变量</span></span><br><span class="line">        <span class="string">"no-restricted-globals"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 禁止 var 声明 与外层作用域的变量同名</span></span><br><span class="line">        <span class="string">"no-shadow"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 禁止覆盖受限制的标识符</span></span><br><span class="line">        <span class="string">"no-shadow-restricted-names"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 禁用未声明的变量，除非它们在 /*global */ 注释中被提到</span></span><br><span class="line">        <span class="string">"no-undef"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 禁止将变量初始化为 undefined</span></span><br><span class="line">        <span class="string">"no-undef-init"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 禁止将 undefined 作为标识符</span></span><br><span class="line">        <span class="string">"no-undefined"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 禁止出现未使用过的变量</span></span><br><span class="line">        <span class="string">"no-unused-vars"</span>: [<span class="number">2</span>, &#123;</span><br><span class="line">            <span class="string">"vars"</span>: <span class="string">"all"</span>,</span><br><span class="line">            <span class="string">"args"</span>: <span class="string">"none"</span></span><br><span class="line">        &#125;],</span><br><span class="line">        <span class="comment">// 不允许在变量定义之前使用它们</span></span><br><span class="line">        <span class="string">"no-use-before-define"</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">//////////////////////////</span></span><br><span class="line">        <span class="comment">// Node.js and CommonJS //</span></span><br><span class="line">        <span class="comment">//////////////////////////</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// require return statements after callbacks</span></span><br><span class="line">        <span class="string">"callback-return"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 要求 require() 出现在顶层模块作用域中</span></span><br><span class="line">        <span class="string">"global-require"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="comment">// 要求回调函数中有容错处理</span></span><br><span class="line">        <span class="string">"handle-callback-err"</span>: [<span class="number">2</span>, <span class="string">"^(err|error)$"</span>],</span><br><span class="line">        <span class="comment">// 禁止混合常规 var 声明和 require 调用</span></span><br><span class="line">        <span class="string">"no-mixed-requires"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 禁止调用 require 时使用 new 操作符</span></span><br><span class="line">        <span class="string">"no-new-require"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 禁止对 __dirname 和 __filename 进行字符串连接</span></span><br><span class="line">        <span class="string">"no-path-concat"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 禁用 process.env</span></span><br><span class="line">        <span class="string">"no-process-env"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 禁用 process.exit()</span></span><br><span class="line">        <span class="string">"no-process-exit"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 禁用同步方法</span></span><br><span class="line">        <span class="string">"no-sync"</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">//////////////</span></span><br><span class="line">        <span class="comment">// 风格指南 //</span></span><br><span class="line">        <span class="comment">//////////////</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指定数组的元素之间要以空格隔开 (, 后面)， never 参数：[ 之前和 ] 之后不能带空格，always 参数：[ 之前和 ] 之后必须带空格</span></span><br><span class="line">        <span class="string">"array-bracket-spacing"</span>: [<span class="number">2</span>, <span class="string">"never"</span>],</span><br><span class="line">        <span class="comment">// 禁止或强制在单行代码块中使用空格 (禁用)</span></span><br><span class="line">        <span class="string">"block-spacing"</span>: [<span class="number">1</span>, <span class="string">"never"</span>],</span><br><span class="line">        <span class="comment">// 强制使用一致的缩进 第二个参数为 "tab" 时，会使用 tab，</span></span><br><span class="line">        <span class="comment">// if while function 后面的 &#123;必须与 if 在同一行，java 风格。</span></span><br><span class="line">        <span class="string">"brace-style"</span>: [<span class="number">2</span>, <span class="string">"1tbs"</span>, &#123;</span><br><span class="line">            <span class="string">"allowSingleLine"</span>: <span class="literal">true</span></span><br><span class="line">        &#125;],</span><br><span class="line">        <span class="comment">// 双峰驼命名格式</span></span><br><span class="line">        <span class="string">"camelcase"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 控制逗号前后的空格</span></span><br><span class="line">        <span class="string">"comma-spacing"</span>: [<span class="number">2</span>, &#123;</span><br><span class="line">            <span class="string">"before"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"after"</span>: <span class="literal">true</span></span><br><span class="line">        &#125;],</span><br><span class="line">        <span class="comment">// 控制逗号在行尾出现还是在行首出现 (默认行尾)</span></span><br><span class="line">        <span class="comment">// http://eslint.org/docs/rules/comma-style</span></span><br><span class="line">        <span class="string">"comma-style"</span>: [<span class="number">2</span>, <span class="string">"last"</span>],</span><br><span class="line">        <span class="comment">//"SwitchCase" (默认：0) 强制 switch 语句中的 case 子句的缩进水平</span></span><br><span class="line">        <span class="comment">// 以方括号取对象属性时，[后面和] 前面是否需要空格, 可选参数 never, always</span></span><br><span class="line">        <span class="string">"computed-property-spacing"</span>: [<span class="number">2</span>, <span class="string">"never"</span>],</span><br><span class="line">        <span class="comment">// 用于指统一在回调函数中指向 this 的变量名，箭头函数中的 this 已经可以指向外层调用者，应该没卵用了</span></span><br><span class="line">        <span class="comment">// e.g [0,"that"] 指定只能 var that = this. that 不能指向其他任何值，this 也不能赋值给 that 以外的其他值</span></span><br><span class="line">        <span class="string">"consistent-this"</span>: [<span class="number">1</span>, <span class="string">"that"</span>],</span><br><span class="line">        <span class="comment">// 强制使用命名的 function 表达式</span></span><br><span class="line">        <span class="string">"func-names"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 文件末尾强制换行</span></span><br><span class="line">        <span class="string">"eol-last"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">"indent"</span>: [<span class="number">2</span>, <span class="number">4</span>, &#123;</span><br><span class="line">            <span class="string">"SwitchCase"</span>: <span class="number">1</span></span><br><span class="line">        &#125;],</span><br><span class="line">        <span class="comment">// 强制在对象字面量的属性中键和值之间使用一致的间距</span></span><br><span class="line">        <span class="string">"key-spacing"</span>: [<span class="number">2</span>, &#123;</span><br><span class="line">            <span class="string">"beforeColon"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"afterColon"</span>: <span class="literal">true</span></span><br><span class="line">        &#125;],</span><br><span class="line">        <span class="comment">// 强制使用一致的换行风格</span></span><br><span class="line">        <span class="string">"linebreak-style"</span>: [<span class="number">1</span>, <span class="string">"unix"</span>],</span><br><span class="line">        <span class="comment">// 要求在注释周围有空行 (要求在块级注释之前有一空行)</span></span><br><span class="line">        <span class="string">"lines-around-comment"</span>: [<span class="number">1</span>, &#123;</span><br><span class="line">            <span class="string">"beforeBlockComment"</span>: <span class="literal">true</span></span><br><span class="line">        &#125;],</span><br><span class="line">        <span class="comment">// 强制一致地使用函数声明或函数表达式，方法定义风格，参数：</span></span><br><span class="line">        <span class="comment">// declaration: 强制使用方法声明的方式，function f()&#123;&#125; e.g [2, "declaration"]</span></span><br><span class="line">        <span class="comment">// expression：强制使用方法表达式的方式，var f = function() &#123;&#125; e.g [2, "expression"]</span></span><br><span class="line">        <span class="comment">// allowArrowFunctions: declaration 风格中允许箭头函数。 e.g [2, "declaration", &#123; "allowArrowFunctions": true&#125;]</span></span><br><span class="line">        <span class="string">"func-style"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 强制回调函数最大嵌套深度 5 层</span></span><br><span class="line">        <span class="string">"max-nested-callbacks"</span>: [<span class="number">1</span>, <span class="number">5</span>],</span><br><span class="line">        <span class="comment">// 禁止使用指定的标识符</span></span><br><span class="line">        <span class="string">"id-blacklist"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 强制标识符的最新和最大长度</span></span><br><span class="line">        <span class="string">"id-length"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 要求标识符匹配一个指定的正则表达式</span></span><br><span class="line">        <span class="string">"id-match"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 强制在 JSX 属性中一致地使用双引号或单引号</span></span><br><span class="line">        <span class="string">"jsx-quotes"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 强制在关键字前后使用一致的空格 (前后腰需要)</span></span><br><span class="line">        <span class="string">"keyword-spacing"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 强制一行的最大长度</span></span><br><span class="line">        <span class="string">"max-len"</span>: [<span class="number">1</span>, <span class="number">200</span>],</span><br><span class="line">        <span class="comment">// 强制最大行数</span></span><br><span class="line">        <span class="string">"max-lines"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 强制 function 定义中最多允许的参数数量</span></span><br><span class="line">        <span class="string">"max-params"</span>: [<span class="number">1</span>, <span class="number">7</span>],</span><br><span class="line">        <span class="comment">// 强制 function 块最多允许的的语句数量</span></span><br><span class="line">        <span class="string">"max-statements"</span>: [<span class="number">1</span>, <span class="number">200</span>],</span><br><span class="line">        <span class="comment">// 强制每一行中所允许的最大语句数量</span></span><br><span class="line">        <span class="string">"max-statements-per-line"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 要求构造函数首字母大写 （要求调用 new 操作符时有首字母大小的函数，允许调用首字母大写的函数时没有 new 操作符。）</span></span><br><span class="line">        <span class="string">"new-cap"</span>: [<span class="number">2</span>, &#123;</span><br><span class="line">            <span class="string">"newIsCap"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="string">"capIsNew"</span>: <span class="literal">false</span></span><br><span class="line">        &#125;],</span><br><span class="line">        <span class="comment">// 要求调用无参构造函数时有圆括号</span></span><br><span class="line">        <span class="string">"new-parens"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 要求或禁止 var 声明语句后有一行空行</span></span><br><span class="line">        <span class="string">"newline-after-var"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 禁止使用 Array 构造函数</span></span><br><span class="line">        <span class="string">"no-array-constructor"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 禁用按位运算符</span></span><br><span class="line">        <span class="string">"no-bitwise"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 要求 return 语句之前有一空行</span></span><br><span class="line">        <span class="string">"newline-before-return"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 要求方法链中每个调用都有一个换行符</span></span><br><span class="line">        <span class="string">"newline-per-chained-call"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="comment">// 禁用 continue 语句</span></span><br><span class="line">        <span class="string">"no-continue"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 禁止在代码行后使用内联注释</span></span><br><span class="line">        <span class="string">"no-inline-comments"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 禁止 if 作为唯一的语句出现在 else 语句中</span></span><br><span class="line">        <span class="string">"no-lonely-if"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 禁止混合使用不同的操作符</span></span><br><span class="line">        <span class="string">"no-mixed-operators"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 不允许空格和 tab 混合缩进</span></span><br><span class="line">        <span class="string">"no-mixed-spaces-and-tabs"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 不允许多个空行</span></span><br><span class="line">        <span class="string">"no-multiple-empty-lines"</span>: [<span class="number">2</span>, &#123;</span><br><span class="line">            <span class="string">"max"</span>: <span class="number">2</span></span><br><span class="line">        &#125;],</span><br><span class="line">        <span class="comment">// 不允许否定的表达式</span></span><br><span class="line">        <span class="string">"no-negated-condition"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 不允许使用嵌套的三元表达式</span></span><br><span class="line">        <span class="string">"no-nested-ternary"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 禁止使用 Object 的构造函数</span></span><br><span class="line">        <span class="string">"no-new-object"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 禁止使用一元操作符 ++ 和 --</span></span><br><span class="line">        <span class="string">"no-plusplus"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 禁止使用特定的语法</span></span><br><span class="line">        <span class="string">"no-restricted-syntax"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 禁止 function 标识符和括号之间出现空格</span></span><br><span class="line">        <span class="string">"no-spaced-func"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 不允许使用三元操作符</span></span><br><span class="line">        <span class="string">"no-ternary"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 禁用行尾空格</span></span><br><span class="line">        <span class="string">"no-trailing-spaces"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 禁止标识符中有悬空下划线_bar</span></span><br><span class="line">        <span class="string">"no-underscore-dangle"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 禁止可以在有更简单的可替代的表达式时使用三元操作符</span></span><br><span class="line">        <span class="string">"no-unneeded-ternary"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 禁止属性前有空白</span></span><br><span class="line">        <span class="string">"no-whitespace-before-property"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 强制花括号内换行符的一致性</span></span><br><span class="line">        <span class="string">"object-curly-newline"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 强制在花括号中使用一致的空格</span></span><br><span class="line">        <span class="string">"object-curly-spacing"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 强制将对象的属性放在不同的行上</span></span><br><span class="line">        <span class="string">"object-property-newline"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 强制函数中的变量要么一起声明要么分开声明</span></span><br><span class="line">        <span class="string">"one-var"</span>: [<span class="number">2</span>, &#123;</span><br><span class="line">            <span class="string">"initialized"</span>: <span class="string">"never"</span></span><br><span class="line">        &#125;],</span><br><span class="line">        <span class="comment">// 要求或禁止在 var 声明周围换行</span></span><br><span class="line">        <span class="string">"one-var-declaration-per-line"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 要求或禁止在可能的情况下要求使用简化的赋值操作符</span></span><br><span class="line">        <span class="string">"operator-assignment"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 强制操作符使用一致的换行符</span></span><br><span class="line">        <span class="string">"operator-linebreak"</span>: [<span class="number">2</span>, <span class="string">"after"</span>, &#123;</span><br><span class="line">            <span class="string">"overrides"</span>: &#123;</span><br><span class="line">                <span class="string">"?"</span>: <span class="string">"before"</span>,</span><br><span class="line">                <span class="string">":"</span>: <span class="string">"before"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;],</span><br><span class="line">        <span class="comment">// 要求或禁止块内填充</span></span><br><span class="line">        <span class="string">"padded-blocks"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 要求对象字面量属性名称用引号括起来</span></span><br><span class="line">        <span class="string">"quote-props"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 强制使用一致的反勾号、双引号或单引号</span></span><br><span class="line">        <span class="string">"quotes"</span>: [<span class="number">2</span>, <span class="string">"double"</span>, <span class="string">"avoid-escape"</span>],</span><br><span class="line">        <span class="comment">// 要求使用 JSDoc 注释</span></span><br><span class="line">        <span class="string">"require-jsdoc"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="comment">// 要求或禁止使用分号而不是 ASI（这个才是控制行尾部分号的，）</span></span><br><span class="line">        <span class="string">"semi"</span>: [<span class="number">2</span>, <span class="string">"always"</span>],</span><br><span class="line">        <span class="comment">// 强制分号之前和之后使用一致的空格</span></span><br><span class="line">        <span class="string">"semi-spacing"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 要求同一个声明块中的变量按顺序排列</span></span><br><span class="line">        <span class="string">"sort-vars"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 强制在块之前使用一致的空格</span></span><br><span class="line">        <span class="string">"space-before-blocks"</span>: [<span class="number">2</span>, <span class="string">"always"</span>],</span><br><span class="line">        <span class="comment">// 强制在 function 的左括号之前使用一致的空格</span></span><br><span class="line">        <span class="string">"space-before-function-paren"</span>: [<span class="number">0</span>, <span class="string">"always"</span>],</span><br><span class="line">        <span class="comment">// 强制在圆括号内使用一致的空格</span></span><br><span class="line">        <span class="string">"space-in-parens"</span>: [<span class="number">2</span>, <span class="string">"never"</span>],</span><br><span class="line">        <span class="comment">// 要求操作符周围有空格</span></span><br><span class="line">        <span class="string">"space-infix-ops"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 强制在一元操作符前后使用一致的空格</span></span><br><span class="line">        <span class="string">"space-unary-ops"</span>: [<span class="number">2</span>, &#123;</span><br><span class="line">            <span class="string">"words"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="string">"nonwords"</span>: <span class="literal">false</span></span><br><span class="line">        &#125;],</span><br><span class="line">        <span class="comment">// 强制在注释中 // 或 /* 使用一致的空格</span></span><br><span class="line">        <span class="string">"spaced-comment"</span>: [<span class="number">2</span>, <span class="string">"always"</span>, &#123;</span><br><span class="line">            <span class="string">"markers"</span>: [<span class="string">"global"</span>, <span class="string">"globals"</span>, <span class="string">"eslint"</span>, <span class="string">"eslint-disable"</span>, <span class="string">"*package"</span>, <span class="string">"!"</span>]</span><br><span class="line">        &#125;],</span><br><span class="line">        <span class="comment">// 要求或禁止 Unicode BOM</span></span><br><span class="line">        <span class="string">"unicode-bom"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 要求正则表达式被括号括起来</span></span><br><span class="line">        <span class="string">"wrap-regex"</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">//////////////</span></span><br><span class="line">        <span class="comment">// ES6. 相关 //</span></span><br><span class="line">        <span class="comment">//////////////</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 要求箭头函数体使用大括号</span></span><br><span class="line">        <span class="string">"arrow-body-style"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 要求箭头函数的参数使用圆括号</span></span><br><span class="line">        <span class="string">"arrow-parens"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">"arrow-spacing"</span>: [<span class="number">2</span>, &#123;</span><br><span class="line">            <span class="string">"before"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="string">"after"</span>: <span class="literal">true</span></span><br><span class="line">        &#125;],</span><br><span class="line">        <span class="comment">// 强制在子类构造函数中用 super() 调用父类构造函数，TypeScrip 的编译器也会提示</span></span><br><span class="line">        <span class="string">"constructor-super"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 强制 generator 函数中 * 号周围使用一致的空格</span></span><br><span class="line">        <span class="string">"generator-star-spacing"</span>: [<span class="number">2</span>, &#123;</span><br><span class="line">            <span class="string">"before"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="string">"after"</span>: <span class="literal">true</span></span><br><span class="line">        &#125;],</span><br><span class="line">        <span class="comment">// 禁止修改类声明的变量</span></span><br><span class="line">        <span class="string">"no-class-assign"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 不允许箭头功能，在那里他们可以混淆的比较</span></span><br><span class="line">        <span class="string">"no-confusing-arrow"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 禁止修改 const 声明的变量</span></span><br><span class="line">        <span class="string">"no-const-assign"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 禁止类成员中出现重复的名称</span></span><br><span class="line">        <span class="string">"no-dupe-class-members"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 不允许复制模块的进口</span></span><br><span class="line">        <span class="string">"no-duplicate-imports"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 禁止 Symbol 的构造函数</span></span><br><span class="line">        <span class="string">"no-new-symbol"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 允许指定模块加载时的进口</span></span><br><span class="line">        <span class="string">"no-restricted-imports"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 禁止在构造函数中，在调用 super() 之前使用 this 或 super</span></span><br><span class="line">        <span class="string">"no-this-before-super"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 禁止不必要的计算性能键对象的文字</span></span><br><span class="line">        <span class="string">"no-useless-computed-key"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 要求使用 let 或 const 而不是 var</span></span><br><span class="line">        <span class="string">"no-var"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 要求或禁止对象字面量中方法和属性使用简写语法</span></span><br><span class="line">        <span class="string">"object-shorthand"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 要求使用箭头函数作为回调</span></span><br><span class="line">        <span class="string">"prefer-arrow-callback"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 要求使用 const 声明那些声明后不再被修改的变量</span></span><br><span class="line">        <span class="string">"prefer-const"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 要求在合适的地方使用 Reflect 方法</span></span><br><span class="line">        <span class="string">"prefer-reflect"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 要求使用扩展运算符而非 .apply()</span></span><br><span class="line">        <span class="string">"prefer-spread"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 要求使用模板字面量而非字符串连接</span></span><br><span class="line">        <span class="string">"prefer-template"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// Suggest using the rest parameters instead of arguments</span></span><br><span class="line">        <span class="string">"prefer-rest-params"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 要求 generator 函数内有 yield</span></span><br><span class="line">        <span class="string">"require-yield"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// enforce spacing between rest and spread operators and their expressions</span></span><br><span class="line">        <span class="string">"rest-spread-spacing"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 强制模块内的 import 排序</span></span><br><span class="line">        <span class="string">"sort-imports"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 要求或禁止模板字符串中的嵌入表达式周围空格的使用</span></span><br><span class="line">        <span class="string">"template-curly-spacing"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="comment">// 强制在 yield* 表达式中 * 周围使用空格</span></span><br><span class="line">        <span class="string">"yield-star-spacing"</span>: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章我从几个方面来介绍我是如何配置开发环境的，尽可能使代码编写风格统一。其实不光是代码，包括日常文字，都有很多规范。比如最常见的中英文之间添加空格，可能很多人并没有在意。但是看到别人的文章里出现这样的问题，肯定是要减印象分的。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>前后端鉴权方式总结</title>
    <link href="http://ifyour.github.io/2018/11/25/%E5%89%8D%E5%90%8E%E7%AB%AF%E9%89%B4%E6%9D%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
    <id>http://ifyour.github.io/2018/11/25/前后端鉴权方式总结/</id>
    <published>2018-11-25T05:02:34.000Z</published>
    <updated>2019-12-07T06:07:38.533Z</updated>
    
    <content type="html"><![CDATA[<p>今天来学习下常见的鉴权方式，从最开始了解的最简单的 Cookie 验证，到后来的 Session-cookie、Token 等，整体来说，安全性越来越高。当然还是对部分方式了解不是很深，这里做个简单总结，查漏补缺。</p><a id="more"></a><p>目前我们常用的鉴权有四种：</p><ol><li>HTTP Basic Authentication</li><li>Session-cookie</li><li>Token 验证</li><li>OAuth(开放授权)</li></ol><h3 id="HTTP-Basic-Authentication"><a href="#HTTP-Basic-Authentication" class="headerlink" title="HTTP Basic Authentication"></a>HTTP Basic Authentication</h3><p>这种授权方式是浏览器遵守 HTTP 协议实现的基本授权方式，HTTP 协议进行通信的过程中，HTTP 协议定义了基本认证认证允许 HTTP 服务器对客户端进行用户身份证的方法。</p><h4 id="认证过程"><a href="#认证过程" class="headerlink" title="认证过程"></a>认证过程</h4><ul><li>1️⃣ 客户端向服务器请求数据，请求的内容可能是一个网页或者是一个 ajax 异步请求，此时，假设客户端尚未被验证，则客户端提供如下请求至服务器：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Get /index.html HTTP/1.0</span><br><span class="line">Host:www.google.com</span><br></pre></td></tr></table></figure><ul><li>2️⃣ 服务器向客户端发送验证请求代码 401，(<code>WWW-Authenticate: Basic realm=&quot;google.com&quot;</code> 这句话是关键，如果没有客户端不会弹出用户名和密码输入界面）服务器返回的数据如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 401 Unauthorised</span><br><span class="line">Server: SokEvo/1.0</span><br><span class="line">WWW-Authenticate: Basic realm=&quot;google.com&quot;</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: xxx</span><br></pre></td></tr></table></figure><ul><li><p>3️⃣ 当符合 http1.0 或 1.1 规范的客户端（如 IE，FIREFOX）收到 401 返回值时，将自动弹出一个登录窗口，要求用户输入用户名和密码。</p></li><li><p>4️⃣ 用户输入用户名和密码后，将用户名及密码以 BASE64 加密方式加密，并将密文放入前一条请求信息中，则客户端发送的第一条请求信息则变成如下内容：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Get /index.html HTTP/1.0</span><br><span class="line">Host:www.google.com</span><br><span class="line">Authorization: Basic d2FuZzp3YW5n</span><br></pre></td></tr></table></figure><div class="tip"><br><code>d2FuZzp3YW5n</code> 表示加密后的用户名及密码（用户名：密码 然后通过 base64 加密，加密过程是浏览器默认的行为，不需要我们人为加密，我们只需要输入用户名密码即可）<br></div><ul><li>5️⃣ 服务器收到上述请求信息后，将 Authorization 字段后的用户信息取出、解密，将解密后的用户名及密码与用户数据库进行比较验证，如用户名及密码正确，服务器则根据请求，将所请求资源发送给客户端。</li></ul><p>客户端未未认证的时候，会弹出用户名密码输入框，这个时候请求时属于 pending 状态，这个时候其实服务当用户输入用户名密码的时候客户端会再次发送带 Authentication 头的请求。</p><p>请求认证 👇<br><img src="https://user-images.githubusercontent.com/15377484/48976178-136a0300-f0bd-11e8-9fd6-b2e67d22bbc6.png" alt="image"></p><p>认证成功 👇<br><img src="https://user-images.githubusercontent.com/15377484/48976167-d1d95800-f0bc-11e8-80fa-35c636dbc103.png" alt="image"></p><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><p><strong>Server.js</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">let</span> app = express();</span><br><span class="line"></span><br><span class="line">app.use(express.static(__dirname + <span class="string">'/public'</span>));</span><br><span class="line">app.get(<span class="string">'/Authentication_base'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'req.headers.authorization:'</span>, req.headers);</span><br><span class="line">  <span class="keyword">if</span> (!req.headers.authorization) &#123;</span><br><span class="line">    res.set(&#123;</span><br><span class="line">      <span class="string">'WWW-Authenticate'</span>: <span class="string">'Basic realm="wang"'</span></span><br><span class="line">    &#125;);</span><br><span class="line">    res.status(<span class="number">401</span>).end();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> base64 = req.headers.authorization.split(<span class="string">' '</span>)[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">let</span> userPass = <span class="keyword">new</span> Buffer(base64, <span class="string">'base64'</span>).toString().split(<span class="string">':'</span>);</span><br><span class="line">    <span class="keyword">let</span> user = userPass[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> pass = userPass[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (user === <span class="string">'wang'</span> &amp;&amp; pass === <span class="string">'wang'</span>) &#123;</span><br><span class="line">      res.end(<span class="string">'OK'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res.status(<span class="number">401</span>).end();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">9090</span>);</span><br></pre></td></tr></table></figure><p><strong>index.html</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>HTTP Basic Authentication<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/jquery-3.2.1.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      $(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        send(<span class="string">'./Authentication_base'</span>);</span></span><br><span class="line">      &#125;);</span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> send = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        $.ajax(&#123;</span></span><br><span class="line">          url: url,</span><br><span class="line"><span class="javascript">          method: <span class="string">'GET'</span></span></span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当然有登陆就有注销，我们会发现当我们认证成功后每次请求请求头都会带上 Authentication 及里面的内容，那么如何做到让这次登陆失效的？</p><p>网上查了半天，目前最有效的方式就是在注销操作的时候，专门在服务器设置一个专门的注销账号，当接收到的 Authentication 信息为注销用户名密码的时候纠就带便注销成功了，而客户端在注销操作的时候，手动的的去修改请求头重的 Authentication，将他设置未服务器默认的注销账号和密码。</p><p>通过上面的简单讲解 其实我们已经可以返现这种验证方式的缺陷加密方式简单，仅仅是 base64 加密，这种加密方式是可逆的。同时在每个请求的头上都会附带上用户名和密码信息，这样在外网是很容易被嗅探器探测到的。</p><p>正式因为这样，这种加密方式一般多被用在内部安全性要求不高的的系统上，只是相对的多，总的来说现在使用这种鉴权比较少了。如果项目需要部署在公网上，这种方式不推荐，当然你也可以和 SSL 来加密传输，这样会好一点，这个如果我后面有时间来研究一下。</p><h3 id="Session-cookie"><a href="#Session-cookie" class="headerlink" title="Session-cookie"></a>Session-cookie</h3><p>第二种这个方式是利用服务器端的 session（会话）和浏览器端的 cookie 来实现前后端的认证，由于 http 请求时是无状态的，服务器正常情况下是不知道当前请求之前有没有来过，这个时候我们如果要记录状态，就需要在服务器端创建一个会话 (seesion), 将同一个客户端的请求都维护在各自得会会话中，每当请求到达服务器端的时候，先去查一下该客户端有没有在服务器端创建 seesion，如果有则已经认证成功了，否则就没有认证。</p><h4 id="认证过程-1"><a href="#认证过程-1" class="headerlink" title="认证过程"></a>认证过程</h4><ol><li>服务器在接受客户端首次访问时在服务器端创建 seesion，然后保存 seesion（我们可以将 seesion 保存在内存中，也可以保存在 redis 中，推荐使用后者），然后给这个 session 生成一个唯一的标识字符串, 然后在响应头中种下这个唯一标识字符串。</li><li>签名。这一步只是对 sid 进行加密处理，服务端会根据这个 secret 密钥进行解密。（非必需步骤）</li><li>浏览器中收到请求响应的时候会解析响应头，然后将 sid 保存在本地 cookie 中，浏览器在下次 http 请求的请求头中会带上该域名下的 cookie 信息。</li><li>服务器在接受客户端请求时会去解析请求头 cookie 中的 sid，然后根据这个 sid 去找服务器端保存的该客户端的 session，然后判断该请求是否合法。</li></ol><p><img src="https://user-images.githubusercontent.com/15377484/38019076-382f84f8-32a9-11e8-9c5d-ef47b58185ad.png" alt></p><h4 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h4><p><strong>server.js</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> RedisStore = <span class="built_in">require</span>(<span class="string">'connect-redis'</span>)(express.session);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="keyword">var</span> secret = <span class="string">'ifyour'</span>;</span><br><span class="line"><span class="comment">// 设置 Cookie</span></span><br><span class="line">app.use(express.cookieParser(secret));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 Session</span></span><br><span class="line">app.use(</span><br><span class="line">  express.session(&#123;</span><br><span class="line">    store: <span class="keyword">new</span> RedisStore(&#123;</span><br><span class="line">      host: <span class="string">'127.0.0.1'</span>,</span><br><span class="line">      port: <span class="number">6379</span>,</span><br><span class="line">      db: <span class="string">'session_db'</span></span><br><span class="line">    &#125;),</span><br><span class="line">    secret: secret</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> session = req.session;</span><br><span class="line">  session.time = session.time || <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> n = session.time++;</span><br><span class="line">  res.send(<span class="string">'hello, session id:'</span> + session.id + <span class="string">'count:'</span> + n);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">9080</span>);</span><br></pre></td></tr></table></figure><h3 id="Token-验证"><a href="#Token-验证" class="headerlink" title="Token 验证"></a>Token 验证</h3><h4 id="认证过程-2"><a href="#认证过程-2" class="headerlink" title="认证过程"></a>认证过程</h4><ol><li>客户端使用用户名跟密码请求登录</li><li>服务端收到请求，去验证用户名与密码</li><li>验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端</li><li>客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 LocalStorage 里</li><li>客户端每次向服务端请求资源的时候需要带着服务端签发的 Token</li><li>服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据</li></ol><p>总的来说就是客户端在首次登陆以后，服务端再次接收 http 请求的时候，就只认 token 了，请求只要每次把 token 带上就行了，服务器端会拦截所有的请求，然后校验 token 的合法性，合法就放行，不合法就返回 401（鉴权失败）。</p><p>乍的一看好像和前面的 seesion-cookie 有点像，seesion-cookie 是通过 seesionid 来作为浏览器和服务端的链接桥梁，而 token 验证方式貌似是 token 来起到 seesionid 的角色。其实这两者差别是很大的。</p><h4 id="与-seesion-cookie-的区别"><a href="#与-seesion-cookie-的区别" class="headerlink" title="与 seesion-cookie 的区别"></a>与 seesion-cookie 的区别</h4><ol><li>sessionid 是一个唯一标识的字符串，服务端是根据这个字符串，来查询在服务器端保持的 seesion，这里面才保存着用户的登陆状态。但是 token 本身就是一种登陆成功凭证，他是在登陆成功后根据某种规则生成的一种信息凭证，他里面本身就保存着用户的登陆状态。服务器端只需要根据定义的规则校验这个 token 是否合法就行。</li><li>session-cookie 是需要 cookie 配合的，居然要 cookie，那么在 http 代理客户端的选择上就是只有浏览器了，因为只有浏览器才会去解析请求响应头里面的 cookie, 然后每次请求再默认带上该域名下的 cookie。但是我们知道 http 代理客户端不只有浏览器，还有原生 APP 等等，这个时候 cookie 是不起作用的，或者浏览器端是可以禁止 cookie 的 (虽然可以，但是这基本上是属于吃饱没事干的人干的事)，但是 token 就不一样，他是登陆请求在登陆成功后再请求响应体中返回的信息，客户端在收到响应的时候，可以把他存在本地的 cookie、storage，或者内存中，然后再下一次请求的请求头重带上这个 token 就行了。简单点来说 cookie-session 机制他限制了客户端的类型，而 token 验证机制丰富了客户端类型。</li><li>时效性。session-cookie 的 sessionid 是在登陆时生成的，而且在登出时一直不变，在一定程度上安全性就会降低，而 token 是可以在一段时间内动态改变的。</li><li>可扩展性。token 验证本身是比较灵活的，一是 token 的解决方案有许多，常用的是 JWT，二来我们可以基于 token 验证机制，专门做一个鉴权服务，用它向多个服务的请求进行统一鉴权。</li></ol><p>下面就拿最常用的 JWT（JSON WEB TOKEN）来说：</p><p>JWT 是 Auth0 提出的通过对 JSON 进行加密签名来实现授权验证的方案，就是登陆成功后将相关信息组成 json 对象，然后对这个对象进行某中方式的加密，返回给客户端，客户端在下次请求时带上这个 token，服务端再收到请求时校验 token 合法性，其实也就是在校验请求的合法性。JWT 对象通常由三部分构成：</p><p>1️⃣ Headers： 包括类别（typ）、加密算法（alg）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"alg"</span>: <span class="string">"HS256"</span>,</span><br><span class="line">  <span class="attr">"typ"</span>: <span class="string">"JWT"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2️⃣ Claims：包括需要传递的用户信息</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"sub"</span>: <span class="string">"1234567890"</span>,</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"John Doe"</span>,</span><br><span class="line">  <span class="attr">"admin"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3️⃣ Signature：根据 alg 算法与私有秘钥进行加密得到的签名字串，这一段是最重要的敏感信息，只能在服务端解密</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(Headers) + &apos;.&apos; + base64UrlEncode(Claims),</span><br><span class="line">  SECREATE_KEY</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>编码之后的 JWT 看起来是这样的一串字符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</span><br></pre></td></tr></table></figure><h4 id="完整代码-2"><a href="#完整代码-2" class="headerlink" title="完整代码"></a>完整代码</h4><p><strong>auth.js</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> jwt = <span class="built_in">require</span>(<span class="string">'jwt-simple'</span>);</span><br><span class="line"><span class="keyword">let</span> secret = <span class="string">'wangyy'</span>;</span><br><span class="line"><span class="keyword">let</span> time = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">/* 检验 token 合法性 */</span></span><br><span class="line">  validate: <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> token = req.body.token || req.headers[<span class="string">'xssToken'</span>];</span><br><span class="line">    <span class="keyword">if</span> (token) &#123;</span><br><span class="line">      <span class="keyword">let</span> decodeToken = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 防止假冒 token 解析报错</span></span><br><span class="line">        decodeToken = jwt.decode(token, secret, <span class="string">'HS256'</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        res.status(<span class="number">401</span>).send(<span class="string">'非法访问'</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> exp = decodeToken.exp;</span><br><span class="line">      <span class="keyword">if</span> (!exp) &#123;</span><br><span class="line">        res.status(<span class="number">401</span>).send(<span class="string">'非法访问'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">      <span class="keyword">if</span> (exp &gt; now + time * <span class="number">60</span> * <span class="number">1000</span>) &#123;</span><br><span class="line">        res.send(&#123; <span class="attr">code</span>: <span class="string">'002'</span>, <span class="attr">errorMsg</span>: <span class="string">'授权超时'</span> &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      next();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res.status(<span class="number">401</span>).send(<span class="string">'非法访问'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/* 生成 token*/</span></span><br><span class="line">  makeToken() &#123;</span><br><span class="line">    <span class="keyword">let</span> Token = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> payload = &#123;</span><br><span class="line">      time: <span class="keyword">new</span> <span class="built_in">Date</span>().getTime(),</span><br><span class="line">      exp: <span class="keyword">this</span>.makeExp(time)</span><br><span class="line">    &#125;;</span><br><span class="line">    Token = jwt.encode(payload, secret, HS256);</span><br><span class="line">    <span class="keyword">return</span> Token;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/* 生成 token 过期时间 */</span></span><br><span class="line">  makeExp: <span class="function"><span class="keyword">function</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> stam = time601000;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Server.js</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">let</span> app = express();</span><br><span class="line"><span class="keyword">let</span> bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>);</span><br><span class="line"><span class="keyword">let</span> auth = <span class="built_in">require</span>(<span class="string">'./lib/auth.js'</span>);</span><br><span class="line"><span class="keyword">let</span> chalk = <span class="built_in">require</span>(<span class="string">'chalk'</span>);</span><br><span class="line"></span><br><span class="line">app.use(bodyParser.json());</span><br><span class="line">app.post(<span class="string">'/login'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> Token = auth.makeToken();</span><br><span class="line">  res.json(&#123; <span class="attr">result</span>: <span class="string">'success'</span>, <span class="attr">token</span>: Token &#125;, <span class="number">200</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.use(<span class="string">'*'</span>, [auth.validate], <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  res.send(<span class="string">'success'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="string">'9999'</span>);</span><br></pre></td></tr></table></figure><h3 id="OAuth-开放授权"><a href="#OAuth-开放授权" class="headerlink" title="OAuth(开放授权)"></a>OAuth(开放授权)</h3><p>OAuth（开放授权）是一个开放标准，允许用户授权第三方网站访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方网站或分享他们数据的所有内容，为了保护用户数据的安全和隐私，第三方网站访问用户数据前都需要显式的向用户征求授权。我们常见的提供 OAuth 认证服务的厂商有支付宝、QQ、微信。</p><p>OAuth 协议又有 1.0 和 2.0 两个版本。相比较 1.0 版，2.0 版整个授权验证流程更简单更安全，也是目前最主要的用户身份验证和授权方式。</p><h4 id="认证过程-3"><a href="#认证过程-3" class="headerlink" title="认证过程"></a>认证过程</h4><p>下面是一张 Auth2.0 的流程图：</p><p><img src="https://user-images.githubusercontent.com/15377484/48976006-b7ea4600-f0b9-11e8-8f94-1102761320b0.png" alt="image"></p><p>从图中我们可以看出，Auth2.0 流程分为六步：</p><p>1️⃣ 向用户请求授权，现在很多的网站在登陆的时候都有第三方登陆的入口，当我们点击等第三方入口时，第三方授权服务会引导我们进入第三方登陆授权页面。</p><p><img src="https://user-images.githubusercontent.com/15377484/48976180-35638580-f0bd-11e8-9c0a-c6aee6bf7da5.png" alt="image"></p><p>通过第三方请求授权页面的浏览器地址栏地址可以看出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://graph.qq.com/oauth2.0/show?which=Login&amp;display=pc&amp;response_type=code&amp;client_id=100270989&amp;redirect_uri=https%3A%2F%2Fpassport.csdn.net%2Faccount%2Flogin%3Foauth_provider%3DQQProvider&amp;state=test</span><br></pre></td></tr></table></figure><p>这里的地址里面的 <code>%</code> 是浏览器强制编码后的显示我们可以使用 <code>decodeURIComponent</code> 进行解码，解码后是这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://graph.qq.com/oauth2.0/show?which=Login&amp;display=pc&amp;response_type=code&amp;client_id=100270989&amp;redirect_uri=https://passport.csdn.net/account/login?oauth_provider=QQProvider&amp;state=test</span><br></pre></td></tr></table></figure><p>这个 url 地址我们可以看见 Auth2.0 常见的几个参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">response_type:  返回类型</span><br><span class="line">client_id:      第三方应用 id, 由授权服务器（qq）在第三方应用提交时颁发给第三方应用。</span><br><span class="line">redirect_uri:   登陆成功重定向页面</span><br><span class="line">oauth_provider: 第三方授权提供方</span><br><span class="line">state:          由第三方应用给出的随机码</span><br></pre></td></tr></table></figure><p>2️⃣ 返回用户凭证（code），并返回一个凭证（code），当用户点击授权并登陆后，授权服务器将生成一个用户凭证（code）。这个用户凭证会附加在重定向的地址 <code>redirect_uri</code> 的后面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://passport.csdn.net/account/login?code=9e3efa6cea739f9aaab2&amp;state=XXX</span><br></pre></td></tr></table></figure><p>3️⃣ 请求授权服务器授权</p><p>经过第二部获取 code 后后面的工作就可以交给后台去处理的，和用户的交互就结束了。接下来我的需要获取凭证（Access Token），我们需要用他来向授权服务器获取用户信息等资源。 第三方应用后台通过第二步的凭证（code）向授权服务器请求凭证（Access Token），这时候需要以下几个信息：</p><ul><li><code>client_id</code>: 标识第三方应用的 id，由授权服务器在第三方应用提交时颁发给第三方应用</li><li><code>client_secret</code>: 第三方应用和授权服务器之间的安全凭证，由授权服务器在第三方应用提交时颁发给第三方应用</li><li><code>code</code>: 第一步中返回的用户凭证 <code>redirect_uri</code> 第一步生成用户凭证后跳转到第二步时的地址</li><li><code>state</code>: 由第三方应用给出的随机码</li></ul><p>4️⃣ 授权服务器同意授权后，返回一个资源访问的凭证（Access Token）。</p><p>5️⃣ 第三方应用通过第四步的凭证（Access Token）向资源服务器请求相关资源。</p><p>6️⃣ 资源服务器验证凭证（Access Token）通过后，将第三方应用请求的资源返回。</p><p>从用户角度来说，第三方授权可以让我们快速的登陆应用，无需进行繁琐的注册，同时不用记住各种账号密码。只需要记住自己常用的几个账号就 OK 了。 从产品经理的角度来所，这种授权方式提高用户的体验满意度。另一方面可以获取更多的用户。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>授权方式多种多样，主要还是要取决于我们对于产品的定位。如果我们的产品只是在企业内部使用，Token 和 Session-cookie 就可以满足我们的需求，如果是面向互联网的大众用户，那么第三方授权 OAuth 在用户体验度上会有一个很大的提升。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天来学习下常见的鉴权方式，从最开始了解的最简单的 Cookie 验证，到后来的 Session-cookie、Token 等，整体来说，安全性越来越高。当然还是对部分方式了解不是很深，这里做个简单总结，查漏补缺。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Axios 使用姿势指南</title>
    <link href="http://ifyour.github.io/2018/09/19/Axios-%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF%E6%8C%87%E5%8D%97/"/>
    <id>http://ifyour.github.io/2018/09/19/Axios-使用姿势指南/</id>
    <published>2018-09-19T14:09:48.000Z</published>
    <updated>2019-12-07T06:07:38.529Z</updated>
    
    <content type="html"><![CDATA[<p>最近几个项目都用到了 Axios，它是一个更现代的 API 请求库，基于 Promise，能运行在浏览器和 Node.js 里。在项目里，一般都是需要进行一次封装再来使用，比如处理鉴权、还有全局的请求 Loading 动画等。今天来总结一下。</p><a id="more"></a><h3 id="Axios-简介"><a href="#Axios-简介" class="headerlink" title="Axios 简介"></a>Axios 简介</h3><p><a href="https://github.com/axios/axios" target="_blank" rel="noopener">Axios</a> 是一个基于 Promise 用于浏览器和 nodejs 的 HTTP 客户端。它有以下功能：</p><ul><li>从浏览器中创建 XMLHttpRequest</li><li>从 Node.js 发出 HTTP 请求</li><li>支持 Promise API</li><li>拦截请求和响应</li><li>转换请求数据和响应数据</li><li>自动转换 JSON 数据</li><li>客户端防止 CSRF/XSRF</li></ul><h3 id="基础-API"><a href="#基础-API" class="headerlink" title="基础 API"></a>基础 API</h3><ul><li><code>axios.request(config)</code></li><li><code>axios.get(url [,config])</code></li><li><code>axios.delete(url [,config])</code></li><li><code>axios.head(url [,config])</code></li><li><code>axios.options(url [,config])</code></li><li><code>axios.post(url [,data [,config]])</code></li><li><code>axios.put(url [,data [,config]])</code></li><li><code>axios.patch(url [,data [,config]])</code></li></ul><div class="tip"><br>  HTTP 请求方法一般会按照它具体的含义来执行相关的动作，这里有一份 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods" target="_blank" rel="noopener">HTTP 动词对应解释 @MDN</a>。<br></div><h3 id="用法示例"><a href="#用法示例" class="headerlink" title="用法示例"></a>用法示例</h3><h4 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向具有指定 ID 的用户发出请求（参数在 URL 上）</span></span><br><span class="line">axios</span><br><span class="line">  .get(<span class="string">'/user?ID=12345'</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以通过 params 对象传递参数</span></span><br><span class="line">axios</span><br><span class="line">  .get(<span class="string">'/user'</span>, &#123;</span><br><span class="line">    params: &#123;</span><br><span class="line">      ID: <span class="number">12345</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h4 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">axios</span><br><span class="line">  .post(</span><br><span class="line">    <span class="string">'/user'</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      userId: <span class="string">'123'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      headers: &#123;</span><br><span class="line">        token: <span class="string">'abc'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h4 id="直接使用-config"><a href="#直接使用-config" class="headerlink" title="直接使用 config"></a>直接使用 config</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GET</span></span><br><span class="line">axios(&#123;</span><br><span class="line">  url: <span class="string">'pakage.json'</span>,</span><br><span class="line">  method: <span class="string">'get'</span>,</span><br><span class="line">  params: &#123;</span><br><span class="line">    <span class="comment">// get 在 params 中定义</span></span><br><span class="line">    userId: <span class="string">'123'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    token: <span class="string">'http-test'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res.data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// POST</span></span><br><span class="line">axios(&#123;</span><br><span class="line">  url: <span class="string">'pakage.json'</span>,</span><br><span class="line">  method: <span class="string">'post'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    <span class="comment">// post 在 data 中定义</span></span><br><span class="line">    userId: <span class="string">'123'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    token: <span class="string">'http-test'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res.data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="并发请求"><a href="#并发请求" class="headerlink" title="并发请求"></a>并发请求</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserAcount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回一个 promise 对象</span></span><br><span class="line">  <span class="keyword">return</span> axios.get(<span class="string">'/user/1234'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserPermissions</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回一个 promise 对象</span></span><br><span class="line">  <span class="keyword">return</span> axios.get(<span class="string">'/user/1234/getUserPermissions'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一次性返回两个接口</span></span><br><span class="line">axios.all([getUserAccount(), getUserPerssions()]).then(</span><br><span class="line">  axios.spread(<span class="function">(<span class="params">acct, perms</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// spread 展开两个返回的结果</span></span><br><span class="line">    <span class="comment">// 两个请求现已完成</span></span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="全局封装、异常处理"><a href="#全局封装、异常处理" class="headerlink" title="全局封装、异常处理"></a>全局封装、异常处理</h3><p>在项目中，如果每次请求都写一堆 <code>config</code> 会存在大量重复代码，一般我们会封装成一个方法，把一些必要的参数配置好，同理，全局的异常还有鉴权等都统一配置。单次请求数据只做和数据相关的业务逻辑。下面来看一下 Axios 的全局封装例子。</p><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;</span><br><span class="line"><span class="keyword">import</span> qs <span class="keyword">from</span> <span class="string">'qs'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// POST 方法封装  (原生 form 提交)</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> postRequest = <span class="function">(<span class="params">url, params</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> axios(&#123;</span><br><span class="line">    method: <span class="string">'post'</span>,</span><br><span class="line">    url: url,</span><br><span class="line">    data: params,</span><br><span class="line">    transformRequest: [</span><br><span class="line">      <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> qs.stringify(data);</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    headers: &#123;</span><br><span class="line">      <span class="string">'Content-Type'</span>: <span class="string">'application/x-www-form-urlencoded'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// POST 方法封装  (文件上传)</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> uploadFileRequest = <span class="function">(<span class="params">url, params</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> axios(&#123;</span><br><span class="line">    method: <span class="string">'post'</span>,</span><br><span class="line">    url: url,</span><br><span class="line">    data: params,</span><br><span class="line">    headers: &#123;</span><br><span class="line">      <span class="string">'Content-Type'</span>: <span class="string">'multipart/form-data'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GET 方法封装</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getRequest = <span class="function"><span class="params">url</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> axios(&#123;</span><br><span class="line">    method: <span class="string">'get'</span>,</span><br><span class="line">    url: url</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PUT 方法封装</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> putRequest = <span class="function">(<span class="params">url, params</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> axios(&#123;</span><br><span class="line">    method: <span class="string">'put'</span>,</span><br><span class="line">    url: url,</span><br><span class="line">    data: params,</span><br><span class="line">    transformRequest: [</span><br><span class="line">      <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> qs.stringify(data);</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    headers: &#123;</span><br><span class="line">      <span class="string">'Content-Type'</span>: <span class="string">'application/x-www-form-urlencoded'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DELETE 方法封装</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> deleteRequest = <span class="function"><span class="params">url</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> axios(&#123;</span><br><span class="line">    method: <span class="string">'delete'</span>,</span><br><span class="line">    url: url</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Message &#125; <span class="keyword">from</span> <span class="string">'element-ui'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  请求拦截</span></span><br><span class="line">axios.interceptors.request.use(</span><br><span class="line">  config =&gt; &#123;</span><br><span class="line">    <span class="comment">// 请求前配置 config</span></span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;,</span><br><span class="line">  err =&gt; &#123;</span><br><span class="line">    <span class="comment">// 错误处理</span></span><br><span class="line">    Message.error(&#123; <span class="attr">message</span>: <span class="string">'请求超时!'</span> &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(err);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应拦截</span></span><br><span class="line">axios.interceptors.response.use(</span><br><span class="line">  data =&gt; &#123;</span><br><span class="line">    <span class="comment">// 请求后处理对应的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式一：和后端约定响应码 `code`</span></span><br><span class="line">    <span class="keyword">switch</span> (data.code) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'0'</span>:</span><br><span class="line">        <span class="comment">// 正常直接返回</span></span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">      <span class="comment">// 需要重新登录</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'-1'</span>:</span><br><span class="line">        <span class="comment">// some code here..</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式二：仅判断 HTTP 状态码</span></span><br><span class="line">    <span class="keyword">if</span> (data.status &amp;&amp; data.status == <span class="number">200</span> &amp;&amp; data.data.status == <span class="string">'error'</span>) &#123;</span><br><span class="line">      Message.error(&#123; <span class="attr">message</span>: data.data.msg &#125;);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;,</span><br><span class="line">  err =&gt; &#123;</span><br><span class="line">    <span class="comment">// 错误处理</span></span><br><span class="line">    <span class="keyword">if</span> (err &amp;&amp; err.response) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (err.response.status) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">400</span>:</span><br><span class="line">          err.message = <span class="string">'请求错误 (400)'</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">401</span>:</span><br><span class="line">          err.message = <span class="string">'未授权，请重新登录 (401)'</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">403</span>:</span><br><span class="line">          err.message = <span class="string">'拒绝访问 (403)'</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">404</span>:</span><br><span class="line">          err.message = <span class="string">'请求出错 (404)'</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">408</span>:</span><br><span class="line">          err.message = <span class="string">'请求超时 (408)'</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">500</span>:</span><br><span class="line">          err.message = <span class="string">'服务器错误 (500)'</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">501</span>:</span><br><span class="line">          err.message = <span class="string">'服务未实现 (501)'</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">502</span>:</span><br><span class="line">          err.message = <span class="string">'网络错误 (502)'</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">503</span>:</span><br><span class="line">          err.message = <span class="string">'服务不可用 (503)'</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">504</span>:</span><br><span class="line">          err.message = <span class="string">'网络超时 (504)'</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">505</span>:</span><br><span class="line">          err.message = <span class="string">'HTTP 版本不受支持 (505)'</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          err.message = <span class="string">`连接出错 (<span class="subst">$&#123;err.response.status&#125;</span>)!`</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      err.message = <span class="string">'连接服务器失败!'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Message.err(&#123; <span class="attr">message</span>: err.message &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(err);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><div class="tip"><br>请求出错的时候执行的是：<code>Promise.resolve(err)</code>，而不是 <code>Promise.reject(err)</code>，这样无论请求成功还是失败，在成功的回调中都能收到通知。<br></div><h3 id="其它配置"><a href="#其它配置" class="headerlink" title="其它配置"></a>其它配置</h3><h4 id="baseURL"><a href="#baseURL" class="headerlink" title="baseURL"></a>baseURL</h4><p>通过 <code>axios.defaults.baseURL</code> 来设置 API 的根域名。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV == <span class="string">'development'</span>) &#123;</span><br><span class="line">  axios.defaults.baseURL = <span class="string">'https://dev.server.com/'</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.NODE_ENV == <span class="string">'debug'</span>) &#123;</span><br><span class="line">  axios.defaults.baseURL = <span class="string">'https://debug.server.com/'</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.NODE_ENV == <span class="string">'production'</span>) &#123;</span><br><span class="line">  axios.defaults.baseURL = <span class="string">'https://pro.server.com/'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="tip"><br><code>process.env</code> 是 Node.js 提供的全局变量，我们可以在 npm scripts 里通过 cross-env 这个工具统一配置不同的环境，cross-env 做了各种系统平台的兼容处理。一般用这个设置环境变量。<br></div><h4 id="请求超时"><a href="#请求超时" class="headerlink" title="请求超时"></a>请求超时</h4><p>通过 <code>axios.defaults.timeout</code> 设置默认的请求超时时间。例如超过了 10s，就会告知用户当前请求超时，请刷新等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.timeout = <span class="number">10000</span>;</span><br></pre></td></tr></table></figure><h4 id="单独设置-POST-的请求头"><a href="#单独设置-POST-的请求头" class="headerlink" title="单独设置 POST 的请求头"></a>单独设置 POST 的请求头</h4><p>比如设置 POST 提交（原生 form）时单独配置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.headers.post[<span class="string">'Content-Type'</span>] =</span><br><span class="line">  <span class="string">'application/x-www-form-urlencoded;charset=UTF-8'</span>;</span><br></pre></td></tr></table></figure><h3 id="附-完整代码"><a href="#附-完整代码" class="headerlink" title="附: 完整代码"></a>附: 完整代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;</span><br><span class="line"><span class="keyword">import</span> QS <span class="keyword">from</span> <span class="string">'qs'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Toast &#125; <span class="keyword">from</span> <span class="string">'vant'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 环境的切换</span></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV == <span class="string">'development'</span>) &#123;</span><br><span class="line">  axios.defaults.baseURL = <span class="string">'https://dev.server.com/'</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.NODE_ENV == <span class="string">'debug'</span>) &#123;</span><br><span class="line">  axios.defaults.baseURL = <span class="string">'https://debug.server.com/'</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.NODE_ENV == <span class="string">'production'</span>) &#123;</span><br><span class="line">  axios.defaults.baseURL = <span class="string">'https://pro.server.com/'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求超时时间</span></span><br><span class="line">axios.defaults.timeout = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// POST 请求头</span></span><br><span class="line">axios.defaults.headers.post[<span class="string">'Content-Type'</span>] =</span><br><span class="line">  <span class="string">'application/x-www-form-urlencoded;charset=UTF-8'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求拦截器</span></span><br><span class="line">axios.interceptors.request.use(</span><br><span class="line">  config = &gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> token = store.state.token;</span><br><span class="line">    token &amp;&amp; (config.headers.Authorization = token);</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;, error = &gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.error(error);</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应拦截器</span></span><br><span class="line">axios.interceptors.response.use(</span><br><span class="line">  response = &gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (response.status === <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(response);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(response);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 服务器状态码不是 200 的情况</span></span><br><span class="line">  error = &gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (error.response.status) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (error.response.status) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">401</span>:</span><br><span class="line">          router.replace(&#123;</span><br><span class="line">            path: <span class="string">'/login'</span>,</span><br><span class="line">            query: &#123;</span><br><span class="line">              redirect: router.currentRoute.fullPath</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">403</span>:</span><br><span class="line">          Toast(&#123;</span><br><span class="line">            message: <span class="string">'登录过期，请重新登录'</span>,</span><br><span class="line">            duration: <span class="number">1000</span>,</span><br><span class="line">            forbidClick: <span class="literal">true</span></span><br><span class="line">          &#125;);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">          <span class="comment">// 404 请求不存在</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">404</span>:</span><br><span class="line">          Toast(&#123;</span><br><span class="line">            message: <span class="string">'网络请求不存在'</span>,</span><br><span class="line">            duration: <span class="number">1500</span>,</span><br><span class="line">            forbidClick: <span class="literal">true</span></span><br><span class="line">          &#125;);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">          <span class="comment">// 其他错误，直接抛出错误提示</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          Toast(&#123;</span><br><span class="line">            message: error.response.data.message,</span><br><span class="line">            duration: <span class="number">1500</span>,</span><br><span class="line">            forbidClick: <span class="literal">true</span></span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error.response);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// GET 请求</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">url, params</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    axios</span><br><span class="line">      .get(url, &#123; <span class="attr">params</span>: params &#125;)</span><br><span class="line">      .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(res.data);</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch (<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        reject(err.data)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// POST 请求</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">post</span>(<span class="params">url, params</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    axios</span><br><span class="line">      .post(url, QS.stringify(params))</span><br><span class="line">      .then(res = &gt; &#123;</span><br><span class="line">        resolve(res.data);</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch (<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        reject(err.data)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="附-Content-Type"><a href="#附-Content-Type" class="headerlink" title="附: Content-Type"></a>附: Content-Type</h3><p>说到和服务端数据交互，总是绕不开这个，必须要扫盲一下了！😂😂</p><blockquote><p>Content-Type 用于指定内容类型，一般是指网页中存在的 Content-Type，Content-Type 属性指定请求和响应的 HTTP 内容类型。如果未指定 ContentType，默认为 <code>text/html</code>。</p></blockquote><p>常见类型有：</p><ul><li>text/html</li><li>application/x-www-form-urlencoded</li><li>multipart/form-data</li><li>application/json</li><li>application/xml</li></ul><p><code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>application/json</code>、<code>application/xml</code> 这四个则是 ajax 请求需要指定的类型，表单提交或上传文件常用的资源类型。</p><h4 id="application-x-www-form-urlencoded"><a href="#application-x-www-form-urlencoded" class="headerlink" title="application/x-www-form-urlencoded"></a>application/x-www-form-urlencoded</h4><p>这是表单默认提交方式，格式为 URL 编码 <code>key=value&amp;key1=value1</code>。</p><div style="max-width: 500px"><img src="https://user-images.githubusercontent.com/9158841/32037816-ade83a36-b9ec-11e7-9f07-4f72a99c6aaa.png" alt="image"></div><p>注：Chrome 浏览器会自动格式化成易读的格式</p><h4 id="multipart-form-data"><a href="#multipart-form-data" class="headerlink" title="multipart/form-data"></a>multipart/form-data</h4><p>使用表单上传文件时，必须指定表单的 enctype 属性值为 <code>multipart/form-data</code>。<br>请求体被分割成多部分，每部分使用 <code>--boundary</code> 分割，使用 <code>--boundary--\r\n</code> 结束。</p><p>表单上传文件 Demo:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/upload"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    用户名: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span>&gt;</span></span><br><span class="line">    密码: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span></span><br><span class="line">    上传文件: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"file"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><div style="max-width: 500px"><img src="https://user-images.githubusercontent.com/9158841/32038354-1201f94c-b9ef-11e7-8817-fb9031b2b036.png" alt="image"></div><h4 id="application-json"><a href="#application-json" class="headerlink" title="application/json"></a>application/json</h4><p>Axios 默认 <code>POST</code> 提交方式就是 <code>application/json</code>，所以，在使用 axios 提交表单时需要注意后端能不能解析，不能解析需要设置 <code>POST</code> 常用格式 <code>application/x-www-form-urlencoded</code>，且提交的数据需要使用 qs 模块序列化格式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">axios.post(</span><br><span class="line">  <span class="string">'https://jsonplaceholder.typicode.com/posts'</span>,</span><br><span class="line">  &#123;</span><br><span class="line">    userId: <span class="number">1</span>,</span><br><span class="line">    name: <span class="string">'ifyour'</span>,</span><br><span class="line">    arr: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    headers: &#123;</span><br><span class="line">      <span class="string">'Content-Type'</span>: <span class="string">'application/x-www-form-urlencoded'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    transformRequest: [</span><br><span class="line">      <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> qs.stringify(data);</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><div style="max-width: 400px"><img src="https://user-images.githubusercontent.com/15377484/45913317-a939a580-be62-11e8-9d96-1a097337da44.png" alt="image"></div><h4 id="application-xml"><a href="#application-xml" class="headerlink" title="application/xml"></a>application/xml</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POST http://www.example.com HTTP/1.1</span><br><span class="line">Content-Type: text/xml</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>123<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">params</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>example<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>21<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">params</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://github.com/axios/axios#installing" target="_blank" rel="noopener">Axios 官方文档 @GitHub</a></li><li><a href="http://tool.oschina.net/commons" target="_blank" rel="noopener">HTTP Content-Type 对照表 @OSChina</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods" target="_blank" rel="noopener">HTTP 请求方法 @MDN</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近几个项目都用到了 Axios，它是一个更现代的 API 请求库，基于 Promise，能运行在浏览器和 Node.js 里。在项目里，一般都是需要进行一次封装再来使用，比如处理鉴权、还有全局的请求 Loading 动画等。今天来总结一下。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Webpack 4 定制前端开发环境</title>
    <link href="http://ifyour.github.io/2018/09/11/webpack4-%E5%AE%9A%E5%88%B6%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <id>http://ifyour.github.io/2018/09/11/webpack4-定制前端开发环境/</id>
    <published>2018-09-11T14:16:37.000Z</published>
    <updated>2019-12-07T06:07:38.533Z</updated>
    
    <content type="html"><![CDATA[<p>本文总结了 Webpack 4 的一些配置点，希望通过学习这些配置点，降低使用门槛。纵观前端的打包历史，似乎是欠了太多债，有很多历史包袱，所以工程化这一块一直是一大痛点。配置繁琐，容易出错，本文总结了最新的 Webpack 4 功能点，一起来学习一下，可以点击右侧的文章目录直达。</p><a id="more"></a><h3 id="webpack-概念和基础使用"><a href="#webpack-概念和基础使用" class="headerlink" title="webpack 概念和基础使用"></a>webpack 概念和基础使用</h3><h4 id="安装和使用"><a href="#安装和使用" class="headerlink" title="安装和使用"></a>安装和使用</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 webpack</span></span><br><span class="line">$ npm install webpack webpack-cli -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">$ yarn global add webpack webpack-cli</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后就可以全局执行命令了</span></span><br><span class="line">$ webpack --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><h4 id="webpack-的基本概念"><a href="#webpack-的基本概念" class="headerlink" title="webpack 的基本概念"></a>webpack 的基本概念</h4><blockquote><p>webpack 本质上是一个打包工具，它会根据代码的内容解析模块依赖，帮助我们把多个模块的代码打包</p></blockquote><p><img src="https://user-images.githubusercontent.com/15377484/59234564-f1cb0600-8c1f-11e9-8bdf-c6041410225a.png" alt="image"></p><blockquote><p>webpack 会把我们项目中使用到的多个代码模块（可以是不同文件类型），打包构建成项目运行仅需要的几个静态文件</p></blockquote><p><strong>入口（entry）</strong></p><blockquote><p>入口可以使用 <code>entry</code> 字段来进行配置，<code>webpack</code> 支持配置多个入口来进行构建</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述配置等同于</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: <span class="string">'./src/index.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者配置多个入口</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    foo: <span class="string">'./src/page-foo.js'</span>,</span><br><span class="line">    bar: <span class="string">'./src/page-bar.js'</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用数组来对多个文件进行打包</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: [<span class="string">'./src/foo.js'</span>, <span class="string">'./src/bar.js'</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>转换器（loader）</strong></p><blockquote><p>可以把 <code>loader</code> 理解为是一个转换器，负责把某种文件格式的内容转换成 webpack 可以支持打包的模块</p></blockquote><ul><li>当我们需要使用不同的 <code>loader</code> 来解析处理不同类型的文件时，我们可以在 <code>module.rules</code> 字段下来配置相关的规则，例如使用 <code>Babel</code> 来处理 <code>.js</code> 文件</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.jsx?/</span>, <span class="comment">// 匹配文件路径的正则表达式，通常我们都是匹配文件类型后缀</span></span><br><span class="line">      include: [</span><br><span class="line">        path.resolve(__dirname, <span class="string">'src'</span>) <span class="comment">// 指定哪些路径下的文件需要经过 loader 处理</span></span><br><span class="line">      ],</span><br><span class="line">      use: <span class="string">'babel-loader'</span>, <span class="comment">// 指定使用的 loader</span></span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>插件（plugin）</strong></p><blockquote><p>模块代码转换的工作由 <code>loader</code> 来处理，除此之外的其他任何工作都可以交由 <code>plugin</code> 来完成。通过添加我们需要的 <code>plugin</code>，可以满足更多构建中特殊的需求。例如，要使用压缩 <code>JS</code> 代码的 <code>uglifyjs-webpack-plugin</code> 插件，只需在配置中通过 <code>plugins</code> 字段添加新的 <code>plugin</code> 即可…</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> UglifyPlugin = <span class="built_in">require</span>(<span class="string">'uglifyjs-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [<span class="keyword">new</span> UglifyPlugin()]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><code>plugin</code> 理论上可以干涉 <code>webpack</code> 整个构建流程，可以在流程的每一个步骤中定制自己的构建需求</p></blockquote><p><strong>输出（output）</strong></p><blockquote><p>构建结果的文件名、路径等都是可以配置的，使用 <code>output</code> 字段</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'bundle.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者多个入口生成不同文件</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    foo: <span class="string">'./src/foo.js'</span>,</span><br><span class="line">    bar: <span class="string">'./src/bar.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">    path: __dirname + <span class="string">'/dist'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路径中使用 hash，每次构建时会有一个不同 hash 值，避免发布新版本时线上使用浏览器缓存</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">    path: __dirname + <span class="string">'/dist/[hash]'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>我们一开始直接使用 <code>webpack</code> 构建时，默认创建的输出内容就是 <code>./dist/main.js</code></p></blockquote><p><strong>一个简单的 webpack 配置</strong></p><blockquote><p>我们把上述涉及的几部分配置内容合到一起，就可以创建一个简单的 <code>webpack</code> 配置了，<code>webpack</code> 运行时默认读取项目下的 <code>webpack.config.js</code> 文件作为配置。所以我们在项目中创建一个 <code>webpack.config.js</code> 文件</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> UglifyPlugin = <span class="built_in">require</span>(<span class="string">'uglifyjs-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line"></span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'bundle.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.jsx?/</span>,</span><br><span class="line">        include: [path.resolve(__dirname, <span class="string">'src'</span>)],</span><br><span class="line">        use: <span class="string">'babel-loader'</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 代码模块路径解析的配置</span></span><br><span class="line">  resolve: &#123;</span><br><span class="line">    modules: [<span class="string">'node_modules'</span>, path.resolve(__dirname, <span class="string">'src'</span>)],</span><br><span class="line"></span><br><span class="line">    extensions: [<span class="string">'.wasm'</span>, <span class="string">'.mjs'</span>, <span class="string">'.js'</span>, <span class="string">'.json'</span>, <span class="string">'.jsx'</span>]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> UglifyPlugin()</span><br><span class="line">    <span class="comment">// 使用 uglifyjs-webpack-plugin 来压缩 JS 代码</span></span><br><span class="line">    <span class="comment">// 如果你留意了我们一开始直接使用 webpack 构建的结果，你会发现默认已经使用了 JS 代码压缩的插件</span></span><br><span class="line">    <span class="comment">// 这其实也是我们命令中的 --mode production 的效果，后续的小节会介绍 webpack 的 mode 参数</span></span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="搭建基础的前端开发环境"><a href="#搭建基础的前端开发环境" class="headerlink" title="搭建基础的前端开发环境"></a>搭建基础的前端开发环境</h3><h4 id="关联-HTML"><a href="#关联-HTML" class="headerlink" title="关联 HTML"></a>关联 HTML</h4><blockquote><p><code>webpack</code> 默认从作为入口的 <code>.js</code> 文件进行构建（更多是基于 <code>SPA</code> 去考虑），但通常一个前端项目都是从一个页面（即 HTML）出发的，最简单的方法是，创建一个 HTML 文件，使用 <code>script</code> 标签直接引用构建好的 JS 文件，如…</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;./dist/bundle.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>但是，如果我们的文件名或者路径会变化，例如使用 <code>[hash]</code> 来进行命名，那么最好是将 <code>HTML</code> 引用路径和我们的构建结果关联起来，这个时候我们可以使用 <code>html-webpack-plugin</code></li><li><code>html-webpack-plugin</code> 是一个独立的 <code>node package</code>，所以在使用之前我们需要先安装它，把它安装到项目的开发依赖中</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install html-webpack-plugin -D</span><br></pre></td></tr></table></figure><blockquote><p>然后在 <code>webpack</code> 配置中，将 <code>html-webpack-plugin</code> 添加到 <code>plugins</code> 列表中</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  plugins: [<span class="keyword">new</span> HtmlWebpackPlugin()]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>这样配置好之后，构建时 <code>html-webpack-plugin</code> 会为我们创建一个 <code>HTML</code> 文件，其中会引用构建出来的 JS 文件。实际项目中，默认创建的 <code>HTML</code> 文件并没有什么用，我们需要自己来写 <code>HTML</code> 文件，可以通过 <code>html-webpack-plugin</code> 的配置，传递一个写好的 HTML 模板…</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'index.html'</span>, <span class="comment">// 配置输出文件名和路径</span></span><br><span class="line">      template: <span class="string">'assets/index.html'</span> <span class="comment">// 配置文件模板</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>这样，通过 <code>html-webpack-plugin</code> 就可以将我们的页面和构建 <code>JS</code> 关联起来，回归日常，从页面开始开发。如果需要添加多个页面关联，那么实例化多个 <code>html-webpack-plugin</code>， 并将它们都放到 <code>plugins</code> 字段数组中就可以了…</p></blockquote><h4 id="构建-CSS"><a href="#构建-CSS" class="headerlink" title="构建 CSS"></a>构建 CSS</h4><blockquote><p>我们编写 <code>CSS</code>，并且希望使用 <code>webpack</code> 来进行构建，为此，需要在配置中引入 <code>loader</code> 来解析和处理 <code>CSS</code> 文件</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css/</span>,</span><br><span class="line">        include: [path.resolve(__dirname, <span class="string">'src'</span>)],</span><br><span class="line">        use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>css-loader</code> 负责解析 <code>CSS</code> 代码，主要是为了处理 <code>CSS</code> 中的依赖，例如 <code>@import</code> 和 <code>url()</code> 等引用外部文件的声明；</li><li><code>style-loader</code> 会将 <code>css-loader</code> 解析的结果转变成 <code>JS</code> 代码，运行时动态插入 <code>style</code> 标签来让 <code>CSS</code> 代码生效…</li></ul><blockquote><p>经由上述两个 <code>loader</code> 的处理后，CSS 代码会转变为 JS，和 <code>index.js</code> 一起打包了。如果需要单独把 CSS 文件分离出来，我们需要使用 <code>extract-text-webpack-plugin</code> 插件</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="comment">// 因为这个插件需要干涉模块转换的内容，所以需要使用它对应的 loader</span></span><br><span class="line">        use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">          fallback: <span class="string">'style-loader'</span>,</span><br><span class="line">          use: <span class="string">'css-loader'</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// 引入插件，配置文件名，这里同样可以使用 [hash]</span></span><br><span class="line">    <span class="keyword">new</span> ExtractTextPlugin(<span class="string">'index.css'</span>)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="CSS-预处理器"><a href="#CSS-预处理器" class="headerlink" title="CSS 预处理器"></a>CSS 预处理器</h4><blockquote><p>在上述使用 CSS 的基础上，通常我们会使用 <code>Less/Sass</code> 等 CSS 预处理器，webpack 可以通过添加对应的 <code>loader</code> 来支持，以使用 <code>Less</code> 为例，我们可以在官方文档中找到对应的 <code>loader</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        <span class="comment">// 因为这个插件需要干涉模块转换的内容，所以需要使用它对应的 loader</span></span><br><span class="line">        use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">          fallback: <span class="string">'style-loader'</span>,</span><br><span class="line">          use: [<span class="string">'css-loader'</span>, <span class="string">'less-loader'</span>]</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="处理图片文件"><a href="#处理图片文件" class="headerlink" title="处理图片文件"></a>处理图片文件</h4><blockquote><p>在前端项目的样式中总会使用到图片，虽然我们已经提到 <code>css-loader</code> 会解析样式中用 <code>url()</code> 引用的文件路径，但是图片对应的 <code>jpg/png/gif</code> 等文件格式，<code>webpack</code> 处理不了。是的，我们只要添加一个处理图片的 <code>loader</code> 配置就可以了，现有的 <code>file-loader</code> 就是个不错的选择…</p></blockquote><ul><li><code>file-loader</code> 可以用于处理很多类型的文件，它的主要作用是直接输出文件，把构建后的文件路径返回。配置很简单，在 <code>rules</code> 中添加一个字段，增加图片类型文件的解析配置</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpg|gif)$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'file-loader'</span>,</span><br><span class="line">            options: &#123;&#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="使用-Babel"><a href="#使用-Babel" class="headerlink" title="使用 Babel"></a>使用 Babel</h4><blockquote><p><code>Babel</code> 是一个让我们能够使用 <code>ES</code> 新特性的 <code>JS</code> 编译工具，我们可以在 <code>webpack</code> 中配置 Babel，以便使用 <code>ES6</code>、<code>ES7</code> 标准来编写 <code>JS</code> 代码</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.jsx?/</span>, <span class="comment">// 支持 js 和 jsx</span></span><br><span class="line">        include: [</span><br><span class="line">          path.resolve(__dirname, <span class="string">'src'</span>) <span class="comment">// src 目录下的才需要经过 babel-loader 处理</span></span><br><span class="line">        ],</span><br><span class="line">        loader: <span class="string">'babel-loader'</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="启动静态服务"><a href="#启动静态服务" class="headerlink" title="启动静态服务"></a>启动静态服务</h4><blockquote><p>至此，我们完成了处理多种文件类型的 webpack 配置。我们可以使用 <code>webpack-dev-server</code> 在本地开启一个简单的静态服务来进行开发</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">  <span class="string">"build"</span>: <span class="string">"webpack --mode production"</span>,</span><br><span class="line">  <span class="string">"start"</span>: <span class="string">"webpack-dev-server --mode development"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>尝试着运行 <code>npm start</code> 或者 <code>yarn start</code>，然后就可以访问 <code>http://localhost:8080/</code> 来查看你的页面了。默认是访问 <code>index.html</code>，如果是其他页面要注意访问的 URL 是否正确</p></blockquote><h4 id="完整示例代码"><a href="#完整示例代码" class="headerlink" title="完整示例代码"></a>完整示例代码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line"></span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'[name].js'</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.jsx?/</span>,</span><br><span class="line">        include: [path.resolve(__dirname, <span class="string">'src'</span>)],</span><br><span class="line">        use: <span class="string">'babel-loader'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        <span class="comment">// 因为这个插件需要干涉模块转换的内容，所以需要使用它对应的 loader</span></span><br><span class="line">        use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">          fallback: <span class="string">'style-loader'</span>,</span><br><span class="line">          use: [<span class="string">'css-loader'</span>, <span class="string">'less-loader'</span>]</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpg|gif)$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'file-loader'</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 代码模块路径解析的配置</span></span><br><span class="line">  resolve: &#123;</span><br><span class="line">    modules: [<span class="string">'node_modules'</span>, path.resolve(__dirname, <span class="string">'src'</span>)],</span><br><span class="line"></span><br><span class="line">    extensions: [<span class="string">'.wasm'</span>, <span class="string">'.mjs'</span>, <span class="string">'.js'</span>, <span class="string">'.json'</span>, <span class="string">'.jsx'</span>]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'index.html'</span>, <span class="comment">// 配置输出文件名和路径</span></span><br><span class="line">      template: <span class="string">'src/index.html'</span> <span class="comment">// 配置文件模板</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> ExtractTextPlugin(<span class="string">'[name].css'</span>)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="webpack-如何解析代码模块路径"><a href="#webpack-如何解析代码模块路径" class="headerlink" title="webpack 如何解析代码模块路径"></a>webpack 如何解析代码模块路径</h3><blockquote><p>webpack 中有一个很关键的模块 <code>enhanced-resolve</code> 就是处理依赖模块路径的解析的，这个模块可以说是 Node.js 那一套模块路径解析的增强版本，有很多可以自定义的解析配置</p></blockquote><ul><li>在 webpack 配置中，和模块路径解析相关的配置都在 <code>resolve</code> 字段下</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="常用的一些配置"><a href="#常用的一些配置" class="headerlink" title="常用的一些配置"></a>常用的一些配置</h4><p><strong>resolve.alias</strong></p><blockquote><p>假设我们有个 <code>utils</code> 模块极其常用，经常编写相对路径很麻烦，希望可以直接 <code>import &#39;utils&#39;</code> 来引用，那么我们可以配置某个模块的别名，如</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alias: &#123;</span><br><span class="line">  utils: path.resolve(__dirname, <span class="string">'src/utils'</span>); <span class="comment">// 这里使用 path.resolve 和 __dirname 来获取绝对路径</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上述的配置是模糊匹配，意味着只要模块路径中携带了 utils 就可以被替换掉，如：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &apos;utils/query.js&apos; // 等同于 import &apos;[项目绝对路径]/src/utils/query.js&apos;</span><br></pre></td></tr></table></figure><blockquote><p>如果需要进行精确匹配可以使用：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alias: &#123;</span><br><span class="line">  utils$: path.resolve(__dirname, <span class="string">'src/utils'</span>); <span class="comment">// 只会匹配 import 'utils'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>resolve.extensions</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extensions: [<span class="string">'.wasm'</span>, <span class="string">'.mjs'</span>, <span class="string">'.js'</span>, <span class="string">'.json'</span>, <span class="string">'.jsx'</span>],</span><br><span class="line"><span class="comment">// 这里的顺序代表匹配后缀的优先级，例如对于 index.js 和 index.jsx，会优先选择 index.js</span></span><br></pre></td></tr></table></figure><blockquote><p>这个配置的作用是和文件后缀名有关的, 这个配置可以定义在进行模块路径解析时，webpack 会尝试帮你补全那些后缀名来进行查找</p></blockquote><h3 id="配置-loader"><a href="#配置-loader" class="headerlink" title="配置 loader"></a>配置 loader</h3><h4 id="loader-匹配规则"><a href="#loader-匹配规则" class="headerlink" title="loader 匹配规则"></a>loader 匹配规则</h4><blockquote><p>当我们需要配置 <code>loader</code> 时，都是在 <code>module.rules</code> 中添加新的配置项，在该字段中，每一项被视为一条匹配使用 <code>loader</code> 的规则</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.jsx?/</span>, <span class="comment">// 条件</span></span><br><span class="line">        include: [path.resolve(__dirname, <span class="string">'src'</span>)], <span class="comment">// 条件</span></span><br><span class="line">        use: <span class="string">'babel-loader'</span> <span class="comment">// 规则应用结果</span></span><br><span class="line">      &#125; <span class="comment">// 一个 object 即一条规则</span></span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><code>loader</code> 的匹配规则中有两个最关键的因素：一个是匹配条件，一个是匹配规则后的应用</p></blockquote><h4 id="规则条件配置"><a href="#规则条件配置" class="headerlink" title="规则条件配置"></a>规则条件配置</h4><blockquote><p>大多数情况下，配置 <code>loader</code> 的匹配条件时，只要使用 <code>test</code> 字段就好了，很多时候都只需要匹配文件后缀名来决定使用什么 <code>loader</code>，但也不排除在某些特殊场景下，我们需要配置比较复杂的匹配条件。webpack 的规则提供了多种配置形式…</p></blockquote><ul><li><code>{test: ...}</code> 匹配特定条件</li><li><code>{include: ...}</code> 匹配特定路径</li><li><code>{exclude: ...}</code> 排除特定路径</li><li><code>{and: [...] }</code> 必须匹配数组中所有条件</li><li><code>{or: [...] }</code> 匹配数组中任意一个条件</li><li><code>{not: [...] }</code> 排除匹配数组中所有条件…</li></ul><blockquote><p>上述的所谓条件的值可以是：</p></blockquote><ul><li>字符串：必须以提供的字符串开始，所以是字符串的话，这里我们需要提供绝对路径</li><li>正则表达式：调用正则的 <code>test</code> 方法来判断匹配</li><li>函数：<code>(path) =&gt; boolean</code>，返回 <code>true</code> 表示匹配</li><li>数组：至少包含一个条件的数组</li><li>对象：匹配所有属性值的条件…</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">rules: [</span><br><span class="line">  &#123;</span><br><span class="line">    test: <span class="regexp">/\.jsx?/</span>, <span class="comment">// 正则</span></span><br><span class="line">    include: [</span><br><span class="line">      path.resolve(__dirname, <span class="string">'src'</span>), <span class="comment">// 字符串，注意是绝对路径</span></span><br><span class="line">    ], <span class="comment">// 数组</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    test: &#123;</span><br><span class="line">      js: <span class="regexp">/\.js/</span>,</span><br><span class="line">      jsx: <span class="regexp">/\.jsx/</span>,</span><br><span class="line">    &#125;, <span class="comment">// 对象，不建议使用</span></span><br><span class="line">    not: [</span><br><span class="line">      (value) =&gt; &#123; <span class="comment">/* ... */</span> <span class="keyword">return</span> <span class="literal">true</span>; &#125;, <span class="comment">// 函数，通常需要高度自定义时才会使用</span></span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="使用-loader-配置"><a href="#使用-loader-配置" class="headerlink" title="使用 loader 配置"></a>使用 loader 配置</h4><blockquote><p><code>module.rules</code> 的匹配规则最重要的还是用于配置 <code>loader</code>，我们可以使用 <code>use</code> 字段</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">rules: [</span><br><span class="line">  &#123;</span><br><span class="line">    test: <span class="regexp">/\.less/</span>,</span><br><span class="line">    use: [</span><br><span class="line">      <span class="string">'style-loader'</span>, <span class="comment">// 直接使用字符串表示 loader</span></span><br><span class="line">      &#123;</span><br><span class="line">        loader: <span class="string">'css-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          importLoaders: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;, <span class="comment">// 用对象表示 loader，可以传递 loader 配置等</span></span><br><span class="line">      &#123;</span><br><span class="line">        loader: <span class="string">'less-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          noIeCompat: <span class="literal">true</span></span><br><span class="line">        &#125;, <span class="comment">// 传递 loader 配置</span></span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p><code>use</code> 字段可以是一个数组，也可以是一个字符串或者表示 <code>loader</code> 的对象。如果只需要一个 <code>loader</code>，也可以这样：<code>use: {loader: &#39;babel-loader&#39;</code>, <code>options: { ...} }</code></p></blockquote><h4 id="loader-应用顺序"><a href="#loader-应用顺序" class="headerlink" title="loader 应用顺序"></a>loader 应用顺序</h4><ul><li>对于上面的 <code>less</code> 规则配置，一个 <code>style.less</code> 文件会途径 <code>less-loader</code>、<code>css-loader</code>、<code>style-loader</code> 处理，成为一个可以打包的模块。</li><li><code>loader</code> 的应用顺序在配置多个 <code>loader</code> 一起工作时很重要，通常会使用在 CSS 配置上，除了 <code>style-loader</code> 和 <code>css-loader</code>，你可能还要配置 <code>less-loader</code> 然后再加个 <code>postcss</code> 的 <code>autoprefixer</code> 等。</li><li>上述从后到前的顺序是在同一个 <code>rule</code> 中进行的，那如果多个 <code>rule</code> 匹配了同一个模块文件，<code>loader</code> 的应用顺序又是怎样的呢？看一份这样的配置…</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">rules: [</span><br><span class="line">  &#123;</span><br><span class="line">    test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">    exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">    loader: <span class="string">"eslint-loader"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">    exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">    loader: <span class="string">"babel-loader"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>这样无法法保证 <code>eslint-loader</code> 在 <code>babel-loader</code> 应用前执行。<code>webpack</code> 在 <code>rules</code> 中提供了一个 <code>enforce</code> 的字段来配置当前 <code>rule</code> 的 <code>loader</code> 类型，没配置的话是普通类型，我们可以配置 <code>pre</code> 或 <code>post</code>，分别对应前置类型或后置类型的 <code>loader</code>…</p></blockquote><ul><li>所有的 <code>loader</code> 按照 <strong>前置</strong> -&gt; <strong>行内</strong> -&gt; <strong>普通</strong> -&gt; <strong>后置</strong> 的顺序执行。所以当我们要确保 <code>eslint-loader</code> 在 <code>babel-loader</code> 之前执行时，可以如下添加 <code>enforce</code> 配置</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rules: [</span><br><span class="line">  &#123;</span><br><span class="line">    enforce: <span class="string">'pre'</span>, <span class="comment">// 指定为前置类型</span></span><br><span class="line">    test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">    exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">    loader: <span class="string">"eslint-loader"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>当项目文件类型和应用的 <code>loader</code> 不是特别复杂的时候，通常建议把要应用的同一类型 <code>loader</code> 都写在同一个匹配规则中，这样更好维护和控制</p></blockquote><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> CopyWebpackPlugin = <span class="built_in">require</span>(<span class="string">'copy-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index'</span>,</span><br><span class="line"></span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'[name].js'</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        enforce: <span class="string">'pre'</span>, <span class="comment">// 指定为前置类型</span></span><br><span class="line">        test: <span class="regexp">/\.jsx?$/</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        loader: <span class="string">'eslint-loader'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.jsx?$/</span>,</span><br><span class="line">        include: [path.resolve(__dirname, <span class="string">'src'</span>)],</span><br><span class="line">        use: <span class="string">'babel-loader'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">          fallback: <span class="string">'style-loader'</span>,</span><br><span class="line">          use: [<span class="string">'css-loader'</span>]</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">          fallback: <span class="string">'style-loader'</span>,</span><br><span class="line">          use: [<span class="string">'css-loader'</span>, <span class="string">'less-loader'</span>]</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpg|gif)$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'file-loader'</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  resolve: &#123;</span><br><span class="line">    alias: &#123;</span><br><span class="line">      utils: path.resolve(__dirname, <span class="string">'src/utils'</span>), <span class="comment">// 这里使用 path.resolve 和 __dirname 来获取绝对路径</span></span><br><span class="line">      log$: path.resolve(__dirname, <span class="string">'src/utils/log.js'</span>) <span class="comment">// 只匹配 log</span></span><br><span class="line">    &#125;,</span><br><span class="line">    extensions: [<span class="string">'.js'</span>, <span class="string">'.json'</span>, <span class="string">'.jsx'</span>, <span class="string">'.css'</span>, <span class="string">'.less'</span>],</span><br><span class="line">    modules: [</span><br><span class="line">      path.resolve(__dirname, <span class="string">'node_modules'</span>) <span class="comment">// 指定当前目录下的 node_modules 优先查找</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'index.html'</span>, <span class="comment">// 配置输出文件名和路径</span></span><br><span class="line">      template: <span class="string">'src/index.html'</span> <span class="comment">// 配置文件模板</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> ExtractTextPlugin(<span class="string">'[name].css'</span>),</span><br><span class="line">    <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">      TWO: <span class="string">'1+1'</span>,</span><br><span class="line">      CONSTANTS: &#123;</span><br><span class="line">        APP_VERSION: <span class="built_in">JSON</span>.stringify(<span class="string">'1.1.2'</span>) <span class="comment">// const CONSTANTS = &#123; APP_VERSION: '1.1.2' &#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> CopyWebpackPlugin([</span><br><span class="line">      &#123; <span class="attr">from</span>: <span class="string">'src/assets/favicon.ico'</span>, <span class="attr">to</span>: <span class="string">'favicon.ico'</span> &#125; <span class="comment">// 顾名思义，from 配置来源，to 配置目标路径</span></span><br><span class="line">    ]),</span><br><span class="line">    <span class="keyword">new</span> webpack.ProvidePlugin(&#123;</span><br><span class="line">      _: <span class="string">'lodash'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  devServer: &#123;</span><br><span class="line">    port: <span class="string">'1234'</span>,</span><br><span class="line">    before(app) &#123;</span><br><span class="line">      app.get(<span class="string">'/api/test.json'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 当访问 /some/path 路径时，返回自定义的 json 数据</span></span><br><span class="line">        res.json(&#123; <span class="attr">code</span>: <span class="number">200</span>, <span class="attr">message</span>: <span class="string">'hello world'</span> &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="使用-plugin"><a href="#使用-plugin" class="headerlink" title="使用 plugin"></a>使用 plugin</h3><blockquote><p>更多的插件可以在这里查找：<a href="https://github.com/webpack-contrib/awesome-webpack#webpack-plugins" target="_blank" rel="noopener">plugins in awesome-webpack</a></p></blockquote><h4 id="DefinePlugin"><a href="#DefinePlugin" class="headerlink" title="DefinePlugin"></a>DefinePlugin</h4><blockquote><p><code>DefinePlugin</code> 是 <code>webpack</code> 内置的插件，可以使用 <code>webpack.DefinePlugin</code> 直接获取</p></blockquote><ul><li>这个插件用于创建一些在编译时可以配置的全局常量，这些常量的值我们可以在 <code>webpack</code> 的配置中去指定，例如</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">      PRODUCTION: <span class="built_in">JSON</span>.stringify(<span class="literal">true</span>), <span class="comment">// const PRODUCTION = true</span></span><br><span class="line">      VERSION: <span class="built_in">JSON</span>.stringify(<span class="string">'5fa3b9'</span>), <span class="comment">// const VERSION = '5fa3b9'</span></span><br><span class="line">      BROWSER_SUPPORTS_HTML5: <span class="literal">true</span>, <span class="comment">// const BROWSER_SUPPORTS_HTML5 = 'true'</span></span><br><span class="line">      TWO: <span class="string">'1+1'</span>, <span class="comment">// const TWO = 1 + 1,</span></span><br><span class="line">      CONSTANTS: &#123;</span><br><span class="line">        APP_VERSION: <span class="built_in">JSON</span>.stringify(<span class="string">'1.1.2'</span>) <span class="comment">// const CONSTANTS = &#123; APP_VERSION: '1.1.2' &#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>有了上面的配置，就可以在应用代码文件中，访问配置好的变量了，如：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'Running App version'</span> + VERSION);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!BROWSER_SUPPORTS_HTML5) <span class="built_in">require</span>(<span class="string">'html5shiv'</span>);</span><br></pre></td></tr></table></figure><blockquote><p>上面配置的注释已经简单说明了这些配置的效果，这里再简述一下整个配置规则。</p></blockquote><ul><li>如果配置的值是字符串，那么整个字符串会被当成代码片段来执行，其结果作为最终变量的值，如上面的 <code>&quot;1+1&quot;</code>，最后的结果是 <code>2</code></li><li>如果配置的值不是字符串，也不是一个对象字面量，那么该值会被转为一个字符串，如 <code>true</code>，最后的结果是 <code>&#39;true&#39;</code></li><li>如果配置的是一个对象字面量，那么该对象的所有 <code>key</code> 会以同样的方式去定义</li><li>这样我们就可以理解为什么要使用 <code>JSON.stringify()</code> 了，因为 <code>JSON.stringify(true)</code> 的结果是 <code>&#39;true&#39;</code>，<code>JSON.stringify(&quot;5fa3b9&quot;)</code> 的结果是 <code>&quot;5fa3b9&quot;</code>。</li></ul><blockquote><p>社区中关于 <code>DefinePlugin</code> 使用得最多的方式是定义环境变量，例如 <code>PRODUCTION = true</code> 或者 <code>__DEV__ = true</code> 等。部分类库在开发环境时依赖这样的环境变量来给予开发者更多的开发调试反馈，例如 react 等。</p></blockquote><ul><li>建议使用 <code>process.env.NODE_ENV</code>: … 的方式来定义 <code>process.env.NODE_ENV</code>，而不是使用 <code>process: {env: { NODE_ENV: ...} }</code> 的方式，因为这样会覆盖掉 <code>process</code> 这个对象，可能会对其他代码造成影响…</li></ul><h4 id="copy-webpack-plugin"><a href="#copy-webpack-plugin" class="headerlink" title="copy-webpack-plugin"></a>copy-webpack-plugin</h4><blockquote><p>我们一般会把开发的所有源码和资源文件放在 <code>src/</code> 目录下，构建的时候产出一个 <code>build/</code> 目录，通常会直接拿 <code>build</code> 中的所有文件来发布。有些文件没经过 <code>webpack</code> 处理，但是我们希望它们也能出现在 <code>build</code> 目录下，这时就可以使用 <code>CopyWebpackPlugin</code> 来处理了…</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CopyWebpackPlugin = <span class="built_in">require</span>(<span class="string">'copy-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> CopyWebpackPlugin([</span><br><span class="line">      &#123; <span class="attr">from</span>: <span class="string">'src/file.txt'</span>, <span class="attr">to</span>: <span class="string">'build/file.txt'</span> &#125;, <span class="comment">// 顾名思义，from 配置来源，to 配置目标路径</span></span><br><span class="line">      &#123; <span class="attr">from</span>: <span class="string">'src/*.ico'</span>, <span class="attr">to</span>: <span class="string">'build/*.ico'</span> &#125; <span class="comment">// 配置项可以使用 glob</span></span><br><span class="line">      <span class="comment">// 可以配置很多项复制规则</span></span><br><span class="line">    ])</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="extract-text-webpack-plugin"><a href="#extract-text-webpack-plugin" class="headerlink" title="extract-text-webpack-plugin"></a>extract-text-webpack-plugin</h4><blockquote><p>我们用它来把依赖的 <code>CSS</code> 分离出来成为单独的文件。这里再看一下使用 <code>extract-text-webpack-plugin</code> 的配置</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="comment">// 因为这个插件需要干涉模块转换的内容，所以需要使用它对应的 loader</span></span><br><span class="line">        use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">          fallback: <span class="string">'style-loader'</span>,</span><br><span class="line">          use: <span class="string">'css-loader'</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// 引入插件，配置文件名，这里同样可以使用 [hash]</span></span><br><span class="line">    <span class="keyword">new</span> ExtractTextPlugin(<span class="string">'index.css'</span>)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>在上述的配置中，我们使用了 <code>index.css</code> 作为单独分离出来的文件名，但有的时候构建入口不止一个，<code>extract-text-webpack-plugin</code> 会为每一个入口创建单独分离的文件，因此最好这样配置</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这样确保在使用多个构建入口时，生成不同名称的文件</span></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> ExtractTextPlugin(<span class="string">'[name].css'</span>),</span><br><span class="line">],</span><br></pre></td></tr></table></figure><h3 id="更好使用-webpack-dev-server"><a href="#更好使用-webpack-dev-server" class="headerlink" title="更好使用 webpack-dev-server"></a>更好使用 webpack-dev-server</h3><blockquote><p><code>webpack-dev-server</code> 是 <code>webpack</code> 官方提供的一个工具，可以基于当前的 <code>webpack</code> 构建配置快速启动一个静态服务。当 <code>mode</code> 为 <code>development</code> 时，会具备 <code>hot reload</code> 的功能，即当源码文件变化时，会即时更新当前页面，以便你看到最新的效果…</p></blockquote><h4 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h4><blockquote><p><code>webpack-dev-server</code> 是一个 <code>npm package</code>，安装后在已经有 <code>webpack</code> 配置文件的项目目录下直接启动就可以</p></blockquote><ul><li><code>webpack-dev-server</code> 默认使用 <code>8080</code> 端口</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack-dev-server -g</span><br><span class="line">webpack-dev-server --mode development</span><br></pre></td></tr></table></figure><blockquote><p><code>package</code> 中的 <code>scripts</code> 配置：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"start"</span>: <span class="string">"webpack-dev-server --mode development"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><blockquote><p>在 webpack 的配置中，可以通过 <code>devServer</code> 字段来配置 <code>webpack-dev-server</code>，如端口设置、启动 <code>gzip</code> 压缩等，这里简单讲解几个常用的配置</p></blockquote><ul><li><code>public</code> 字段用于指定静态服务的域名，默认是 <code>http://localhost:8080/</code> ，当你使用 <code>Nginx</code> 来做反向代理时，应该就需要使用该配置来指定 <code>Nginx</code> 配置使用的服务域名</li><li><code>port</code> 字段用于指定静态服务的端口，如上，默认是 <code>8080</code>，通常情况下都不需要改动</li><li><code>publicPath</code> 字段用于指定构建好的静态文件在浏览器中用什么路径去访问，默认是 <code>/</code>，例如，对于一个构建好的文件 <code>bundle.js</code>，完整的访问路径是 <code>http://localhost:8080/bundle.js</code>，如果你配置了 <code>publicPath: &#39;assets/&#39;</code>，那么上述 <code>bundle.js</code> 的完整访问路径就是 <code>http://localhost:8080/assets/bundle.js</code>。可以使用整个 <code>URL</code> 来作为 <code>publicPath</code> 的值，如 <code>publicPath: &#39;http://localhost:8080/assets/&#39;</code>。如果你使用了 <code>HMR</code>，那么要设置 <code>publicPath</code> 就必须使用完整的 <code>URL</code></li></ul><blockquote><p>建议将 <code>devServer.publicPath</code> 和 <code>output.publicPath</code> 的值保持一致</p></blockquote><ul><li><code>proxy</code> 用于配置 <code>webpack-dev-server</code> 将特定 <code>URL</code> 的请求代理到另外一台服务器上。当你有单独的后端开发服务器用于请求 API 时，这个配置相当有用。例如</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">proxy: &#123;</span><br><span class="line">  <span class="string">'/api'</span>: &#123;</span><br><span class="line">    target: <span class="string">"http://localhost:3000"</span>, <span class="comment">// 将 URL 中带有 /api 的请求代理到本地的 3000 端口的服务上</span></span><br><span class="line">    pathRewrite: &#123;<span class="string">'^/api'</span>: <span class="string">''</span>&#125;, <span class="comment">// 把 URL 中 path 部分的 `api` 移除掉</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>before</code> 和 <code>after</code> 配置用于在 <code>webpack-dev-server</code> 定义额外的中间件，如</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">before(app)&#123;</span><br><span class="line">  app.get(<span class="string">'/some/path'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123; <span class="comment">// 当访问 /some/path 路径时，返回自定义的 json 数据</span></span><br><span class="line">    res.json(&#123;<span class="attr">custom</span>: <span class="string">'response'</span>&#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>before</code> 在 <code>webpack-dev-server</code> 静态资源中间件处理之前，可以用于拦截部分请求返回特定内容，或者实现简单的数据 <code>mock</code>。</li><li><code>after</code> 在 <code>webpack-dev-server</code> 静态资源中间件处理之后，比较少用到，可以用于打印日志或者做一些额外处理…</li></ul><h3 id="开发和生产环境的构建配置差异"><a href="#开发和生产环境的构建配置差异" class="headerlink" title="开发和生产环境的构建配置差异"></a>开发和生产环境的构建配置差异</h3><ul><li>我们在日常的前端开发工作中，一般都会有两套构建环境：一套开发时使用，构建结果用于本地开发调试，不进行代码压缩，打印 <code>debug</code> 信息，包含 <code>sourcemap</code> 文件</li><li>另外一套构建后的结果是直接应用于线上的，即代码都是压缩后，运行时不打印 <code>debug</code> 信息，静态文件不包括 <code>sourcemap</code> 的。有的时候可能还需要多一套测试环境，在运行时直接进行请求 <code>mock</code> 等工作</li><li><code>webpack 4.x</code> 版本引入了 <code>mode</code> 的概念，在运行 <code>webpack</code> 时需要指定使用 <code>production</code> 或 <code>development</code> 两个 <code>mode</code> 其中一个，这个功能也就是我们所需要的运行两套构建环境的能力。</li></ul><h4 id="在配置文件中区分-mode"><a href="#在配置文件中区分-mode" class="headerlink" title="在配置文件中区分 mode"></a>在配置文件中区分 mode</h4><blockquote><p>之前我们的配置文件都是直接对外暴露一个 <code>JS</code> 对象，这种方式暂时没有办法获取到 <code>webpack</code> 的 <code>mode</code> 参数，我们需要更换一种方式来处理配置。根据官方的文档多种配置类型，配置文件可以对外暴露一个函数，因此我们可以这样做</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">env, argv</span>) =&gt;</span> (&#123;</span><br><span class="line">  <span class="comment">// ... 其他配置</span></span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimize: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 使用 argv 来获取 mode 参数的值</span></span><br><span class="line">    minimizer:</span><br><span class="line">      argv.mode === <span class="string">'production'</span></span><br><span class="line">        ? [</span><br><span class="line">            <span class="keyword">new</span> UglifyJsPlugin(&#123;</span><br><span class="line">              <span class="comment">/* 你自己的配置 */</span></span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="comment">// 仅在我们要自定义压缩配置时才需要这么做</span></span><br><span class="line">            <span class="comment">// mode 为 production 时 webpack 会默认使用压缩 JS 的 plugin</span></span><br><span class="line">          ]</span><br><span class="line">        : []</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>这样获取 <code>mode</code> 之后，我们就能够区分不同的构建环境，然后根据不同环境再对特殊的 <code>loader</code> 或 <code>plugin</code> 做额外的配置就可以了</p></blockquote><ul><li>以上是 <code>webpack 4.x</code> 的做法，由于有了 <code>mode</code> 参数，区分环境变得简单了。不过在当前业界，估计还是使用 <code>webpack 3.x</code> 版本的居多，所以这里也简单介绍一下 <code>3.x</code> 如何区分环境</li></ul><blockquote><p><code>webpack</code> 的运行时环境是 <code>Node.js</code>，我们可以通过 <code>Node.js</code> 提供的机制给要运行的 <code>webpack</code> 程序传递环境变量，来控制不同环境下的构建行为。例如，我们在 <code>npm</code> 中的 <code>scripts</code> 字段添加一个用于生产环境的构建命令…</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"build"</span>: <span class="string">"NODE_ENV=production webpack"</span>,</span><br><span class="line">    <span class="string">"develop"</span>: <span class="string">"NODE_ENV=development webpack-dev-server"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>然后在 <code>webpack.config.js</code> 文件中可以通过 <code>process.env.NODE_ENV</code> 来获取命令传入的环境变量</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="comment">// ... webpack 配置</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'production'</span>) &#123;</span><br><span class="line">  <span class="comment">// 生产环境需要做的事情，如使用代码压缩插件等</span></span><br><span class="line">  config.plugins.push(<span class="keyword">new</span> UglifyJsPlugin());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = config;</span><br></pre></td></tr></table></figure><h4 id="运行时的环境变量"><a href="#运行时的环境变量" class="headerlink" title="运行时的环境变量"></a>运行时的环境变量</h4><blockquote><p>我们使用 webpack 时传递的 mode 参数，是可以在我们的应用代码运行时，通过 <code>process.env.NODE_ENV</code> 这个变量获取的。这样方便我们在运行时判断当前执行的构建环境，使用最多的场景莫过于控制是否打印 <code>debug</code> 信息…</p></blockquote><ul><li>下面这个简单的例子，在应用开发的代码中实现一个简单的 <code>console</code> 打印封装</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'development'</span> &amp;&amp; <span class="built_in">console</span> &amp;&amp; <span class="built_in">console</span>.log) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log.apply(<span class="built_in">console</span>, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>同样，以上是 <code>webpack 4.x</code> 的做法，下面简单介绍一下 <code>3.x</code> 版本应该如何实现。这里需要用到 <code>DefinePlugin</code> 插件，它可以帮助我们在构建时给运行时定义变量，那么我们只要在前面 <code>webpack 3.x</code> 版本区分构建环境的例子的基础上，再使用 <code>DefinePlugin</code> 添加环境变量即可影响到运行时的代码…</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// webpack 的配置</span></span><br><span class="line"></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">      <span class="comment">// webpack 3.x 的 process.env.NODE_ENV 是通过手动在命令行中指定 NODE_ENV=... 的方式来传递的</span></span><br><span class="line">      <span class="string">'process.env.NODE_ENV'</span>: <span class="built_in">JSON</span>.stringify(process.env.NODE_ENV)</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="常见的环境差异配置"><a href="#常见的环境差异配置" class="headerlink" title="常见的环境差异配置"></a>常见的环境差异配置</h4><p><strong>常见的 webpack 构建差异配置</strong></p><ul><li>生产环境可能需要分离 <code>CSS</code> 成单独的文件，以便多个页面共享同一个 <code>CSS</code> 文件</li><li>生产环境需要压缩 <code>HTML/CSS/JS</code> 代码</li><li>生产环境需要压缩图片</li><li>开发环境需要生成 <code>sourcemap</code> 文件</li><li>开发环境需要打印 <code>debug</code> 信息</li><li>开发环境需要 <code>live reload</code> 或者 <code>hot reload</code> 的功能…</li></ul><blockquote><p><code>webpack 4.x</code> 的 <code>mode</code> 已经提供了上述差异配置的大部分功能，<code>mode</code> 为 <code>production</code> 时默认使用 <code>JS</code> 代码压缩，而 <code>mode</code> 为 <code>development</code> 时默认启用 <code>hot</code> <code>reload</code>，等等。这样让我们的配置更为简洁，我们只需要针对特别使用的 <code>loader</code> 和 <code>plugin</code> 做区分配置就可以了…</p></blockquote><ul><li><code>webpack 3.x</code> 版本还是只能自己动手修改配置来满足大部分环境差异需求，所以如果你要开始一个新的项目，建议直接使用 <code>webpack 4.x</code> 版本</li></ul><h4 id="拆分配置"><a href="#拆分配置" class="headerlink" title="拆分配置"></a>拆分配置</h4><blockquote><p>前面我们列出了几个环境差异配置，可能这些构建需求就已经有点多了，会让整个 <code>webpack</code> 的配置变得复杂，尤其是有着大量环境变量判断的配置。我们可以把 <code>webpack</code> 的配置按照不同的环境拆分成多个文件，运行时直接根据环境变量加载对应的配置即可。基本的划分如下…</p></blockquote><ul><li><code>webpack.base.js</code>：基础部分，即多个文件中共享的配置</li><li><code>webpack.development.js</code>：开发环境使用的配置</li><li><code>webpack.production.js</code>：生产环境使用的配置</li><li><code>webpack.test.js</code>：测试环境使用的配置…</li></ul><p><strong>如何处理这样的配置拆分</strong></p><blockquote><p>首先我们要明白，对于 <code>webpack</code> 的配置，其实是对外暴露一个 <code>JS</code> 对象，所以对于这个对象，我们都可以用 <code>JS</code> 代码来修改它，例如</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="comment">// ... webpack 配置</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们可以修改这个 config 来调整配置，例如添加一个新的插件</span></span><br><span class="line">config.plugins.push(<span class="keyword">new</span> YourPlugin());</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = config;</span><br></pre></td></tr></table></figure><blockquote><p>因此，只要有一个工具能比较智能地合并多个配置对象，我们就可以很轻松地拆分 webpack 配置，然后通过判断环境变量，使用工具将对应环境的多个配置对象整合后提供给 webpack 使用。这个工具就是 <strong><a href="https://github.com/survivejs/webpack-merge" target="_blank" rel="noopener">webpack-merge</a></strong></p></blockquote><ul><li>我们的 webpack 配置基础部分，即 <code>webpack.base.js</code> 应该大致是这样的</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'...'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    <span class="comment">// 这里是一个简单的例子，后面介绍 API 时会用到</span></span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: [<span class="string">'babel'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>然后 <code>webpack.development.js</code> 需要添加 <code>loader</code> 或 <code>plugin</code>，就可以使用 <code>webpack-merge</code> 的 <code>API</code>，例如</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;smart&#125; = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>)</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"><span class="keyword">const</span> base = <span class="built_in">require</span>(<span class="string">'./webpack.base.js'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = smart(base, &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// 用 smart API，当这里的匹配规则相同且 use 值都是数组时，smart 会识别后处理</span></span><br><span class="line">      <span class="comment">// 和上述 base 配置合并后，这里会是 &#123;test: /\.js$/, use: ['babel', 'coffee'] &#125;</span></span><br><span class="line">      <span class="comment">// 如果这里 use 的值用的是字符串或者对象的话，那么会替换掉原本的规则 use 的值</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: [<span class="string">'coffee'</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// plugins 这里的数组会和 base 中的 plugins 数组进行合并</span></span><br><span class="line">    <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">      <span class="string">'process.env.NODE_ENV'</span>: <span class="built_in">JSON</span>.stringify(process.env.NODE_ENV),</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;)；</span><br></pre></td></tr></table></figure><blockquote><p>可见 <code>webpack-merge</code> 提供的 <code>smart</code> 方法，可以帮助我们更加轻松地处理 <code>loader</code> 配置的合并。<code>webpack-merge</code> 还有其他 <code>API</code> 可以用于自定义合并行为</p></blockquote><h4 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h4><blockquote><p><code>webpack.config.js</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">env, argv</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> argv.mode === <span class="string">'production'</span></span><br><span class="line">    ? <span class="built_in">require</span>(<span class="string">'./configs/webpack.production'</span>)</span><br><span class="line">    : <span class="built_in">require</span>(<span class="string">'./configs/webpack.development'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><code>configs/webpack.base.js</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line"></span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'../dist'</span>),</span><br><span class="line">    filename: <span class="string">'[name].js'</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.jsx?/</span>,</span><br><span class="line">        include: [path.resolve(__dirname, <span class="string">'../src'</span>)],</span><br><span class="line">        use: <span class="string">'babel-loader'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpg|gif)$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'file-loader'</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'index.html'</span>, <span class="comment">// 配置输出文件名和路径</span></span><br><span class="line">      template: <span class="string">'src/index.html'</span> <span class="comment">// 配置文件模板</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><code>configs/webpack.development.js</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);</span><br><span class="line"><span class="keyword">const</span> baseConfig = <span class="built_in">require</span>(<span class="string">'./webpack.base'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = merge.smart(baseConfig, &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        enforce: <span class="string">'pre'</span>,</span><br><span class="line">        test: <span class="regexp">/\.jsx?$/</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        loader: <span class="string">'eslint-loader'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'less-loader'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  devServer: &#123;</span><br><span class="line">    port: <span class="string">'1234'</span>,</span><br><span class="line">    before(app) &#123;</span><br><span class="line">      app.get(<span class="string">'/api/test.json'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">        res.json(&#123; <span class="attr">code</span>: <span class="number">200</span>, <span class="attr">message</span>: <span class="string">'hello world'</span> &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">config.plugins.push(</span><br><span class="line">  <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">    __DEV__: <span class="built_in">JSON</span>.stringify(<span class="literal">true</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = config;</span><br></pre></td></tr></table></figure><blockquote><p><code>configs/webpack.production.js</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);</span><br><span class="line"><span class="keyword">const</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> baseConfig = <span class="built_in">require</span>(<span class="string">'./webpack.base'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = merge.smart(baseConfig, &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">          fallback: <span class="string">'style-loader'</span>,</span><br><span class="line">          use: [</span><br><span class="line">            &#123;</span><br><span class="line">              loader: <span class="string">'css-loader'</span>,</span><br><span class="line">              options: &#123;</span><br><span class="line">                minimize: <span class="literal">true</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">'less-loader'</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">config.plugins.push(<span class="keyword">new</span> ExtractTextPlugin(<span class="string">'[name].css'</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = config;</span><br></pre></td></tr></table></figure><h3 id="模块热替换提高开发效率"><a href="#模块热替换提高开发效率" class="headerlink" title="模块热替换提高开发效率"></a>模块热替换提高开发效率</h3><blockquote><p><code>HMR</code> 全称是 <code>Hot Module Replacement</code>，即模块热替换。在这个概念出来之前，我们使用过 <code>Hot Reloading</code>，当代码变更时通知浏览器刷新页面，以避免频繁手动刷新浏览器页面。HMR 可以理解为增强版的 <code>Hot Reloading</code>，但不用整个页面刷新，而是局部替换掉部分模块代码并且使其生效，可以看到代码变更后的效果。所以，<code>HMR</code> 既避免了频繁手动刷新页面，也减少了页面刷新时的等待，可以极大地提高前端页面开发效率…</p></blockquote><h4 id="配置使用-HMR"><a href="#配置使用-HMR" class="headerlink" title="配置使用 HMR"></a>配置使用 HMR</h4><blockquote><p><code>HMR</code> 是 <code>webpack</code> 提供的非常有用的一个功能，跟我们之前提到的一样，安装好 <code>webpack-dev-server</code>， 添加一些简单的配置，即在 <code>webpack</code> 的配置文件中添加启用 <code>HMR</code> 需要的两个插件</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  devServer: &#123;</span><br><span class="line">    hot: <span class="literal">true</span> <span class="comment">// dev server 的配置要启动 hot，或者在命令行中带参数开启</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">new</span> webpack.NamedModulesPlugin(), <span class="comment">// 用于启动 HMR 时可以显示模块的相对路径</span></span><br><span class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin() <span class="comment">// Hot Module Replacement 的插件</span></span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="module-hot-常见的-API"><a href="#module-hot-常见的-API" class="headerlink" title="module.hot 常见的 API"></a>module.hot 常见的 API</h4><blockquote><p>前面 <code>HMR</code> 实现部分已经讲解了实现 HMR 接口的重要性，下面来看看常见的 <code>module.hot</code> <code>API</code> 有哪些，以及如何使用</p></blockquote><ul><li><code>module.hot.accept</code> 方法指定在应用特定代码模块更新时执行相应的 <code>callback</code>，第一个参数可以是字符串或者数组，如</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span>.hot) &#123;</span><br><span class="line">  <span class="built_in">module</span>.hot.accept([<span class="string">'./bar.js'</span>, <span class="string">'./index.css'</span>], () =&gt; &#123;</span><br><span class="line">    <span class="comment">// ... 这样当 bar.js 或者 index.css 更新时都会执行该函数</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>module.hot.decline</code> 对于指定的代码模块，拒绝进行模块代码的更新，进入更新失败状态，如 <code>module.hot.decline(&#39;./bar.js&#39;)</code>。这个方法比较少用到</li><li><code>module.hot.dispose</code> 用于添加一个处理函数，在当前模块代码被替换时运行该函数，例如</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span>.hot) &#123;</span><br><span class="line">  <span class="built_in">module</span>.hot.dispose(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// data 用于传递数据，如果有需要传递的数据可以挂在 data 对象上，然后在模块代码更新后可以通过 module.hot.data 来获取</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>module.hot.accept</code> 通常用于指定当前依赖的某个模块更新时需要做的处理，如果是当前模块更新时需要处理的动作，使用 <code>module.hot.dispose</code> 会更加容易方便</li><li><code>module.hot.removeDisposeHandler</code> 用于移除 <code>dispose</code> 方法添加的 <code>callback</code></li></ul><h3 id="图片加载优化"><a href="#图片加载优化" class="headerlink" title="图片加载优化"></a>图片加载优化</h3><h4 id="CSS-Sprites"><a href="#CSS-Sprites" class="headerlink" title="CSS Sprites"></a>CSS Sprites</h4><ul><li>如果你使用的 <code>webpack 3.x</code> 版本，需要 <code>CSS Sprites</code> 的话，可以使用 <code>webpack-spritesmith</code> 或者 <code>sprite-webpack-plugin</code>。</li><li>我们以 <code>webpack-spritesmith</code> 为例，先安装依赖…</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  loaders: [</span><br><span class="line">    <span class="comment">// ... 这里需要有处理图片的 loader，如 file-loader</span></span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br><span class="line">resolve: &#123;</span><br><span class="line">  modules: [</span><br><span class="line">    <span class="string">'node_modules'</span>,</span><br><span class="line">    <span class="string">'spritesmith-generated'</span>, <span class="comment">// webpack-spritesmith 生成所需文件的目录</span></span><br><span class="line">  ],</span><br><span class="line">&#125;,</span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> SpritesmithPlugin(&#123;</span><br><span class="line">    src: &#123;</span><br><span class="line">      cwd: path.resolve(__dirname, <span class="string">'src/ico'</span>), <span class="comment">// 多个图片所在的目录</span></span><br><span class="line">      glob: <span class="string">'*.png'</span> <span class="comment">// 匹配图片的路径</span></span><br><span class="line">    &#125;,</span><br><span class="line">    target: &#123;</span><br><span class="line">      <span class="comment">// 生成最终图片的路径</span></span><br><span class="line">      image: path.resolve(__dirname, <span class="string">'src/spritesmith-generated/sprite.png'</span>),</span><br><span class="line">      <span class="comment">// 生成所需 SASS/LESS/Stylus mixins 代码，我们使用 Stylus 预处理器做例子</span></span><br><span class="line">      css: path.resolve(__dirname, <span class="string">'src/spritesmith-generated/sprite.styl'</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">    apiOptions: &#123;</span><br><span class="line">      cssImageRef: <span class="string">"~sprite.png"</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;),</span><br><span class="line">],</span><br></pre></td></tr></table></figure><blockquote><p>在你需要的样式代码中引入 <code>sprite.styl</code> 后调用需要的 <code>mixins</code> 即可</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@import &apos;~sprite.styl&apos;</span><br><span class="line"></span><br><span class="line">.close-button</span><br><span class="line">    sprite($close)</span><br><span class="line">.open-button</span><br><span class="line">    sprite($open)</span><br></pre></td></tr></table></figure><blockquote><p>如果你使用的是 <code>webpack 4.x</code>，你需要配合使用 <code>postcss</code> 和 <code>postcss-sprites</code>，才能实现 <code>CSS Sprites</code> 的相关构建</p></blockquote><h4 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩"></a>图片压缩</h4><ul><li>在一般的项目中，图片资源会占前端资源的很大一部分，既然代码都进行压缩了，占大头的图片就更不用说了</li><li>我们之前提及使用 <code>file-loader</code> 来处理图片文件，在此基础上，我们再添加一个 <code>image-webpack-loader</code> 来压缩图片文件。简单的配置如下…</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/.*\.(gif|png|jpe?g|svg|webp)$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'file-loader'</span>,</span><br><span class="line">            options: &#123;&#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'image-webpack-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              mozjpeg: &#123; <span class="comment">// 压缩 jpeg 的配置</span></span><br><span class="line">                progressive: <span class="literal">true</span>,</span><br><span class="line">                quality: <span class="number">65</span></span><br><span class="line">              &#125;,</span><br><span class="line">              optipng: &#123; <span class="comment">// 使用 imagemin-optipng 压缩 png，enable: false 为关闭</span></span><br><span class="line">                enabled: <span class="literal">false</span>,</span><br><span class="line">              &#125;,</span><br><span class="line">              pngquant: &#123; <span class="comment">// 使用 imagemin-pngquant 压缩 png</span></span><br><span class="line">                quality: <span class="string">'65-90'</span>,</span><br><span class="line">                speed: <span class="number">4</span></span><br><span class="line">              &#125;,</span><br><span class="line">              gifsicle: &#123; <span class="comment">// 压缩 gif 的配置</span></span><br><span class="line">                interlaced: <span class="literal">false</span>,</span><br><span class="line">              &#125;,</span><br><span class="line">              webp: &#123; <span class="comment">// 开启 webp，会把 jpg 和 png 图片压缩为 webp 格式</span></span><br><span class="line">                quality: <span class="number">75</span></span><br><span class="line">              &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="使用-DataURL"><a href="#使用-DataURL" class="headerlink" title="使用 DataURL"></a>使用 DataURL</h4><blockquote><p>有的时候我们的项目中会有一些很小的图片，因为某些缘故并不想使用 <code>CSS Sprites</code> 的方式来处理（譬如小图片不多，因此引入 CSS Sprites 感觉麻烦），那么我们可以在 webpack 中使用 <code>url-loader</code> 来处理这些很小的图片…</p></blockquote><ul><li><code>url-loader</code> 和 <code>file-loader</code> 的功能类似，但是在处理文件的时候，可以通过配置指定一个大小，当文件小于这个配置值时，<code>url-loader</code> 会将其转换为一个 <code>base64</code> 编码的 <code>DataURL</code>，配置如下</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpg|gif)$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'url-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              limit: <span class="number">8192</span> <span class="comment">// 单位是 Byte，当文件小于 8KB 时作为 DataURL 处理</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="代码压缩"><a href="#代码压缩" class="headerlink" title="代码压缩"></a>代码压缩</h4><ul><li><code>webpack 4.x</code> 版本运行时，<code>mode</code> 为 <code>production</code> 即会启动压缩 <code>JS</code> 代码的插件，而对于 <code>webpack</code> <code>3.x</code>，使用压缩 <code>JS</code> 代码插件的方式也已经介绍过了。在生产环境中，压缩 <code>JS</code> 代码基本是一个必不可少的步骤，这样可以大大减小 <code>JavaScript</code> 的体积，相关内容这里不再赘述。</li><li>除了 JS 代码之外，我们一般还需要 HTML 和 CSS 文件，这两种文件也都是可以压缩的，虽然不像 JS 的压缩那么彻底（替换掉长变量等），只能移除空格换行等无用字符，但也能在一定程度上减小文件大小。在 webpack 中的配置使用也不是特别麻烦，所以我们通常也会使用。</li><li>对于 HTML 文件，之前介绍的 <code>html-webpack-plugin</code> 插件可以帮助我们生成需要的 HTML 并对其进行压缩…</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'index.html'</span>, <span class="comment">// 配置输出文件名和路径</span></span><br><span class="line">      template: <span class="string">'assets/index.html'</span>, <span class="comment">// 配置文件模板</span></span><br><span class="line">      minify: &#123;</span><br><span class="line">        <span class="comment">// 压缩 HTML 的配置</span></span><br><span class="line">        minifyCSS: <span class="literal">true</span>, <span class="comment">// 压缩 HTML 中出现的 CSS 代码</span></span><br><span class="line">        minifyJS: <span class="literal">true</span> <span class="comment">// 压缩 HTML 中出现的 JS 代码</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>如上，使用 <code>minify</code> 字段配置就可以使用 <code>HTML</code> 压缩，这个插件是使用 <code>html-minifier</code> 来实现 <code>HTML</code> 代码压缩的，<code>minify</code> 下的配置项直接透传给 <code>html-minifier</code>，配置项参考 <code>html-minifier</code> 文档即可。</li><li>对于 CSS 文件，我们之前介绍过用来处理 CSS 文件的 <code>css-loader</code>，也提供了压缩 CSS 代码的功能：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css/</span>,</span><br><span class="line">        include: [path.resolve(__dirname, <span class="string">'src'</span>)],</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">'style-loader'</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'css-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              minimize: <span class="literal">true</span> <span class="comment">// 使用 css 的压缩功能</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>在 <code>css-loader</code> 的选项中配置 <code>minimize</code> 字段为 <code>true</code> 来使用 <code>CSS</code> 压缩代码的功能。<code>css-loader</code> 是使用 <code>cssnano</code> 来压缩代码的，<code>minimize</code> 字段也可以配置为一个对象，来将相关配置传递给 <code>cssnano</code></p></blockquote><h3 id="分离代码文件"><a href="#分离代码文件" class="headerlink" title="分离代码文件"></a>分离代码文件</h3><ul><li>关于分离 CSS 文件这个主题，之前在介绍如何搭建基本的前端开发环境时有提及，在 <code>webpack</code> 中使用 <code>extract-text-webpack-plugin</code> 插件即可。</li><li>先简单解释一下为何要把 CSS 文件分离出来，而不是直接一起打包在 JS 中。最主要的原因是我们希望更好地利用缓存。</li><li>假设我们原本页面的静态资源都打包成一个 JS 文件，加载页面时虽然只需要加载一个 JS 文件，但是我们的代码一旦改变了，用户访问新的页面时就需要重新加载一个新的 JS 文件。有些情况下，我们只是单独修改了样式，这样也要重新加载整个应用的 JS 文件，相当不划算。</li><li>还有一种情况是我们有多个页面，它们都可以共用一部分样式（这是很常见的，CSS Reset、基础组件样式等基本都是跨页面通用），如果每个页面都单独打包一个 JS 文件，那么每次访问页面都会重复加载原本可以共享的那些 CSS 代码。如果分离开来，第二个页面就有了 CSS 文件的缓存，访问速度自然会加快。虽然对第一个页面来说多了一个请求，但是对随后的页面来说，缓存带来的速度提升相对更加可观</li></ul><blockquote><p><code>3.x</code> 以前的版本是使用 <code>CommonsChunkPlugin</code> 来做代码分离的，而 <code>webpack 4.x</code> 则是把相关的功能包到了 <code>optimize.splitChunks</code> 中，直接使用该配置就可以实现代码分离。</p></blockquote><h4 id="webpack-4-x-的-optimization"><a href="#webpack-4-x-的-optimization" class="headerlink" title="webpack 4.x 的 optimization"></a>webpack 4.x 的 optimization</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ... webpack 配置</span></span><br><span class="line"></span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      chunks: <span class="string">'all'</span> <span class="comment">// 所有的 chunks 代码公共的部分分离出来成为一个单独的文件</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>我们需要在 HTML 中引用两个构建出来的 JS 文件，并且 <code>commons.js</code> 需要在入口代码之前。下面是个简单的例子</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"commons.js"</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"entry.bundle.js"</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>如果你使用了 <code>html-webpack-plugin</code>，那么对应需要的 JS 文件都会在 HTML 文件中正确引用，不用担心。如果没有使用，那么你需要从 <code>stats</code> 的 <code>entrypoints</code> 属性来获取入口应该引用哪些 JS 文件，可以参考 Node API 了解如何从 stats 中获取信息</p></blockquote><p><strong>显式配置共享类库可以这么操作</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    vendor: [<span class="string">"react"</span>, <span class="string">"lodash"</span>, <span class="string">"angular"</span>, ...], <span class="comment">// 指定公共使用的第三方类库</span></span><br><span class="line">  &#125;,</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        vendor: &#123;</span><br><span class="line">          chunks: <span class="string">"initial"</span>,</span><br><span class="line">          test: <span class="string">"vendor"</span>,</span><br><span class="line">          name: <span class="string">"vendor"</span>, <span class="comment">// 使用 vendor 入口作为公共部分</span></span><br><span class="line">          enforce: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ... 其他配置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        vendor: &#123;</span><br><span class="line">          test: <span class="regexp">/react|angluar|lodash/</span>, <span class="comment">// 直接使用 test 来做路径匹配</span></span><br><span class="line">          chunks: <span class="string">"initial"</span>,</span><br><span class="line">          name: <span class="string">"vendor"</span>,</span><br><span class="line">          enforce: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        vendor: &#123;</span><br><span class="line">          chunks: <span class="string">"initial"</span>,</span><br><span class="line">          test: path.resolve(__dirname, <span class="string">"node_modules"</span>) <span class="comment">// 路径在 node_modules 目录下的都作为公共部分</span></span><br><span class="line">          name: <span class="string">"vendor"</span>, <span class="comment">// 使用 vendor 入口作为公共部分</span></span><br><span class="line">          enforce: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上述第一种做法是显示指定哪些类库作为公共部分，第二种做法实现的功能差不多，只是利用了 test 来做模块路径的匹配，第三种做法是把所有在 node_modules 下的模块，即作为依赖安装的，都作为公共部分。你可以针对项目情况，选择最合适的做法</p></blockquote><h4 id="webpack-3-x-的-CommonsChunkPlugin"><a href="#webpack-3-x-的-CommonsChunkPlugin" class="headerlink" title="webpack 3.x 的 CommonsChunkPlugin"></a>webpack 3.x 的 CommonsChunkPlugin</h4><blockquote><p><code>webpack 3.x</code> 以下的版本需要用到 webpack 自身提供的 <code>CommonsChunkPlugin</code> 插件。我们先来看一个最简单的例子</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">      name: <span class="string">'commons'</span>, <span class="comment">// 公共使用的 chunk 的名称</span></span><br><span class="line">      filename: <span class="string">'commons.js'</span>, <span class="comment">// 公共 chunk 的生成文件名</span></span><br><span class="line">      minChunks: <span class="number">3</span> <span class="comment">// 公共的部分必须被 3 个 chunk 共享</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>chunk</code> 在这里是构建的主干，可以简单理解为一个入口对应一个 <code>chunk</code>。</li><li>以上插件配置在构建后会生成一个 <code>commons.js</code> 文件，该文件就是代码中的公共部分。上面的配置中 <code>minChunks</code> 字段为 3，该字段的意思是当一个模块被 3 个以上的 <code>chunk</code> 依赖时，这个模块就会被划分到 <code>commons chunk</code> 中去。单从这个配置的角度上讲，这种方式并没有 <code>4.x</code> 的 <code>chunks: &quot;all&quot;</code> 那么方便。</li></ul><p><strong>CommonsChunkPlugin 也是支持显式配置共享类库的</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    vendor: [<span class="string">'react'</span>, <span class="string">'react-redux'</span>], <span class="comment">// 指定公共使用的第三方类库</span></span><br><span class="line">    app: <span class="string">'./src/entry'</span>,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">      name: <span class="string">'vendor'</span> <span class="comment">// 使用 vendor 入口作为公共部分</span></span><br><span class="line">      filename: <span class="string">"vendor.js"</span>,</span><br><span class="line">      minChunks: <span class="literal">Infinity</span>, <span class="comment">// 这个配置会让 webpack 不再自动抽离公共模块</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上述配置会生成一个名为 <code>vendor.js</code> 的共享代码文件，里面包含了 <code>React</code> 和 <code>React-Redux</code> 库的代码，可以提供给多个不同的入口代码使用。这里的 <code>minChunks</code> 字段的配置，我们使用了 <code>Infinity</code>，可以理解为 <code>webpack</code> 不自动抽离公共模块。如果这里和之前一样依旧设置为 3，那么被 3 个以上的 <code>chunk</code> 依赖的模块会和 <code>React</code>、<code>React-Redux</code> 一同打包进 <code>vendor</code>，这样就失去显式指定的意义了。</p></blockquote><blockquote><p><code>minChunks</code> 其实还可以是一个函数，如：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">minChunks: <span class="function">(<span class="params"><span class="built_in">module</span>, count</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">module</span>, count);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><blockquote><p>该函数在分析每一个依赖的时候会被调用，传入当前依赖模块的信息 <code>module</code>，以及已经被作为公共模块的数量 <code>count</code>，你可以在函数中针对每一个模块做更加精细化的控制。看一个简单的例子：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">minChunks: <span class="function">(<span class="params"><span class="built_in">module</span>, count</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.context &amp;&amp; <span class="built_in">module</span>.context.includes(<span class="string">"node_modules"</span>);</span><br><span class="line">  <span class="comment">// node_modules 目录下的模块都作为公共部分，效果就如同 webpack 4.x 中的 test: path.resolve(__dirname, "node_modules")</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><ul><li>更多使用 <code>CommonsChunkPlugin</code> 的配置参考官方文档 <code>commons-chunk-plugin</code>。</li></ul><h3 id="进一步控制-JS-大小"><a href="#进一步控制-JS-大小" class="headerlink" title="进一步控制 JS 大小"></a>进一步控制 JS 大小</h3><h4 id="按需加载模块"><a href="#按需加载模块" class="headerlink" title="按需加载模块"></a>按需加载模块</h4><blockquote><p>在 webpack 的构建环境中，要按需加载代码模块很简单，遵循 ES 标准的动态加载语法 <code>dynamic-import</code> 来编写代码即可，<code>webpack</code> 会自动处理使用该语法编写的模块</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import 作为一个方法使用，传入模块名即可，返回一个 promise 来获取模块暴露的对象</span></span><br><span class="line"><span class="comment">// 注释 webpackChunkName: "lodash" 可以用于指定 chunk 的名称，在输出文件时有用</span></span><br><span class="line"><span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "lodash" */</span> <span class="string">'lodash'</span>).then(<span class="function">(<span class="params">_</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(_.lash([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])) <span class="comment">// 打印 3</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>注意一下，如果你使用了 <code>Babel</code> 的话，还需要 <code>Syntax Dynamic Import</code> 这个 <code>Babel</code> 插件来处理 <code>import()</code> 这种语法。</li><li>由于动态加载代码模块的语法依赖于 <code>promise</code>，对于低版本的浏览器，需要添加 <code>promise</code> 的 <code>polyfill</code> 后才能使用。</li><li>如上的代码，webpack 构建时会自动把 <code>lodash</code> 模块分离出来，并且在代码内部实现动态加载 <code>lodash</code> 的功能。动态加载代码时依赖于网络，其模块内容会异步返回，所以 import 方法是返回一个 <code>promise</code> 来获取动态加载的模块内容。</li><li><code>import</code> 后面的注释 <code>webpackChunkName: &quot;lodash&quot;</code> 用于告知 <code>webpack</code> 所要动态加载模块的名称。我们在 webpack 配置中添加一个 <code>output.chunkFilename</code> 的配置…</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">  path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">  filename: <span class="string">'[name].[hash:8].js'</span>,</span><br><span class="line">  chunkFilename: <span class="string">'[name].[hash:8].js'</span> <span class="comment">// 指定分离出来的代码文件的名称</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><blockquote><p>这样就可以把分离出来的文件名称用 lodash 标识了，如下图：</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1480597-ae36b6816feed422.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><blockquote><p>如果没有添加注释 <code>webpackChunkName: &quot;lodash&quot; 以及 output.chunkFilename</code> 配置，那么分离出来的文件名称会以简单数字的方式标识，不便于识别</p></blockquote><h4 id="以上完整示例代码"><a href="#以上完整示例代码" class="headerlink" title="以上完整示例代码"></a>以上完整示例代码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line"></span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'[name].js'</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.jsx?/</span>,</span><br><span class="line">        include: [path.resolve(__dirname, <span class="string">'src'</span>)],</span><br><span class="line">        use: <span class="string">'babel-loader'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">          fallback: <span class="string">'style-loader'</span>,</span><br><span class="line">          use: [<span class="string">'css-loader'</span>, <span class="string">'postcss-loader'</span>, <span class="string">'less-loader'</span>]</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpg|gif)$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'url-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              limit: <span class="number">8192</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'image-webpack-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              mozjpeg: &#123;</span><br><span class="line">                <span class="comment">// 压缩 jpeg 的配置</span></span><br><span class="line">                progressive: <span class="literal">true</span>,</span><br><span class="line">                quality: <span class="number">65</span></span><br><span class="line">              &#125;,</span><br><span class="line">              optipng: &#123;</span><br><span class="line">                <span class="comment">// 使用 imagemin-optipng 压缩 png，enable: false 为关闭</span></span><br><span class="line">                enabled: <span class="literal">false</span></span><br><span class="line">              &#125;,</span><br><span class="line">              pngquant: &#123;</span><br><span class="line">                <span class="comment">// 使用 imagemin-pngquant 压缩 png</span></span><br><span class="line">                quality: <span class="string">'65-90'</span>,</span><br><span class="line">                speed: <span class="number">4</span></span><br><span class="line">              &#125;,</span><br><span class="line">              gifsicle: &#123;</span><br><span class="line">                <span class="comment">// 压缩 gif 的配置</span></span><br><span class="line">                interlaced: <span class="literal">false</span></span><br><span class="line">              &#125;,</span><br><span class="line">              webp: &#123;</span><br><span class="line">                <span class="comment">// 开启 webp，会把 jpg 和 png 图片压缩为 webp 格式</span></span><br><span class="line">                quality: <span class="number">75</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        vendor: &#123;</span><br><span class="line">          chunks: <span class="string">'initial'</span>,</span><br><span class="line">          test: path.resolve(__dirname, <span class="string">'node_modules'</span>), <span class="comment">// 路径在 node_modules 目录下的都作为公共部分</span></span><br><span class="line">          name: <span class="string">'vendor'</span>, <span class="comment">// 使用 vendor 入口作为公共部分</span></span><br><span class="line">          enforce: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'index.html'</span>, <span class="comment">// 配置输出文件名和路径</span></span><br><span class="line">      template: <span class="string">'src/index.html'</span>, <span class="comment">// 配置文件模板</span></span><br><span class="line">      minify: &#123;</span><br><span class="line">        <span class="comment">// 压缩 HTML 的配置</span></span><br><span class="line">        minifyCSS: <span class="literal">true</span>, <span class="comment">// 压缩 HTML 中出现的 CSS 代码</span></span><br><span class="line">        minifyJS: <span class="literal">true</span>, <span class="comment">// 压缩 HTML 中出现的 JS 代码</span></span><br><span class="line">        removeComments: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> ExtractTextPlugin(<span class="string">'[name].css'</span>),</span><br><span class="line">    <span class="keyword">new</span> webpack.NamedModulesPlugin(),</span><br><span class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  devServer: &#123;</span><br><span class="line">    hot: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文总结了 Webpack 4 的一些配置点，希望通过学习这些配置点，降低使用门槛。纵观前端的打包历史，似乎是欠了太多债，有很多历史包袱，所以工程化这一块一直是一大痛点。配置繁琐，容易出错，本文总结了最新的 Webpack 4 功能点，一起来学习一下，可以点击右侧的文章目录直达。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Async/await 查漏补缺</title>
    <link href="http://ifyour.github.io/2018/07/22/Async-await-%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"/>
    <id>http://ifyour.github.io/2018/07/22/Async-await-查漏补缺/</id>
    <published>2018-07-22T06:44:15.000Z</published>
    <updated>2019-12-07T06:07:38.529Z</updated>
    
    <content type="html"><![CDATA[<p>上周末我复习了 Promise 的用法，通过一些实例加深了 Promise 的理解。今天来看下异步编程的终极解决方案 async/await。JavaScript 中的异步操作从最初的 callback 演进到 Promise，再到 Generator，都是逐步的改进，而 async 函数的出现仿佛看到了异步方案的终点，用同步的方式写异步代码。</p><a id="more"></a><h3 id="async-函数"><a href="#async-函数" class="headerlink" title="async 函数"></a>async 函数</h3><p>简单解释：async 函数就是 Generator 函数的语法糖。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Generator 函数写法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(val);</span><br><span class="line">      resolve(val);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> gen = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> p1 = <span class="keyword">yield</span> promise(<span class="string">'1'</span>);</span><br><span class="line">  <span class="keyword">let</span> p2 = <span class="keyword">yield</span> promise(<span class="string">'2'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> genF = gen(); <span class="comment">// Iterator 对象</span></span><br><span class="line">genF.next(); <span class="comment">// =&gt; 1</span></span><br><span class="line">genF.next(); <span class="comment">// =&gt; 2</span></span><br></pre></td></tr></table></figure><p>更多 <code>yield</code> 表达式可以看这篇文章：<a href="https://juejin.im/post/5a6db41351882573351a8d72" target="_blank" rel="noopener">Generator 函数语法解析</a>。</p><p>使用 async 来改写上面的 <code>gen</code> 函数 👇：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> gen = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> p1 = <span class="keyword">await</span> promise(<span class="string">'1'</span>);</span><br><span class="line">  <span class="keyword">let</span> p2 = <span class="keyword">await</span> promise(<span class="string">'2'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">gen();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果 👇：</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>async 函数是在 Generator 函数上进行的改进，语法上 Generator 函数的星号换成了 <code>async</code>，<code>yield</code> 换成了 <code>await</code>。</p><p>而 async 也与 Generator 函数 <strong>不同</strong>：</p><ul><li><code>async</code> 自带内置执行器，Generator 函数需要依靠执行器，并且 <code>async</code> 可以和普通函数一样，只需要一行</li><li>相对 Generator 函数，<code>async</code> 和 <code>await</code> 语义更清楚</li><li>适用性强，<code>yield</code> 后只能是 Thunk 函数和 Promise 对象，而 <code>await</code> 后可以是 Promise 对象和原始类型的值 (数值、字符串、布尔型等)</li></ul><h3 id="async-作用"><a href="#async-作用" class="headerlink" title="async 作用"></a>async 作用</h3><p>寄予 async 函数的期望是希望可以帮助我们解决异步操作问题，所以需要搞清楚 async 函数的返回值是什么。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncAwait</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'async await'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = asyncAwait();</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果 👇：</span></span><br><span class="line"><span class="built_in">Promise</span> &#123;&lt;resolved&gt;: <span class="string">"async await"</span>&#125;</span><br></pre></td></tr></table></figure><p>可以看出 async 函数返回的是一个 Promise 对象，如果函数中 return 一个直接量，async 函数会封装成 Promise 对象返回，而如果没有返回值时，async 函数会返回 <code>undefined</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有返回值时的输出结果 👇：</span></span><br><span class="line"><span class="built_in">Promise</span> &#123;&lt;resolved&gt;: <span class="literal">undefined</span>&#125;</span><br></pre></td></tr></table></figure><p>在没有结合 await 时，async 函数会立即执行，返回一个 Promise 对象。</p><h3 id="await-等待"><a href="#await-等待" class="headerlink" title="await 等待"></a>await 等待</h3><p>await 是个运算符，等待的结果是 Promise 对象或其它值，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'async'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">func2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">'await'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncAwait</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> f1 = <span class="keyword">await</span> func1();</span><br><span class="line">  <span class="keyword">let</span> f2 = <span class="keyword">await</span> func2();</span><br><span class="line">  <span class="built_in">console</span>.log(f1, f2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncAwait();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果 👇：</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">await</span></span><br></pre></td></tr></table></figure><p>await 表达式的运算取决于等待的结果，如果它等到的不是一个 Promise 对象，那运算结果就是它等到的东西, 而如果它等到的是一个 Promise 对象，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为表达式的运算结果。</p><div class="tip"><strong>async 函数调用</strong> 会封装在 Promise 中，这也是 await 需要在 async 函数中使用的原因。</div><h3 id="async-await-链式处理"><a href="#async-await-链式处理" class="headerlink" title="async/await 链式处理"></a>async/await 链式处理</h3><p>对于多个异步操作中，Promise 的 then 可以解决多层回调问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Promise 解决多层嵌套问题</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">t</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(t + <span class="number">200</span>), t);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step1</span>(<span class="params">t</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`step1 in <span class="subst">$&#123;t&#125;</span>ms`</span>);</span><br><span class="line">  <span class="keyword">return</span> ajax(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step2</span>(<span class="params">t</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`step2 in <span class="subst">$&#123;t&#125;</span>ms`</span>);</span><br><span class="line">  <span class="keyword">return</span> ajax(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step3</span>(<span class="params">t</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`step3 in <span class="subst">$&#123;t&#125;</span>ms`</span>);</span><br><span class="line">  <span class="keyword">return</span> ajax(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">submit</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.time(<span class="string">'submit'</span>);</span><br><span class="line">  step1(<span class="number">200</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">time2</span> =&gt;</span> step2(time2))</span><br><span class="line">    .then(<span class="function"><span class="params">time3</span> =&gt;</span> step3(time3))</span><br><span class="line">    .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`result is <span class="subst">$&#123;result&#125;</span>ms`</span>);</span><br><span class="line">      <span class="built_in">console</span>.timeEnd(<span class="string">'submit'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">submit();</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// async 函数实现，解决多层嵌套</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">t</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(t + <span class="number">200</span>), t);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step1</span>(<span class="params">t</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`step1 in <span class="subst">$&#123;t&#125;</span>ms`</span>);</span><br><span class="line">  <span class="keyword">return</span> ajax(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step2</span>(<span class="params">t</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`step2 in <span class="subst">$&#123;t&#125;</span>ms`</span>);</span><br><span class="line">  <span class="keyword">return</span> ajax(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step3</span>(<span class="params">t</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`step3 in <span class="subst">$&#123;t&#125;</span>ms`</span>);</span><br><span class="line">  <span class="keyword">return</span> ajax(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">submit</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.time(<span class="string">'submit'</span>);</span><br><span class="line">  <span class="keyword">const</span> t1 = <span class="number">200</span>;</span><br><span class="line">  <span class="keyword">const</span> t2 = <span class="keyword">await</span> step1(t1);</span><br><span class="line">  <span class="keyword">const</span> t3 = <span class="keyword">await</span> step2(t2);</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> step3(t3);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`result is <span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">  <span class="built_in">console</span>.timeEnd(<span class="string">'submit'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">submit();</span><br></pre></td></tr></table></figure><p>输出结果 👇：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">step1 in 200ms</span><br><span class="line">step2 in 400ms</span><br><span class="line">step3 in 600ms</span><br><span class="line">result is 800</span><br><span class="line">submit: 1209.85107421875ms</span><br></pre></td></tr></table></figure><p>而如果需求变更，每一步的参数都是之前步骤的结果后，async 函数可以写成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">t</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(t + <span class="number">200</span>), t);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step1</span>(<span class="params">t1</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`step1 in <span class="subst">$&#123;t1&#125;</span>ms`</span>);</span><br><span class="line">  <span class="keyword">return</span> ajax(t1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step2</span>(<span class="params">t1, t2</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`step2 in <span class="subst">$&#123;t1&#125;</span>ms,<span class="subst">$&#123;t2&#125;</span>ms`</span>);</span><br><span class="line">  <span class="keyword">return</span> ajax(t1 + t2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step3</span>(<span class="params">t1, t2, t3</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`step3 in <span class="subst">$&#123;t1&#125;</span>ms,<span class="subst">$&#123;t2&#125;</span>ms,<span class="subst">$&#123;t3&#125;</span>ms`</span>);</span><br><span class="line">  <span class="keyword">return</span> ajax(t1 + t2 + t3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">submit</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.time(<span class="string">'submit'</span>);</span><br><span class="line">  <span class="keyword">const</span> t1 = <span class="number">200</span>;</span><br><span class="line">  <span class="keyword">const</span> t2 = <span class="keyword">await</span> step1(t1);</span><br><span class="line">  <span class="keyword">const</span> t3 = <span class="keyword">await</span> step2(t1, t2);</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> step3(t1, t2, t3);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`result is <span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">  <span class="built_in">console</span>.timeEnd(<span class="string">'submit'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">submit();</span><br></pre></td></tr></table></figure><p>输出结果 👇：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">step1 in 200ms</span><br><span class="line">step2 in 200ms,400ms</span><br><span class="line">step3 in 200ms,400ms,800ms</span><br><span class="line">result is 1600</span><br><span class="line">submit: 2210.47998046875ms</span><br></pre></td></tr></table></figure><h3 id="async-await-注意点"><a href="#async-await-注意点" class="headerlink" title="async/await 注意点"></a>async/await 注意点</h3><ol><li><code>async</code> 用来声明里面包裹的内容 <strong>能够以同步的方式执行</strong>，<code>await</code> 则是进行执行顺序控制，每次执行一个 <code>await</code>，阻塞代码执行等待 <code>await</code> 返回值，然后再执行之后的 <code>await</code></li><li><code>await</code> 只能用在 <code>async</code> 函数之中，用在普通函数中会报错</li><li><code>await</code> 命令后面的 Promise 对象，运行结果可能是 <code>rejected</code>，所以最好把 <code>await</code> 命令放在 <code>try...catch</code> 代码块中</li><li><code>await</code> 后面的表达式如果不是 Promise 实例，<code>await</code> 会阻塞后面的代码，然后执行 <code>async</code> 外面的同步代码，等同步代码执行完毕后回到 <code>async</code> 执行这个表达式作为 <code>await</code> 内容，详见这个 <a href="https://jsfiddle.net/zd4cbfrv/" target="_blank" rel="noopener">JSFiddle</a></li><li><code>await</code> 后面的表达式是一个 Promise 对象，<code>await</code> 也会暂停 <code>async</code> 后面的代码，先执行 <code>async</code> 外面的同步代码，等着 Promise 对象 <code>fulfilled</code>，然后把 <code>resolve</code> 的参数作为 await 表达式的运算结果，详见<a href="https://github.com/ifyour/learn-javascript/issues/15" target="_blank" rel="noopener">这道</a>面试题</li></ol><h4 id="async-await-结合-try-catch-写法"><a href="#async-await-结合-try-catch-写法" class="headerlink" title="async/await 结合 try/catch 写法"></a>async/await 结合 try/catch 写法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncAwait</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> promise();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种写法</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncAwait</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> promise().catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Async/await 是 ES7 的重要特性之一，也是目前社区里公认的优秀异步解决方案，当你深入了解原理后会发现仿佛看到了异步回调隧道的尽头亮光。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="http://es6.ruanyifeng.com/#docs/generator" target="_blank" rel="noopener">Generator 函数的语法 @阮一峰《ECMAScript 6 入门》</a></li><li><a href="http://es6.ruanyifeng.com/#docs/async" target="_blank" rel="noopener">async 函数 @阮一峰《ECMAScript 6 入门》</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上周末我复习了 Promise 的用法，通过一些实例加深了 Promise 的理解。今天来看下异步编程的终极解决方案 async/await。JavaScript 中的异步操作从最初的 callback 演进到 Promise，再到 Generator，都是逐步的改进，而 async 函数的出现仿佛看到了异步方案的终点，用同步的方式写异步代码。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Promise 查漏补缺</title>
    <link href="http://ifyour.github.io/2018/07/15/Promise-%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"/>
    <id>http://ifyour.github.io/2018/07/15/Promise-查漏补缺/</id>
    <published>2018-07-15T01:17:58.000Z</published>
    <updated>2019-12-07T06:07:38.529Z</updated>
    
    <content type="html"><![CDATA[<p>Promise 的重要性不用多说, 曾经看到关于 JavaScript 的描述 — JS 的三座大山就是: <code>原型</code>/<code>作用域</code>/<code>异步</code>, 所以如果说你是一个合格的 JavaScript 程序员, 这三块的内容肯定是要吃透的. 纵观 JavaScript 的异步史, 它经历了 <code>callback</code> -&gt; <code>Promise</code> -&gt; <code>Generator</code> -&gt; <code>async-await</code> 这样一个历程, 前前后后编写异步代码的变化. 从变化中就可以体会到, 确实越来越简洁, 越来越易读. 掌握它们, 你能写出更优雅的代码.</p><a id="more"></a><h3 id="Promise-简介"><a href="#Promise-简介" class="headerlink" title="Promise 简介"></a>Promise 简介</h3><p><img src="https://user-images.githubusercontent.com/15377484/42730799-8a283548-8830-11e8-9cc0-adb620f7f71a.png" alt="image"></p><p>ECMAscript6 原生提供了 Promise 对象, 由浏览器直接支持, 目前大多数浏览器都已经实现了, 低版本浏览器可以使用 <em>es6-promise</em> 库来填平兼容性问题. Promise 最大的好处是把执行代码和处理代码分离开, 使异步操作逻辑更加清晰.</p><h3 id="Promise-特点"><a href="#Promise-特点" class="headerlink" title="Promise 特点"></a>Promise 特点</h3><ol><li>对象的状态不受外界影响 Promise 对象代表一个异步操作, 有三种状态:<ul><li>pending - 初始状态</li><li>fulfilled - 操作成功完成</li><li>rejected - 操作失败</li></ul></li><li>一旦状态改变, 就不会再发生变化. Promise 对象的状态改变. 只有两种情况: 从 <code>Pending</code> 变为 <code>Resolved</code> 和从 <code>Pending</code> 变为 <code>Rejected</code>. 只要这两种情况发生, 状态就会固定, 不会再变了, 会一直保持这个结果, 与事件不同的是, 就算改变已经发生了, 再对 Promise 对象添加回调函数, 也会立即得到这个结果, 而事件一旦错过再去监听, 就不会得到结果.</li></ol><p><img src="https://user-images.githubusercontent.com/15377484/42730787-1d531df2-8830-11e8-8514-0a810d945440.png" alt="image"></p><div class="tip"> 只有异步操作的结果可以决定当前是哪一种状态, 其他操作都不会影响状态改变, 这也是 Promise 最本质的特性, 对于调用者的一种承诺 </div><h3 id="Promise-优缺点"><a href="#Promise-优缺点" class="headerlink" title="Promise 优缺点"></a>Promise 优缺点</h3><p>优点:</p><ul><li>可以将异步操作以同步操作的流程表达出来, 避免了层层嵌套的回调函数 Promise</li><li>对象提供统一的接口, 使得控制异步操作更加容易</li></ul><p>缺点:</p><ul><li>无法取消 Promise, 一旦新建它就会立即执行, 无法中途取消</li><li>如果不设置回调函数, Promise 内部抛出的错误, 不会反应到外部</li><li>当处于 <code>Pending</code> 状态时, 无法得知目前进展到哪一个阶段（刚刚开始或者即将完成）</li></ul><h3 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then"></a>Promise.prototype.then</h3><p>Promise.prototype.then 方法返回的是一个新的 Promise 对象, 因此可以采用链式写法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ajax(<span class="string">'http://some.api.com/'</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">json</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> json.post;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">post</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// post 处理</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>👆 代码中使用了两个 then 方法, 分别指定了对应的回调参数. 第一个回调函数完成后, 会将返回结果作为参数, 传入第二个 then 中的回调函数执行.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ajax(<span class="string">'http://some.api.com/'</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">jsonURL</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ajax(jsonURL);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">post</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// post 处理</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>👆 如果第一个回调函数返回的是 Promise 对象, 后一个回调函数会等待该 Promise 对象的运行结果, 等 Promise 运行结果返回, 再进一步调用. 这种设计使得嵌套的异步操作, 可以被很容易得改写, 把回调函数的 “横向发展” 改为了 “向下发展”.</p><h3 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch"></a>Promise.prototype.catch</h3><p>Promise.prototype.catch 错误捕捉方法是 <code>Promise.prototype.then(null, rejection)</code> 的别名, 用来指定发生错误时的处理函数.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ajax(<span class="string">'http://some.api.com/'</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">post</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">Error</span>();</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 捕捉回调函数运行时发生的错误进行处理</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'error:'</span> + error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>Promise 对象的错误具有 “冒泡” 性质, 会一直向后传递, 直到被捕获为止.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ajax(<span class="string">'http://some.api.com/'</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">jsonURL</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ajax(jsonURL);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">comments</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">Error</span>();</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 处理前两个回调函数的错误</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'error:'</span> + error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve"></a>Promise.resolve</h3><p>Promise.resolve 方法可以将现有对象转为 Promise 对象. 如果 Promise.resolve 方法的参数, 不是 thenable 对象 (具有 then 方法的对象), 则返回一个新的 Promise 对象, 且它的状态为 <code>fulfilled</code>.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resolve = <span class="built_in">Promise</span>.resolve(<span class="string">'promise resolve'</span>);</span><br><span class="line"></span><br><span class="line">resolve.then(<span class="function">(<span class="params">s</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// output 👇</span></span><br><span class="line">promise resolve</span><br></pre></td></tr></table></figure><p>如果 Promise 对象的实例状态为 <code>fulfilled</code>, 回调函数会立即执行, Promise.resolve 方法的参数就是回调函数的参数. 如果 Promise.resolve 方法的参数是一个 Promise 对象的实例, 则会返回该 Promise 实例.</p><h3 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject"></a>Promise.reject</h3><p>Promise.reject(reason) 方法与 resolve 方法类似, 也会返回一个新的 Promise 实例, 但该实例的状态为 <code>rejected</code>. Promise.reject 方法的参数, 会被传递给实例的回调函数.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reject = <span class="built_in">Promise</span>.reject(<span class="string">'promise reject'</span>);</span><br><span class="line"></span><br><span class="line">reject.then(<span class="literal">null</span>, (err) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// output 👇</span></span><br><span class="line">promise reject</span><br></pre></td></tr></table></figure><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h3><p>Promise.all 方法用于将多个 Promise 实例, 包装成一个新的 Promise 实例, 该方法一般接受一个数组作为参数, 但不一定是数组, 只要具有 iterator 接口. 且返回的每个成员都是 Promise 实例.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getRandom = <span class="function"><span class="params">()</span> =&gt;</span> +(<span class="built_in">Math</span>.random() * <span class="number">1000</span>).toFixed(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">const</span> ajax = <span class="function">(<span class="params">taskID</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> timeout = getRandom();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`taskID=<span class="subst">$&#123;taskID&#125;</span> start.`</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`taskID=<span class="subst">$&#123;taskID&#125;</span> finished in time=<span class="subst">$&#123;timeout&#125;</span>.`</span>);</span><br><span class="line">    resolve(taskID)</span><br><span class="line">  &#125;, timeout);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([ajax(<span class="number">1</span>), ajax(<span class="number">2</span>), ajax(<span class="number">3</span>)])</span><br><span class="line">  .then(<span class="function"><span class="params">resultList</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'results:'</span>, resultList);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>输出结果 👇:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">taskID=1 start.</span><br><span class="line">taskID=2 start.</span><br><span class="line">taskID=3 start.</span><br><span class="line">taskID=2 finished in time=27.</span><br><span class="line">taskID=3 finished in time=257.</span><br><span class="line">taskID=1 finished in time=876.</span><br><span class="line">results: [1, 2, 3]</span><br></pre></td></tr></table></figure><p>Promise.all 状态分为两种:</p><ul><li>只有 ajax(1)、ajax(2)、ajax(3) 的状态都变成 <code>fulfilled</code>, Promise.all 返回的状态才会变成 <code>fulfilled</code>, 此时 ajax(1)、ajax(2)、ajax(3) 的返回值组成一个数组, 传递给 Promise.all 的回调函数.</li><li>只要 ajax(1)、ajax(2)、ajax(3) 之中有一个是 <code>rejected</code>, Promise.all 返回的状态就变成 <code>rejected</code>, 此时第一个被 reject 的实例的返回值, 会传递给 Promise.all 的回调函数.</li></ul><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h3><p>Promise.race 方法也是将多个 Promise 实例, 包装成一个新的 Promise 实例, 与 Promise.all 不同的是一旦有状态改变, 就会返回第一个状态改变的 Promise 实例返回值.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getRandom = <span class="function"><span class="params">()</span> =&gt;</span> +(<span class="built_in">Math</span>.random() * <span class="number">1000</span>).toFixed(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">const</span> ajax = <span class="function">(<span class="params">taskID</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> timeout = getRandom();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`taskID=<span class="subst">$&#123;taskID&#125;</span> start.`</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`taskID=<span class="subst">$&#123;taskID&#125;</span> finished in time=<span class="subst">$&#123;timeout&#125;</span>.`</span>);</span><br><span class="line">    resolve(taskID)</span><br><span class="line">  &#125;, timeout);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([ajax(<span class="number">1</span>), ajax(<span class="number">2</span>), ajax(<span class="number">3</span>)])</span><br><span class="line">  .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'results:'</span>, result);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>输出结果 👇:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">taskID=1 start.</span><br><span class="line">taskID=2 start.</span><br><span class="line">taskID=3 start.</span><br><span class="line">taskID=2 finished in time=59.</span><br><span class="line">results: 2</span><br><span class="line">taskID=3 finished in time=707.</span><br><span class="line">taskID=1 finished in time=854.</span><br></pre></td></tr></table></figure><p>Promise.race 虽然 <strong>返回第一个状态改变的 Promise 实例</strong>, 但不能阻止其他 Promise 实例状态改变.</p><p>如果 <code>Promise.all</code> 和 <code>Promise.race</code> 的参数不是 Promise 实例, 它们就会调用 Promise.resolve 方法, 将参数转为 Promise 实例, 再进一步处理.</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://github.com/wangfupeng1988/js-async-tutorial" target="_blank" rel="noopener">js-async-tutorial @GitHub</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">Promise constructor @MDN</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Promise 的重要性不用多说, 曾经看到关于 JavaScript 的描述 — JS 的三座大山就是: &lt;code&gt;原型&lt;/code&gt;/&lt;code&gt;作用域&lt;/code&gt;/&lt;code&gt;异步&lt;/code&gt;, 所以如果说你是一个合格的 JavaScript 程序员, 这三块的内容肯定是要吃透的. 纵观 JavaScript 的异步史, 它经历了 &lt;code&gt;callback&lt;/code&gt; -&amp;gt; &lt;code&gt;Promise&lt;/code&gt; -&amp;gt; &lt;code&gt;Generator&lt;/code&gt; -&amp;gt; &lt;code&gt;async-await&lt;/code&gt; 这样一个历程, 前前后后编写异步代码的变化. 从变化中就可以体会到, 确实越来越简洁, 越来越易读. 掌握它们, 你能写出更优雅的代码.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>如何在 Git 中使用撤消操作</title>
    <link href="http://ifyour.github.io/2018/06/26/%E5%A6%82%E4%BD%95%E5%9C%A8-Git-%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%92%A4%E6%B6%88%E6%93%8D%E4%BD%9C/"/>
    <id>http://ifyour.github.io/2018/06/26/如何在-Git-中使用撤消操作/</id>
    <published>2018-06-26T23:19:14.000Z</published>
    <updated>2019-12-07T06:07:38.533Z</updated>
    
    <content type="html"><![CDATA[<p>版本控制系统的一个好处就是你可以轻易地撤销之前错误的操作。当你用 <code>git commit</code> 提交了一个新的更改后 git 会将当时的文件内容暂时保存下来，之后你就可以用 git 随意回滚到任意一个版本。这篇文章会介绍一些常见的可能用到撤销 <code>undo</code> 操作的情况。</p><a id="more"></a><h3 id="撤销一个已发布的更新"><a href="#撤销一个已发布的更新" class="headerlink" title="撤销一个已发布的更新"></a>撤销一个已发布的更新</h3><p><strong>情景</strong>: 你已经用 <code>git push</code> 将代码提交到了 GitHub，然后你意识到这其中的一个 commit 有错误，于是你想撤销那个 commit。</p><p><strong>操作</strong>: <code>git revert &lt;SHA&gt;</code></p><p><strong>效果</strong>: git 会新建一个新的 commit 来执行提供的 <sha> 对应 commit 的相反的更改，任何在该旧 commit 中删除的内容将会在新 commit 中添加进去，反之亦然。</sha></p><p>这是 git 里最安全的撤消操作的办法，因为这不会影响你的提交历史。于是现在你可以提交新的 commit 去撤销之前错误的操作了。</p><h3 id="修改上次-commit-的提交信息"><a href="#修改上次-commit-的提交信息" class="headerlink" title="修改上次 commit 的提交信息"></a>修改上次 commit 的提交信息</h3><p><strong>情景</strong>: 你在上次 commit 提交信息中打错了一个单词，比如你执行了 <code>git commit -m &quot;fxied bug #42&quot;</code> 然后你意识到应该是 <code>fixed bug #42</code>。</p><p><strong>操作</strong>: <code>git commit --amend</code> 或 <code>git commit --amend -m &quot;Fixes bug #42&quot;</code></p><p><strong>效果</strong>: <code>git commit --amend</code> 结合最新的文件修改情况和上一次提交信息更新并替换上一次提交。没有新的文件更改就直接覆盖上次提交。</p><h3 id="撤销本地修改"><a href="#撤销本地修改" class="headerlink" title="撤销本地修改"></a>撤销本地修改</h3><p><strong>情景</strong>: 你家的喵星人跑到你的键盘上装逼用双爪打字然后不知怎么还点了保存，然后编辑器还崩溃了，你还没有 commit 这只猫做的修改，你想撤销那个文件里被猫修改的内容。</p><p><strong>操作</strong>: <code>git checkout -- &lt;bad filename&gt;</code></p><p><strong>效果</strong>: <code>git checkout</code> 会将该文件的内容恢复到上一次 git commit 的状态。你可以提供一个分支名称或者直接提供要回到的 SHA。</p><p>请记住，这种方法作出的撤销是彻底的，这些内容不会被 commit 所以之后你并不能再用 git 恢复这些内容。</p><h3 id="重置本地修改"><a href="#重置本地修改" class="headerlink" title="重置本地修改"></a>重置本地修改</h3><p><strong>情景</strong>: 你在本地 commit 了一些内容（并没有 push），但是你搞错了，你想撤销最近这三个 commit，就像让它们从来不存在那样。</p><p><strong>操作</strong>: <code>git reset &lt;last good SHA&gt;</code> 或 <code>git reset --hard &lt;last good SHA&gt;</code></p><p><strong>效果</strong>: <code>git reset</code> 会让你的 git 历史会退到你指定的 SHA 的状态。这些 commit 不存在了但是你硬盘上的这些文件还是维持在被修改了的状态，这是最安全的做法。但是有时你也想同时撤销硬盘上的修改，这时加上 <code>--hard</code> 就会很有用。</p><h3 id="撤销本地修改之后重做"><a href="#撤销本地修改之后重做" class="headerlink" title="撤销本地修改之后重做"></a>撤销本地修改之后重做</h3><p><strong>情景</strong>: 你提交了一些 commit，然后执行 <code>git reset --hard</code> 来撤消这些 commit 并清除本地硬盘上的修改。但是最后你意识到你想要回这些 commit！</p><p><strong>操作</strong>: <code>git reflog</code> 和 <code>git reset</code> 或 <code>git checkout</code></p><p><strong>效果</strong>: <code>git reflog</code> 是个修复项目提交历史的好方法。你可以找回几乎所有内容 —— 所有你 commit 过的内容 —— 用 reflog 就行。</p><p>你可能对 <code>git log</code> 很熟悉，这个操作会列出你的 git 提交历史。<code>git reflog</code> 很像它，但是列出的是 <code>HEAD</code> 修改的时间。</p><p>一些说明:</p><ul><li><code>HEAD</code> 修改。在切换分支时 <code>HEAD</code> 会被修改，用 commit 保存修改然后用 reset 撤消修改。但是在你 <code>git checkout -- &lt;bad filename&gt;</code> 时并不会被修改，就像上面说过的那样，这些修改不会被 commit，所以 <code>git reflog</code> 也不能帮你找回这些内容。</li><li><code>git reflog</code> 不是永远有用的。git 会定期清理那些无法追溯的内容。不要期望能用 <code>git reflog</code> 找回一个多月以前的内容。</li><li>你的 <code>git reflog</code> 仅对你有用。你不能用 <code>git reflog</code> 来找回其他人 commit 的修改。</li></ul><p><img src="https://cloud.githubusercontent.com/assets/2077/6953866/f6b9f054-d891-11e4-8c53-838eff9f40ae.png" alt="reflog"></p><p>然后…接下来怎么做才能撤销之前的撤销？这取决你到你要干什么:</p><ul><li>如果你想回到一个特定的时间，用 <code>git reset --hard &lt;SHA&gt;</code>。</li><li>如果你想在不修改提交历史的情况下找回那些文件并作为新文件保存，用 <code>git checkout &lt;SHA&gt; -- &lt;filename&gt;</code>。</li><li>如果你想使其中一个 commit 回到你的项目历史中，用 <code>git cherry-pick &lt;SHA&gt;</code>。</li></ul><h3 id="提交到了另一个分支"><a href="#提交到了另一个分支" class="headerlink" title="提交到了另一个分支"></a>提交到了另一个分支</h3><p><strong>情景</strong>: 你提交了一些 commits，然后意识到你当前是在 master 分支上，而你其实是想提交到一个 <code>feature</code> 分支上。</p><p><strong>操作</strong>: <code>git branch feature</code>, <code>git reset --hard origin/master</code>, 和 <code>git checkout feature</code></p><p><strong>效果</strong>: 你可能常常使用 <code>git checkout -b &lt;name&gt;</code> 操作来检出一个新分支，这是一个很方便的创建新分支的操作，但是你并不想同时切换到那个分支上。现在使用 <code>git branch feature</code> 既可以创建一个 <code>feature</code> 新分支并且不会切换到那个分支，同时该分支会指向你当前分支最新的一个 commit。</p><p>下一步，用 <code>git reset --hard</code> 去恢复 <code>master</code> 分支到 <code>origin/master</code> 的状态。</p><p>最后，<code>git checkout</code> 到你的 <code>feature</code> 分支，你能看到所有的更改。</p><h3 id="覆盖整个分支"><a href="#覆盖整个分支" class="headerlink" title="覆盖整个分支"></a>覆盖整个分支</h3><p><strong>情景</strong>: 你基于 <code>master</code> 分支创建了 <code>feature</code> 分支，但是 <code>master</code> 分支远远落后 <code>origin/master</code> 的更改。现在 <code>master</code> 分支和 <code>origin/master</code> 同步了，你想马上同步到 <code>feature</code> 分支，还不是再次远远落后。</p><p><strong>操作</strong>: <code>git checkout feature</code> 和 <code>git rebase master</code></p><p><strong>效果</strong>: 你可能知道用 <code>git reset</code> 然后重新 commit 来达到类似效果，不过那样会丢失 commit 历史。</p><div class="tip">文章翻译: <a href="https://egoist.moe/2015/10/04/how-to-undo-with-git" target="_blank" rel="noopener">@egoist</a>，版权归原作者所有。</div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;版本控制系统的一个好处就是你可以轻易地撤销之前错误的操作。当你用 &lt;code&gt;git commit&lt;/code&gt; 提交了一个新的更改后 git 会将当时的文件内容暂时保存下来，之后你就可以用 git 随意回滚到任意一个版本。这篇文章会介绍一些常见的可能用到撤销 &lt;code&gt;undo&lt;/code&gt; 操作的情况。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>我的主管给我的一些建议</title>
    <link href="http://ifyour.github.io/2018/06/20/%E6%88%91%E7%9A%84%E4%B8%BB%E7%AE%A1%E7%BB%99%E6%88%91%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BB%BA%E8%AE%AE/"/>
    <id>http://ifyour.github.io/2018/06/20/我的主管给我的一些建议/</id>
    <published>2018-06-20T23:43:58.000Z</published>
    <updated>2019-12-07T06:07:38.533Z</updated>
    
    <content type="html"><![CDATA[<p>本文翻译自 <a href="https://www.reddit.com/r/startups/comments/74pms1/my_manager_who_i_loved_recently_left_my_company_i/" target="_blank" rel="noopener">Reddit</a> 上的一篇文章。其主要内容为一名职工记录了他与其已离职的主管的一对一交流。其中总结了大量关于职业生涯，工作内容，人际关系，自我成长的建议。</p><a id="more"></a><h3 id="首要任务"><a href="#首要任务" class="headerlink" title="首要任务"></a>首要任务</h3><p><strong>确定并专注于你的首要任务 – 如果不，那么你整天在干什么？</strong></p><p>优先任务真的是最首要任务的吗？ 当前你需要做得最为重要的事是什么？如果你不能回答这个问题，那么你就应该停下手头的所有工作然后先弄清楚你的答案。有明确的答案能让你更加明确目标与专注。没有明确的答案往往会导致你经常在做一些并不重要的事并且浪费大量宝贵的时间。</p><p>每天总会有源源不断需要做的事儿。人们常会倾向于先做简单、有趣或熟悉的任务。但长远来看这是一个陷阱。完成首要任务 5%-10% 的工作量比做大量对目标无益的任务更好。</p><blockquote><p>往往自己认为应该优先做的工作其实并不是当前目标的首要任务</p></blockquote><p>你负责什么？ 企业中的每个人都应该负责一定的工作。理想情况下，它应该是与你的首要目标相关的度量指标。如果不是，那么你就应该和你的主管或者老板好好谈一谈来确定你的首要任务。当你确立好你的首要任务后，你还会保证你已了解了足够的信息来提升这个指标。</p><p>掌控好你的负责范围。 一般人们都会想善于完成他们的工作。听起来很明显，但有时候环境会诱惑你去做一些无关紧要的事情。这时候就值得注意了，返回去看第一条 – 保持首要任务的优先。</p><p>精确你的目标。 如果目标有点模糊，空出一点时间来确立它的精确性。不要去做较为模糊的工作 – 它们常常会令人分心和做一些超出目标范围的事。要学会鉴别自己思考，文字，及交流中的模糊地带，然后把这些模糊都消除掉，使之清晰明了。</p><h3 id="高效管理"><a href="#高效管理" class="headerlink" title="高效管理"></a>高效管理</h3><p><strong>把自己当做宝贵且重要的资源一样管理</strong></p><p>不要不懂装懂。 对自己要坦诚相待，对自己有清晰的自我认识能让你更快的学习和提升。如果你抱着坦诚的心态与他人交流，别人也会坦诚对待你，由此一个舒适健康的交流环境就建立起来了，并且不断的影响着周围的人。</p><p>制定计划并执行。 我小时候非常讨厌日历和时间表，并且花费了大量时间应付各种截至日期的潜在压力。但事实是：无论讨厌还是喜欢计划，我们只有有限的时间和无尽的任务需要做，这些都不会随着我们的主观意识而改变。没有良好的计划，我们最终会无休止的工作。如果你不主动提前决定你应该怎么花费你得时间和精力，那么会有其他的事情会帮你做决定 – 被别人打断或者一些无关紧要的任务（它们都会让你不由自主的花时间去处理）。</p><p>经过多年的反思和摇摆，我逐渐意识到我的问题并非是指定计划，而且被动的去做一些我不想做的事儿。我只是潜意识的对日历，计划有着反抗态度。如果你和我一样，这需要花费大量精力去消除这些影响。开始制定一些简单的计划然后完成。写下一些你能 5 分钟内完成的事，然后执行，完成。反复如此计划执行，计划执行，直到你做的越来越好，然后逐渐加多时间。冰冻三尺非一日之寒，通过不断练习及加大任务量及时间，会变得越来越复杂，就像玩游戏一样。当你开始习惯这样的循序渐进方式时，会变得越来越有趣和令人激动。你将会越来越了解你自己及你周围的世界。</p><p>劳逸结合。 你是一项宝贵的资源，并且需要休整。不要快速耗尽精力，要学会细水长流，当做马拉松来看。但我开始工作时，我感觉我获得了一个难得可贵的机会、觉的自己还不够格、顶着压力、常常埋头苦干、但还感到自己落后于工作，然后我开始拖延和延期直到我休了个假。现在回过头来看，这真是个滑稽的行为，而且我非常后悔。如果当初我抗住压力和提前安排好时间，我会更加开心，健康，完成更多得工作。</p><p>吾日三省吾身。 分析过去的工作，哪些完成了，哪些没有，哪些最终效果不错，哪些失败…… 你应该定期独立这样回顾分析工作。我经常偷懒记笔记，即使记了也基本不会回头再看。如果我能重新来过，我会更加系统的严于利己的对待此事。</p><blockquote><p>通过定期复盘能够不断强化自己对一个项目的理解，如果项目越滚越大，还是会对项目的掌控游刃有余。定期的复盘还能起到找出弱项，弥补不足，吸取经验，让自己之后能够更优异的完成任务。很多宝贵的经验，经历了一次就完了的人算作普通人；经历了一次并吸取经验在以后遇到同样问题能够通过经验解决的人算作优秀的人；经历了一次不仅吸取了经验，还能做到复盘举一反三的能称之为非常有前景的人才了</p></blockquote><p>表述你的进度。 这在多个层面上均非常有帮助。首先，只需要给高强度工作的大脑腾点休息时间，把工作进度手写在纸上，这是一个非常有用的习惯。这会强迫你把想要表达的东西表述出来。你想要达成什么目标？你是如果做出决策的？当你在用文字表述你的进度的时候，你还能顺带分析下。你能找出弱项并强化它们。这就像是在看自己的回放一样，能够注意到更多的细节。当然，你还能与他人分享你的表述，并收到反馈，这又是更进一步的提升了。</p><blockquote><p>通过具体的语言或者文字表述自己工作的进度，可以把大脑里抽象的思考具体化，并由此观察细节找出问题或者弱点并强化。通过具体的表述能够增强逻辑能力，锻炼表达能力与更清晰的认识自己做的事儿。</p></blockquote><p>为自己负责。 即使你有非常优秀的主管，但是你最终会为自己的学习、执行和成长进行负责。回顾以前，我觉得我自己花费了第一个 3-4 年在舒适区，从不主动出击。我的确有一个非常优秀的主管，给我了大量的目标、建议和规划，也许他们还给我剧透了一些信息。但我花了几年的时间才发现『我必须给自己设定更高的目标，并努力达成』。除非你有一个非常疯狂的老板或者主管分配给你高难度工作，不然没有人能比你更适合把自己推到极限。（我并不是暗示大量的工作和大量的时间，我想表达的是跳出你的舒适区，挑战自己达到下一个高度。尝试新鲜事物，学习超出你工作范畴的新东西等等）</p><p>花时间学习。 当你发现一些和你工作相关的干货资料时，标注一下稍后再看，然后定期去浏览学习这些存货。按周来规划是非常不错的。如果你已经在大量的阅读和学习了，那么和其他人分享下你的心得。这会帮助你更加深刻的理解你学到的东西。建议设置月度或者季度学习目标。</p><blockquote><p>学习的最高形式便是传授；不积跬步无以至千里，要想通过 7 天学会 XXX，21 天学会 XXX 的这类爆款无异于痴人说梦，这些鸡汤往往只能教会你最基础的 hello, world. 合理的设定学习计划与目标按部就班的学习不仅能缓和学习压力而且能打下坚实的基础。</p></blockquote><h3 id="用心沟通"><a href="#用心沟通" class="headerlink" title="用心沟通"></a>用心沟通</h3><p><strong>你在团队中的影响力是非常重要的</strong></p><p>尽早沟通，经常交流。 早期，我非常害羞并且经常独自一人解决所有问题。如果我欠着某人一些工作，我会尝试把所有任务都做完了再转交给下一个人。如果我遇到困难了，我要么会小激动要么拖延一阵直到我没时间了，然后会慌张的做完工作。展示你的工作，分享你的草图和草稿，你需要和你的团队建立融洽的关系和信任，如此你才会感到舒适的去沟通分享。早期的反馈对比晚期的反馈更加有用并且更具有高执行度。有时候只需要简单的问同事几个问题或者交流下看法就会得到一个意想不到的解决你问题的方法。</p><p>提有效的问题。 在你尚未意识到的情况下，所有事都一定程度上是模糊的。由此尝试把事情给精确化。对期望的结果非常明确是非常重要的。人们通常对一个场景有不同的期待，不同的理解 – 这些都是摩擦和挫折的来源。所以，这非常值得花费一定的时间和精力确保每个人都对你做的事情保持一致的理解。</p><p>三人行必有我师焉。 真实的生活并不是一本书，你只需要独自一人阅读理解就行了。有需要就寻求帮助，这也许在不同的公司文化和同事个性稍有不同。有些人也去会强行打扰他人，但我能觉察到那些聪明，有修养的人能小心避免打扰到他人的情况下寻求帮助。这也就是说，当你寻求帮助的时候，要简洁明礼貌的提出『小强，当你有空的时候来帮助我下，我需要旁观者来看看我的 PPT 是否有任何值得提升的地方』。不要强行打断别人的工作，那是不礼貌的。当你有礼貌的提出明确的帮助需求的时候，有时候人们会不在意分心来帮助你。</p><p>心态要积极向上。 这不仅对自己，对整个工作氛围都非常有帮助！</p><h3 id="尝试交际"><a href="#尝试交际" class="headerlink" title="尝试交际"></a>尝试交际</h3><p><strong>公司和组织都是由人构成的，尝试与他人建立关系</strong></p><p>协作工作。 有时候非常容易陷入一个困境：你觉得自己需要处理所有摆在你面前的问题。总会有做不完的工作，你需要既能综观大局又能专注细节。去认识一些做和你工作性质差不多的人，这会对你的工作非常有帮助。人们知道一些东西，他们也许不会写在博客里但他们会愿意当面教授你这些东西，并且这些东西可能会对你非常有用。人们可以帮你开门，可以帮你预先把东西处理好。有时候你花费了大量时间都未解决的问题，正好有人的脑袋里早有解决方法，你也许只需要请他们一杯咖啡就可以寻求帮助了。</p><p>招人内推。 即使你不负责招聘工作，列出一堆你想要共同工作的人或者想要学习的榜样给相关负责人也是有帮助的。</p><p>尝试演讲。 与他人交流你知道的内容是一项非常强大的技能。这会使你更加专业，也会让你在工作时更加轻松，因为通过教授预分享能让你在你的领域内更加自信。</p><h3 id="其它思考"><a href="#其它思考" class="headerlink" title="其它思考"></a>其它思考</h3><p>甄别束缚你的外因。 是钱吗？是念头吗？是执行力吗？是时间吗？是什么阻碍了你完成 2 倍，4 倍甚至 10 倍于挡墙你的成就？</p><p>白日梦有时候还是很有用的。 如果你有更多的资源可以用？如果你每周有额外 500 块钱你要做什么？那么 1000 块，2000 块，5000 块喃？如果你从头再来，你会做什么不一样的事儿吗？如果你只用工作当前时间的一半？如果你做了你当前目标完全相反的结果会发生什么？</p><p>换位思考。 很多情况下，市场营销就是关于换位思考。为什么人们要用你的产品而不是其它的？为什么人们关系一些特定的内容数据？为什么别人要雇佣你？你有什么价值，特点值得别人注意？</p><p>了解行业工作市场。 我尽量避免这个很久了，因为我喜欢我现在工作的地方，而且哪怕有浏览其他工作职位信息的念头都感觉可怕。但了解实时行业动态及招人信息是非常有用的。你可以由此规划你的职业生涯，看看对应的职位都需要什么条件，自问自己还差什么，然后弥补这些不足。而且这些行业信息也能够提供对你的职位晋升及加薪的有效信息。</p><p>主人翁意识。 让你的老板更加信任你，对你的建议更容易说同意。每个老板都喜欢雇佣能直接把活给干完的员工，而且过程不寻求任何建议与管理。当你即了解你的首要任务与目标时，执行计划并完成。你的老板是雇佣你来完成工作的，他并不想和你一起做出每一个决定。（当然一个好老板会在最初教你一些计划与职责内容）。尝试替老板思考，做出计划，并且只需要让老板做出同意或者否决的决定。</p><p>照顾好自己身心健康。 你的工作会占据你的大部分生活，所以尝试做好它，严肃对待它，享受其过程，并不断挑战自我。但是如果你发现你精力耗尽，身心疲惫，这时候不要再自己催眠强撑下去了。毕竟，你才是你生活中最重要的人，照顾好你自己。</p><div class="tip"><br>本文转载自: <a href="https://moyu.io/2017/10/advices-from-my-supervisor/" target="_blank" rel="noopener">MOYU</a>，版权归原作者所有。<br></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文翻译自 &lt;a href=&quot;https://www.reddit.com/r/startups/comments/74pms1/my_manager_who_i_loved_recently_left_my_company_i/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Reddit&lt;/a&gt; 上的一篇文章。其主要内容为一名职工记录了他与其已离职的主管的一对一交流。其中总结了大量关于职业生涯，工作内容，人际关系，自我成长的建议。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>代码重构</title>
    <link href="http://ifyour.github.io/2018/06/16/%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84/"/>
    <id>http://ifyour.github.io/2018/06/16/代码重构/</id>
    <published>2018-06-16T14:46:36.000Z</published>
    <updated>2019-12-07T06:07:38.533Z</updated>
    
    <content type="html"><![CDATA[<p>今天读了曾探的<a href="https://book.douban.com/subject/26382780/" target="_blank" rel="noopener">《设计模式》</a>中的代码重构这一章节, 知识点不多却非常实用, 在实际项目中除了使用设计模式重构代码外, 还有一些容易忽略的细节. 这些细节也是重构的重要手段. 写这篇文章总结一下.</p><a id="more"></a><blockquote><p>代码是写给人看的, 顺便给机器运行. 优雅的代码应该是简单、易维护、可扩展的.</p></blockquote><h3 id="提炼函数"><a href="#提炼函数" class="headerlink" title="提炼函数"></a>提炼函数</h3><p>如果一个函数过长, 而且需要注释才清楚它是如何工作的, 那么需要考虑把它独立出来. 这样做的好处是:</p><ul><li>避免超大函数, 作用域过大变量不好维护</li><li>抽离公共逻辑, 易于复用和覆写</li><li>良好的命名起到了注释作用</li></ul><p><strong>例子:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getUserInfo = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  fetch(<span class="string">'https://xxx.com/userInfo'</span>, (data) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`</span></span><br><span class="line"><span class="string">      userId: <span class="subst">$&#123;data.userId&#125;</span>\n</span></span><br><span class="line"><span class="string">      userName: <span class="subst">$&#123;data.userName&#125;</span>\n</span></span><br><span class="line"><span class="string">      nickName: <span class="subst">$&#123;data.NickName&#125;</span></span></span><br><span class="line"><span class="string">    `</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>重构如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> printDetail = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`</span></span><br><span class="line"><span class="string">    userId: <span class="subst">$&#123;data.userId&#125;</span>\n</span></span><br><span class="line"><span class="string">    userName: <span class="subst">$&#123;data.userName&#125;</span>\n</span></span><br><span class="line"><span class="string">    nickName: <span class="subst">$&#123;data.NickName&#125;</span></span></span><br><span class="line"><span class="string">  `</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getUserInfo = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  fetch(<span class="string">'https://xxx.com/userInfo'</span>, (data) =&gt; &#123;</span><br><span class="line">    printDetail(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="#">⤴️Go Top</a></p><h3 id="合并重复的条件片段"><a href="#合并重复的条件片段" class="headerlink" title="合并重复的条件片段"></a>合并重复的条件片段</h3><p>如果一个函数体内有一些条件分支, 而且这些条件分支内散布了一些重复的代码, 这个时候就有必要进行合并去重操作.</p><p><strong>例子:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> paging = <span class="function">(<span class="params">currPage</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (currPage &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    currPage = <span class="number">0</span>;</span><br><span class="line">    jump(currPage); <span class="comment">// 跳转</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currPage &gt;= totalPage) &#123;</span><br><span class="line">    currPage = totalPage;</span><br><span class="line">    jump(currPage); <span class="comment">// 跳转</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    jump(currPage); <span class="comment">// 跳转</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到上面的 <code>jump(currPage)</code> 重复了, 完全可以把它独立出来:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> paging = <span class="function">(<span class="params">currPage</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (currPage &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    currPage = <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currPage &gt;= totalPage) &#123;</span><br><span class="line">    currPage = totalPage;</span><br><span class="line">  &#125;</span><br><span class="line">  jump(currPage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="#">⤴️Go Top</a></p><h3 id="把条件分支语句提炼成函数"><a href="#把条件分支语句提炼成函数" class="headerlink" title="把条件分支语句提炼成函数"></a>把条件分支语句提炼成函数</h3><p>复杂的条件分支语句是导致程序难以阅读和理解的重要原因, 而且很容易导致一个庞大的函数. 这种情况下就需要把条件分支语句提炼出来.</p><p><strong>例子:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需求: 如果当季是处于夏季, 那么所有的商品 8 折出售</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getPrice = <span class="function">(<span class="params">price</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  <span class="keyword">if</span> (date.getMonth() &gt;= <span class="number">6</span> &amp;&amp; date.getMonth() &lt;= <span class="number">9</span>) &#123; <span class="comment">// 夏季</span></span><br><span class="line">    <span class="keyword">return</span> price * <span class="number">0.8</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> price;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>观察这段代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (date.getMonth() &gt;= <span class="number">6</span> &amp;&amp; date.getMonth() &lt;= <span class="number">9</span>) &#123; <span class="comment">// 夏季</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要让它更符合语义, 这样读代码的人能很轻松理解意图, 这里就可以提炼成一个单独函数.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isSummer = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  <span class="keyword">return</span> date.getMonth() &gt;= <span class="number">6</span> &amp;&amp; date.getMonth() &lt;= <span class="number">9</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getPrice = <span class="function">(<span class="params">price</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  <span class="keyword">if</span> (isSummer()) &#123;</span><br><span class="line">    <span class="keyword">return</span> price * <span class="number">0.8</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> price;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="#">⤴️Go Top</a></p><h3 id="合理的使用循环"><a href="#合理的使用循环" class="headerlink" title="合理的使用循环"></a>合理的使用循环</h3><p>在函数体内, 如果一些代码只是完成一些重复的工作, 那么可以合理利用循环完成同样的功能, 这样可以保持代码量更少.</p><p><strong>例子:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需求: IE9 以下创建一个 XHR 对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> createXHR = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> xhr;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    xhr = <span class="keyword">new</span> ActiveXObject(<span class="string">'MSXML2.XMLHttp.6.0'</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      xhr = <span class="keyword">new</span> ActiveXObject(<span class="string">'MSXML2.XMLHttp.3.0'</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">      xhr = <span class="keyword">new</span> ActiveXObject(<span class="string">'MSXML2.XMLHttp'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> xhr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xhr = createXHR();</span><br></pre></td></tr></table></figure><p>这个时候, 使用循环来优化上面的代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这段代码就看着符合语义了, 而且好理解 🤡</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> createXHR = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> versions = [<span class="string">'MSXML2.XMLHttp.6.0'</span>, <span class="string">'MSXML2.XMLHttp.3.0'</span>, <span class="string">'MSXML2.XMLHttp'</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, version; version = versions[i++];) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ActiveXObject(version);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xhr = createXHR();</span><br></pre></td></tr></table></figure><p><a href="#">⤴️Go Top</a></p><h3 id="提前让函数退出代替嵌套条件分支"><a href="#提前让函数退出代替嵌套条件分支" class="headerlink" title="提前让函数退出代替嵌套条件分支"></a>提前让函数退出代替嵌套条件分支</h3><p>很多程序员👨‍💻‍都有这种观念 “每个函数只能有一个入口和一个出口”, 但是关于 “函数只有一个出口” 往往有一些不同的看法, 下面用代码来说明一下, 光讲概念有点晦涩.</p><p><strong>例子:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面是 "函数只有一个出口" 的典型代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> del = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> ret;</span><br><span class="line">  <span class="keyword">if</span> (!obj.isReadOnly) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.isFolder) &#123;</span><br><span class="line">      ret = delFolder(obj);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj.isFile) &#123;</span><br><span class="line">      ret = delFile(obj);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>嵌套的条件分支绝对是代码维护者的噩梦, 多层嵌套的条件更加不容易理解, 有时候如果代码过长, 上一个 <code>if ()</code> 语句可能相隔很远. 严重影响了阅读体验啊. 重构的 <code>del</code> 函数如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> del = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj.isReadOnly) &#123; <span class="comment">// 反转 if</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (obj.isFolder) &#123;</span><br><span class="line">    <span class="keyword">return</span> delFolder(obj);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (obj.isFile) &#123;</span><br><span class="line">    <span class="keyword">return</span> delFile(obj);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 瞬间清爽 👌</span></span><br></pre></td></tr></table></figure><p><a href="#">⤴️Go Top</a></p><h3 id="传递对象参数代替过长的参数列表"><a href="#传递对象参数代替过长的参数列表" class="headerlink" title="传递对象参数代替过长的参数列表"></a>传递对象参数代替过长的参数列表</h3><p>有时候一个函数可能接收多个参数, 而且参数越多, 就越难理解和使用. 最重要的一点需要注意参数的顺序, 如果不传的情况要使用占位符代替. 如果参数超过 3 个, 请使用对象吧.</p><p><strong>例子:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> setUserInfo = <span class="function">(<span class="params">id, name, address, sex, mobile, qq</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 ☹️:</span></span><br><span class="line">setUserInfo(<span class="number">1</span>, <span class="string">'ifyour'</span>, <span class="literal">undefined</span>, <span class="string">'male'</span>, <span class="literal">undefined</span>, <span class="string">'123456'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重构 😁:</span></span><br><span class="line">setUserInfo(&#123;</span><br><span class="line">  id: <span class="number">1</span>,</span><br><span class="line">  name: <span class="string">'ifyour'</span>,</span><br><span class="line">  sex: <span class="string">'male'</span>,</span><br><span class="line">  qq: <span class="string">'123456'</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><a href="#">⤴️Go Top</a></p><h3 id="尽量减少参数数量"><a href="#尽量减少参数数量" class="headerlink" title="尽量减少参数数量"></a>尽量减少参数数量</h3><p>如果调用一个函数, 需要传递很多参数, 这样的函数用起来就要小心了, 必须搞清楚每个参数的含义, 所以, 如果能尽量少传参数就少传参数. 把复杂的逻辑封装到函数内部.</p><p><strong>例子:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需求: 有一个画图函数 draw</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> draw = <span class="function">(<span class="params">width, height, square</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化如下:</span></span><br><span class="line"><span class="keyword">const</span> draw = <span class="function">(<span class="params">width, height</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> square = width * height;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>square</code> 参数没必要, 可以通过 <code>width</code> 和 <code>height</code> 计算获得, 还有一种情况, 这个画图函数, 如果可以画多种图形呢? 所以需要在内部去处理, 什么时候需要 <code>square</code> 什么时候需要 <code>radius</code>, 然后可以使用 <strong>策略模式</strong> 让它支持画多种图形.</p><p><a href="#">⤴️Go Top</a></p><h3 id="少用三目运算"><a href="#少用三目运算" class="headerlink" title="少用三目运算"></a>少用三目运算</h3><p>三目运算能减少代码量, 但是不能滥用, 如果以牺牲代码可读性为代价, 那就得不偿失了.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> global = <span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">'undefined'</span> ? <span class="built_in">window</span> : <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是这种情况就完全没必要了, 老实写 if..else...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!aup || !bup) &#123;</span><br><span class="line">  <span class="keyword">return</span> a === doc ? <span class="number">-1</span> :</span><br><span class="line">    b === doc ? <span class="number">1</span> :</span><br><span class="line">    aup ? <span class="number">-1</span> :</span><br><span class="line">    bup ? <span class="number">1</span> :</span><br><span class="line">    sortInput ?</span><br><span class="line">    (indexOf.call(sortInput, a) - indexOf.call(sortInput, b)) :</span><br><span class="line">    <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 😡 这是人看的吗</span></span><br></pre></td></tr></table></figure><p><a href="#">⤴️Go Top</a></p><h3 id="合理使用链式调用"><a href="#合理使用链式调用" class="headerlink" title="合理使用链式调用"></a>合理使用链式调用</h3><p>jQuery 中的链式调用用起来还是很爽的, 它的实现也非常简单, 我们可以很容易的实现一个链式调用. 使用的前提就是链条的结构相对来说稳定, 不容易发生修改, 如果是经常发生修改的话, 还是建议使用普通的调用. 因为它调试的时候需要把这个链子拆开, 才知道是哪个环节有 Bug.</p><p><strong>例子:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> User = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.id = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">User.prototype.setId = <span class="function"><span class="keyword">function</span> (<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.id = id;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>; <span class="comment">// 返回实例本身</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">User.prototype.setName = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式调用</span></span><br><span class="line"><span class="keyword">new</span> User()</span><br><span class="line">  .setId(<span class="number">1</span>)</span><br><span class="line">  .setNmae(<span class="string">'ifyour'</span>);</span><br></pre></td></tr></table></figure><p>或者这样:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> User = &#123;</span><br><span class="line">  id: <span class="literal">null</span>,</span><br><span class="line">  name: <span class="literal">null</span>,</span><br><span class="line">  setId: <span class="function"><span class="keyword">function</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  setName: <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">User.setId(<span class="number">1</span>).setName(<span class="string">'ifyour'</span>);</span><br></pre></td></tr></table></figure><p><a href="#">⤴️Go Top</a></p><h3 id="分解大型类"><a href="#分解大型类" class="headerlink" title="分解大型类"></a>分解大型类</h3><p>从字面意思我们就能理解, 如果一个类里面有太多的方法, 我们要考虑把其中同一类型相关的方法抽离出来. 模块化的好处不言而喻, 把逻辑复杂的分离成小的单元, 这样更便于维护, 出现 bug 了也好定位问题. 来看一段代码.</p><p><strong>例子:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 英雄类</span></span><br><span class="line"><span class="keyword">var</span> Spirit = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型上的攻击方法</span></span><br><span class="line">Spirit.prototype.attack = <span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (type === <span class="string">'waveBoxing'</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">': 使用波动拳'</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">'whirlKick'</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">': 使用旋风腿'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ... 还有很多攻击方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> spirit = <span class="keyword">new</span> Spirit(<span class="string">'RYU'</span>);</span><br><span class="line">spirit.attack(<span class="string">'waveBoxing'</span>); <span class="comment">// RYU: 使用波动拳</span></span><br><span class="line">spirit.attack(<span class="string">'whirlKick'</span>); <span class="comment">// RYU: 使用旋风腿</span></span><br></pre></td></tr></table></figure><p>面向对象的设计鼓励将 <strong>行为</strong> 分解到合理数量的更小的对象中:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Attack = <span class="function"><span class="keyword">function</span> (<span class="params">spirit</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.spirit = spirit;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Attack.prototype.start = <span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.list[type].call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Attack.prototype.list = &#123;</span><br><span class="line">  waveBoxing: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.sprite.name + <span class="string">': 使用波动拳'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  whirlKick: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.sprite.name + <span class="string">': 使用旋风腿'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在 Sprite 类精简了很多, 不再直接包含攻击相关的方法, 而是把方法委托给 Attack 类来执行. 这段代码也是 <strong>策略模式</strong> 的运用之一, 看代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Spirit = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.attackObj = <span class="keyword">new</span> Attack(<span class="keyword">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Spirit.prototype.attack = <span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.attackObj.start(type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> spirit = <span class="keyword">new</span> Spirit(<span class="string">'RYU'</span>);</span><br><span class="line">spirit.attack(<span class="string">'waveBoxing'</span>); <span class="comment">// RYU: 使用波动拳</span></span><br><span class="line">spirit.attack(<span class="string">'whirlKick'</span>); <span class="comment">// RYU: 使用旋风腿</span></span><br></pre></td></tr></table></figure><p><a href="#">⤴️Go Top</a></p><h3 id="退出多重循环"><a href="#退出多重循环" class="headerlink" title="退出多重循环"></a>退出多重循环</h3><p>使用 <code>return</code> 退出多重循环. 一定程度上能简化代码, 使代码更容易理解.</p><p><strong>例子:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需求: 假设在一个函数体内的多重循环内, 达到某个临界条件时退出循环</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> flag = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i * j &gt; <span class="number">30</span>) &#123;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这种代码看着就头晕目眩, 重构如下:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i * j &gt; <span class="number">30</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>直接使用 <code>return</code> 后, 后面的代码无法执行, 还是有点小问题的:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i * j &gt; <span class="number">30</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(i) <span class="comment">// 无法执行</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了解决这个问题, 我们可以把相关的代码放到 <code>return</code> 后面. 如果需要执行的代码较多, 可以提取成一个函数:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> print = <span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i * j &gt; <span class="number">30</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> print(i); <span class="comment">// 执行</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="#">⤴️Go Top</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天读了曾探的&lt;a href=&quot;https://book.douban.com/subject/26382780/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《设计模式》&lt;/a&gt;中的代码重构这一章节, 知识点不多却非常实用, 在实际项目中除了使用设计模式重构代码外, 还有一些容易忽略的细节. 这些细节也是重构的重要手段. 写这篇文章总结一下.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>给小白读的 WEB 托管服务进化史</title>
    <link href="http://ifyour.github.io/2018/06/09/%E7%BB%99%E5%B0%8F%E7%99%BD%E8%AF%BB%E7%9A%84-WEB-%E6%89%98%E7%AE%A1%E6%9C%8D%E5%8A%A1%E8%BF%9B%E5%8C%96%E5%8F%B2/"/>
    <id>http://ifyour.github.io/2018/06/09/给小白读的-WEB-托管服务进化史/</id>
    <published>2018-06-09T10:29:12.000Z</published>
    <updated>2019-12-07T06:07:38.533Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章是来拓展自己知识面的, 在我读高中那会 (08 年), 我身边就有沉迷电脑技术的同学, 那个时候我想着做一个自己的网站, 肯定是非常牛逼的事了. 从最开始接触的服务, 依次来排个序. 永硕 E 盘 -&gt; 免费空间建站 (国外居多) -&gt; 虚拟空间 -&gt; 虚拟服务器 (VPS) -&gt; 独立服务器. 看完这篇文章后, 我总算对这方面知识有了一个比较系统性的认识了. 一起来学习一下.</p><a id="more"></a><h3 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h3><p>文章开始之前, 我觉得还是有必要把这些专有名词先科普一下, 不要觉得很高大上, 简称而已.</p><ul><li>IaaS - 基础设施即服务</li><li>PaaS - 平台即服务</li><li>CaaS - 容器即服务</li></ul><p>本文介绍了 Web 托管服务进化的历史, 从专用服务器到虚拟化到 IaaS、PaaS 和最新的 CaaS; 说明了每种方式的优点和缺点. 着重阐述了构建 PaaS 应用的各个组件, 以及在选择 CaaS 提供商时应该考虑的问题. 最后从成本和功能性的角度论述了 PaaS 用户应该迁移到 CaaS 平台.</p><p>读完这篇博文, 你应该可以清楚的理解:</p><ul><li>这些名词到底指什么</li><li>这为什么对你很重要</li><li>对于你的使用场景，哪种方式最适合</li></ul><p>当然没有一种方式能够适合所有的 Web 基础设施的场景, 你的特殊场景或许需要特殊的考虑.</p><h3 id="从头开始——专用服务器"><a href="#从头开始——专用服务器" class="headerlink" title="从头开始——专用服务器"></a>从头开始——专用服务器</h3><p>Web 托管的本质还是在一个数据中心里布满了服务器、交换机、路由器、存储阵列和其它网络组件. 我们所讨论的每一个选项不管它是 PaaS、IaaS 还是 CaaS, 它底层使用的基础设施都是相同的, 即在一个大屋子里的很多独立服务器. 他们只是上面增加了很多抽象层使得管理变得更简单, 和使用自动化的方式处理以前很慢或者需要手动步骤的任务.</p><p>专用服务器, 或者叫做 “裸机” 有它的优点和缺点.</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>性能——你在直接使用一个服务器, 没有任何抽象层例如虚拟化带来的性能开销.</li><li>可靠性——没有抽象层和虚拟化, 出错的可能性会降低.</li><li>资源利用率——使用专用服务器, 你的进程不需要跟其它的虚拟机或者进程竞争资源例如 CPU、内存和带宽.</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>管理复杂性——你无法容易地克隆专用服务器来产生更多的实例, 专用服务器没有 AMI（译者注: Amazon Machine Image）或者镜像的概念. 想扩展你的基础设施到多个服务器上？我希望你用配置管理, 或者使用可信赖的老朋友 rsync.</li><li>成本——使用专用服务器, 在大多数情况下你需要预先支付服务器的硬件价格, 然后再付租用场地的成本, 或者你从一个服务提供商那里租赁它们. 无论哪种方式, 你都没法在不使用时终止服务器的租赁来节省成本, 因此你需要更加谨慎的对待你的财务计划.</li><li>你所有的进程和应用都运行在专用服务器上, 因此运行在相同的操作系统上. 为了可扩展性的目的, 你往往希望服务器只运行单一的进程, 例如 Web 服务或者数据库服务. 在一个服务器上运行所有的应用使得操作系统的调优变得更困难.</li></ul><h3 id="使事情变得更容易——虚拟化"><a href="#使事情变得更容易——虚拟化" class="headerlink" title="使事情变得更容易——虚拟化"></a>使事情变得更容易——虚拟化</h3><p>尽管专用服务器有很多优点, 但是它的缺点在大多数情况下会远远超过其优点. 公司为了能够迅速进入市场赢得竞争, 对于部署的速度提出了更高的要求, 虚拟化就很自然的成为了数据中心进化中的下一个步骤.</p><h4 id="什么是虚拟化"><a href="#什么是虚拟化" class="headerlink" title="什么是虚拟化"></a>什么是虚拟化</h4><p>简而言之, 虚拟化就是将物理服务器分成更小的虚拟机, 这些虚拟机只能访问物理机的部分资源. 例如你有一个 8CPU 核以及 16GB 内存的物理服务器, 则可以将它分成 8 个虚拟机, 每个虚拟机有 1 个 CPU 和 2GB 内存. 你或许已经听说过一些虚拟化技术如 Xen, KVM, VMware 和 Hyper-V, 其实很有更多.</p><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li>你可以在需要更多虚拟机实例或者想要虚拟机共享时进行虚拟机的克隆.</li><li>你可以备份虚拟机镜像作为安全保护或者灾备.</li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li>使用虚拟化意味着额外的性能开销, 可能造成性能下降.</li><li>虚拟机镜像在不同的服务提供商和虚拟化技术之间基本上是不可移植的.</li><li>管理虚拟机依然是手工步骤, 需要管理的时间和专业知识.</li></ul><h3 id="进化——虚拟化变成-IaaS"><a href="#进化——虚拟化变成-IaaS" class="headerlink" title="进化——虚拟化变成 IaaS"></a>进化——虚拟化变成 IaaS</h3><p>你知道 <a href="http://www.businessinsider.com/people-think-stormy-weather-affects-cloud-computing-2012-8" target="_blank" rel="noopener">51% 的人认为 “云” 会被天气影响吗</a>？你知道当人们谈论 “云” 时他们实际上是在讨论基础设施即服务 (IaaS) 吗？</p><h4 id="什么是基础设施即服务-IaaS"><a href="#什么是基础设施即服务-IaaS" class="headerlink" title="什么是基础设施即服务 (IaaS)"></a>什么是基础设施即服务 (IaaS)</h4><ul><li>通过 API 来管理硬件的虚拟化.</li><li>通过编程接口访问计算、存储和网络资源和配置.</li><li>当你需要是申请一个新的虚拟机, 当你完成后终止虚拟机, 你只需要为你使用的资源付费.</li><li>将数据中心资源视为公共设施.</li></ul><p>亚马逊在 2006 年发布了其 Amazon Web Services（AWS）和 EC2 产品，成为了这个领域的先驱。</p><h4 id="为什么这个进化如此重要"><a href="#为什么这个进化如此重要" class="headerlink" title="为什么这个进化如此重要"></a>为什么这个进化如此重要</h4><p>在过去当你需要上线一个在线业务时, 你不得不进行复杂的计划来保证你在数据中心内有足够的机架空间、足够的服务器和存储来处理业务的增长, 足够的网络带宽来处理所有的用户流量. 这种计划并不容易, 尤其是对早期的业务来讲, 你无法预测业务的未来和增长轨迹.</p><ol><li>它给了开发者超能量:<ul><li>构思一个想法立即上线.</li><li>如果成功了, 可以容易的扩展规模.</li><li>如果失败了, 关闭虚拟机以节约成本.</li></ul></li><li>它使得数据中心自动化变得更强大:<ul><li>全自动基础设施管理成为可能, 出现了 “基础设施即代码” 的概念.</li><li>弹性伸缩在过去是不可能实现的, 但是现在 web 基础设施可以当业务变化时自动的扩展或者收缩.</li><li>在服务器的自动化管理之后, 数据中心的自动化也扩展到了存储、网络以及其它大量的需要专业知识的系统, 在代码和 API 能够处理这些自动化之后, 这给全球的开发者社区带来了新的机遇.</li></ul></li></ol><h3 id="进一步演化——平台即服务-PaaS"><a href="#进一步演化——平台即服务-PaaS" class="headerlink" title="进一步演化——平台即服务 (PaaS)"></a>进一步演化——平台即服务 (PaaS)</h3><p>平台即服务 (PaaS) 使得开发人员可以很容易的部署和管理应用而隐藏掉所有的实现细节例如服务器、负载均衡器、DNS 等等. 他们或多或少的去除了对运维团队的需求, 而是让开发人员去关注应用部署. 有很多 PaaS 提供商, 其中一个最流行的是 Heroku. 关于 Heroku 的一个有趣的事情是 Heroku 完全是运行在 AWS 之上并依赖 AWS 的. 如果你不愿意你的应用运行在美国东部或者欧洲西部的 AWS 上的话, 这或许是一个问题. 没有 IaaS, 像 Heroku 这样的平台可能就不会存在了. PaaS 提供商利用 IaaS 作为一个非常重要的组成部分来交付它们的服务. 在减少从想法到部署的时间、自动化流程以及减少特殊的系统知识需求的趋势中, PaaS 是合理的下一步, 就像是从专用服务器到 IaaS 一样.</p><h4 id="构建-PaaS-是困难的"><a href="#构建-PaaS-是困难的" class="headerlink" title="构建 PaaS 是困难的"></a>构建 PaaS 是困难的</h4><p>能够通过抽象而避免处理服务器相关的问题是不容易的, 需要引入很多东西才能做到.</p><p>在 PaaS 的概念之下有几个主要的模块：</p><ul><li>编译系统——把你的代码编译成可以运行的应用, 并且把它存储到某个地方作为后续使用.</li><li>应用管理数据库——管理 Git 版本、build 版本和应用元数据.</li><li>集群调度器——将一组服务器作为一台大的服务器来管理, 在服务器资源池的某个服务器上运行你的程序, 并检查和替换失效的作业.</li><li>负载均衡——允许从 Internet 和内部程序来的业务负载被正确的路由到合适的位置.</li><li>DNS——在你产生和修改应用时自动配置 DNS 条目.</li><li>或许是最重要的——某个形式的容器化例如  freebsd jails、solaris zones、或者 linux containers, 容器化使得某个的应用不会进入和影响到其它的应用.</li></ul><p>第一个和最后一个点是 Docker 迅速发展的非常重要的原因. Linux 容器技术已经存在了一段时间了, 但是只有某些大的公司或者 PaaS 提供商自动化了容器的使用, Docker 使 Linux 容器的使用变得非常简单, 也提供了标准化的镜像格式, 它成为了 PaaS 中重要的组成部分.</p><p>这非常强大, 因为很多公司在处理爆发式的用户增长, 来自于移动、社交和 IoT 的新的业务模式, 以及期望从传统的长的版本发布周期转变到持续交付. 他们利用基于软件的架构或者微服务. 他们需要能够自动部署和测试新的代码, 并根据业务的变化弹性伸缩. 但问题是他们没有足够的资源和经验来交付到他们的开发团队, 所以他们不得不将其外包给 PaaS 提供商. 不幸的是, 当你这么做的时候, 你就放弃了对于这个黑盒子的很多控制, 而是花很多钱并使得自己完全依赖于它. 另外一个选项是, 很多公司反复的重新发明轮子或者使用那些难于维护的、运行缓慢的和易于出错的工具.</p><p>最好的情形是在自己的数据中心或者 Cloud 帐号中运行一个 PaaS 平台, 你可以全权控制, 你的团队可以直接参与应用的部署, 因此可以形成一种真正的 DevOps 文化. Docker 及其标准化的生态系统是这种愿景成为现实的重要一步.</p><h3 id="最后——容器托管平台-CaaS"><a href="#最后——容器托管平台-CaaS" class="headerlink" title="最后——容器托管平台 (CaaS)"></a>最后——容器托管平台 (CaaS)</h3><p>什么是容器托管平台, 或者叫容器即服务呢？这就是我在上面的章节中提到的另外一种构建在 Docker 基础上的 Web 托管方式. 它是你用容器来部署复杂的多层次的应用所需要的自动化的编译系统, 集群调度器, 负载均衡, DNS 自动化以及服务发现. 这是 PaaS 的另外一部分内容, 但是你不是用一个复杂的编译系统来编译你的应用, 而是用 Docker 镜像. 镜像可以非常容易的进行编译和本地测试, 因此你在部署应用之前就确认应用可以正常工作. 现在 PaaS 用户也可以得到相同的体验, 但是不需要拥有自己的硬件或者云帐号的前提下节约大量的成本. 他们不再受限于其服务提供商所支持的环境, 可以通过将应用打包成 Docker 镜像的方式在任何地方运行.</p><p>在这个过程中, 利用诸如 ContainerShip Cloud, 你可以在任何地方, 在任何云平台上甚至是裸机上用相同的方式运行你的应用. 你不再被卡在构建复杂的应用来解决非常困难的问题, 或者卡在使用某个提供商的特殊的自动化部署工具上.</p><ul><li>但是选择一个正确的 Docker 容器托管平台并不是一件容易的事情, 有很多的问题需要你去思考和注意.</li><li>有大量的选项, 因此选择其中一个进行研究就变得困难. 好消息是如果你的应用已经容器化, 你就可以轻松的测试其中的每一个.</li><li>你正在使用的服务提供商例如 Triton 或者 ECS 的某个解决方案或许使得你无法脱离这个提供商, 这也使得 Docker 的最令人兴奋的可移植性变得不那么重要了.</li><li>许多 CaaS 方案在他们自己的硬件上运行所有的管理系统, 你自己的服务器上只是运行某个代理程序来连接他们的 API, 因此如果他们的系统宕机后你的集群将无法工作.</li><li>允许你在防火墙后运行整个系统的方案是非常复杂的, 需要一个团队去管理和升级.</li><li>能够容易的在防火墙后运行整个系统的方案会使得高可用成为低优先级的事情.</li><li>当你选择了一个 CaaS 提供商时, 你就可以摆脱了你的服务托管提供商的锁定, 但是你将陷入到 CaaS 提供商的锁定. 你无法不使用他们的 SaaS 管理接口而在你自己的硬件上运行整个系统包括管理系统, API 和 UI. 你一旦决定付钱, 你最好可以一直付钱.</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>终于看完了, 真的是又臭又长啊. 回顾一下这篇文章, 总体来说是经历了这样一个过程:</p><ol><li>专有服务器</li><li>虚拟化技术</li><li>基础设施即服务 (IaaS)</li><li>平台即服务 (PaaS)</li><li>容器即服务 (CaaS)</li></ol><p>总结一下, 我觉得开发人员还是有必要了解一下关于产品部署相关的技术发展. 然后根据自己的业务来选择合适的服务提供商.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章是来拓展自己知识面的, 在我读高中那会 (08 年), 我身边就有沉迷电脑技术的同学, 那个时候我想着做一个自己的网站, 肯定是非常牛逼的事了. 从最开始接触的服务, 依次来排个序. 永硕 E 盘 -&amp;gt; 免费空间建站 (国外居多) -&amp;gt; 虚拟空间 -&amp;gt; 虚拟服务器 (VPS) -&amp;gt; 独立服务器. 看完这篇文章后, 我总算对这方面知识有了一个比较系统性的认识了. 一起来学习一下.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ES6 Promise 简明指南</title>
    <link href="http://ifyour.github.io/2018/05/29/ES6-Promise-%E7%AE%80%E6%98%8E%E6%8C%87%E5%8D%97/"/>
    <id>http://ifyour.github.io/2018/05/29/ES6-Promise-简明指南/</id>
    <published>2018-05-29T14:28:41.000Z</published>
    <updated>2019-12-07T06:07:38.529Z</updated>
    
    <content type="html"><![CDATA[<p>Promise 是 JavaScriptES6 中最令人兴奋的新增功能之一. ES5 中使用回调函数来处理异步操作. 过度使用回调则会产生回调地狱和多级嵌套缩带来的问题. Promise 通过将异步代码转化成同步执行的方式, 大大简化了异步编程方式.</p><a id="more"></a><p>这篇文章中, 我们来学习一下什么是 Promise 以及在开发中的实践.</p><h3 id="什么是-Promise"><a href="#什么是-Promise" class="headerlink" title="什么是 Promise"></a>什么是 Promise</h3><p>简单来说 Promise 就是一个存放着未来才会有计算结果的占位符. 稍微想想, 你会发现, 这和我们平常在谈话过程中说的承诺很像. 举个例子: 你准备去印度旅行, 你订了一张去印度的机票. 这个机票上写着多少号, 座位号是多少. 这个场景下, 机票就是航空公司给你许下的承诺: 在你准备出发那天给你预留了一个头等舱！😎</p><p>还有一个简单的例子, 你承诺你的朋友, 当你读完《计算机编程艺术》这本书后, 你就把这本书还回去. 在这里, 你所说的话就好比是一个占位符, 需要返回的值就是这本书.</p><p>你还可以想到其他一些类似承诺的例子, 比如在医生办公室等着、在餐馆点餐、在图书馆写书等等. 都涉及某种形式的承诺.</p><h3 id="生成一个-Promise"><a href="#生成一个-Promise" class="headerlink" title="生成一个 Promise"></a>生成一个 Promise</h3><p>当某项任务的完成时间不确定或太长时, 就可以使用 Promise. 例如, 网络请求可能需要 10ms 到 200ms（或更长）的时间, 具体取决于网速. 我们不想在获取数据时等待. 200 毫秒对你来说可能不太重要, 但对于一台电脑来说, 这是一段很长的时间. Promise 就是要让这种异步变得简单、轻松. 使用 Promise 构造函数, 来实例化一个 myPromise 实例, 像这样:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Math</span>.random() * <span class="number">100</span> &lt;= <span class="number">90</span>) &#123;</span><br><span class="line">    resolve(<span class="string">'Hello, Promises!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'In 10% of the cases, I fail. Miserably.'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>来看一下这个接收两个参数的函数. <code>new Promise()</code> 被称为执行器函数, 它描述了要完成的计算. 它的这两个参数通常被叫做 <code>resolve</code> 和 <code>reject</code>, 可以理解为 <strong>执行</strong> 和 <strong>拒绝</strong>, 它们用来标记执行器函数最终的计算结果. <code>resolve</code> 和 <code>reject</code> 本身是一个函数, 它用来返回一个值给我们的 Promise 实例.</p><p>当运算结果成功时, 或者未来着这个值准备就绪时, 我们就使用这个 <code>resolve</code> 函数来返回一个值, 我们就说: 我践行了当初许下的这个承诺.</p><p>同理, 当计算结果失败时, 或者计算过程中遇到了错误, 我们就使用 <code>reject</code> 函数, 我们就说: 我拒绝履行这个承诺. <code>reject</code> 函数可以接收任何值来作为参数, 但是比较推荐的是我们可以传递一个 <code>Error</code> 对象, 即: 抛出一个错误, 用来帮助我们调试代码, 这样就可以根据具体的抛出错误信息去解决问题啦.</p><p>在上面的这个例子中, <code>Math.random()</code> 用来生成一个随机数, 在 90% 的情况下, 这个 Promise 都应该被执行 (假设等概率分布), 剩余的情况下都是拒绝执行的.</p><h3 id="如何使用-Promises"><a href="#如何使用-Promises" class="headerlink" title="如何使用 Promises"></a>如何使用 Promises</h3><p>在上面的代码例子中, 我们生成了一个 Promise 实例 <code>myPromise</code>, 那么如何通过 <code>resolve</code> 和 <code>reject</code> 函数访问计算完成后的值呢? 所有的 <code>Promise</code> 实例都有一个 <code>.then()</code> 方法, 我们来瞧瞧:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Math</span>.random() * <span class="number">100</span> &lt; <span class="number">90</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'resolving the promise ...'</span>);</span><br><span class="line">    resolve(<span class="string">'Hello, Promises!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'In 10% of the cases, I fail. Miserably.'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Two functions</span></span><br><span class="line"><span class="keyword">const</span> onResolved = <span class="function"><span class="params">resolvedValue</span> =&gt;</span> <span class="built_in">console</span>.log(resolvedValue);</span><br><span class="line"><span class="keyword">const</span> onRejected = <span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(error);</span><br><span class="line"></span><br><span class="line">myPromise.then(onResolved, onRejected);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Same as above, written concisely</span></span><br><span class="line">myPromise.then(</span><br><span class="line">  resolvedValue =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(resolvedValue);</span><br><span class="line">  &#125;,</span><br><span class="line">  error =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output (in 90% of the cases)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// resolving the promise ...</span></span><br><span class="line"><span class="comment">// Hello, Promises!</span></span><br><span class="line"><span class="comment">// Hello, Promises!</span></span><br></pre></td></tr></table></figure><p><code>.then()</code> 方法接收 2 个回调函数, 第一个回调函数是当我们的 Promise 实例被执行 (resolve) 时调用, 第二个则是被拒绝 (reject) 时调用. 在上面的代码中, 我们使用 <code>onResolved</code> 和 <code>onRejected</code> 定义了这两个函数, 然后把它放到 <code>.then</code> 函数里, 当然, 你也可以按照常规写法, 直接在 <code>.then</code> 函数里写两个函数, 都是一样的.</p><p>在这个例子中, 有几点非常重要, 我们来说一下:</p><ul><li>一个 <code>promise</code> 只能是成功或者失败状态中的一个. 它不能成功或者失败多次. 也不能从成功状态切换到失败状态, 失败反之亦然.</li><li>你可以在成功或者失败状态后, 去定义这样一个回调函数. 当他们 <code>resolve</code> 或者 <code>reject</code> 仍然能正确调用.</li></ul><p>这就说明, <code>Promise</code> 最终只有一个状态, 即使你多次使用 <code>.then</code> 处理函数, 这个状态不能更改 (计算结果也不会重复执行).</p><p>为了验证这点, 你可以看到在第 3 行代码中, <code>console.log</code> 语句, 当你多次使用 <code>.then</code> 处理程序运行上述代码时, <code>console.log</code> 的语句只会被打印一次. 这就说明了 Promise 会缓存计算结果的, 当有一些相同的结果时, 缓存结果会被返回.</p><p>另一个重要的要注意的是, Promise 是 <a href="https://zh.wikipedia.org/wiki/%E5%8F%8A%E6%97%A9%E6%B1%82%E5%80%BC" target="_blank" rel="noopener">及早求值 (evaluated eagerly)</a> 的: 只要声明并将其赋值到变量上, 它已经开始在内存中执行了. 没有 <code>.start</code> 或 <code>.begin</code> 方法. 就像它在前面的例子中开始的那样.</p><p>为了确保 Promise 能被延迟调用, 我们通常还需要在它的外层包裹一个函数, 稍后的例子中我们会解释这个.</p><h3 id="捕获-Promise"><a href="#捕获-Promise" class="headerlink" title="捕获 Promise"></a>捕获 Promise</h3><p>到目前为止, 我们已经看到了 <code>resolve</code> 的场景, 那么当执行函数中出现一个错误时, 会发生什么呢? 在 <code>.then()</code> 函数中的第二个参数, 就是上面例子中的 <code>onRejected</code> 会被执行, 来看一个例子:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Math</span>.random() * <span class="number">100</span> &lt; <span class="number">90</span>) &#123;</span><br><span class="line">    reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'The promise was rejected by using reject function.'</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'The promise was rejected by throwing an error'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">myPromise.then(</span><br><span class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'resolved'</span>),</span><br><span class="line">  error =&gt; <span class="built_in">console</span>.log(error.message)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output (in 90% of cases)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The promise was rejected by using reject function.</span></span><br></pre></td></tr></table></figure><p>和第一个例子一样的, 但是现在 90% 的情况是被 <code>reject</code> 的, 另外 10% 的情况则是抛出一个错误语句.</p><p>在第一个例子中, 我们分别定义了 <code>onResolved</code> 和 <code>onRejected</code> 方法, <code>onRejected</code> 方法将在错误发生时被调用, 可以看到 <code>reject</code> 函数的参数可以直接是错误提示, 没必要必须 <code>new Error</code>, 两个写法都一样.</p><p>健壮的程序代码离不开错误处理, <code>.then</code> 方法的第二个参数给了我们这样一个捷径. 当需要处理一个错误时, 可以用 <code>.catch(onRejected)</code> 来代替 <code>.then(null, () =&gt; {...})</code>, <code>catch</code> 方法接收一个回调函数 <code>onRejected</code>, 因此, 上面的代码, 可以使用 <code>catch</code> 来简化写法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myPromise.catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(error.message));</span><br></pre></td></tr></table></figure><p>记住: <code>.catch</code> 方法仅仅是 <code>.then(undefined, onRejected)</code> 的语法糖而已.</p><h3 id="链式-Promise"><a href="#链式-Promise" class="headerlink" title="链式 Promise"></a>链式 Promise</h3><p><code>.then()</code> 和 <code>.catch()</code> 方法永远会返回一个 Promise 实例, 所以你可以链式使用多个 <code>.then</code> 一起来调用. 让我们来举个例子理解它.</p><p>首先, 我们写一个函数, 来延迟返回一个 Promise 实例. 这个返回的 Promise 将在稍后的时间内 <code>resolve</code>. 这里是实现方法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> delay = <span class="function"><span class="params">ms</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(resolve, ms));</span><br></pre></td></tr></table></figure><p>在这个例子中, 我们正在使用一个函数来包裹我们的 Promise 实例, 所以它并不会立即执行. 这个 <code>delay</code> 函数接收一个时间来作为参数. 这个执行函数将接收 <code>ms</code> 作为他的参数, 它还包含一个 <code>setTimeout</code> , 它在 <code>ms</code> 毫秒后调用 <code>resolve</code> 函数, 从而正确执行. 看这个例子:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delay(<span class="number">5000</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Resolved after 5 seconds'</span>));</span><br></pre></td></tr></table></figure><p><code>.then</code> 中的回调语句将在 <code>delay(5000)</code> 后执行. 当你执行上面的代码 5 秒后, 你就可以在控制台上看到输出结果了.</p><p>这里, 我们可以使用多个 <code>.then()</code> 方法来链式调用:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> delay = <span class="function"><span class="params">ms</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(resolve, ms));</span><br><span class="line"></span><br><span class="line">delay(<span class="number">2000</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Resolved after 2 seconds'</span>);</span><br><span class="line">    <span class="keyword">return</span> delay(<span class="number">1500</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Resolved after 1.5 seconds'</span>);</span><br><span class="line">    <span class="keyword">return</span> delay(<span class="number">3000</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Resolved after 3 seconds'</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Caught an error.'</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Done.'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Resolved after 2 seconds</span></span><br><span class="line"><span class="comment">// Resolved after 1.5 seconds</span></span><br><span class="line"><span class="comment">// Resolved after 3 seconds</span></span><br><span class="line"><span class="comment">// Caught an error.</span></span><br><span class="line"><span class="comment">// Done.</span></span><br></pre></td></tr></table></figure><p>从第 3 行开始, 它的执行步骤是这样的:</p><ul><li><code>delay(2000)</code> 函数执行, 它返回一个稍后 2 秒即将执行的 Promise 实例.</li><li>第 1 个 <code>.then()</code> 执行, 它输出语句 <code>Resolved after 2 seconds</code>, 然后它执行 <code>delay(1500)</code> 又返回一个 Promise 实例, 如果一个 <code>.then()</code> 返回了一个 Promise 实例, 那么它的 <code>resolve</code> 将被转发给下一个 <code>.then</code> 方法调用, 技术上叫: 沉降 (settlement).</li><li>只要像这样继续串联下去, 它会继续执行.</li></ul><p>注意在第三个 <code>.then()</code> 方法时, 我们在 <code>.then</code> 中抛出了一个错误. 这意味着当前的 Promise 被拒绝. 然后它会在下一个 <code>.catch</code> 语句中被捕获, <code>Caught an error</code> 将会被输出. 然而一个 <code>.catch</code> 语句它自己永远是被 <code>resolve</code> 的, 所以不需要在语句里再写 <code>reject</code> (除非你故意抛出一个错误), 这也是为什么在 <code>.catch</code> 语句后还可以继续写 <code>.then</code> 的原因.</p><p>比较推荐的做法是在 <code>.then</code> 方法后执行 <code>.catch</code> 而不是使用 <code>onResolved</code> 和 <code>onRejected</code>, 我们来举个例子说明一下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promiseThatResolves = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Leads to UnhandledPromiseRejection</span></span><br><span class="line">promiseThatResolves().then(</span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">  &#125;,</span><br><span class="line">  err =&gt; <span class="built_in">console</span>.log(err)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Proper error handling</span></span><br><span class="line">promiseThatResolves()</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err));</span><br></pre></td></tr></table></figure><p>我们创造一个永远能被 <code>resolve</code> 的 Promise 实例, 当你执行 <code>.then</code> 时, 可以带两个回调函数: <code>onResolved</code> 和 <code>onRejected</code>, 第一种写法, 在 <code>then</code> 种放入两个回调函数, 但是: 如果在第一个回调函数中继续抛出错误, 那么这个错误是不能被捕获的. 😅</p><p>第二种写法, 在 <code>.then</code> 语句的后面使用 <code>.catch</code> 捕获, 不光能捕获到执行函数 <code>promiseThatResolves</code> 的错误, 而且在 <code>.then()</code> 中的错误也是能被捕获到. 知道这样写的好处了吧!😁</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>你可以执行上面的所有代码片段来更深入的学习. 一种比较好的实践就是, 把所有基于回调的函数都用 Promise 来重新实现. 如果你写 Node.js 的话, 你会发现 <code>fs</code> 还有其他模块都是基于回调函数来实现的. 所以会存在一些工具库, 它们把所有基于回调的实现方式使用 Promise 来实现了. 比如 Node.js 的 <a href="https://nodejs.org/api/util.html#util_util_promisify_original" target="_blank" rel="noopener">util.promisify</a> 和 <a href="https://github.com/sindresorhus/pify" target="_blank" rel="noopener">pify</a>. 如果你在学习的话, 那么尽可能的尝试自己去实现. 或者说去读这些 Promise 实现库的源代码. 然后你就可以把这些最佳实践用于你的产品中啦!</p><p>还有一些关于 Promise 的东西没有完全讲到, 比如 <code>Promise.all</code> 和 <code>Promise.race</code> 方法, 处理 Promise 中的错误, 以及一些常见的反模式和细节等. 你可以参考下面的链接来学习更多关于 Promise 的知识.</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="http://www.ecma-international.org/ecma-262/6.0/#sec-promise-objects" target="_blank" rel="noopener">ECMA Promise Specification</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">Mozilla Docs</a></li><li><a href="https://developers.google.com/web/fundamentals/primers/promises#promise-api-reference" target="_blank" rel="noopener">Google’s Developer’s Guide on Promises written by Jake Archibald</a></li><li><a href="http://exploringjs.com/es6/ch_promises.html#sec_first-example-promises" target="_blank" rel="noopener">Exploring JS’s Chapter on Promises</a></li><li><a href="http://jamesknelson.com/grokking-es6-promises-the-four-functions-you-need-to-avoid-callback-hell/" target="_blank" rel="noopener">Introduction to Promises</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Promise 是 JavaScriptES6 中最令人兴奋的新增功能之一. ES5 中使用回调函数来处理异步操作. 过度使用回调则会产生回调地狱和多级嵌套缩带来的问题. Promise 通过将异步代码转化成同步执行的方式, 大大简化了异步编程方式.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>如何避免 async/await 地狱</title>
    <link href="http://ifyour.github.io/2018/05/20/%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D-async-await-%E5%9C%B0%E7%8B%B1/"/>
    <id>http://ifyour.github.io/2018/05/20/如何避免-async-await-地狱/</id>
    <published>2018-05-20T14:11:35.000Z</published>
    <updated>2019-12-07T06:07:38.533Z</updated>
    
    <content type="html"><![CDATA[<p>最近阅读了 Aditya Agarwal 的一篇文章：How to escape async/await hell。这篇文章主要讨论了过度使用 async/await 导致的新的「地狱」问题，其已经在 Medium 上获得了 19k+ 的 Applause。</p><a id="more"></a><div class="tip"><br>  async/await 是 ES7 的新语法。在 async/await 标准出来之前，JavaScript 的异步编程经历了 callback –&gt; promise –&gt; generator 的演变过程。<br></div><p>在 callback 的时代，最让人头疼的问题就是回调地狱 (callback hell)。所以，在 async/await 一经推出，社区就有人认为「这是 JavaScript 异步编程的终极解决方案」。但 async/await 也可能带来新的问题。</p><blockquote><p>好不容易逃离了一个「地狱」，又马上陷入另一个「地狱」了。</p></blockquote><h3 id="何为-async-await-地狱"><a href="#何为-async-await-地狱" class="headerlink" title="何为 async/await 地狱"></a>何为 async/await 地狱</h3><p>在编写异步代码时，人们总是喜欢一次写多个语句，并且在一个函数调用之前使用 await 关键字。这可能会导致性能问题，因为很多时候一个语句并不依赖于前一个语句——但使用 await 关键字后，你就需要等待前一个语句完成。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>假设你要写一个订购 pizza 和 drink 的脚本，代码可能是如下这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> pizzaData = <span class="keyword">await</span> getPizzaData(); <span class="comment">// async call</span></span><br><span class="line">  <span class="keyword">const</span> drinkData = <span class="keyword">await</span> getDrinkData(); <span class="comment">// async call</span></span><br><span class="line">  <span class="keyword">const</span> chosenPizza = choosePizza(); <span class="comment">// sync call</span></span><br><span class="line">  <span class="keyword">const</span> chosenDrink = chooseDrink(); <span class="comment">// sync call</span></span><br><span class="line">  <span class="keyword">await</span> addPizzaToCart(chosenPizza); <span class="comment">// async call</span></span><br><span class="line">  <span class="keyword">await</span> addDrinkToCart(chosenDrink); <span class="comment">// async call</span></span><br><span class="line">  orderItems(); <span class="comment">// async call</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>这段代码开起来没什么问题，也能正常的运行。但是，这并不是一个好的实现，因为这把本身可以并行执行的任务变成了串行执行。</p><p>选择一个 drink 添加到购物车和选择一个 pizza 添加到购物车可以看作是两个任务，而这两个任务之间并没有相互依赖的关系，也没有特定的顺序执行关系。所以这两个任务是可以并行执行的，这样能提高性能。而上述代码将二者变成了串行执行，显然是降低了程序性能的。</p><h3 id="更糟糕的例子"><a href="#更糟糕的例子" class="headerlink" title="更糟糕的例子"></a>更糟糕的例子</h3><p>假设要写一个程序，根据 followers 数用来显示 GitHub 中国区用户的排名情况。</p><p>如果只是获取排名，我们可以调用 Github 官方的 <a href="https://developer.github.com/v3/search/#search-users" target="_blank" rel="noopener">Search users</a> 接口，伪代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getUserRank</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> fetch(search_url);</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getUserRank();</span><br></pre></td></tr></table></figure><p>调用 getUserRank 函数就能获取到想要的结果。但是，你可能还要想要获取每个用户的 follower 数、email、地区和仓库等数据，而 Search users 接口并没有返回这些数据，你可能需要再去调用 <a href="https://developer.github.com/v3/users/#get-a-single-user" target="_blank" rel="noopener">Single user</a> 接口。</p><p>然后上述代码可能被改写为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getUserRank</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> fetch(search_url);</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> item = data[i];</span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">await</span> fetch(user_url);</span><br><span class="line">    res.push(&#123;...item, ...user&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getUserRank();</span><br></pre></td></tr></table></figure><p>运行查看结果，自己想要的数据都拿到了。但是，你发现一个问题，程序运行时间有点长，该怎么优化下呢？</p><p>其实，铺垫了这么长，就是想说明一个问题：你陷入了 async/await 的地狱。</p><p>上述代码的问题在于，获取每个用户资料的请求并不存在依赖性，就类似上文中的选择 pizza 和 drink 一样，这是可以并行执行的请求。而根据上述代码，请求都变成了串行执行，这当然会损耗程序的性能。</p><p>按照上述代码，可以看一下其异步请求的动态图：</p><p><img src="https://user-images.githubusercontent.com/7871813/40270076-c08ec820-5bb9-11e8-8470-5e716e87dc76.gif" alt="image"></p><p>可以看到，获取用户资料的每个请求都需要等到上一个请求完成之后才能执行，Waterfall 处于一个串行的状态。那要怎么改进这个问题呢？</p><p>既然获取每个用户资料的请求并不存在依赖性，那么我们可以先触发异步请求，然后延迟处理异步请求的结果，而不是一直等该请求完成。根据这个思路，那可能改进的代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getUserDetails</span> (<span class="params">username</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> user = <span class="keyword">await</span> fetch(user_url);</span><br><span class="line">  <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getUserRank</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> fetch(search_url);</span><br><span class="line">  <span class="keyword">const</span> promises = data.map(<span class="function">(<span class="params">item</span>) =&gt;</span> getUserDetails(item.username));</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.all(promises).then(handleYourData);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getUserRank();</span><br></pre></td></tr></table></figure><p>可以看一下异步请求的动态图：</p><p><img src="https://user-images.githubusercontent.com/7871813/40270077-c2536602-5bb9-11e8-9438-a15ac05b41e0.gif" alt="image"></p><p>可以看到，获取用户资料的异步请求处理不再是串行执行，而是并行执行了，这将大大提高程序的运行效率和性能。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Aditya Agarwal 在其文章中也给出了怎么避免陷入 async/await 地狱的建议：</p><ol><li>首先找出依赖于其他语句的执行的语句</li><li>然后将有依赖关系的一系列语句进行组合，合并成一个异步函数</li><li>最后用正确的方式执行这些函数</li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://github.com/dt-fe/weekly/blob/master/55.%E7%B2%BE%E8%AF%BB%E3%80%8Aasync%20await%20%E6%98%AF%E6%8A%8A%E5%8F%8C%E5%88%83%E5%89%91%E3%80%8B.md" target="_blank" rel="noopener">精读《async/await 是把双刃剑》</a></li><li><a href="http://www.ruanyifeng.com/blog/2015/05/async.html" target="_blank" rel="noopener">async 函数的含义和用法</a></li><li><a href="https://cnodejs.org/topic/5640b80d3a6aa72c5e0030b6" target="_blank" rel="noopener">体验异步的终极解决方案 - ES7 的 Async/Await</a></li><li><a href="https://github.com/dwqs/blog/issues/65" target="_blank" rel="noopener">How to escape async/await hell</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近阅读了 Aditya Agarwal 的一篇文章：How to escape async/await hell。这篇文章主要讨论了过度使用 async/await 导致的新的「地狱」问题，其已经在 Medium 上获得了 19k+ 的 Applause。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>React 组件模式</title>
    <link href="http://ifyour.github.io/2018/05/14/React-%E7%BB%84%E4%BB%B6%E6%A8%A1%E5%BC%8F/"/>
    <id>http://ifyour.github.io/2018/05/14/React-组件模式/</id>
    <published>2018-05-14T16:33:40.000Z</published>
    <updated>2019-12-07T06:07:38.529Z</updated>
    
    <content type="html"><![CDATA[<p>使用 React 已经有一段时间了， React 是 Facebook 公司开发的用于构建网页界面的 UI 库。本文试图总结实践中所学到的一些模式，同时希望能够帮助到即将迈入组件世界的开发者。</p><a id="more"></a><h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><ul><li>有状态组件 vs 无状态组件</li><li>容器组件 vs 展示组件</li><li>高阶组件 vs 回调渲染组件</li></ul><p><img src="https://user-images.githubusercontent.com/15377484/40128970-a333542c-5965-11e8-8505-d1284d2759b1.png" alt="image"></p><h3 id="有状态组件-vs-无状态组件"><a href="#有状态组件-vs-无状态组件" class="headerlink" title="有状态组件 vs 无状态组件"></a>有状态组件 vs 无状态组件</h3><p>正如 WEB 服务有静态和动态之分，React 组件也有有状态和无状态的区分。</p><ul><li>有状态组件：在应用中组件可以拥有自身状态并操纵它；</li><li>无状态组件：只接收属性进行效果呈现。</li></ul><p>一个简单的无状态组件，只受属性控制:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Button = <span class="function"><span class="params">props</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;props.onClick&#125;</span>&gt;</span>&#123;props.text&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure><p>一个具有计数功能的按钮组件 (复用上面 Button 组件)</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ButtonCounter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">clicks</span>: <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">clicks</span>: <span class="keyword">this</span>.state.clicks + <span class="number">1</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Button</span><br><span class="line">        onClick=&#123;<span class="keyword">this</span>.handleClick&#125;</span><br><span class="line">        text=&#123;<span class="string">`You've clicked me <span class="subst">$&#123;<span class="keyword">this</span>.state.clicks&#125;</span> times!`</span>&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如上面两个 Demo 所示，第二个组件的 <code>constructor</code> 具有状态的定义，第一个组件只是单纯地渲染属性文字。有状态组件和无状态组件的划分看起来非常简单，但是它对于组件复用具有重大意义。</p><h3 id="容器组件-vs-展示组件"><a href="#容器组件-vs-展示组件" class="headerlink" title="容器组件 vs 展示组件"></a>容器组件 vs 展示组件</h3><p>当组件需要获取外部数据时，我们又可以将组件划分为两种新的类型。容器组件负责获取数据，它常常是超出了 React 范畴的，如使用 Redux 或 Relay 进行了绑定。对比而言，展示型组件不依赖于程序其他部分，它只和自身状态或属性有关。下面我们实现一个用户列表的展示组件:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> UserList = <span class="function"><span class="params">props</span> =&gt;</span> (</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &#123;props.users.map(<span class="function"><span class="params">u</span> =&gt;</span> (</span><br><span class="line">      &lt;li&gt;</span><br><span class="line">        &#123;u.name&#125; — &#123;u.age&#125; years old</span><br><span class="line">      &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    ))&#125;</span></span><br><span class="line"><span class="regexp">  &lt;/u</span>l&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>容器组件可以用来更新用户列表的展示:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserListContainer</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">users</span>: [] &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    fetchUsers(<span class="function"><span class="params">users</span> =&gt;</span> <span class="keyword">this</span>.setState(&#123; users &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">UserList</span> <span class="attr">users</span>=<span class="string">&#123;this.state.users&#125;</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p>这种分类将数据获取和渲染的逻辑分开，进而使用户列表组件可以复用。</p><p>如果你想了解更多该模式的信息，<a href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0" target="_blank" rel="noopener">这篇文章</a>对它进行了详细的解释。</p><h3 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h3><p>当你想复用组件逻辑时，高阶组件非常有用。高阶组件：是将组件作为参数并返回新组件的 JS 函数。</p><p>假设你需要构建一个可扩展菜单组件，当用户点击时，它会显示隐藏子组件内容。因此，你可以使用高阶组件来实现:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeToggleable</span>(<span class="params">Clickable</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">      <span class="keyword">super</span>();</span><br><span class="line">      <span class="keyword">this</span>.toggle = <span class="keyword">this</span>.toggle.bind(<span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">this</span>.state = &#123; <span class="attr">show</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    toggle() &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(<span class="function"><span class="params">prevState</span> =&gt;</span> (&#123; <span class="attr">show</span>: !prevState.show &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;Clickable &#123;...this.props&#125; onClick=&#123;<span class="keyword">this</span>.toggle&#125; /&gt;</span><br><span class="line">          &#123;<span class="keyword">this</span>.state.show &amp;&amp; <span class="keyword">this</span>.props.children&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>这种方法允许我们使用 ES7 装饰器语法将逻辑应用于 ToggleableMenu 组件:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@makeToggleable</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ToggleableMenu</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div onClick=&#123;<span class="keyword">this</span>.props.onClick&#125;&gt;</span><br><span class="line">        &lt;h1&gt;&#123;<span class="keyword">this</span>.props.title&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们可以将任何子组件传递给 ToggleableMenu 组件:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Menu</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;ToggleableMenu title=<span class="string">"First Menu"</span>&gt;</span><br><span class="line">          &lt;p&gt;Some content&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>ToggleableMenu&gt;</span><br><span class="line">        &lt;ToggleableMenu title=<span class="string">"Second Menu"</span>&gt;</span><br><span class="line">          &lt;p&gt;Another content&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>ToggleableMenu&gt;</span><br><span class="line">        &lt;ToggleableMenu title=<span class="string">"Third Menu"</span>&gt;</span><br><span class="line">          &lt;p&gt;More content&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>ToggleableMenu&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>如果你熟悉 Redux 的 connect 函数或者 React Router 的 withRouter 函数，那么你已经使用过高阶组件了。</p><h3 id="回调渲染组件"><a href="#回调渲染组件" class="headerlink" title="回调渲染组件"></a>回调渲染组件</h3><p>另一个比较高端的复用组件逻辑的方法是将函数作为组件的 <code>props.children</code>，该方法也称为 <strong>Function as Child Components</strong>。我们将使用<strong>渲染回调</strong>来重新实现上面的可扩展 Menu:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Toggleable</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.toggle = <span class="keyword">this</span>.toggle.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">show</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toggle() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function"><span class="params">prevState</span> =&gt;</span> (&#123; <span class="attr">show</span>: !prevState.show &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.children(<span class="keyword">this</span>.state.show, <span class="keyword">this</span>.toggle);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们可以将函数作为组件的子级进行传递:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;Toggleable&gt;</span><br><span class="line">  &#123;(show, onClick) =&gt; (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div onClick=&#123;onClick&#125;&gt;</span><br><span class="line">        &lt;h1&gt;&#123;props.title&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">      &#123;show &amp;&amp; props.children&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>Toggleable&gt;</span><br></pre></td></tr></table></figure><p>上面的代码已经将一个函数作为<strong>子组件</strong>，但是，若我们想复用上述逻辑，我们需要创建一个转换逻辑的新组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ToggleableMenu = <span class="function"><span class="params">props</span> =&gt;</span> (</span><br><span class="line">  &lt;Toggleable&gt;</span><br><span class="line">    &#123;(show, onClick) =&gt; (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div onClick=&#123;onClick&#125;&gt;</span><br><span class="line">          &lt;h1&gt;&#123;props.title&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">        &#123;show &amp;&amp; props.children&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )&#125;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>Toggleable&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>我们使用 Render Callbacks 实现的可扩展的 Menu 组件如下:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Menu</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;ToggleableMenu title=<span class="string">"First Menu"</span>&gt;</span><br><span class="line">          &lt;p&gt;Some content&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>ToggleableMenu&gt;</span><br><span class="line">        &lt;ToggleableMenu title=<span class="string">"Second Menu"</span>&gt;</span><br><span class="line">          &lt;p&gt;Another content&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>ToggleableMenu&gt;</span><br><span class="line">        &lt;ToggleableMenu title=<span class="string">"Third Menu"</span>&gt;</span><br><span class="line">          &lt;p&gt;More content&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>ToggleableMenu&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>回调渲染组件 (Render Callbacks) 和高阶函数使我们的组件更加灵活，掌握和适应起来具有一定的难度，需要反复学习和消化。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 React 已经有一段时间了， React 是 Facebook 公司开发的用于构建网页界面的 UI 库。本文试图总结实践中所学到的一些模式，同时希望能够帮助到即将迈入组件世界的开发者。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Git 操作详细总结</title>
    <link href="http://ifyour.github.io/2018/05/11/Git-%E6%93%8D%E4%BD%9C%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
    <id>http://ifyour.github.io/2018/05/11/Git-操作详细总结/</id>
    <published>2018-05-11T15:25:56.000Z</published>
    <updated>2019-12-07T06:07:38.529Z</updated>
    
    <content type="html"><![CDATA[<p>Git 操作详细总结，以便回顾和查询。理解这些指令，觉得最重要的是理解 Git 的内部原理，比如 Git 的分布式版本控制，分清楚工作区、暂存区、版本库，还有就是理解 Git 跟踪并管理的是修改，而非文件。</p><a id="more"></a><p><img src="https://user-images.githubusercontent.com/15377484/39952532-4c0c156e-55cb-11e8-8052-e62c448325fe.png" alt="image"></p><h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"Your Name"</span></span><br><span class="line">git config --global user.email <span class="string">"email@example.com"</span></span><br></pre></td></tr></table></figure><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><p>Git 追踪的是修改，而不是文件。</p><p><img src="https://user-images.githubusercontent.com/15377484/39952534-5c10f236-55cb-11e8-81bf-c4d369d07054.png" alt="image"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 “当前修改” 移动到暂存区 (stage)</span></span><br><span class="line">git add filename.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将暂存区修改提交</span></span><br><span class="line">git commit -m <span class="string">"Add filename.txt."</span></span><br></pre></td></tr></table></figure><h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line">git diff</span><br></pre></td></tr></table></figure><h2 id="回退"><a href="#回退" class="headerlink" title="回退"></a>回退</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 放弃工作区修改</span></span><br><span class="line">git checkout -- file.name</span><br><span class="line">git checkout -- .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消 commit(比如需要重写 commit 信息)</span></span><br><span class="line">git reset --soft HEAD</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消 commit、add(重新提交代码和 commit)</span></span><br><span class="line">git reset HEAD</span><br><span class="line">git reset --mixed HEAD</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消 commit、add、工作区修改 (需要完全重置)</span></span><br><span class="line">git reset --hard HEAD</span><br></pre></td></tr></table></figure><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rm file.name</span><br><span class="line">git rm file.name</span><br><span class="line">git commit -m <span class="string">"Del"</span></span><br></pre></td></tr></table></figure><h2 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:ifyour/ifyour.github.io.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一次推送，-u(--set-upstream) 指定默认上游</span></span><br><span class="line">git push -u origin master</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><h2 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/ifyour/ifyour.github.io.git path</span><br><span class="line">git <span class="built_in">clone</span> git@github.com:ifyour/ifyour.github.io.git path</span><br></pre></td></tr></table></figure><h2 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h2><p><img src="https://user-images.githubusercontent.com/15377484/39952537-6b679758-55cb-11e8-9ff7-87440fcbb4d0.png" alt="image"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前分支</span></span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建分支</span></span><br><span class="line">git branch dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换分支</span></span><br><span class="line">git checkout dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建并 checkout 分支</span></span><br><span class="line">git checkout -b dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并分支</span></span><br><span class="line">git merge dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除分支</span></span><br><span class="line">git branch -d dev</span><br></pre></td></tr></table></figure><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag 0.1.1</span><br><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure><h2 id="More"><a href="#More" class="headerlink" title="More"></a>More</h2><ul><li><a href="http://www.bootcss.com/p/git-guide/" target="_blank" rel="noopener">Git - 简易指南</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git 操作详细总结，以便回顾和查询。理解这些指令，觉得最重要的是理解 Git 的内部原理，比如 Git 的分布式版本控制，分清楚工作区、暂存区、版本库，还有就是理解 Git 跟踪并管理的是修改，而非文件。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Why Immutable Data?</title>
    <link href="http://ifyour.github.io/2018/05/05/Why-Immutable-Data/"/>
    <id>http://ifyour.github.io/2018/05/05/Why-Immutable-Data/</id>
    <published>2018-05-05T13:14:23.000Z</published>
    <updated>2019-12-07T06:07:38.529Z</updated>
    
    <content type="html"><![CDATA[<p>什么是不可变数据, 如何理解不可变数据, 不可变数据在项目中的实践. 弄清楚了这些问题, 你才能更好的处理项目中一些调优问题. 比如 React 性能优化等. 一起来学习下吧! 👨🏼‍💻</p><a id="more"></a><h2 id="What"><a href="#What" class="headerlink" title="What"></a>What</h2><blockquote><p><strong><em>Immutable Data</em></strong> 是指一旦被创造后就不可以被改变的数据, 通过使用 Immutable Data, 可以让我们更容易的去处理缓存、回退、数据变化检测等问题, 简化我们的开发.</p></blockquote><p><img src="https://user-images.githubusercontent.com/15377484/39663322-c4bb61ae-50a3-11e8-8267-4c2a80c00af7.png" alt="image"></p><h2 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h2><p>在原生 JS 中, 存在两种数据类型:</p><ul><li>静态数据类型</li><li>引用数据类型</li></ul><p>引用类型数据结构非常灵活, 节约内存, 能给开发带来不少便利. 但与此同时也产生了一些副作用:</p><h4 id="Case-1"><a href="#Case-1" class="headerlink" title="Case 1"></a>Case 1</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">count</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> copyObj = obj;</span><br><span class="line">copyObj.count = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(copyObj.count); <span class="comment">// =&gt; 2</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.count); <span class="comment">// =&gt; 2, 这并不是我们期望的</span></span><br></pre></td></tr></table></figure><h4 id="Case-2"><a href="#Case-2" class="headerlink" title="Case 2"></a>Case 2</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj2 = &#123; <span class="attr">count</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 团队协作, 大家都在用这个 obj2</span></span><br><span class="line">unKnowFunction(obj2);</span><br><span class="line"><span class="built_in">console</span>.log(obj2.count); <span class="comment">// 能保证这个结果一定是1吗?</span></span><br></pre></td></tr></table></figure><p>针对以上引用类型产生的副作用, 有人提出了 <strong><em>深度拷贝</em></strong> (Deep Clone)的方法, 实现代码如下:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> obj === <span class="string">'object'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArray</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.isArray(arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isObject(obj))  <span class="keyword">return</span> obj;</span><br><span class="line">  <span class="keyword">var</span> cloneObj = isArray(obj) ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">      <span class="keyword">var</span> value = obj[key];</span><br><span class="line">      <span class="keyword">var</span> copy = value;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (isObject(value)) &#123;</span><br><span class="line">        <span class="comment">// 这里使用了递归</span></span><br><span class="line">        cloneObj[key] = deepClone(value);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cloneObj[key] = value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cloneObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在我们可以使用 <code>deepClone</code> 这个方法来解决文章一开头的问题了:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  age: <span class="number">5</span>,</span><br><span class="line">  list: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 深拷贝一个新的对象, 两者互相独立, 不存在引用关系</span></span><br><span class="line"><span class="keyword">let</span> trueCopyObj = deepClone(obj);</span><br><span class="line"><span class="built_in">console</span>.log(obj.list === trueCopyObj.list); <span class="comment">// =&gt; false, 这是我们期望的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是又有一个问题, 我只是想拷贝一个新的对象, 改一下 `age`</span></span><br><span class="line"><span class="keyword">let</span> obj2 = deepClone(obj);</span><br><span class="line">obj2.age = <span class="number">6</span>;</span><br><span class="line"><span class="comment">// 难不成剩下的一堆引用类型的属性都要递归做一次深拷贝?</span></span><br><span class="line"><span class="comment">// 所以这明显是多余的, 并且存在严重的性能问题</span></span><br></pre></td></tr></table></figure></p><p>在原生 JavaScript 中实现数据不可变, 有 2 个办法:</p><ul><li>ES6: <code>const</code></li><li>ES5: <code>Object.freeze</code></li></ul><p>但是这两种都是浅处理, 遇到深层次的数据结构, 就需要递归处理, 又会存在性能上的问题.</p><h3 id="How"><a href="#How" class="headerlink" title="How"></a>How</h3><p>针对以上一系列需求, 我们完全可以使用不可变数据结构来处理, 对应的实现库有:</p><ul><li><a href="https://github.com/facebook/immutable-js" target="_blank" rel="noopener">facebook/immutable-js</a></li><li><a href="https://github.com/rtfeldman/seamless-immutable" target="_blank" rel="noopener">rtfeldman/seamless-immutable</a></li></ul><p>Immutable.js 主要特点:</p><ul><li>稳定数据结构 (Persistent Data Structure), 每次返回新的对象, 不存在引用</li><li>结构共享 (Structural Sharing), 基于哈希映射树, 可以实现部分结构共享</li><li>支持延迟操作 (Support Lazy Operation)</li><li>强大的 API (Power API)</li></ul><p>针对以上特点, 我们用一些代码实例来说明一下:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 稳定数据结构</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">count</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> map = Immutable.fromJS(obj);</span><br><span class="line"><span class="keyword">let</span> map2 = map.set(<span class="string">'count'</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="string">'count'</span>)); <span class="comment">// =&gt; 1</span></span><br><span class="line"><span class="built_in">console</span>.log(map2.get(<span class="string">'count'</span>)); <span class="comment">// =&gt; 2</span></span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结构共享</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  count: <span class="number">1</span>,</span><br><span class="line">  list: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> map1 = Immutable.fromJS(obj);</span><br><span class="line"><span class="keyword">let</span> map2 = map1.set(<span class="string">'count'</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(map1.list === map2.list); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><div style="width: 300px; "><img src="https://user-images.githubusercontent.com/15377484/39665040-d92a0764-50bf-11e8-84e3-ad83cf758acd.gif" alt="image"></div><p>这张 GIF 很形象的解释了 <code>结构共享</code> 👍</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 强大的 API</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  a: &#123;</span><br><span class="line">    b: &#123;</span><br><span class="line">      list: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> map = Immutable.fromJS(obj);</span><br><span class="line"><span class="keyword">let</span> map2 = Immutable.updateIn([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'list'</span>], (list) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> list.push(<span class="number">4</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(map2.getIn([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'list'</span>])); <span class="comment">// =&gt; List [ 1, 2, 3, 4 ]</span></span><br></pre></td></tr></table></figure><p>还有一个特点就不举例子了, 超纲! 😁</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://github.com/camsong/blog/issues/3" target="_blank" rel="noopener">Immutable 详解及 React 中实践</a></li><li><a href="https://stackoverflow.com/questions/27936772/how-to-deep-merge-instead-of-shallow-merge/28248548" target="_blank" rel="noopener">浅合并 (shallow merge) 例子</a></li><li><a href="https://lodash.com/docs/4.17.10#merge" target="_blank" rel="noopener">Lodash merge 方法</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是不可变数据, 如何理解不可变数据, 不可变数据在项目中的实践. 弄清楚了这些问题, 你才能更好的处理项目中一些调优问题. 比如 React 性能优化等. 一起来学习下吧! 👨🏼‍💻&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>持续集成 (CI) 及简单实践</title>
    <link href="http://ifyour.github.io/2018/04/30/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90-CI-%E5%8F%8A%E7%AE%80%E5%8D%95%E5%AE%9E%E8%B7%B5/"/>
    <id>http://ifyour.github.io/2018/04/30/持续集成-CI-及简单实践/</id>
    <published>2018-04-30T01:00:00.000Z</published>
    <updated>2019-12-07T06:07:38.533Z</updated>
    
    <content type="html"><![CDATA[<p>在软件开发领域, 一直有很多比较专业的术语, 本着科普的精神, 来填一下自己的 <del>知识盲区</del> 😂, 什么是持续集成? 如何做持续集成? 为什么要做持续集成? 带着这些问题, 本篇文章会给你答案.</p><a id="more"></a><h2 id="What"><a href="#What" class="headerlink" title="What"></a>What</h2><blockquote><p>持续集成（英语：Continuous integration，缩写 CI）是一种软件工程流程，是将所有软件工程师对于软件的工作副本持续提交到共用主线（mainline）的一种措施。</p></blockquote><h2 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h2><p>持续集成的目的，就是让产品可以快速迭代，同时还能保持高质量。</p><p><img src="https://user-images.githubusercontent.com/15377484/39465580-acb719cc-4d56-11e8-9915-2964d5e523c5.png" alt="image"></p><h2 id="How"><a href="#How" class="headerlink" title="How"></a>How</h2><p>它的核心措施是，代码集成到主干之前，必须通过自动化测试。只要有一个测试用例失败，就不能集成。以本次给博客做持续集成为例，它的流程是这样子的：</p><ol><li>写完博客后，直接 push 到 GitHub 的 <code>src</code> 分支(我的 <code>master</code> 分支是 pages)</li><li>CI 服务通过配置文件 <code>.travis.yml</code> 监听当前 <code>src</code> 分支发生变化，触发 webhook</li><li>CI 服务将当前项目 clone 过去，根据 <code>.travis.yml</code> 的配置执行测试和构建</li><li>将最终可以作为生产环境的代码推送到线上环境，并且 push 回  <code>src</code> 分支</li></ol><p>这样做的好处就是：</p><ul><li>发布新文章，只需 push 一次到仓库，剩下的测试、构建、部署生产环境等，CI 帮我自动完成。</li><li>快速发现错误。每完成一点更新，就集成到主干，定位错误也比较容易。</li><li>防止分支大幅偏离主干。如果不是经常集成，主干又在不断更新，会导致以后集成的难度变大。</li></ul><h2 id="More"><a href="#More" class="headerlink" title="More"></a>More</h2><ul><li><a href="http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html" target="_blank" rel="noopener">持续集成是什么</a></li><li><a href="https://segmentfault.com/a/1190000009054888" target="_blank" rel="noopener">使用 Travis 自动部署 Hexo</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在软件开发领域, 一直有很多比较专业的术语, 本着科普的精神, 来填一下自己的 &lt;del&gt;知识盲区&lt;/del&gt; 😂, 什么是持续集成? 如何做持续集成? 为什么要做持续集成? 带着这些问题, 本篇文章会给你答案.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>call、apply、bind 的区别及应用</title>
    <link href="http://ifyour.github.io/2016/03/26/call%E3%80%81apply%E3%80%81bind-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    <id>http://ifyour.github.io/2016/03/26/call、apply、bind-的区别及应用/</id>
    <published>2016-03-26T10:14:16.000Z</published>
    <updated>2019-12-07T06:07:38.529Z</updated>
    
    <content type="html"><![CDATA[<p>在面向对象的编程中，经常会处理 <code>this</code> 的指向问题，改变 this 的指向就不得不谈谈今天的主角—— <code>call</code>、<code>apply</code>、<code>bind</code>。个人感觉 <code>this</code> 的问题初学者不同容易一下理解透彻，今天再来好好捋一捋加深理解。<br><a id="more"></a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p><code>call</code>、<code>apply</code>、<code>bind</code> 的作用就是改变函数执行时的上下文，即改变 <code>this</code> 指向。</p><p><code>this</code> 的指向其实也就<a href="https://ifyour.github.io/2016/02/19/JavaScript-%E4%B8%AD%E7%9A%84-this-%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/">不外乎这四种情况</a>，其实理解起来还是很容易的，理解不了也没关系，先记住，后面在工作中大量编码应用，写多了就知道为啥要这样用了。先来一个简单的例子。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义人类构造函数，属性是姓名，方法是输出自己的姓名</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    showName: function() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'ifyour'</span>);</span><br><span class="line">p1.showName(); <span class="comment">// =&gt; ifyour</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个动物对象，它有个一姓名属性</span></span><br><span class="line"><span class="keyword">var</span> animal = &#123;</span><br><span class="line">    name: <span class="string">'cat'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>人类实例 <code>p1</code> 想要打印自己的姓名，只要调用自身的 <code>showName</code> 方法即可，但是动物呢？我也想要动物实例 <code>animal</code> 打印自己的名字，如何做呢？当然改变 this 咯，把人类的 <code>showName</code> 方法借给动物用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以直接去原型上借用</span></span><br><span class="line">Person.prototype.showName.call(animal);<span class="comment">//=&gt;cat</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以从人类上生成的实例 p1 去借用</span></span><br><span class="line">p1.showName.call(animal);<span class="comment">//  =&gt; cat</span></span><br><span class="line">p1.showName.apply(animal);<span class="comment">// =&gt; cat</span></span><br><span class="line">p1.showName.bind(animal)();<span class="comment">//=&gt; cat</span></span><br></pre></td></tr></table></figure><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><h4 id="call、apply-与-bind"><a href="#call、apply-与-bind" class="headerlink" title="call、apply 与 bind"></a>call、apply 与 bind</h4><ul><li><code>call</code>、<code>apply</code> 改变 <code>this</code> 指向后会 <strong><em>立即执行</em></strong></li><li><code>bind</code> 并不会执行</li></ul><p>在上面的例子我们也看到了，<code>bind</code> 方法改变 this 时，还需要加一个 <code>()</code> 才能执行输出 <code>cat</code>。</p><h4 id="call-与-apply"><a href="#call-与-apply" class="headerlink" title="call 与 apply"></a>call 与 apply</h4><ul><li><code>call</code> 把参数按顺序传入，即：<code>fn.call(obj, arg1, arg2, arg3...);</code></li><li><code>apply</code> 把参数打包成 <code>Array</code> 后传入，即： <code>fn.apply(obj, [arg1, arg2, arg3...]);</code></li></ul><p>它们俩之间的差别在于 <strong><em>参数</em></strong>，<code>call</code> 和 <code>aplly</code> 的第一个参数都是要改变上下文的对象，而 <code>call</code> 从第二个参数开始以参数列表的形式展现，<code>apply</code> 则是把除了改变上下文对象的参数放在一个数组里面作为它的第二个参数。</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>知道了怎么使用和它们之间的区别，接下来我们来了解一下使用 <code>call</code>、<code>apply</code>、<code>bind</code> 的常见应用场景。</p><h4 id="求数组中的最大、最小值"><a href="#求数组中的最大、最小值" class="headerlink" title="求数组中的最大、最小值"></a>求数组中的最大、最小值</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">34</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">54</span>,<span class="number">6</span>,<span class="number">-67</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">-8</span>,<span class="number">687</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.max.call(<span class="built_in">Math</span>, <span class="number">34</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">54</span>,<span class="number">6</span>,<span class="number">-67</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">-8</span>,<span class="number">687</span>);</span><br><span class="line"><span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, arr);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.min.call(<span class="built_in">Math</span>, <span class="number">34</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">54</span>,<span class="number">6</span>,<span class="number">-67</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">-8</span>,<span class="number">687</span>);</span><br><span class="line"><span class="built_in">Math</span>.min.apply(<span class="built_in">Math</span>, arr);</span><br></pre></td></tr></table></figure><h4 id="将伪数组转化为数组"><a href="#将伪数组转化为数组" class="headerlink" title="将伪数组转化为数组"></a>将伪数组转化为数组</h4><p>JavaScript 中的伪数组(例如通过 <code>document.getElementsByTagName</code> 获取的元素)具有 <code>length</code> 属性，并且可以通过 0、1、2……下标来访问其中的元素，但是没有 <code>Array</code> 中的 <code>push</code>、<code>pop</code> 等方法。我们可以利用 <code>call</code>、<code>apply</code> 来将其转化为真正的数组这样便可以方便地使用数组方法了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个伪数组</span></span><br><span class="line"><span class="keyword">var</span> arrayLike = &#123;</span><br><span class="line">    <span class="number">0</span>: <span class="string">'aaaa'</span>,</span><br><span class="line">    <span class="number">1</span>: <span class="string">'bbbb'</span>,</span><br><span class="line">    <span class="number">2</span>: <span class="string">'cccc'</span>,</span><br><span class="line">    length: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过这个方法转换</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.prototype.slice.call(arrayLike);</span><br></pre></td></tr></table></figure><div class="tip">上面 <code>arr</code> 便是一个包含 <code>arrayLike</code> 元素的真正的数组啦( 注意数据结构必须是以数字为下标而且一定要有 <code>length</code> 属性 )<br></div><h4 id="数组追加"><a href="#数组追加" class="headerlink" title="数组追加"></a>数组追加</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">[].push.apply(arr1, arr2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr1);<span class="comment">// =&gt; [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2);<span class="comment">// =&gt; [1, 2, 3]</span></span><br></pre></td></tr></table></figure><h4 id="变量类型判断"><a href="#变量类型判断" class="headerlink" title="变量类型判断"></a>变量类型判断</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArray</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) == <span class="string">'[object Array]'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = <span class="string">'[1,2,3]'</span>;</span><br><span class="line"></span><br><span class="line">isArray(arr1);<span class="comment">//   =&gt; true</span></span><br><span class="line">isArray(arr2);<span class="comment">//   =&gt; false</span></span><br></pre></td></tr></table></figure><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基础类</span></span><br><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 女孩类继承基础人类</span></span><br><span class="line"><span class="keyword">var</span> Girl = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="keyword">this</span>, name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 男孩类继承基础人类</span></span><br><span class="line"><span class="keyword">var</span> Boy = <span class="function"><span class="keyword">function</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  Person.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g1 = <span class="keyword">new</span> Girl (<span class="string">'Jilly'</span>);</span><br><span class="line"><span class="keyword">var</span> b1 = <span class="keyword">new</span> Boy(<span class="string">'ifyour'</span>, <span class="number">18</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在面向对象的编程中，经常会处理 &lt;code&gt;this&lt;/code&gt; 的指向问题，改变 this 的指向就不得不谈谈今天的主角—— &lt;code&gt;call&lt;/code&gt;、&lt;code&gt;apply&lt;/code&gt;、&lt;code&gt;bind&lt;/code&gt;。个人感觉 &lt;code&gt;this&lt;/code&gt; 的问题初学者不同容易一下理解透彻，今天再来好好捋一捋加深理解。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ProxyChains-NG + ShadowSocks 实现终端代理</title>
    <link href="http://ifyour.github.io/2016/03/23/ProxyChains-NG-ShadowSocks-%E5%AE%9E%E7%8E%B0%E7%BB%88%E7%AB%AF%E4%BB%A3%E7%90%86/"/>
    <id>http://ifyour.github.io/2016/03/23/ProxyChains-NG-ShadowSocks-实现终端代理/</id>
    <published>2016-03-23T00:25:31.000Z</published>
    <updated>2019-12-07T06:07:38.529Z</updated>
    
    <content type="html"><![CDATA[<p>经常在终端下执行一些网络命令，例如 <code>wget</code> 、<code>git</code>、<code>ssh</code> 等命令，速度慢的不行，说白了，有些是因为 GFW 的原因，有些则是访问国外的服务器本来速度就很慢，而我们的 ShadowSocks 提供的是 <code>socks5</code> 代理，终端无法享用。这个时候 <strong>ProxyChains-NG</strong> 应势而生。<br><a id="more"></a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>使用 <a href="http://brew.sh/index_zh-cn.html" target="_blank" rel="noopener">brew</a> 快速安装 ProxyChains-NG，想详细了解 ProxyChains-NG 可以去他们<a href="https://github.com/rofl0r/proxychains-ng" target="_blank" rel="noopener">项目主页</a>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install proxychains-ng</span><br></pre></td></tr></table></figure></p><p>配置<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/<span class="built_in">local</span>/etc/proxychains.conf</span><br></pre></td></tr></table></figure></p><p>添加代理<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socks5  127.0.0.1 1080</span><br></pre></td></tr></table></figure></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>到此为止，整个命令安装完成，用法 <code>proxychains4 需要执行的命令</code>。举个例子：执行下面的命令后，可以看到是 ss 的 IP 了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 curl ip.cn</span><br></pre></td></tr></table></figure></p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>这个命令太长了，我想换一个！我使用的是 zsh，来给 <code>proxychains4</code> 配置一个别名吧！:P<br>编辑 zsh 配置文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.zshrc</span><br></pre></td></tr></table></figure></p><p>添加别名<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> myss=<span class="string">'proxychains4'</span></span><br></pre></td></tr></table></figure></p><p>让配置生效<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure></p><p>再执行之前查看 ip 的命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myss curl ip.cn</span><br></pre></td></tr></table></figure></p><p>Have done! :)</p><h3 id="测速"><a href="#测速" class="headerlink" title="测速"></a>测速</h3><p>使用 speedtest 的命令行工具，来测上行宽带和下行宽度。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载 speedtest-cli</span></span><br><span class="line">wget -O speedtest-cli https://raw.githubusercontent.com/sivel/speedtest-cli/master/speedtest.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给执行权限</span></span><br><span class="line">chmod +x speedtest-cli</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行</span></span><br><span class="line">./speedtest-cli</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试下代理的速度</span></span><br><span class="line">myss ./speedtest-cli</span><br></pre></td></tr></table></figure></p><h4 id="附：brew-常用命令"><a href="#附：brew-常用命令" class="headerlink" title="附：brew 常用命令"></a>附：brew 常用命令</h4><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">安装包</td><td style="text-align:left">brew install <code>&lt;PackageName&gt;</code></td></tr><tr><td style="text-align:left">搜索包</td><td style="text-align:left">brew search <code>&lt;PackageName&gt;</code></td></tr><tr><td style="text-align:left">查询包信息</td><td style="text-align:left">brew info <code>&lt;PackageName&gt;</code></td></tr><tr><td style="text-align:left">升级指定包</td><td style="text-align:left">brew upgrade <code>&lt;PackageName&gt;</code></td></tr><tr><td style="text-align:left">更新自己</td><td style="text-align:left">brew update</td></tr><tr><td style="text-align:left">检查过时包</td><td style="text-align:left">brew outdated</td></tr><tr><td style="text-align:left">升级所有包</td><td style="text-align:left">brew upgrade</td></tr><tr><td style="text-align:left">清理缓存</td><td style="text-align:left">brew cleanup</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;经常在终端下执行一些网络命令，例如 &lt;code&gt;wget&lt;/code&gt; 、&lt;code&gt;git&lt;/code&gt;、&lt;code&gt;ssh&lt;/code&gt; 等命令，速度慢的不行，说白了，有些是因为 GFW 的原因，有些则是访问国外的服务器本来速度就很慢，而我们的 ShadowSocks 提供的是 &lt;code&gt;socks5&lt;/code&gt; 代理，终端无法享用。这个时候 &lt;strong&gt;ProxyChains-NG&lt;/strong&gt; 应势而生。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>一段神奇的 CSS 调试代码</title>
    <link href="http://ifyour.github.io/2016/03/22/%E4%B8%80%E6%AE%B5%E7%A5%9E%E5%A5%87%E7%9A%84-CSS-%E8%B0%83%E8%AF%95%E4%BB%A3%E7%A0%81/"/>
    <id>http://ifyour.github.io/2016/03/22/一段神奇的-CSS-调试代码/</id>
    <published>2016-03-22T08:32:52.000Z</published>
    <updated>2019-12-07T06:07:38.533Z</updated>
    
    <content type="html"><![CDATA[<p>现在到处都是 JavaScript，倘若花点时间去深入分析，每次都能学到点新的东西。当我发现些有意思的东西，习惯先收藏起来。等时技（时间＋技术）成熟，再去 Review 他们的代码，看一看它们是如何做到的，览一览大牛们的 “奇技淫巧”。<br><a id="more"></a></p><h3 id="代码片段"><a href="#代码片段" class="headerlink" title="代码片段"></a>代码片段</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[].forEach.call($$(<span class="string">"*"</span>),<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    a.style.outline=<span class="string">"1px solid #"</span>+(~~(<span class="built_in">Math</span>.random()*(<span class="number">1</span>&lt;&lt;<span class="number">24</span>))).toString(<span class="number">16</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在浏览器控制台运行此段代码，会给页面里所有的 DOM 元素添加一个 1px 的描边（outline），方便我们在调试 CSS 过程中分析、排查问题。<br><img src="http://ww1.sinaimg.cn/large/6057861cgy1fbzi0vggl6j21kw0vyq8s.jpg" alt></p><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>这段代码是 Github 上的 140 Bytes 活动中的代码，简单分析下这段 JS 代码，作者使用了不少技巧：</p><p>首先是需要选择页面上的所有元素，这里使用了只能在 Console 调试工具中使用的 <code>$$</code> 函数，你可以在 Console 中输入 <code>$$(&#39;a&#39;)</code> 自己试一下。它会返回当前页面的所有 anchor（链接）元素。<code>$$</code> 与 <code>document.querySelectorAll</code> 是等价的，有兴趣可<a href="http://ourjs.com/detail/54ab768a5695544119000007" target="_blank" rel="noopener">查看</a> $$ 和 $ 选择器的历史。</p><p>其次遍历所有元素，这里用的是 <code>[].forEach.call(...)</code>，使用 forEach 替代 for 之类循环能减少不少代码量，而 forEach 是 Array 对象的方法，所以用了个 <code>[]</code> 空数组来代替 <code>Array.prototype</code> 更显简洁，得到所有元素的节点列表（NodeList），但是它并没有实现 Array 的所有接口，因此使用 <code>$$(&quot;*&quot;).forEach</code> 会返回错误，这里使用 <code>call</code> 方法来更改 forEach 内部 <code>this</code> 指向，当然也可以使用 <code>apply</code>。</p><p>之后就是让元素有一个漂亮的边框，并拥有不同的颜色了。在 CSS 渲染的盒子模型（Box Model）中，<code>outline</code> <strong><em>并不会改变元素及其布局的位置</em></strong>。这里较有意思的是定义不同的颜色的色值：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~(<span class="built_in">Math</span>.random()*(<span class="number">1</span>&lt;&lt;<span class="number">24</span>))).toString(<span class="number">16</span>)</span><br></pre></td></tr></table></figure></p><p>这里想构造的其实是一个 16 进制的颜色值，即 <code>000000～ffffff</code>，也就是 <code>parseInt(&#39;0&#39;,16)</code> 到 <code>parseInt(&#39;ffffff&#39;,16)</code> 之间的一个值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'ffffff'</span>,<span class="number">16</span>) == <span class="number">16777215</span> == (<span class="number">2</span>^<span class="number">24</span><span class="number">-1</span>) == (<span class="number">1</span>&lt;&lt;<span class="number">24</span> - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>而 <code>Math.random()</code>，得到的是一个 0~1 之间的浮点数，<code>(Math.random()*(1&lt;&lt;24)</code>，即得到 0~16777215 之间的浮点数，而色值是需要整数的，所以就需要将浮点数进行 int 转换。这里用到了 <code>~~</code>，可<a href="http://www.jeffjade.com/2015/05/31/2015-05-31-javascript-operational%EF%BC%8Dsymbol/" target="_blank" rel="noopener">参见</a>理解 JavaScript 非运算符(~/~~ )。当然可以将 <code>~~</code> 视为 <code>parseInt</code> 的简写。并且使用按位或 <code>|</code> 操作符也可以得到相同的结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1.234567890</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">0.000000001</span>;</span><br><span class="line">~~a == <span class="number">0</span>|a == <span class="built_in">parseInt</span>(a, <span class="number">10</span>) == <span class="number">1</span></span><br><span class="line">~~b == <span class="number">0</span>|b == <span class="built_in">parseInt</span>(b, <span class="number">10</span>) == <span class="number">0</span></span><br></pre></td></tr></table></figure><p><code>toString(16)</code> 使用数字类型的 <code>toString</code> 方法进行十进制到 16 进制的转换。至此我们得到了一个 0 到 16777215 之间的随机数，然后使用 <code>toString(16)</code> 转换成 16 进制，将此值赋予到页面上所有元素节点的 <code>outline</code> 附加属性上。它就是这样工作的。精致巧妙而且非常实用，顶一个！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在到处都是 JavaScript，倘若花点时间去深入分析，每次都能学到点新的东西。当我发现些有意思的东西，习惯先收藏起来。等时技（时间＋技术）成熟，再去 Review 他们的代码，看一看它们是如何做到的，览一览大牛们的 “奇技淫巧”。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript 中的 this 用法总结</title>
    <link href="http://ifyour.github.io/2016/02/19/JavaScript-%E4%B8%AD%E7%9A%84-this-%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://ifyour.github.io/2016/02/19/JavaScript-中的-this-用法总结/</id>
    <published>2016-02-19T11:23:36.000Z</published>
    <updated>2019-12-07T06:07:38.529Z</updated>
    
    <content type="html"><![CDATA[<p><code>this</code> 是 Javascript 语言的一个关键字。它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。随着函数使用场合的不同，<code>this</code> 的值会发生变化。但是有一个总的原则，那就是 <code>this</code> 指的是，调用函数的那个对象。</p><a id="more"></a><h3 id="四种情况"><a href="#四种情况" class="headerlink" title="四种情况"></a>四种情况</h3><h4 id="纯粹的函数调用"><a href="#纯粹的函数调用" class="headerlink" title="纯粹的函数调用"></a>纯粹的函数调用</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eg:1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>);<span class="comment">// =&gt; window 对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// eg:2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// =&gt; 1</span></span><br><span class="line"><span class="comment">// this 指向全局对象，即 DOM 中的 window 对象</span></span><br></pre></td></tr></table></figure><h4 id="作为对象方法的调用"><a href="#作为对象方法的调用" class="headerlink" title="作为对象方法的调用"></a>作为对象方法的调用</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user = &#123;</span><br><span class="line">    count: <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">    getCount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(user.getCount());<span class="comment">// 1</span></span><br><span class="line"><span class="comment">// this 指向调用 getCount 方法的对象 user</span></span><br></pre></td></tr></table></figure><h4 id="作为构造函数的调用"><a href="#作为构造函数的调用" class="headerlink" title="作为构造函数的调用"></a>作为构造函数的调用</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> fun();</span><br><span class="line"><span class="built_in">console</span>.log(obj.x); <span class="comment">// =&gt; 1</span></span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// =&gt; 2</span></span><br><span class="line"><span class="comment">//this 就指向构造器创建的新对象 obj</span></span><br></pre></td></tr></table></figure><h4 id="apply-call-调用"><a href="#apply-call-调用" class="headerlink" title="apply/call 调用"></a>apply/call 调用</h4><p><code>apply()</code> 是函数对象的一个方法，它的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象，无参数时传入 window 对象。因此，<code>this</code> 指的就是这第一个参数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.x = <span class="number">1</span>;</span><br><span class="line">obj.m = fun;</span><br><span class="line"></span><br><span class="line">obj.m(); <span class="comment">//           =&gt; 1  this 指向调用方法的对象即：obj</span></span><br><span class="line">obj.m.apply();  <span class="comment">//    =&gt; 0  this 指向的是全局对象即：window</span></span><br><span class="line">obj.m.apply(obj);<span class="comment">//   =&gt; 1  this 指向的第一个参数即：obj</span></span><br><span class="line">obj.m.call(obj);<span class="comment">//    =&gt; 1  this 指向的第一个参数即：obj</span></span><br></pre></td></tr></table></figure></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>纯粹的函数调用: <code>this</code> 就代表全局对象 Global（浏览器下就是 window）</li><li>作为对象方法的调用: <code>this</code> 指向调用方法的对象</li><li>作为构造函数调用：<code>this</code> 就指向构造器创建的新对象</li><li><code>apply</code>, <code>call</code> 调用：<code>this</code> 指向就是这些函数的第一个参数</li></ol><p>下一篇文章总结一下：<code>apply</code>、<code>call</code>、<code>bind</code> 的用法 :P</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;this&lt;/code&gt; 是 Javascript 语言的一个关键字。它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。随着函数使用场合的不同，&lt;code&gt;this&lt;/code&gt; 的值会发生变化。但是有一个总的原则，那就是 &lt;code&gt;this&lt;/code&gt; 指的是，调用函数的那个对象。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
