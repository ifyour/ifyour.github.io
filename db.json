{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/favicon.ico","path":"favicon.ico","modified":0,"renderable":0},{"_id":"themes/hexo-theme-apollo/source/favicon.png","path":"favicon.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-apollo/source/css/apollo.css","path":"css/apollo.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-apollo/source/font/sourcesanspro.woff","path":"font/sourcesanspro.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-apollo/source/font/sourcesanspro.woff2","path":"font/sourcesanspro.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-apollo/source/scss/apollo.scss","path":"scss/apollo.scss","modified":0,"renderable":1}],"Cache":[{"_id":"themes/hexo-theme-apollo/.gitignore","hash":"a006beea0877a0aa3610ee00e73f62cb1d45125b","modified":1529228970000},{"_id":"themes/hexo-theme-apollo/LICENSE","hash":"6e31ac9076bfc8f09ae47977419eee4edfb63e5b","modified":1529228970000},{"_id":"source/favicon.ico","hash":"10df6f583311f8533e055ab21ad1be9eb3a7d80d","modified":1529228970000},{"_id":"themes/hexo-theme-apollo/README.md","hash":"201c76d030a98578ed5a6ad5c766a7bde91c32d3","modified":1529228970000},{"_id":"themes/hexo-theme-apollo/_config.yml","hash":"6b35d2a1c948621f20298fe60602a90f1e8e8877","modified":1529228970000},{"_id":"themes/hexo-theme-apollo/gulpfile.js","hash":"857a026b6643a2cd52c65d4ae0dc7fe9618206ee","modified":1529228970000},{"_id":"themes/hexo-theme-apollo/package.json","hash":"dee40ba0d89f70bf47d63f0bece41226baa6d592","modified":1529228970000},{"_id":"source/_posts/7招轻松搞定-JavaScript-多行字符串拼接.md","hash":"9f44011273ddbd72ef37179f84bc77f255941ef3","modified":1529228970000},{"_id":"source/_posts/CentOS-6-x86-Node-js-MongoDB-Express-环境配置笔记.md","hash":"0dd99e65f66f722d645a823f910551a567239c72","modified":1529228970000},{"_id":"source/_posts/ES6-Promise-简明指南.md","hash":"1a5b115ff8db5054ba8170c4ac26bf0218ecd1c6","modified":1529228970000},{"_id":"source/_posts/Git-操作详细总结.md","hash":"67100f507fb33044881e49890bc80694e3c31bd1","modified":1529228970000},{"_id":"themes/hexo-theme-apollo/yarn.lock","hash":"8a6b065e679c598c09e61e090d5579499bbdcc3d","modified":1529228970000},{"_id":"source/_posts/JavaScript-中的-this-用法总结.md","hash":"9aac09ce6e26627426898d9b3039447495777be6","modified":1529228970000},{"_id":"source/_posts/Mongodb-学习笔记----增删改查.md","hash":"e30b8c0b1fee1f2388513244c72f6d88f50cdf78","modified":1529228970000},{"_id":"source/_posts/Node.JS-学习笔记-[01]----入门.md","hash":"81d3a168d27f0b0c1aefb67a5e95b331239f1b96","modified":1529228970000},{"_id":"source/_posts/Node.JS-学习笔记-[02]----同步异步.md","hash":"af63eb5983f1e82a3f3be435286992ef42ef0b53","modified":1529228970000},{"_id":"source/_posts/Node.JS-学习笔记-[03]----Buffer-fs-path.md","hash":"e82c5de197792c6ee5d9eca5acd34b6f5af4d618","modified":1529228970000},{"_id":"source/_posts/Node.JS-学习笔记-[04]----HTTP.md","hash":"5732c4a6a0b5cfbe98e1f781d6ba713e4f7ba967","modified":1529228970000},{"_id":"source/_posts/Node.JS-学习笔记-[05]----Express.md","hash":"c1db8ab0fc866df9bdc0f2b6d53dd7b6f25a91fe","modified":1529228970000},{"_id":"source/_posts/ProxyChains-NG + ShadowSocks 实现终端代理.md","hash":"605995615e4e36dc1d62569dcfc6ff07eb0e4f3f","modified":1529228970000},{"_id":"source/_posts/React-组件模式.md","hash":"66a160679f2dfa79c07bfe7241bd830f6d66660a","modified":1529228970000},{"_id":"source/_posts/Why-Immutable-Data.md","hash":"28f2cda7c0cf672ec2cc5c4cafb8afa05d854b97","modified":1529228970000},{"_id":"source/_posts/代码重构.md","hash":"76ebe9c8c0af69549e58db14337d3bc285b943ab","modified":1529239127000},{"_id":"source/_posts/call、apply、bind-的区别及应用.md","hash":"a94d9ae6eb6a4c1c2f92e0f20600a190882af430","modified":1529228970000},{"_id":"source/_posts/一段神奇的-CSS-调试代码.md","hash":"af5eb08ecfa0decf557a35fec2ef7d8c7e1f9827","modified":1529228970000},{"_id":"source/_posts/持续集成-CI-及简单实践.md","hash":"bd5c47acf28494bcb96241dfbddb70ef9f79a7e1","modified":1529228970000},{"_id":"source/_posts/如何避免-async-await-地狱.md","hash":"23f232f0345ceec631edd80a681a690c6a7e3bbb","modified":1529228970000},{"_id":"source/_posts/浏览器跨域请求数据总结.md","hash":"d7cc336bcbbb988423500c2e429622492e69b826","modified":1529228970000},{"_id":"source/_posts/给小白读的-WEB-托管服务进化史.md","hash":"681f629a67ee4c4e1b2907296e95fa92592927a8","modified":1529228970000},{"_id":"source/about/index.md","hash":"7cfbcf09b4085801762ba5161589a295961c7703","modified":1529228970000},{"_id":"source/docs/index.md","hash":"97e5e0c56e91f300d6a03276d1fab7f3e5623185","modified":1529228970000},{"_id":"source/categories/index.md","hash":"fe4bebea66d0ac9f7f2b961a0a55b5dbee2eae88","modified":1529228970000},{"_id":"source/upload/fetch.min.js","hash":"36bfa4b7953ddf6db8c9c1471139c0ee775a037b","modified":1529228970000},{"_id":"themes/hexo-theme-apollo/doc/doc-en.md","hash":"fc0a961b1fe5bf40c0347df28eab4205a0fae316","modified":1529228970000},{"_id":"themes/hexo-theme-apollo/doc/doc-zh.md","hash":"e6151b25d3abba657e0c57aab98b95275cfd9355","modified":1529228970000},{"_id":"themes/hexo-theme-apollo/languages/en.yml","hash":"ca168b190932229884db1de755ec2f793c758a16","modified":1529228970000},{"_id":"themes/hexo-theme-apollo/languages/zh-cn.yml","hash":"22a2d16fe8c0dddb016b5325b9b9c182a1b49ae1","modified":1529228970000},{"_id":"themes/hexo-theme-apollo/layout/archive.jade","hash":"62797414355bf4474092bc3a32726c8340820ffb","modified":1529228970000},{"_id":"themes/hexo-theme-apollo/layout/index.jade","hash":"55f2f1b4b5364a0e09cb18e1112664c6415fb881","modified":1529228970000},{"_id":"themes/hexo-theme-apollo/layout/post.jade","hash":"245c26244c075c3632d1545c3b228ee9d112f15d","modified":1529228970000},{"_id":"themes/hexo-theme-apollo/source/favicon.png","hash":"a9cdcb22d1e74d5480323e19d1983de5a6873b8c","modified":1529228970000},{"_id":"themes/hexo-theme-apollo/layout/mixins/paginator.jade","hash":"f4ee2fb61a32e199b48cf93771749edc8a007391","modified":1529228970000},{"_id":"themes/hexo-theme-apollo/layout/mixins/post.jade","hash":"bdf9595ab8a581862c1344360fe656381f69887c","modified":1529228970000},{"_id":"themes/hexo-theme-apollo/layout/partial/comment.jade","hash":"1cf2ae3fb1d8fb5914280337f1564525f3dd9409","modified":1529228970000},{"_id":"themes/hexo-theme-apollo/layout/partial/copyright.jade","hash":"df74de116edf92d00f3a33914dc8f82b45bcc9ab","modified":1529228970000},{"_id":"themes/hexo-theme-apollo/layout/partial/head.jade","hash":"43d2db73f0247a9a3ed00ecb95b537a872b7201a","modified":1529228970000},{"_id":"themes/hexo-theme-apollo/layout/partial/layout.jade","hash":"529c2ec06cfbc3d5b6d66dd320db50dfab5577a6","modified":1529228970000},{"_id":"themes/hexo-theme-apollo/layout/partial/nav.jade","hash":"1473b86269497af34edc5e3741db2d4c5e4656cf","modified":1529228970000},{"_id":"themes/hexo-theme-apollo/layout/partial/scripts.jade","hash":"6bff591ae3d1ff6750f239c4c933ad61f009f36a","modified":1529228970000},{"_id":"themes/hexo-theme-apollo/source/css/apollo.css","hash":"4a00f3214073a2c5da7299ee14e2ae169ad86fca","modified":1529228970000},{"_id":"themes/hexo-theme-apollo/source/font/sourcesanspro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1529228970000},{"_id":"themes/hexo-theme-apollo/source/font/sourcesanspro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1529228970000},{"_id":"themes/hexo-theme-apollo/source/scss/apollo.scss","hash":"20ed9505718c7365282f0ebc78ef505eea14d2f1","modified":1529228970000},{"_id":"themes/hexo-theme-apollo/source/scss/_partial/archive-post-list.scss","hash":"d2f740a7d48349b7536777c795f82ab740836d0f","modified":1529228970000},{"_id":"themes/hexo-theme-apollo/source/scss/_partial/base.scss","hash":"5f1b5987f8cf1bea0b9430003179a0635e109bd5","modified":1529228970000},{"_id":"themes/hexo-theme-apollo/source/scss/_partial/copyright.scss","hash":"cd0fcc9cf01317eb02fd4b71046ddeb2facb5811","modified":1529228970000},{"_id":"themes/hexo-theme-apollo/source/scss/_partial/footer.scss","hash":"094aca6e52f11b139ac7980ca03fa7b9d8fc7b2f","modified":1529228970000},{"_id":"themes/hexo-theme-apollo/source/scss/_partial/git-comment.scss","hash":"f8a680e4b53209c15a66644fbaceb8543eff8900","modified":1529228970000},{"_id":"themes/hexo-theme-apollo/source/scss/_partial/header.scss","hash":"153bde88bf8ffeae4ffd813d8cc694dd83d33d94","modified":1529228970000},{"_id":"themes/hexo-theme-apollo/source/scss/_partial/mq.scss","hash":"d456417a9f1ded95ff39dab63d4a6d22bb396246","modified":1529228970000},{"_id":"themes/hexo-theme-apollo/source/scss/_partial/home-post-list.scss","hash":"6b5c59f3d2295944f934aee2c1156012a3306d5d","modified":1529228970000},{"_id":"themes/hexo-theme-apollo/source/scss/_partial/post.scss","hash":"33622fad24cc1d21397fd6b24ddd8737feb5fbc1","modified":1529228970000},{"_id":"themes/hexo-theme-apollo/source/scss/_partial/normalize.scss","hash":"fd0b27bed6f103ea95b08f698ea663ff576dbcf1","modified":1529228970000},{"_id":"public/upload/fetch.min.js","hash":"d1d8e61809354e9fc4311032ee422f41a670510c","modified":1529239158652},{"_id":"public/atom.xml","hash":"b186e55bbc5b354cb3350842158c32ddd7e9d887","modified":1529239158658},{"_id":"public/sitemap.xml","hash":"068cfabe5fa570077d7485a2675b9423f1381d79","modified":1529239158659},{"_id":"public/about/index.html","hash":"ef58494a944dae00e4cb6153cac83913162f80da","modified":1529239158663},{"_id":"public/docs/index.html","hash":"c89b161864ad0c5903a8ce492c467b1045b2d9da","modified":1529239158663},{"_id":"public/categories/index.html","hash":"1dfaf62516a8098a97771ad25224afaa577eacb2","modified":1529239158663},{"_id":"public/2018/05/20/如何避免-async-await-地狱/index.html","hash":"e53ebd266da6c55d8d9400c500feab77f9ceb4b2","modified":1529239158663},{"_id":"public/2018/05/11/Git-操作详细总结/index.html","hash":"6b55f58159b1cd0662dfcb75a3ec3d3d6defa907","modified":1529239158663},{"_id":"public/2018/04/30/持续集成-CI-及简单实践/index.html","hash":"38c472d0fe091106807dc85290cb363f159d63c8","modified":1529239158663},{"_id":"public/2016/03/23/ProxyChains-NG + ShadowSocks 实现终端代理/index.html","hash":"0f364b3adbc3ff3832511aef2ab48362438489fd","modified":1529239158663},{"_id":"public/2016/03/22/一段神奇的-CSS-调试代码/index.html","hash":"277b476a49530d6bd85e6ce61046b8c8f9228051","modified":1529239158663},{"_id":"public/2016/02/19/JavaScript-中的-this-用法总结/index.html","hash":"9c8c42af086c6e31ae8c46de37899f206b1e897a","modified":1529239158663},{"_id":"public/2016/01/19/浏览器跨域请求数据总结/index.html","hash":"e5527c97580f003df40cc5c9413caf139a9acc65","modified":1529239158663},{"_id":"public/2016/01/06/7招轻松搞定-JavaScript-多行字符串拼接/index.html","hash":"2b8a87699e52b692fbac43160edbeb96cde0a950","modified":1529239158663},{"_id":"public/2015/01/02/Node.JS-学习笔记-[01]----入门/index.html","hash":"35b83a2e50fb6cbd6a40ea1ed1a5af1099498d97","modified":1529239158664},{"_id":"public/2015/01/01/CentOS-6-x86-Node-js-MongoDB-Express-环境配置笔记/index.html","hash":"5ff2d001d0a6cf32a5081d6456279bf8e7e17ce3","modified":1529239158664},{"_id":"public/archives/index.html","hash":"cb3cfde2397fb5b3558ed63a58b0d803b169f08f","modified":1529239158664},{"_id":"public/archives/page/2/index.html","hash":"f078968b2ecaf151f032c438c86be29acda61f4b","modified":1529239158664},{"_id":"public/archives/page/3/index.html","hash":"06f4470eef4fc7f64d3878fbc54ea8d895c0b2b6","modified":1529239158664},{"_id":"public/archives/2015/index.html","hash":"401a82b552210212f33c194210adb0be3bfd2917","modified":1529239158664},{"_id":"public/archives/2015/01/index.html","hash":"401a82b552210212f33c194210adb0be3bfd2917","modified":1529239158664},{"_id":"public/archives/2016/index.html","hash":"3c9a12d380169eaf838f4e71a4c689bc69054dc6","modified":1529239158664},{"_id":"public/archives/2016/01/index.html","hash":"36b0ce5388bbaf1fa086799b7d807b6d38cc0825","modified":1529239158664},{"_id":"public/archives/2016/02/index.html","hash":"59e3b6e32ce45fcb8f5d0a57a8cff92466af0d8a","modified":1529239158664},{"_id":"public/archives/2016/03/index.html","hash":"765ee0148c29d52bea31d92dce26c2009916e844","modified":1529239158664},{"_id":"public/archives/2018/index.html","hash":"722d47d8febca3f45c8672c4f26fb64874a78936","modified":1529239158664},{"_id":"public/archives/2018/04/index.html","hash":"767648aacab34f130f7591939580e85fa9e3f745","modified":1529239158665},{"_id":"public/archives/2018/05/index.html","hash":"43622a68438c006eee087975f9f520f8317c911a","modified":1529239158665},{"_id":"public/archives/2018/06/index.html","hash":"642ae6cc6eb2646f86a69d987180c9cdc80bfd3c","modified":1529239158665},{"_id":"public/index.html","hash":"67eb2a814dee4438b787888f0c9a5ee9e4ab7d63","modified":1529239158665},{"_id":"public/page/2/index.html","hash":"c1227da8d019be7a07b5817c96193b6f51bbc3ab","modified":1529239158665},{"_id":"public/page/3/index.html","hash":"f33a9107e5720d36760b8820c3b4e75c24174f4a","modified":1529239158665},{"_id":"public/2018/06/16/代码重构/index.html","hash":"017871aaf2fe6e83add1fe9fad1c43fc6135e208","modified":1529239158665},{"_id":"public/2018/06/09/给小白读的-WEB-托管服务进化史/index.html","hash":"1a2a47090fbada5f49f7f16d2eb6297ec14902fa","modified":1529239158665},{"_id":"public/2018/05/29/ES6-Promise-简明指南/index.html","hash":"e507c4751b84f87683d1fe61c7b8260abfbf92fd","modified":1529239158665},{"_id":"public/2018/05/16/React-组件模式/index.html","hash":"13f1dab5919fe9d57cd93c765c9c4e7b2d3a3d17","modified":1529239158665},{"_id":"public/2018/05/05/Why-Immutable-Data/index.html","hash":"b9c99e0576046a19d78c6bedc11da27435082bef","modified":1529239158665},{"_id":"public/2016/03/26/call、apply、bind-的区别及应用/index.html","hash":"c99901e61005338ed62b140f44676c873d2279de","modified":1529239158666},{"_id":"public/2016/01/05/Mongodb-学习笔记----增删改查/index.html","hash":"9dd76d1ddbb660a51f194339b4fc61b3f74be4fa","modified":1529239158666},{"_id":"public/2015/01/06/Node.JS-学习笔记-[05]----Express/index.html","hash":"f99cae87c296ba8f27bf09bed0a3b935d7a3bcbd","modified":1529239158666},{"_id":"public/2015/01/05/Node.JS-学习笔记-[04]----HTTP/index.html","hash":"1780f5896e27468043f32e80f6b16b5700e14e96","modified":1529239158666},{"_id":"public/2015/01/04/Node.JS-学习笔记-[03]----Buffer-fs-path/index.html","hash":"a7948314c2351578cc1905876920b1946973cd24","modified":1529239158666},{"_id":"public/2015/01/03/Node.JS-学习笔记-[02]----同步异步/index.html","hash":"7c91277afe250470b870913b57debf79a9b25687","modified":1529239158666},{"_id":"public/favicon.ico","hash":"10df6f583311f8533e055ab21ad1be9eb3a7d80d","modified":1529239158671},{"_id":"public/favicon.png","hash":"a9cdcb22d1e74d5480323e19d1983de5a6873b8c","modified":1529239158672},{"_id":"public/font/sourcesanspro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1529239158672},{"_id":"public/font/sourcesanspro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1529239158673},{"_id":"public/scss/apollo.scss","hash":"20ed9505718c7365282f0ebc78ef505eea14d2f1","modified":1529239158673},{"_id":"public/css/apollo.css","hash":"4a00f3214073a2c5da7299ee14e2ae169ad86fca","modified":1529239158681}],"Category":[],"Data":[],"Page":[{"title":"About Me","date":"2018-04-30T03:14:00.000Z","comments":0,"_content":"\n```js\nlet me = {\n    name    : 'Willard Wong',\n    gender  : 'male',\n    age     :  26,\n    job     : 'Front-end Developer',\n    Hobbies : ['watch movie', 'reading', 'photography', 'write code'],\n    email   : 'ifyour{at}outlook.com'\n};\n```\n\n> *念念不忘, 必有回响!*\n","source":"about/index.md","raw":"---\ntitle: About Me\ndate: 2018-04-30 11:14:00\ncomments: false\n---\n\n```js\nlet me = {\n    name    : 'Willard Wong',\n    gender  : 'male',\n    age     :  26,\n    job     : 'Front-end Developer',\n    Hobbies : ['watch movie', 'reading', 'photography', 'write code'],\n    email   : 'ifyour{at}outlook.com'\n};\n```\n\n> *念念不忘, 必有回响!*\n","updated":"2018-06-17T09:49:30.000Z","path":"about/index.html","layout":"page","_id":"cjiitidi00001u4q95xohu3pj","content":"<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> me = &#123;</span><br><span class=\"line\">    name    : <span class=\"string\">'Willard Wong'</span>,</span><br><span class=\"line\">    gender  : <span class=\"string\">'male'</span>,</span><br><span class=\"line\">    age     :  <span class=\"number\">26</span>,</span><br><span class=\"line\">    job     : <span class=\"string\">'Front-end Developer'</span>,</span><br><span class=\"line\">    Hobbies : [<span class=\"string\">'watch movie'</span>, <span class=\"string\">'reading'</span>, <span class=\"string\">'photography'</span>, <span class=\"string\">'write code'</span>],</span><br><span class=\"line\">    email   : <span class=\"string\">'ifyour&#123;at&#125;outlook.com'</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><em>念念不忘, 必有回响!</em></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> me = &#123;</span><br><span class=\"line\">    name    : <span class=\"string\">'Willard Wong'</span>,</span><br><span class=\"line\">    gender  : <span class=\"string\">'male'</span>,</span><br><span class=\"line\">    age     :  <span class=\"number\">26</span>,</span><br><span class=\"line\">    job     : <span class=\"string\">'Front-end Developer'</span>,</span><br><span class=\"line\">    Hobbies : [<span class=\"string\">'watch movie'</span>, <span class=\"string\">'reading'</span>, <span class=\"string\">'photography'</span>, <span class=\"string\">'write code'</span>],</span><br><span class=\"line\">    email   : <span class=\"string\">'ifyour&#123;at&#125;outlook.com'</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><em>念念不忘, 必有回响!</em></p>\n</blockquote>\n"},{"title":"工具及文档","date":"2018-05-06T03:56:00.000Z","comments":1,"_content":"\n### Interesting tools\n\n* [Rico's cheatsheets](https://devhints.io/) - 记忆小抄, 长话短说各种开发文档\n* [Carbon](https://carbon.now.sh/) - 带样式分享代码\n* [Codepan](https://codepan.net/) - 在线测试前端代码, 可以离线使用\n* [jsFiddle](https://jsfiddle.net/) - 同上, 注册账号后可以保存代码\n* [Prettier](https://prettier.io/playground/) - 在线格式化 JavaScript 代码\n* [Text-formatter](https://text-formatter.herokuapp.com/) - 格式化文本, 中英文之间留空格以及英文标点\n* [DevDocs](https://devdocs.io/) - 一站式开发文档集合\n* [Grammarly](https://app.grammarly.com/ddocs/261389934) - 英文语法错误检查\n* [JSONPlaceholder](http://jsonplaceholder.typicode.com/) - RESTful API 假数据模拟\n* [JSON2YAML](https://www.json2yaml.com/) - JSON 和 YAML 互转\n* [JSON Parser](http://json.parser.online.fr/beta/) - JSON 格式化\n* [RegExr](https://regexr.com/) - 在线正则测试及调试\n* [Regulex](https://jex.im/regulex/) - 正则表达可视化, 快速理解正则表达式\n* [CSSMatic](https://www.cssmatic.com/) - 生成镜像渐变, 盒子阴影等\n* [SassMeister](https://www.sassmeister.com/) - Sass 演练场, 可以输出 AutoPrefixer 的结果\n* [KeyframesApp](https://keyframes.app/) - CSS3 动画关键帧生成工具\n* [CSS Sprites Generator](https://www.toptal.com/developers/css/sprite-generator) - CSS 精灵生成工具\n* [JSNice](http://www.jsnice.org/) - 反编译已压缩的 JS 代码, 理解变量是什么意思\n* [Love2.io](https://love2.io/) - 开源技术文档分享平台\n* [WakaTime](https://wakatime.com/) - 记录每天的编码情况, 使用什么语言及统计时长\n* [蓝湖](https://lanhuapp.com/) - 高效的产品设计协作平台, 标注切图很好用\n\n### Docs\n\n* **React**\n\n  * [React 中文文档](https://doc.react-china.org/docs/hello-world.html)\n  * [Redux 中文文档](https://www.kancloud.cn/allanyu/redux-in-chinese/82399)\n  * [React-saga 中文文档](http://leonshi.com/redux-saga-in-chinese/docs/api/index.html)\n  * [React-router 中文文档](https://react-guide.github.io/react-router-cn)\n  * [Mobx 中文文档](https://suprise.gitbooks.io/mobx-cn/content/fp.html)\n  * [Ant-design 文档](https://ant.design/docs/react/introduce-cn)\n  * [React-Native 文档](http://reactnative.cn/docs/0.50/getting-started.html)\n\n* **Vue.js**\n\n  * [Vue.js 官网](https://cn.vuejs.org/v2/guide/)\n  * [Vue-Router](https://router.vuejs.org/zh-cn/)\n  * [Vuex](https://vuex.vuejs.org/zh-cn/)\n  * [Vue-SSR 服务器端渲染](https://ssr.vuejs.org/zh/)\n  * [Vue-NUXT](https://zh.nuxtjs.org/guide/installation)\n\n* **Node.js**\n\n  * [Node.js API](http://nodejs.cn/api/)\n  * [Express 官网](http://www.expressjs.com.cn/guide/routing.html)\n\n* **Electron**\n\n  * [Electron 官方文档](https://electronjs.org/docs/)\n\n* **WeChat**\n\n  * [小程序官方文档](https://mp.weixin.qq.com/debug/wxadoc/dev/index.html?t=201832)\n\n* **TypeScript**\n\n  * [TypeScript 中文网](https://www.tslang.cn/index.html)\n\n* **Vanilla JS**\n\n  * [JavaScript 基础进阶系列](https://segmentfault.com/a/1190000012646488)\n  * [深入理解 JS 异步](https://github.com/wangfupeng1988/js-async-tutorial)\n  * [深入理解 JS (Tom)](https://www.cnblogs.com/tomxu/archive/2011/12/15/2288411.html)\n\n* **Webpack**\n\n  * [Webpack 3.x](http://www.css88.com/doc/webpack/)\n  * [Webpack 2.x](http://www.css88.com/doc/webpack2/api/loaders/#version)\n\n* **Python**\n\n  * [Python 3 教程 (廖雪峰)](https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000)\n  * [Django 中文文档](https://docs.djangoproject.com/zh-hans/2.0/)\n\n* **More...**\n  * [印记中文](https://docschina.org/)\n\n### One more thing\n\n欢迎在下面留言板分享你觉得有趣的所有东西, 本文[源代码地址](https://raw.githubusercontent.com/ifyour/ifyour.github.io/src/source/docs/index.md). 😎\n","source":"docs/index.md","raw":"---\ntitle: 工具及文档\ndate: 2018-05-06 11:56:00\ncomments: true\n---\n\n### Interesting tools\n\n* [Rico's cheatsheets](https://devhints.io/) - 记忆小抄, 长话短说各种开发文档\n* [Carbon](https://carbon.now.sh/) - 带样式分享代码\n* [Codepan](https://codepan.net/) - 在线测试前端代码, 可以离线使用\n* [jsFiddle](https://jsfiddle.net/) - 同上, 注册账号后可以保存代码\n* [Prettier](https://prettier.io/playground/) - 在线格式化 JavaScript 代码\n* [Text-formatter](https://text-formatter.herokuapp.com/) - 格式化文本, 中英文之间留空格以及英文标点\n* [DevDocs](https://devdocs.io/) - 一站式开发文档集合\n* [Grammarly](https://app.grammarly.com/ddocs/261389934) - 英文语法错误检查\n* [JSONPlaceholder](http://jsonplaceholder.typicode.com/) - RESTful API 假数据模拟\n* [JSON2YAML](https://www.json2yaml.com/) - JSON 和 YAML 互转\n* [JSON Parser](http://json.parser.online.fr/beta/) - JSON 格式化\n* [RegExr](https://regexr.com/) - 在线正则测试及调试\n* [Regulex](https://jex.im/regulex/) - 正则表达可视化, 快速理解正则表达式\n* [CSSMatic](https://www.cssmatic.com/) - 生成镜像渐变, 盒子阴影等\n* [SassMeister](https://www.sassmeister.com/) - Sass 演练场, 可以输出 AutoPrefixer 的结果\n* [KeyframesApp](https://keyframes.app/) - CSS3 动画关键帧生成工具\n* [CSS Sprites Generator](https://www.toptal.com/developers/css/sprite-generator) - CSS 精灵生成工具\n* [JSNice](http://www.jsnice.org/) - 反编译已压缩的 JS 代码, 理解变量是什么意思\n* [Love2.io](https://love2.io/) - 开源技术文档分享平台\n* [WakaTime](https://wakatime.com/) - 记录每天的编码情况, 使用什么语言及统计时长\n* [蓝湖](https://lanhuapp.com/) - 高效的产品设计协作平台, 标注切图很好用\n\n### Docs\n\n* **React**\n\n  * [React 中文文档](https://doc.react-china.org/docs/hello-world.html)\n  * [Redux 中文文档](https://www.kancloud.cn/allanyu/redux-in-chinese/82399)\n  * [React-saga 中文文档](http://leonshi.com/redux-saga-in-chinese/docs/api/index.html)\n  * [React-router 中文文档](https://react-guide.github.io/react-router-cn)\n  * [Mobx 中文文档](https://suprise.gitbooks.io/mobx-cn/content/fp.html)\n  * [Ant-design 文档](https://ant.design/docs/react/introduce-cn)\n  * [React-Native 文档](http://reactnative.cn/docs/0.50/getting-started.html)\n\n* **Vue.js**\n\n  * [Vue.js 官网](https://cn.vuejs.org/v2/guide/)\n  * [Vue-Router](https://router.vuejs.org/zh-cn/)\n  * [Vuex](https://vuex.vuejs.org/zh-cn/)\n  * [Vue-SSR 服务器端渲染](https://ssr.vuejs.org/zh/)\n  * [Vue-NUXT](https://zh.nuxtjs.org/guide/installation)\n\n* **Node.js**\n\n  * [Node.js API](http://nodejs.cn/api/)\n  * [Express 官网](http://www.expressjs.com.cn/guide/routing.html)\n\n* **Electron**\n\n  * [Electron 官方文档](https://electronjs.org/docs/)\n\n* **WeChat**\n\n  * [小程序官方文档](https://mp.weixin.qq.com/debug/wxadoc/dev/index.html?t=201832)\n\n* **TypeScript**\n\n  * [TypeScript 中文网](https://www.tslang.cn/index.html)\n\n* **Vanilla JS**\n\n  * [JavaScript 基础进阶系列](https://segmentfault.com/a/1190000012646488)\n  * [深入理解 JS 异步](https://github.com/wangfupeng1988/js-async-tutorial)\n  * [深入理解 JS (Tom)](https://www.cnblogs.com/tomxu/archive/2011/12/15/2288411.html)\n\n* **Webpack**\n\n  * [Webpack 3.x](http://www.css88.com/doc/webpack/)\n  * [Webpack 2.x](http://www.css88.com/doc/webpack2/api/loaders/#version)\n\n* **Python**\n\n  * [Python 3 教程 (廖雪峰)](https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000)\n  * [Django 中文文档](https://docs.djangoproject.com/zh-hans/2.0/)\n\n* **More...**\n  * [印记中文](https://docschina.org/)\n\n### One more thing\n\n欢迎在下面留言板分享你觉得有趣的所有东西, 本文[源代码地址](https://raw.githubusercontent.com/ifyour/ifyour.github.io/src/source/docs/index.md). 😎\n","updated":"2018-06-17T09:49:30.000Z","path":"docs/index.html","layout":"page","_id":"cjiitidi30003u4q9sv1bzq9f","content":"<h3 id=\"Interesting-tools\"><a href=\"#Interesting-tools\" class=\"headerlink\" title=\"Interesting tools\"></a>Interesting tools</h3><ul>\n<li><a href=\"https://devhints.io/\" target=\"_blank\" rel=\"noopener\">Rico’s cheatsheets</a> - 记忆小抄, 长话短说各种开发文档</li>\n<li><a href=\"https://carbon.now.sh/\" target=\"_blank\" rel=\"noopener\">Carbon</a> - 带样式分享代码</li>\n<li><a href=\"https://codepan.net/\" target=\"_blank\" rel=\"noopener\">Codepan</a> - 在线测试前端代码, 可以离线使用</li>\n<li><a href=\"https://jsfiddle.net/\" target=\"_blank\" rel=\"noopener\">jsFiddle</a> - 同上, 注册账号后可以保存代码</li>\n<li><a href=\"https://prettier.io/playground/\" target=\"_blank\" rel=\"noopener\">Prettier</a> - 在线格式化 JavaScript 代码</li>\n<li><a href=\"https://text-formatter.herokuapp.com/\" target=\"_blank\" rel=\"noopener\">Text-formatter</a> - 格式化文本, 中英文之间留空格以及英文标点</li>\n<li><a href=\"https://devdocs.io/\" target=\"_blank\" rel=\"noopener\">DevDocs</a> - 一站式开发文档集合</li>\n<li><a href=\"https://app.grammarly.com/ddocs/261389934\" target=\"_blank\" rel=\"noopener\">Grammarly</a> - 英文语法错误检查</li>\n<li><a href=\"http://jsonplaceholder.typicode.com/\" target=\"_blank\" rel=\"noopener\">JSONPlaceholder</a> - RESTful API 假数据模拟</li>\n<li><a href=\"https://www.json2yaml.com/\" target=\"_blank\" rel=\"noopener\">JSON2YAML</a> - JSON 和 YAML 互转</li>\n<li><a href=\"http://json.parser.online.fr/beta/\" target=\"_blank\" rel=\"noopener\">JSON Parser</a> - JSON 格式化</li>\n<li><a href=\"https://regexr.com/\" target=\"_blank\" rel=\"noopener\">RegExr</a> - 在线正则测试及调试</li>\n<li><a href=\"https://jex.im/regulex/\" target=\"_blank\" rel=\"noopener\">Regulex</a> - 正则表达可视化, 快速理解正则表达式</li>\n<li><a href=\"https://www.cssmatic.com/\" target=\"_blank\" rel=\"noopener\">CSSMatic</a> - 生成镜像渐变, 盒子阴影等</li>\n<li><a href=\"https://www.sassmeister.com/\" target=\"_blank\" rel=\"noopener\">SassMeister</a> - Sass 演练场, 可以输出 AutoPrefixer 的结果</li>\n<li><a href=\"https://keyframes.app/\" target=\"_blank\" rel=\"noopener\">KeyframesApp</a> - CSS3 动画关键帧生成工具</li>\n<li><a href=\"https://www.toptal.com/developers/css/sprite-generator\" target=\"_blank\" rel=\"noopener\">CSS Sprites Generator</a> - CSS 精灵生成工具</li>\n<li><a href=\"http://www.jsnice.org/\" target=\"_blank\" rel=\"noopener\">JSNice</a> - 反编译已压缩的 JS 代码, 理解变量是什么意思</li>\n<li><a href=\"https://love2.io/\" target=\"_blank\" rel=\"noopener\">Love2.io</a> - 开源技术文档分享平台</li>\n<li><a href=\"https://wakatime.com/\" target=\"_blank\" rel=\"noopener\">WakaTime</a> - 记录每天的编码情况, 使用什么语言及统计时长</li>\n<li><a href=\"https://lanhuapp.com/\" target=\"_blank\" rel=\"noopener\">蓝湖</a> - 高效的产品设计协作平台, 标注切图很好用</li>\n</ul>\n<h3 id=\"Docs\"><a href=\"#Docs\" class=\"headerlink\" title=\"Docs\"></a>Docs</h3><ul>\n<li><p><strong>React</strong></p>\n<ul>\n<li><a href=\"https://doc.react-china.org/docs/hello-world.html\" target=\"_blank\" rel=\"noopener\">React 中文文档</a></li>\n<li><a href=\"https://www.kancloud.cn/allanyu/redux-in-chinese/82399\" target=\"_blank\" rel=\"noopener\">Redux 中文文档</a></li>\n<li><a href=\"http://leonshi.com/redux-saga-in-chinese/docs/api/index.html\" target=\"_blank\" rel=\"noopener\">React-saga 中文文档</a></li>\n<li><a href=\"https://react-guide.github.io/react-router-cn\" target=\"_blank\" rel=\"noopener\">React-router 中文文档</a></li>\n<li><a href=\"https://suprise.gitbooks.io/mobx-cn/content/fp.html\" target=\"_blank\" rel=\"noopener\">Mobx 中文文档</a></li>\n<li><a href=\"https://ant.design/docs/react/introduce-cn\" target=\"_blank\" rel=\"noopener\">Ant-design 文档</a></li>\n<li><a href=\"http://reactnative.cn/docs/0.50/getting-started.html\" target=\"_blank\" rel=\"noopener\">React-Native 文档</a></li>\n</ul>\n</li>\n<li><p><strong>Vue.js</strong></p>\n<ul>\n<li><a href=\"https://cn.vuejs.org/v2/guide/\" target=\"_blank\" rel=\"noopener\">Vue.js 官网</a></li>\n<li><a href=\"https://router.vuejs.org/zh-cn/\" target=\"_blank\" rel=\"noopener\">Vue-Router</a></li>\n<li><a href=\"https://vuex.vuejs.org/zh-cn/\" target=\"_blank\" rel=\"noopener\">Vuex</a></li>\n<li><a href=\"https://ssr.vuejs.org/zh/\" target=\"_blank\" rel=\"noopener\">Vue-SSR 服务器端渲染</a></li>\n<li><a href=\"https://zh.nuxtjs.org/guide/installation\" target=\"_blank\" rel=\"noopener\">Vue-NUXT</a></li>\n</ul>\n</li>\n<li><p><strong>Node.js</strong></p>\n<ul>\n<li><a href=\"http://nodejs.cn/api/\" target=\"_blank\" rel=\"noopener\">Node.js API</a></li>\n<li><a href=\"http://www.expressjs.com.cn/guide/routing.html\" target=\"_blank\" rel=\"noopener\">Express 官网</a></li>\n</ul>\n</li>\n<li><p><strong>Electron</strong></p>\n<ul>\n<li><a href=\"https://electronjs.org/docs/\" target=\"_blank\" rel=\"noopener\">Electron 官方文档</a></li>\n</ul>\n</li>\n<li><p><strong>WeChat</strong></p>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/debug/wxadoc/dev/index.html?t=201832\" target=\"_blank\" rel=\"noopener\">小程序官方文档</a></li>\n</ul>\n</li>\n<li><p><strong>TypeScript</strong></p>\n<ul>\n<li><a href=\"https://www.tslang.cn/index.html\" target=\"_blank\" rel=\"noopener\">TypeScript 中文网</a></li>\n</ul>\n</li>\n<li><p><strong>Vanilla JS</strong></p>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000012646488\" target=\"_blank\" rel=\"noopener\">JavaScript 基础进阶系列</a></li>\n<li><a href=\"https://github.com/wangfupeng1988/js-async-tutorial\" target=\"_blank\" rel=\"noopener\">深入理解 JS 异步</a></li>\n<li><a href=\"https://www.cnblogs.com/tomxu/archive/2011/12/15/2288411.html\" target=\"_blank\" rel=\"noopener\">深入理解 JS (Tom)</a></li>\n</ul>\n</li>\n<li><p><strong>Webpack</strong></p>\n<ul>\n<li><a href=\"http://www.css88.com/doc/webpack/\" target=\"_blank\" rel=\"noopener\">Webpack 3.x</a></li>\n<li><a href=\"http://www.css88.com/doc/webpack2/api/loaders/#version\" target=\"_blank\" rel=\"noopener\">Webpack 2.x</a></li>\n</ul>\n</li>\n<li><p><strong>Python</strong></p>\n<ul>\n<li><a href=\"https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000\" target=\"_blank\" rel=\"noopener\">Python 3 教程 (廖雪峰)</a></li>\n<li><a href=\"https://docs.djangoproject.com/zh-hans/2.0/\" target=\"_blank\" rel=\"noopener\">Django 中文文档</a></li>\n</ul>\n</li>\n<li><p><strong>More…</strong></p>\n<ul>\n<li><a href=\"https://docschina.org/\" target=\"_blank\" rel=\"noopener\">印记中文</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"One-more-thing\"><a href=\"#One-more-thing\" class=\"headerlink\" title=\"One more thing\"></a>One more thing</h3><p>欢迎在下面留言板分享你觉得有趣的所有东西, 本文<a href=\"https://raw.githubusercontent.com/ifyour/ifyour.github.io/src/source/docs/index.md\" target=\"_blank\" rel=\"noopener\">源代码地址</a>. 😎</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Interesting-tools\"><a href=\"#Interesting-tools\" class=\"headerlink\" title=\"Interesting tools\"></a>Interesting tools</h3><ul>\n<li><a href=\"https://devhints.io/\" target=\"_blank\" rel=\"noopener\">Rico’s cheatsheets</a> - 记忆小抄, 长话短说各种开发文档</li>\n<li><a href=\"https://carbon.now.sh/\" target=\"_blank\" rel=\"noopener\">Carbon</a> - 带样式分享代码</li>\n<li><a href=\"https://codepan.net/\" target=\"_blank\" rel=\"noopener\">Codepan</a> - 在线测试前端代码, 可以离线使用</li>\n<li><a href=\"https://jsfiddle.net/\" target=\"_blank\" rel=\"noopener\">jsFiddle</a> - 同上, 注册账号后可以保存代码</li>\n<li><a href=\"https://prettier.io/playground/\" target=\"_blank\" rel=\"noopener\">Prettier</a> - 在线格式化 JavaScript 代码</li>\n<li><a href=\"https://text-formatter.herokuapp.com/\" target=\"_blank\" rel=\"noopener\">Text-formatter</a> - 格式化文本, 中英文之间留空格以及英文标点</li>\n<li><a href=\"https://devdocs.io/\" target=\"_blank\" rel=\"noopener\">DevDocs</a> - 一站式开发文档集合</li>\n<li><a href=\"https://app.grammarly.com/ddocs/261389934\" target=\"_blank\" rel=\"noopener\">Grammarly</a> - 英文语法错误检查</li>\n<li><a href=\"http://jsonplaceholder.typicode.com/\" target=\"_blank\" rel=\"noopener\">JSONPlaceholder</a> - RESTful API 假数据模拟</li>\n<li><a href=\"https://www.json2yaml.com/\" target=\"_blank\" rel=\"noopener\">JSON2YAML</a> - JSON 和 YAML 互转</li>\n<li><a href=\"http://json.parser.online.fr/beta/\" target=\"_blank\" rel=\"noopener\">JSON Parser</a> - JSON 格式化</li>\n<li><a href=\"https://regexr.com/\" target=\"_blank\" rel=\"noopener\">RegExr</a> - 在线正则测试及调试</li>\n<li><a href=\"https://jex.im/regulex/\" target=\"_blank\" rel=\"noopener\">Regulex</a> - 正则表达可视化, 快速理解正则表达式</li>\n<li><a href=\"https://www.cssmatic.com/\" target=\"_blank\" rel=\"noopener\">CSSMatic</a> - 生成镜像渐变, 盒子阴影等</li>\n<li><a href=\"https://www.sassmeister.com/\" target=\"_blank\" rel=\"noopener\">SassMeister</a> - Sass 演练场, 可以输出 AutoPrefixer 的结果</li>\n<li><a href=\"https://keyframes.app/\" target=\"_blank\" rel=\"noopener\">KeyframesApp</a> - CSS3 动画关键帧生成工具</li>\n<li><a href=\"https://www.toptal.com/developers/css/sprite-generator\" target=\"_blank\" rel=\"noopener\">CSS Sprites Generator</a> - CSS 精灵生成工具</li>\n<li><a href=\"http://www.jsnice.org/\" target=\"_blank\" rel=\"noopener\">JSNice</a> - 反编译已压缩的 JS 代码, 理解变量是什么意思</li>\n<li><a href=\"https://love2.io/\" target=\"_blank\" rel=\"noopener\">Love2.io</a> - 开源技术文档分享平台</li>\n<li><a href=\"https://wakatime.com/\" target=\"_blank\" rel=\"noopener\">WakaTime</a> - 记录每天的编码情况, 使用什么语言及统计时长</li>\n<li><a href=\"https://lanhuapp.com/\" target=\"_blank\" rel=\"noopener\">蓝湖</a> - 高效的产品设计协作平台, 标注切图很好用</li>\n</ul>\n<h3 id=\"Docs\"><a href=\"#Docs\" class=\"headerlink\" title=\"Docs\"></a>Docs</h3><ul>\n<li><p><strong>React</strong></p>\n<ul>\n<li><a href=\"https://doc.react-china.org/docs/hello-world.html\" target=\"_blank\" rel=\"noopener\">React 中文文档</a></li>\n<li><a href=\"https://www.kancloud.cn/allanyu/redux-in-chinese/82399\" target=\"_blank\" rel=\"noopener\">Redux 中文文档</a></li>\n<li><a href=\"http://leonshi.com/redux-saga-in-chinese/docs/api/index.html\" target=\"_blank\" rel=\"noopener\">React-saga 中文文档</a></li>\n<li><a href=\"https://react-guide.github.io/react-router-cn\" target=\"_blank\" rel=\"noopener\">React-router 中文文档</a></li>\n<li><a href=\"https://suprise.gitbooks.io/mobx-cn/content/fp.html\" target=\"_blank\" rel=\"noopener\">Mobx 中文文档</a></li>\n<li><a href=\"https://ant.design/docs/react/introduce-cn\" target=\"_blank\" rel=\"noopener\">Ant-design 文档</a></li>\n<li><a href=\"http://reactnative.cn/docs/0.50/getting-started.html\" target=\"_blank\" rel=\"noopener\">React-Native 文档</a></li>\n</ul>\n</li>\n<li><p><strong>Vue.js</strong></p>\n<ul>\n<li><a href=\"https://cn.vuejs.org/v2/guide/\" target=\"_blank\" rel=\"noopener\">Vue.js 官网</a></li>\n<li><a href=\"https://router.vuejs.org/zh-cn/\" target=\"_blank\" rel=\"noopener\">Vue-Router</a></li>\n<li><a href=\"https://vuex.vuejs.org/zh-cn/\" target=\"_blank\" rel=\"noopener\">Vuex</a></li>\n<li><a href=\"https://ssr.vuejs.org/zh/\" target=\"_blank\" rel=\"noopener\">Vue-SSR 服务器端渲染</a></li>\n<li><a href=\"https://zh.nuxtjs.org/guide/installation\" target=\"_blank\" rel=\"noopener\">Vue-NUXT</a></li>\n</ul>\n</li>\n<li><p><strong>Node.js</strong></p>\n<ul>\n<li><a href=\"http://nodejs.cn/api/\" target=\"_blank\" rel=\"noopener\">Node.js API</a></li>\n<li><a href=\"http://www.expressjs.com.cn/guide/routing.html\" target=\"_blank\" rel=\"noopener\">Express 官网</a></li>\n</ul>\n</li>\n<li><p><strong>Electron</strong></p>\n<ul>\n<li><a href=\"https://electronjs.org/docs/\" target=\"_blank\" rel=\"noopener\">Electron 官方文档</a></li>\n</ul>\n</li>\n<li><p><strong>WeChat</strong></p>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/debug/wxadoc/dev/index.html?t=201832\" target=\"_blank\" rel=\"noopener\">小程序官方文档</a></li>\n</ul>\n</li>\n<li><p><strong>TypeScript</strong></p>\n<ul>\n<li><a href=\"https://www.tslang.cn/index.html\" target=\"_blank\" rel=\"noopener\">TypeScript 中文网</a></li>\n</ul>\n</li>\n<li><p><strong>Vanilla JS</strong></p>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000012646488\" target=\"_blank\" rel=\"noopener\">JavaScript 基础进阶系列</a></li>\n<li><a href=\"https://github.com/wangfupeng1988/js-async-tutorial\" target=\"_blank\" rel=\"noopener\">深入理解 JS 异步</a></li>\n<li><a href=\"https://www.cnblogs.com/tomxu/archive/2011/12/15/2288411.html\" target=\"_blank\" rel=\"noopener\">深入理解 JS (Tom)</a></li>\n</ul>\n</li>\n<li><p><strong>Webpack</strong></p>\n<ul>\n<li><a href=\"http://www.css88.com/doc/webpack/\" target=\"_blank\" rel=\"noopener\">Webpack 3.x</a></li>\n<li><a href=\"http://www.css88.com/doc/webpack2/api/loaders/#version\" target=\"_blank\" rel=\"noopener\">Webpack 2.x</a></li>\n</ul>\n</li>\n<li><p><strong>Python</strong></p>\n<ul>\n<li><a href=\"https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000\" target=\"_blank\" rel=\"noopener\">Python 3 教程 (廖雪峰)</a></li>\n<li><a href=\"https://docs.djangoproject.com/zh-hans/2.0/\" target=\"_blank\" rel=\"noopener\">Django 中文文档</a></li>\n</ul>\n</li>\n<li><p><strong>More…</strong></p>\n<ul>\n<li><a href=\"https://docschina.org/\" target=\"_blank\" rel=\"noopener\">印记中文</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"One-more-thing\"><a href=\"#One-more-thing\" class=\"headerlink\" title=\"One more thing\"></a>One more thing</h3><p>欢迎在下面留言板分享你觉得有趣的所有东西, 本文<a href=\"https://raw.githubusercontent.com/ifyour/ifyour.github.io/src/source/docs/index.md\" target=\"_blank\" rel=\"noopener\">源代码地址</a>. 😎</p>\n"},{"title":"categories","date":"2015-12-27T14:33:51.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2015-12-27 22:33:51\ntype: \"categories\"\ncomments: false\n---\n","updated":"2018-06-17T09:49:30.000Z","path":"categories/index.html","layout":"page","_id":"cjiitidi50005u4q9nw2b7ssr","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"(function(o){if(o.fetch){return}var l={searchParams:\"URLSearchParams\" in o,iterable:\"Symbol\" in o&&\"iterator\" in Symbol,blob:\"FileReader\" in o&&\"Blob\" in o&&(function(){try{new Blob();return true}catch(x){return false}})(),formData:\"FormData\" in o,arrayBuffer:\"ArrayBuffer\" in o};if(l.arrayBuffer){var m=[\"[object Int8Array]\",\"[object Uint8Array]\",\"[object Uint8ClampedArray]\",\"[object Int16Array]\",\"[object Uint16Array]\",\"[object Int32Array]\",\"[object Uint32Array]\",\"[object Float32Array]\",\"[object Float64Array]\"];var s=function(x){return x&&DataView.prototype.isPrototypeOf(x)};var b=ArrayBuffer.isView||function(x){return x&&m.indexOf(Object.prototype.toString.call(x))>-1}}function i(x){if(typeof x!==\"string\"){x=String(x)}if(/[^a-z0-9-#$%&'*+.^_`|~]/i.test(x)){throw new TypeError(\"Invalid character in header field name\")}return x.toLowerCase()}function j(x){if(typeof x!==\"string\"){x=String(x)}return x}function e(x){var y={next:function(){var z=x.shift();return{done:z===undefined,value:z}}};if(l.iterable){y[Symbol.iterator]=function(){return y}}return y}function p(x){this.map={};if(x instanceof p){x.forEach(function(z,y){this.append(y,z)},this)}else{if(Array.isArray(x)){x.forEach(function(y){this.append(y[0],y[1])},this)}else{if(x){Object.getOwnPropertyNames(x).forEach(function(y){this.append(y,x[y])},this)}}}}p.prototype.append=function(y,z){y=i(y);z=j(z);var x=this.map[y];this.map[y]=x?x+\",\"+z:z};p.prototype[\"delete\"]=function(x){delete this.map[i(x)]};p.prototype.get=function(x){x=i(x);return this.has(x)?this.map[x]:null};p.prototype.has=function(x){return this.map.hasOwnProperty(i(x))};p.prototype.set=function(x,y){this.map[i(x)]=j(y)};p.prototype.forEach=function(z,x){for(var y in this.map){if(this.map.hasOwnProperty(y)){z.call(x,this.map[y],y,this)}}};p.prototype.keys=function(){var x=[];this.forEach(function(z,y){x.push(y)});return e(x)};p.prototype.values=function(){var x=[];this.forEach(function(y){x.push(y)});return e(x)};p.prototype.entries=function(){var x=[];this.forEach(function(z,y){x.push([y,z])});return e(x)};if(l.iterable){p.prototype[Symbol.iterator]=p.prototype.entries}function f(x){if(x.bodyUsed){return Promise.reject(new TypeError(\"Already read\"))}x.bodyUsed=true}function h(x){return new Promise(function(z,y){x.onload=function(){z(x.result)};x.onerror=function(){y(x.error)}})}function c(y){var x=new FileReader();var z=h(x);x.readAsArrayBuffer(y);return z}function d(y){var x=new FileReader();var z=h(x);x.readAsText(y);return z}function u(y){var x=new Uint8Array(y);var A=new Array(x.length);for(var z=0;z<x.length;z++){A[z]=String.fromCharCode(x[z])}return A.join(\"\")}function k(y){if(y.slice){return y.slice(0)}else{var x=new Uint8Array(y.byteLength);x.set(new Uint8Array(y));return x.buffer}}function q(){this.bodyUsed=false;this._initBody=function(x){this._bodyInit=x;if(!x){this._bodyText=\"\"}else{if(typeof x===\"string\"){this._bodyText=x}else{if(l.blob&&Blob.prototype.isPrototypeOf(x)){this._bodyBlob=x}else{if(l.formData&&FormData.prototype.isPrototypeOf(x)){this._bodyFormData=x}else{if(l.searchParams&&URLSearchParams.prototype.isPrototypeOf(x)){this._bodyText=x.toString()}else{if(l.arrayBuffer&&l.blob&&s(x)){this._bodyArrayBuffer=k(x.buffer);this._bodyInit=new Blob([this._bodyArrayBuffer])}else{if(l.arrayBuffer&&(ArrayBuffer.prototype.isPrototypeOf(x)||b(x))){this._bodyArrayBuffer=k(x)}else{throw new Error(\"unsupported BodyInit type\")}}}}}}}if(!this.headers.get(\"content-type\")){if(typeof x===\"string\"){this.headers.set(\"content-type\",\"text/plain;charset=UTF-8\")}else{if(this._bodyBlob&&this._bodyBlob.type){this.headers.set(\"content-type\",this._bodyBlob.type)}else{if(l.searchParams&&URLSearchParams.prototype.isPrototypeOf(x)){this.headers.set(\"content-type\",\"application/x-www-form-urlencoded;charset=UTF-8\")}}}}};if(l.blob){this.blob=function(){var x=f(this);if(x){return x}if(this._bodyBlob){return Promise.resolve(this._bodyBlob)}else{if(this._bodyArrayBuffer){return Promise.resolve(new Blob([this._bodyArrayBuffer]))}else{if(this._bodyFormData){throw new Error(\"could not read FormData body as blob\")}else{return Promise.resolve(new Blob([this._bodyText]))}}}};this.arrayBuffer=function(){if(this._bodyArrayBuffer){return f(this)||Promise.resolve(this._bodyArrayBuffer)}else{return this.blob().then(c)}}}this.text=function(){var x=f(this);if(x){return x}if(this._bodyBlob){return d(this._bodyBlob)}else{if(this._bodyArrayBuffer){return Promise.resolve(u(this._bodyArrayBuffer))}else{if(this._bodyFormData){throw new Error(\"could not read FormData body as text\")}else{return Promise.resolve(this._bodyText)}}}};if(l.formData){this.formData=function(){return this.text().then(n)}}this.json=function(){return this.text().then(JSON.parse)};return this}var t=[\"DELETE\",\"GET\",\"HEAD\",\"OPTIONS\",\"POST\",\"PUT\"];function v(y){var x=y.toUpperCase();return(t.indexOf(x)>-1)?x:y}function r(y,z){z=z||{};var x=z.body;if(y instanceof r){if(y.bodyUsed){throw new TypeError(\"Already read\")}this.url=y.url;this.credentials=y.credentials;if(!z.headers){this.headers=new p(y.headers)}this.method=y.method;this.mode=y.mode;if(!x&&y._bodyInit!=null){x=y._bodyInit;y.bodyUsed=true}}else{this.url=String(y)}this.credentials=z.credentials||this.credentials||\"omit\";if(z.headers||!this.headers){this.headers=new p(z.headers)}this.method=v(z.method||this.method||\"GET\");this.mode=z.mode||this.mode||null;this.referrer=null;if((this.method===\"GET\"||this.method===\"HEAD\")&&x){throw new TypeError(\"Body not allowed for GET or HEAD requests\")}this._initBody(x)}r.prototype.clone=function(){return new r(this,{body:this._bodyInit})};function n(x){var y=new FormData();x.trim().split(\"&\").forEach(function(z){if(z){var B=z.split(\"=\");var A=B.shift().replace(/+/g,\" \");var C=B.join(\"=\").replace(/+/g,\" \");y.append(decodeURIComponent(A),decodeURIComponent(C))}});return y}function w(z){var y=new p();var x=z.replace(/r?n[t ]+/g,\" \");x.split(/r?n/).forEach(function(A){var D=A.split(\":\");var B=D.shift().trim();if(B){var C=D.join(\":\").trim();y.append(B,C)}});return y}q.call(r.prototype);function a(y,x){if(!x){x={}}this.type=\"default\";this.status=x.status===undefined?200:x.status;this.ok=this.status>=200&&this.status<300;this.statusText=\"statusText\" in x?x.statusText:\"OK\";this.headers=new p(x.headers);this.url=x.url||\"\";this._initBody(y)}q.call(a.prototype);a.prototype.clone=function(){return new a(this._bodyInit,{status:this.status,statusText:this.statusText,headers:new p(this.headers),url:this.url})};a.error=function(){var x=new a(null,{status:0,statusText:\"\"});x.type=\"error\";return x};var g=[301,302,303,307,308];a.redirect=function(y,x){if(g.indexOf(x)===-1){throw new RangeError(\"Invalid status code\")}return new a(null,{status:x,headers:{location:y}})};o.Headers=p;o.Request=r;o.Response=a;o.fetch=function(x,y){return new Promise(function(B,A){var z=new r(x,y);var C=new XMLHttpRequest();C.onload=function(){var E={status:C.status,statusText:C.statusText,headers:w(C.getAllResponseHeaders()||\"\")};E.url=\"responseURL\" in C?C.responseURL:E.headers.get(\"X-Request-URL\");var D=\"response\" in C?C.response:C.responseText;B(new a(D,E))};C.onerror=function(){A(new TypeError(\"Network request failed\"))};C.ontimeout=function(){A(new TypeError(\"Network request failed\"))};C.open(z.method,z.url,true);if(z.credentials===\"include\"){C.withCredentials=true}else{if(z.credentials===\"omit\"){C.withCredentials=false}}if(\"responseType\" in C&&l.blob){C.responseType=\"blob\"}z.headers.forEach(function(E,D){C.setRequestHeader(D,E)});C.send(typeof z._bodyInit===\"undefined\"?null:z._bodyInit)})};o.fetch.polyfill=true})(typeof self!==\"undefined\"?self:this);","source":"upload/fetch.min.js","raw":"(function(o){if(o.fetch){return}var l={searchParams:\"URLSearchParams\" in o,iterable:\"Symbol\" in o&&\"iterator\" in Symbol,blob:\"FileReader\" in o&&\"Blob\" in o&&(function(){try{new Blob();return true}catch(x){return false}})(),formData:\"FormData\" in o,arrayBuffer:\"ArrayBuffer\" in o};if(l.arrayBuffer){var m=[\"[object Int8Array]\",\"[object Uint8Array]\",\"[object Uint8ClampedArray]\",\"[object Int16Array]\",\"[object Uint16Array]\",\"[object Int32Array]\",\"[object Uint32Array]\",\"[object Float32Array]\",\"[object Float64Array]\"];var s=function(x){return x&&DataView.prototype.isPrototypeOf(x)};var b=ArrayBuffer.isView||function(x){return x&&m.indexOf(Object.prototype.toString.call(x))>-1}}function i(x){if(typeof x!==\"string\"){x=String(x)}if(/[^a-z0-9-#$%&'*+.^_`|~]/i.test(x)){throw new TypeError(\"Invalid character in header field name\")}return x.toLowerCase()}function j(x){if(typeof x!==\"string\"){x=String(x)}return x}function e(x){var y={next:function(){var z=x.shift();return{done:z===undefined,value:z}}};if(l.iterable){y[Symbol.iterator]=function(){return y}}return y}function p(x){this.map={};if(x instanceof p){x.forEach(function(z,y){this.append(y,z)},this)}else{if(Array.isArray(x)){x.forEach(function(y){this.append(y[0],y[1])},this)}else{if(x){Object.getOwnPropertyNames(x).forEach(function(y){this.append(y,x[y])},this)}}}}p.prototype.append=function(y,z){y=i(y);z=j(z);var x=this.map[y];this.map[y]=x?x+\",\"+z:z};p.prototype[\"delete\"]=function(x){delete this.map[i(x)]};p.prototype.get=function(x){x=i(x);return this.has(x)?this.map[x]:null};p.prototype.has=function(x){return this.map.hasOwnProperty(i(x))};p.prototype.set=function(x,y){this.map[i(x)]=j(y)};p.prototype.forEach=function(z,x){for(var y in this.map){if(this.map.hasOwnProperty(y)){z.call(x,this.map[y],y,this)}}};p.prototype.keys=function(){var x=[];this.forEach(function(z,y){x.push(y)});return e(x)};p.prototype.values=function(){var x=[];this.forEach(function(y){x.push(y)});return e(x)};p.prototype.entries=function(){var x=[];this.forEach(function(z,y){x.push([y,z])});return e(x)};if(l.iterable){p.prototype[Symbol.iterator]=p.prototype.entries}function f(x){if(x.bodyUsed){return Promise.reject(new TypeError(\"Already read\"))}x.bodyUsed=true}function h(x){return new Promise(function(z,y){x.onload=function(){z(x.result)};x.onerror=function(){y(x.error)}})}function c(y){var x=new FileReader();var z=h(x);x.readAsArrayBuffer(y);return z}function d(y){var x=new FileReader();var z=h(x);x.readAsText(y);return z}function u(y){var x=new Uint8Array(y);var A=new Array(x.length);for(var z=0;z<x.length;z++){A[z]=String.fromCharCode(x[z])}return A.join(\"\")}function k(y){if(y.slice){return y.slice(0)}else{var x=new Uint8Array(y.byteLength);x.set(new Uint8Array(y));return x.buffer}}function q(){this.bodyUsed=false;this._initBody=function(x){this._bodyInit=x;if(!x){this._bodyText=\"\"}else{if(typeof x===\"string\"){this._bodyText=x}else{if(l.blob&&Blob.prototype.isPrototypeOf(x)){this._bodyBlob=x}else{if(l.formData&&FormData.prototype.isPrototypeOf(x)){this._bodyFormData=x}else{if(l.searchParams&&URLSearchParams.prototype.isPrototypeOf(x)){this._bodyText=x.toString()}else{if(l.arrayBuffer&&l.blob&&s(x)){this._bodyArrayBuffer=k(x.buffer);this._bodyInit=new Blob([this._bodyArrayBuffer])}else{if(l.arrayBuffer&&(ArrayBuffer.prototype.isPrototypeOf(x)||b(x))){this._bodyArrayBuffer=k(x)}else{throw new Error(\"unsupported BodyInit type\")}}}}}}}if(!this.headers.get(\"content-type\")){if(typeof x===\"string\"){this.headers.set(\"content-type\",\"text/plain;charset=UTF-8\")}else{if(this._bodyBlob&&this._bodyBlob.type){this.headers.set(\"content-type\",this._bodyBlob.type)}else{if(l.searchParams&&URLSearchParams.prototype.isPrototypeOf(x)){this.headers.set(\"content-type\",\"application/x-www-form-urlencoded;charset=UTF-8\")}}}}};if(l.blob){this.blob=function(){var x=f(this);if(x){return x}if(this._bodyBlob){return Promise.resolve(this._bodyBlob)}else{if(this._bodyArrayBuffer){return Promise.resolve(new Blob([this._bodyArrayBuffer]))}else{if(this._bodyFormData){throw new Error(\"could not read FormData body as blob\")}else{return Promise.resolve(new Blob([this._bodyText]))}}}};this.arrayBuffer=function(){if(this._bodyArrayBuffer){return f(this)||Promise.resolve(this._bodyArrayBuffer)}else{return this.blob().then(c)}}}this.text=function(){var x=f(this);if(x){return x}if(this._bodyBlob){return d(this._bodyBlob)}else{if(this._bodyArrayBuffer){return Promise.resolve(u(this._bodyArrayBuffer))}else{if(this._bodyFormData){throw new Error(\"could not read FormData body as text\")}else{return Promise.resolve(this._bodyText)}}}};if(l.formData){this.formData=function(){return this.text().then(n)}}this.json=function(){return this.text().then(JSON.parse)};return this}var t=[\"DELETE\",\"GET\",\"HEAD\",\"OPTIONS\",\"POST\",\"PUT\"];function v(y){var x=y.toUpperCase();return(t.indexOf(x)>-1)?x:y}function r(y,z){z=z||{};var x=z.body;if(y instanceof r){if(y.bodyUsed){throw new TypeError(\"Already read\")}this.url=y.url;this.credentials=y.credentials;if(!z.headers){this.headers=new p(y.headers)}this.method=y.method;this.mode=y.mode;if(!x&&y._bodyInit!=null){x=y._bodyInit;y.bodyUsed=true}}else{this.url=String(y)}this.credentials=z.credentials||this.credentials||\"omit\";if(z.headers||!this.headers){this.headers=new p(z.headers)}this.method=v(z.method||this.method||\"GET\");this.mode=z.mode||this.mode||null;this.referrer=null;if((this.method===\"GET\"||this.method===\"HEAD\")&&x){throw new TypeError(\"Body not allowed for GET or HEAD requests\")}this._initBody(x)}r.prototype.clone=function(){return new r(this,{body:this._bodyInit})};function n(x){var y=new FormData();x.trim().split(\"&\").forEach(function(z){if(z){var B=z.split(\"=\");var A=B.shift().replace(/+/g,\" \");var C=B.join(\"=\").replace(/+/g,\" \");y.append(decodeURIComponent(A),decodeURIComponent(C))}});return y}function w(z){var y=new p();var x=z.replace(/r?n[t ]+/g,\" \");x.split(/r?n/).forEach(function(A){var D=A.split(\":\");var B=D.shift().trim();if(B){var C=D.join(\":\").trim();y.append(B,C)}});return y}q.call(r.prototype);function a(y,x){if(!x){x={}}this.type=\"default\";this.status=x.status===undefined?200:x.status;this.ok=this.status>=200&&this.status<300;this.statusText=\"statusText\" in x?x.statusText:\"OK\";this.headers=new p(x.headers);this.url=x.url||\"\";this._initBody(y)}q.call(a.prototype);a.prototype.clone=function(){return new a(this._bodyInit,{status:this.status,statusText:this.statusText,headers:new p(this.headers),url:this.url})};a.error=function(){var x=new a(null,{status:0,statusText:\"\"});x.type=\"error\";return x};var g=[301,302,303,307,308];a.redirect=function(y,x){if(g.indexOf(x)===-1){throw new RangeError(\"Invalid status code\")}return new a(null,{status:x,headers:{location:y}})};o.Headers=p;o.Request=r;o.Response=a;o.fetch=function(x,y){return new Promise(function(B,A){var z=new r(x,y);var C=new XMLHttpRequest();C.onload=function(){var E={status:C.status,statusText:C.statusText,headers:w(C.getAllResponseHeaders()||\"\")};E.url=\"responseURL\" in C?C.responseURL:E.headers.get(\"X-Request-URL\");var D=\"response\" in C?C.response:C.responseText;B(new a(D,E))};C.onerror=function(){A(new TypeError(\"Network request failed\"))};C.ontimeout=function(){A(new TypeError(\"Network request failed\"))};C.open(z.method,z.url,true);if(z.credentials===\"include\"){C.withCredentials=true}else{if(z.credentials===\"omit\"){C.withCredentials=false}}if(\"responseType\" in C&&l.blob){C.responseType=\"blob\"}z.headers.forEach(function(E,D){C.setRequestHeader(D,E)});C.send(typeof z._bodyInit===\"undefined\"?null:z._bodyInit)})};o.fetch.polyfill=true})(typeof self!==\"undefined\"?self:this);","date":"2018-06-17T09:49:30.000Z","updated":"2018-06-17T09:49:30.000Z","path":"upload/fetch.min.js","layout":"false","title":"","comments":1,"_id":"cjiitidi80007u4q9n3iplo8k","content":"(function(o){if(o.fetch){return}var l={searchParams:\"URLSearchParams\" in o,iterable:\"Symbol\" in o&&\"iterator\" in Symbol,blob:\"FileReader\" in o&&\"Blob\" in o&&(function(){try{new Blob();return true}catch(x){return false}})(),formData:\"FormData\" in o,arrayBuffer:\"ArrayBuffer\" in o};if(l.arrayBuffer){var m=[\"[object Int8Array]\",\"[object Uint8Array]\",\"[object Uint8ClampedArray]\",\"[object Int16Array]\",\"[object Uint16Array]\",\"[object Int32Array]\",\"[object Uint32Array]\",\"[object Float32Array]\",\"[object Float64Array]\"];var s=function(x){return x&&DataView.prototype.isPrototypeOf(x)};var b=ArrayBuffer.isView||function(x){return x&&m.indexOf(Object.prototype.toString.call(x))>-1}}function i(x){if(typeof x!==\"string\"){x=String(x)}if(/[^a-z0-9-#$%&'*+.^_`|~]/i.test(x)){throw new TypeError(\"Invalid character in header field name\")}return x.toLowerCase()}function j(x){if(typeof x!==\"string\"){x=String(x)}return x}function e(x){var y={next:function(){var z=x.shift();return{done:z===undefined,value:z}}};if(l.iterable){y[Symbol.iterator]=function(){return y}}return y}function p(x){this.map={};if(x instanceof p){x.forEach(function(z,y){this.append(y,z)},this)}else{if(Array.isArray(x)){x.forEach(function(y){this.append(y[0],y[1])},this)}else{if(x){Object.getOwnPropertyNames(x).forEach(function(y){this.append(y,x[y])},this)}}}}p.prototype.append=function(y,z){y=i(y);z=j(z);var x=this.map[y];this.map[y]=x?x+\",\"+z:z};p.prototype[\"delete\"]=function(x){delete this.map[i(x)]};p.prototype.get=function(x){x=i(x);return this.has(x)?this.map[x]:null};p.prototype.has=function(x){return this.map.hasOwnProperty(i(x))};p.prototype.set=function(x,y){this.map[i(x)]=j(y)};p.prototype.forEach=function(z,x){for(var y in this.map){if(this.map.hasOwnProperty(y)){z.call(x,this.map[y],y,this)}}};p.prototype.keys=function(){var x=[];this.forEach(function(z,y){x.push(y)});return e(x)};p.prototype.values=function(){var x=[];this.forEach(function(y){x.push(y)});return e(x)};p.prototype.entries=function(){var x=[];this.forEach(function(z,y){x.push([y,z])});return e(x)};if(l.iterable){p.prototype[Symbol.iterator]=p.prototype.entries}function f(x){if(x.bodyUsed){return Promise.reject(new TypeError(\"Already read\"))}x.bodyUsed=true}function h(x){return new Promise(function(z,y){x.onload=function(){z(x.result)};x.onerror=function(){y(x.error)}})}function c(y){var x=new FileReader();var z=h(x);x.readAsArrayBuffer(y);return z}function d(y){var x=new FileReader();var z=h(x);x.readAsText(y);return z}function u(y){var x=new Uint8Array(y);var A=new Array(x.length);for(var z=0;z<x.length;z++){a[z]=string.fromcharcode(x[z])}return a.join(\"\")}function=\"\" k(y){if(y.slice){return=\"\" y.slice(0)}else{var=\"\" x=\"new\" uint8array(y.bytelength);x.set(new=\"\" uint8array(y));return=\"\" x.buffer}}function=\"\" q(){this.bodyused=\"false;this._initBody=function(x){this._bodyInit=x;if(!x){this._bodyText=\"\"}else{if(typeof\" blob([this._bodyarraybuffer])}else{if(l.arraybuffer&&(arraybuffer.prototype.isprototypeof(x)||b(x))){this._bodyarraybuffer=\"k(x)}else{throw\" new=\"\" error(\"unsupported=\"\" bodyinit=\"\" type\")}}}}}}}if(!this.headers.get(\"content-type\")){if(typeof=\"\" x}if(this._bodyblob){return=\"\" promise.resolve(this._bodyblob)}else{if(this._bodyarraybuffer){return=\"\" promise.resolve(new=\"\" blob([this._bodyarraybuffer]))}else{if(this._bodyformdata){throw=\"\" error(\"could=\"\" not=\"\" read=\"\" formdata=\"\" body=\"\" as=\"\" blob\")}else{return=\"\" blob([this._bodytext]))}}}};this.arraybuffer=\"function(){if(this._bodyArrayBuffer){return\" f(this)||promise.resolve(this._bodyarraybuffer)}else{return=\"\" this.blob().then(c)}}}this.text=\"function(){var\" d(this._bodyblob)}else{if(this._bodyarraybuffer){return=\"\" promise.resolve(u(this._bodyarraybuffer))}else{if(this._bodyformdata){throw=\"\" text\")}else{return=\"\" promise.resolve(this._bodytext)}}}};if(l.formdata){this.formdata=\"function(){return\" this.text().then(n)}}this.json=\"function(){return\" this.text().then(json.parse)};return=\"\" this}var=\"\" t=\"[\"DELETE\",\"GET\",\"HEAD\",\"OPTIONS\",\"POST\",\"PUT\"];function\" v(y){var=\"\">-1)?x:y}function r(y,z){z=z||{};var x=z.body;if(y instanceof r){if(y.bodyUsed){throw new TypeError(\"Already read\")}this.url=y.url;this.credentials=y.credentials;if(!z.headers){this.headers=new p(y.headers)}this.method=y.method;this.mode=y.mode;if(!x&&y._bodyInit!=null){x=y._bodyInit;y.bodyUsed=true}}else{this.url=String(y)}this.credentials=z.credentials||this.credentials||\"omit\";if(z.headers||!this.headers){this.headers=new p(z.headers)}this.method=v(z.method||this.method||\"GET\");this.mode=z.mode||this.mode||null;this.referrer=null;if((this.method===\"GET\"||this.method===\"HEAD\")&&x){throw new TypeError(\"Body not allowed for GET or HEAD requests\")}this._initBody(x)}r.prototype.clone=function(){return new r(this,{body:this._bodyInit})};function n(x){var y=new FormData();x.trim().split(\"&\").forEach(function(z){if(z){var B=z.split(\"=\");var A=B.shift().replace(/+/g,\" \");var C=B.join(\"=\").replace(/+/g,\" \");y.append(decodeURIComponent(A),decodeURIComponent(C))}});return y}function w(z){var y=new p();var x=z.replace(/r?n[t ]+/g,\" \");x.split(/r?n/).forEach(function(A){var D=A.split(\":\");var B=D.shift().trim();if(B){var C=D.join(\":\").trim();y.append(B,C)}});return y}q.call(r.prototype);function a(y,x){if(!x){x={}}this.type=\"default\";this.status=x.status===undefined?200:x.status;this.ok=this.status>=200&&this.status</x.length;z++){a[z]=string.fromcharcode(x[z])}return>","site":{"data":{}},"excerpt":"","more":"(function(o){if(o.fetch){return}var l={searchParams:\"URLSearchParams\" in o,iterable:\"Symbol\" in o&&\"iterator\" in Symbol,blob:\"FileReader\" in o&&\"Blob\" in o&&(function(){try{new Blob();return true}catch(x){return false}})(),formData:\"FormData\" in o,arrayBuffer:\"ArrayBuffer\" in o};if(l.arrayBuffer){var m=[\"[object Int8Array]\",\"[object Uint8Array]\",\"[object Uint8ClampedArray]\",\"[object Int16Array]\",\"[object Uint16Array]\",\"[object Int32Array]\",\"[object Uint32Array]\",\"[object Float32Array]\",\"[object Float64Array]\"];var s=function(x){return x&&DataView.prototype.isPrototypeOf(x)};var b=ArrayBuffer.isView||function(x){return x&&m.indexOf(Object.prototype.toString.call(x))>-1}}function i(x){if(typeof x!==\"string\"){x=String(x)}if(/[^a-z0-9-#$%&'*+.^_`|~]/i.test(x)){throw new TypeError(\"Invalid character in header field name\")}return x.toLowerCase()}function j(x){if(typeof x!==\"string\"){x=String(x)}return x}function e(x){var y={next:function(){var z=x.shift();return{done:z===undefined,value:z}}};if(l.iterable){y[Symbol.iterator]=function(){return y}}return y}function p(x){this.map={};if(x instanceof p){x.forEach(function(z,y){this.append(y,z)},this)}else{if(Array.isArray(x)){x.forEach(function(y){this.append(y[0],y[1])},this)}else{if(x){Object.getOwnPropertyNames(x).forEach(function(y){this.append(y,x[y])},this)}}}}p.prototype.append=function(y,z){y=i(y);z=j(z);var x=this.map[y];this.map[y]=x?x+\",\"+z:z};p.prototype[\"delete\"]=function(x){delete this.map[i(x)]};p.prototype.get=function(x){x=i(x);return this.has(x)?this.map[x]:null};p.prototype.has=function(x){return this.map.hasOwnProperty(i(x))};p.prototype.set=function(x,y){this.map[i(x)]=j(y)};p.prototype.forEach=function(z,x){for(var y in this.map){if(this.map.hasOwnProperty(y)){z.call(x,this.map[y],y,this)}}};p.prototype.keys=function(){var x=[];this.forEach(function(z,y){x.push(y)});return e(x)};p.prototype.values=function(){var x=[];this.forEach(function(y){x.push(y)});return e(x)};p.prototype.entries=function(){var x=[];this.forEach(function(z,y){x.push([y,z])});return e(x)};if(l.iterable){p.prototype[Symbol.iterator]=p.prototype.entries}function f(x){if(x.bodyUsed){return Promise.reject(new TypeError(\"Already read\"))}x.bodyUsed=true}function h(x){return new Promise(function(z,y){x.onload=function(){z(x.result)};x.onerror=function(){y(x.error)}})}function c(y){var x=new FileReader();var z=h(x);x.readAsArrayBuffer(y);return z}function d(y){var x=new FileReader();var z=h(x);x.readAsText(y);return z}function u(y){var x=new Uint8Array(y);var A=new Array(x.length);for(var z=0;z<x.length;z++){a[z]=string.fromcharcode(x[z])}return a.join(\"\")}function=\"\" k(y){if(y.slice){return=\"\" y.slice(0)}else{var=\"\" x=\"new\" uint8array(y.bytelength);x.set(new=\"\" uint8array(y));return=\"\" x.buffer}}function=\"\" q(){this.bodyused=\"false;this._initBody=function(x){this._bodyInit=x;if(!x){this._bodyText=\"\"}else{if(typeof\" blob([this._bodyarraybuffer])}else{if(l.arraybuffer&&(arraybuffer.prototype.isprototypeof(x)||b(x))){this._bodyarraybuffer=\"k(x)}else{throw\" new=\"\" error(\"unsupported=\"\" bodyinit=\"\" type\")}}}}}}}if(!this.headers.get(\"content-type\")){if(typeof=\"\" x}if(this._bodyblob){return=\"\" promise.resolve(this._bodyblob)}else{if(this._bodyarraybuffer){return=\"\" promise.resolve(new=\"\" blob([this._bodyarraybuffer]))}else{if(this._bodyformdata){throw=\"\" error(\"could=\"\" not=\"\" read=\"\" formdata=\"\" body=\"\" as=\"\" blob\")}else{return=\"\" blob([this._bodytext]))}}}};this.arraybuffer=\"function(){if(this._bodyArrayBuffer){return\" f(this)||promise.resolve(this._bodyarraybuffer)}else{return=\"\" this.blob().then(c)}}}this.text=\"function(){var\" d(this._bodyblob)}else{if(this._bodyarraybuffer){return=\"\" promise.resolve(u(this._bodyarraybuffer))}else{if(this._bodyformdata){throw=\"\" text\")}else{return=\"\" promise.resolve(this._bodytext)}}}};if(l.formdata){this.formdata=\"function(){return\" this.text().then(n)}}this.json=\"function(){return\" this.text().then(json.parse)};return=\"\" this}var=\"\" t=\"[\"DELETE\",\"GET\",\"HEAD\",\"OPTIONS\",\"POST\",\"PUT\"];function\" v(y){var=\"\">-1)?x:y}function r(y,z){z=z||{};var x=z.body;if(y instanceof r){if(y.bodyUsed){throw new TypeError(\"Already read\")}this.url=y.url;this.credentials=y.credentials;if(!z.headers){this.headers=new p(y.headers)}this.method=y.method;this.mode=y.mode;if(!x&&y._bodyInit!=null){x=y._bodyInit;y.bodyUsed=true}}else{this.url=String(y)}this.credentials=z.credentials||this.credentials||\"omit\";if(z.headers||!this.headers){this.headers=new p(z.headers)}this.method=v(z.method||this.method||\"GET\");this.mode=z.mode||this.mode||null;this.referrer=null;if((this.method===\"GET\"||this.method===\"HEAD\")&&x){throw new TypeError(\"Body not allowed for GET or HEAD requests\")}this._initBody(x)}r.prototype.clone=function(){return new r(this,{body:this._bodyInit})};function n(x){var y=new FormData();x.trim().split(\"&\").forEach(function(z){if(z){var B=z.split(\"=\");var A=B.shift().replace(/+/g,\" \");var C=B.join(\"=\").replace(/+/g,\" \");y.append(decodeURIComponent(A),decodeURIComponent(C))}});return y}function w(z){var y=new p();var x=z.replace(/r?n[t ]+/g,\" \");x.split(/r?n/).forEach(function(A){var D=A.split(\":\");var B=D.shift().trim();if(B){var C=D.join(\":\").trim();y.append(B,C)}});return y}q.call(r.prototype);function a(y,x){if(!x){x={}}this.type=\"default\";this.status=x.status===undefined?200:x.status;this.ok=this.status>=200&&this.status</x.length;z++){a[z]=string.fromcharcode(x[z])}return>"}],"Post":[{"title":"7招轻松搞定 JavaScript 多行字符串拼接","date":"2016-01-06T13:24:40.000Z","comments":0,"_content":"\n平常在做项目的时候，会经常遇到多行字符串拼接的需求，例如，我需要处理一个 `li` 标签动态拼接显示到 `ul` 中，等等，像这样的需求场景还是非常多的，这就需要根据在项目中实际遇到的需求来处理，选择合适的拼接方式会大大提高开发效率并减少出错的可能，在这里我总结了7招字符串拼接方法。\n\n<!-- more -->\n#### 需求场景\n在项目中，动态处理分页，根据系统设定的显示条目确定有多少分页，这时，需要将分页的内容经过处理动态生成再放回到原来的 `ul` 中，这时就需要进行多行字符串的拼接。\n\n```html\n<li><a href=\"#\">上页</a></li>\n<li><a href=\"#\"> 1 </a></li>\n<li><a href=\"#\">下页</a></li>\n```\n对于这样的 DOM 结构需要在 JavaScript 中拼接，你会怎样处理？\n#### 1. 常规方法\n```js\nvar s=`<li><a href=\"\">上页</a></li><li><a href=\"\">1</a></li><li><a href=\"\">下页</a></li>`;\n```\n#### 2. 字符串相加\n```js\nvar str = `<li><a href=\"#\">上页</a></li>` +\n          `<li><a href=\"#\"> 1 </a></li>` +\n          `<li><a href=\"#\">下页</a></li>`;\n```\n\n#### 3.反斜杠\n```js\nvar str = `<li><a href=\"#\">上页</a></li>\\\n           <li><a href=\"#\"> 1 </a></li>\\\n           <li><a href=\"#\">下页</a></li>`;\n```\n\n#### 4.数组切割\n```js\nvar str = [\n    `<li><a href=\"#\">上页</a></li>`,\n    `<li><a href=\"#\"> 1 </a></li>`,\n    `<li><a href=\"#\">下页</a></li>`\n].join('\\n');\n```\n\n#### 5. ES6 语法\n```js\nvar str = `<li><a href=\"#\">上页</a></li>\n          <li><a href=\"#\"> 1 </a></li>\n          <li><a href=\"#\">下页</a></li>`\n```\n\n#### 6.正则表达式\n```text\n查找：\\n\n替换：\\\\\\n\n通过正则表达式把原有的换行 \\n 替换成了 \\\\\\n 带有反斜杠的换行，本质是和反斜杠方法一样\n```\n![](http://ww3.sinaimg.cn/large/6057861cgw1fbn70seheej218s0v8n0x.jpg)\n\n#### 7.黑魔法\n```js\nfunction aHereDoc() {/*\n    <li><a href=\"#\">上页</a></li>\n    <li><a href=\"#\"> 1 </a></li>\n    <li><a href=\"#\">下页</a></li>\n    */}\n\nfunction hereDoc(func) {\n    return func.toString().split(/\\n/).slice(1, -1).join('\\n');\n}\nconsole.log(hereDoc(aHereDoc));\n```\n利用 `func.toString()` 获取需要批量处理的字符串，利用 `split(/\\n/).slice(1, -1)` 去掉首尾两行函数定义的代码，控制台输出：\n![](http://ww3.sinaimg.cn/large/6057861cgw1fbn6ta8s3yj21460b5jt0.jpg)\n","source":"_posts/7招轻松搞定-JavaScript-多行字符串拼接.md","raw":"---\ntitle: '7招轻松搞定 JavaScript 多行字符串拼接'\ndate: 2016-01-06 21:24:40\ntags:\ncomments: false\n---\n\n平常在做项目的时候，会经常遇到多行字符串拼接的需求，例如，我需要处理一个 `li` 标签动态拼接显示到 `ul` 中，等等，像这样的需求场景还是非常多的，这就需要根据在项目中实际遇到的需求来处理，选择合适的拼接方式会大大提高开发效率并减少出错的可能，在这里我总结了7招字符串拼接方法。\n\n<!-- more -->\n#### 需求场景\n在项目中，动态处理分页，根据系统设定的显示条目确定有多少分页，这时，需要将分页的内容经过处理动态生成再放回到原来的 `ul` 中，这时就需要进行多行字符串的拼接。\n\n```html\n<li><a href=\"#\">上页</a></li>\n<li><a href=\"#\"> 1 </a></li>\n<li><a href=\"#\">下页</a></li>\n```\n对于这样的 DOM 结构需要在 JavaScript 中拼接，你会怎样处理？\n#### 1. 常规方法\n```js\nvar s=`<li><a href=\"\">上页</a></li><li><a href=\"\">1</a></li><li><a href=\"\">下页</a></li>`;\n```\n#### 2. 字符串相加\n```js\nvar str = `<li><a href=\"#\">上页</a></li>` +\n          `<li><a href=\"#\"> 1 </a></li>` +\n          `<li><a href=\"#\">下页</a></li>`;\n```\n\n#### 3.反斜杠\n```js\nvar str = `<li><a href=\"#\">上页</a></li>\\\n           <li><a href=\"#\"> 1 </a></li>\\\n           <li><a href=\"#\">下页</a></li>`;\n```\n\n#### 4.数组切割\n```js\nvar str = [\n    `<li><a href=\"#\">上页</a></li>`,\n    `<li><a href=\"#\"> 1 </a></li>`,\n    `<li><a href=\"#\">下页</a></li>`\n].join('\\n');\n```\n\n#### 5. ES6 语法\n```js\nvar str = `<li><a href=\"#\">上页</a></li>\n          <li><a href=\"#\"> 1 </a></li>\n          <li><a href=\"#\">下页</a></li>`\n```\n\n#### 6.正则表达式\n```text\n查找：\\n\n替换：\\\\\\n\n通过正则表达式把原有的换行 \\n 替换成了 \\\\\\n 带有反斜杠的换行，本质是和反斜杠方法一样\n```\n![](http://ww3.sinaimg.cn/large/6057861cgw1fbn70seheej218s0v8n0x.jpg)\n\n#### 7.黑魔法\n```js\nfunction aHereDoc() {/*\n    <li><a href=\"#\">上页</a></li>\n    <li><a href=\"#\"> 1 </a></li>\n    <li><a href=\"#\">下页</a></li>\n    */}\n\nfunction hereDoc(func) {\n    return func.toString().split(/\\n/).slice(1, -1).join('\\n');\n}\nconsole.log(hereDoc(aHereDoc));\n```\n利用 `func.toString()` 获取需要批量处理的字符串，利用 `split(/\\n/).slice(1, -1)` 去掉首尾两行函数定义的代码，控制台输出：\n![](http://ww3.sinaimg.cn/large/6057861cgw1fbn6ta8s3yj21460b5jt0.jpg)\n","slug":"7招轻松搞定-JavaScript-多行字符串拼接","published":1,"updated":"2018-06-17T09:49:30.000Z","layout":"post","photos":[],"link":"","_id":"cjiitidhv0000u4q9aa1hww8v","content":"<p>平常在做项目的时候，会经常遇到多行字符串拼接的需求，例如，我需要处理一个 <code>li</code> 标签动态拼接显示到 <code>ul</code> 中，等等，像这样的需求场景还是非常多的，这就需要根据在项目中实际遇到的需求来处理，选择合适的拼接方式会大大提高开发效率并减少出错的可能，在这里我总结了7招字符串拼接方法。</p>\n<a id=\"more\"></a>\n<h4 id=\"需求场景\"><a href=\"#需求场景\" class=\"headerlink\" title=\"需求场景\"></a>需求场景</h4><p>在项目中，动态处理分页，根据系统设定的显示条目确定有多少分页，这时，需要将分页的内容经过处理动态生成再放回到原来的 <code>ul</code> 中，这时就需要进行多行字符串的拼接。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#\"</span>&gt;</span>上页<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#\"</span>&gt;</span> 1 <span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#\"</span>&gt;</span>下页<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>对于这样的 DOM 结构需要在 JavaScript 中拼接，你会怎样处理？</p>\n<h4 id=\"1-常规方法\"><a href=\"#1-常规方法\" class=\"headerlink\" title=\"1. 常规方法\"></a>1. 常规方法</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s=<span class=\"string\">`&lt;li&gt;&lt;a href=\"\"&gt;上页&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=\"\"&gt;1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=\"\"&gt;下页&lt;/a&gt;&lt;/li&gt;`</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-字符串相加\"><a href=\"#2-字符串相加\" class=\"headerlink\" title=\"2. 字符串相加\"></a>2. 字符串相加</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">`&lt;li&gt;&lt;a href=\"#\"&gt;上页&lt;/a&gt;&lt;/li&gt;`</span> +</span><br><span class=\"line\">          <span class=\"string\">`&lt;li&gt;&lt;a href=\"#\"&gt; 1 &lt;/a&gt;&lt;/li&gt;`</span> +</span><br><span class=\"line\">          <span class=\"string\">`&lt;li&gt;&lt;a href=\"#\"&gt;下页&lt;/a&gt;&lt;/li&gt;`</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-反斜杠\"><a href=\"#3-反斜杠\" class=\"headerlink\" title=\"3.反斜杠\"></a>3.反斜杠</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">`&lt;li&gt;&lt;a href=\"#\"&gt;上页&lt;/a&gt;&lt;/li&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">           &lt;li&gt;&lt;a href=\"#\"&gt; 1 &lt;/a&gt;&lt;/li&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">           &lt;li&gt;&lt;a href=\"#\"&gt;下页&lt;/a&gt;&lt;/li&gt;`</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-数组切割\"><a href=\"#4-数组切割\" class=\"headerlink\" title=\"4.数组切割\"></a>4.数组切割</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = [</span><br><span class=\"line\">    <span class=\"string\">`&lt;li&gt;&lt;a href=\"#\"&gt;上页&lt;/a&gt;&lt;/li&gt;`</span>,</span><br><span class=\"line\">    <span class=\"string\">`&lt;li&gt;&lt;a href=\"#\"&gt; 1 &lt;/a&gt;&lt;/li&gt;`</span>,</span><br><span class=\"line\">    <span class=\"string\">`&lt;li&gt;&lt;a href=\"#\"&gt;下页&lt;/a&gt;&lt;/li&gt;`</span></span><br><span class=\"line\">].join(<span class=\"string\">'\\n'</span>);</span><br></pre></td></tr></table></figure>\n<h4 id=\"5-ES6-语法\"><a href=\"#5-ES6-语法\" class=\"headerlink\" title=\"5. ES6 语法\"></a>5. ES6 语法</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">`&lt;li&gt;&lt;a href=\"#\"&gt;上页&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">          &lt;li&gt;&lt;a href=\"#\"&gt; 1 &lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">          &lt;li&gt;&lt;a href=\"#\"&gt;下页&lt;/a&gt;&lt;/li&gt;`</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"6-正则表达式\"><a href=\"#6-正则表达式\" class=\"headerlink\" title=\"6.正则表达式\"></a>6.正则表达式</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">查找：\\n</span><br><span class=\"line\">替换：\\\\\\n</span><br><span class=\"line\">通过正则表达式把原有的换行 \\n 替换成了 \\\\\\n 带有反斜杠的换行，本质是和反斜杠方法一样</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://ww3.sinaimg.cn/large/6057861cgw1fbn70seheej218s0v8n0x.jpg\" alt=\"\"></p>\n<h4 id=\"7-黑魔法\"><a href=\"#7-黑魔法\" class=\"headerlink\" title=\"7.黑魔法\"></a>7.黑魔法</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">aHereDoc</span>(<span class=\"params\"></span>) </span>&#123;<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    &lt;li&gt;&lt;a href=\"#\"&gt;上页&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"comment\">    &lt;li&gt;&lt;a href=\"#\"&gt; 1 &lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"comment\">    &lt;li&gt;&lt;a href=\"#\"&gt;下页&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"comment\">    */</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">hereDoc</span>(<span class=\"params\">func</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> func.toString().split(<span class=\"regexp\">/\\n/</span>).slice(<span class=\"number\">1</span>, <span class=\"number\">-1</span>).join(<span class=\"string\">'\\n'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(hereDoc(aHereDoc));</span><br></pre></td></tr></table></figure>\n<p>利用 <code>func.toString()</code> 获取需要批量处理的字符串，利用 <code>split(/\\n/).slice(1, -1)</code> 去掉首尾两行函数定义的代码，控制台输出：<br><img src=\"http://ww3.sinaimg.cn/large/6057861cgw1fbn6ta8s3yj21460b5jt0.jpg\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<p>平常在做项目的时候，会经常遇到多行字符串拼接的需求，例如，我需要处理一个 <code>li</code> 标签动态拼接显示到 <code>ul</code> 中，等等，像这样的需求场景还是非常多的，这就需要根据在项目中实际遇到的需求来处理，选择合适的拼接方式会大大提高开发效率并减少出错的可能，在这里我总结了7招字符串拼接方法。</p>","more":"<h4 id=\"需求场景\"><a href=\"#需求场景\" class=\"headerlink\" title=\"需求场景\"></a>需求场景</h4><p>在项目中，动态处理分页，根据系统设定的显示条目确定有多少分页，这时，需要将分页的内容经过处理动态生成再放回到原来的 <code>ul</code> 中，这时就需要进行多行字符串的拼接。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#\"</span>&gt;</span>上页<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#\"</span>&gt;</span> 1 <span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#\"</span>&gt;</span>下页<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>对于这样的 DOM 结构需要在 JavaScript 中拼接，你会怎样处理？</p>\n<h4 id=\"1-常规方法\"><a href=\"#1-常规方法\" class=\"headerlink\" title=\"1. 常规方法\"></a>1. 常规方法</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s=<span class=\"string\">`&lt;li&gt;&lt;a href=\"\"&gt;上页&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=\"\"&gt;1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=\"\"&gt;下页&lt;/a&gt;&lt;/li&gt;`</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-字符串相加\"><a href=\"#2-字符串相加\" class=\"headerlink\" title=\"2. 字符串相加\"></a>2. 字符串相加</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">`&lt;li&gt;&lt;a href=\"#\"&gt;上页&lt;/a&gt;&lt;/li&gt;`</span> +</span><br><span class=\"line\">          <span class=\"string\">`&lt;li&gt;&lt;a href=\"#\"&gt; 1 &lt;/a&gt;&lt;/li&gt;`</span> +</span><br><span class=\"line\">          <span class=\"string\">`&lt;li&gt;&lt;a href=\"#\"&gt;下页&lt;/a&gt;&lt;/li&gt;`</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-反斜杠\"><a href=\"#3-反斜杠\" class=\"headerlink\" title=\"3.反斜杠\"></a>3.反斜杠</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">`&lt;li&gt;&lt;a href=\"#\"&gt;上页&lt;/a&gt;&lt;/li&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">           &lt;li&gt;&lt;a href=\"#\"&gt; 1 &lt;/a&gt;&lt;/li&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">           &lt;li&gt;&lt;a href=\"#\"&gt;下页&lt;/a&gt;&lt;/li&gt;`</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-数组切割\"><a href=\"#4-数组切割\" class=\"headerlink\" title=\"4.数组切割\"></a>4.数组切割</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = [</span><br><span class=\"line\">    <span class=\"string\">`&lt;li&gt;&lt;a href=\"#\"&gt;上页&lt;/a&gt;&lt;/li&gt;`</span>,</span><br><span class=\"line\">    <span class=\"string\">`&lt;li&gt;&lt;a href=\"#\"&gt; 1 &lt;/a&gt;&lt;/li&gt;`</span>,</span><br><span class=\"line\">    <span class=\"string\">`&lt;li&gt;&lt;a href=\"#\"&gt;下页&lt;/a&gt;&lt;/li&gt;`</span></span><br><span class=\"line\">].join(<span class=\"string\">'\\n'</span>);</span><br></pre></td></tr></table></figure>\n<h4 id=\"5-ES6-语法\"><a href=\"#5-ES6-语法\" class=\"headerlink\" title=\"5. ES6 语法\"></a>5. ES6 语法</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">`&lt;li&gt;&lt;a href=\"#\"&gt;上页&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">          &lt;li&gt;&lt;a href=\"#\"&gt; 1 &lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">          &lt;li&gt;&lt;a href=\"#\"&gt;下页&lt;/a&gt;&lt;/li&gt;`</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"6-正则表达式\"><a href=\"#6-正则表达式\" class=\"headerlink\" title=\"6.正则表达式\"></a>6.正则表达式</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">查找：\\n</span><br><span class=\"line\">替换：\\\\\\n</span><br><span class=\"line\">通过正则表达式把原有的换行 \\n 替换成了 \\\\\\n 带有反斜杠的换行，本质是和反斜杠方法一样</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://ww3.sinaimg.cn/large/6057861cgw1fbn70seheej218s0v8n0x.jpg\" alt=\"\"></p>\n<h4 id=\"7-黑魔法\"><a href=\"#7-黑魔法\" class=\"headerlink\" title=\"7.黑魔法\"></a>7.黑魔法</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">aHereDoc</span>(<span class=\"params\"></span>) </span>&#123;<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    &lt;li&gt;&lt;a href=\"#\"&gt;上页&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"comment\">    &lt;li&gt;&lt;a href=\"#\"&gt; 1 &lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"comment\">    &lt;li&gt;&lt;a href=\"#\"&gt;下页&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"comment\">    */</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">hereDoc</span>(<span class=\"params\">func</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> func.toString().split(<span class=\"regexp\">/\\n/</span>).slice(<span class=\"number\">1</span>, <span class=\"number\">-1</span>).join(<span class=\"string\">'\\n'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(hereDoc(aHereDoc));</span><br></pre></td></tr></table></figure>\n<p>利用 <code>func.toString()</code> 获取需要批量处理的字符串，利用 <code>split(/\\n/).slice(1, -1)</code> 去掉首尾两行函数定义的代码，控制台输出：<br><img src=\"http://ww3.sinaimg.cn/large/6057861cgw1fbn6ta8s3yj21460b5jt0.jpg\" alt=\"\"></p>"},{"title":"CentOS 6 x86 Node.js + MongoDB + Express 环境配置笔记","date":"2015-01-01T12:18:33.000Z","comments":0,"_content":"\n总体来说配置比较顺利，也踩了不少坑 TAT，毕竟不是专业的运维人员，Linux 经验完全在平常项目中一点点积累的。\n<!-- more -->\n\n<div class=\"tip\">\n    重要提示：本文适用于有一定 Linux 基础的童鞋操作，比如懂得 `ls`、`cd`、`vim`等命令基本用法。\n    适用于操作系统：CentOS-6-x86_64，安装 node v6.9.4，mongodb v3.4.2。\n</div>\n\n### Node.js 安装\n0.进入到待安装位置\n```bash\ncd /usr/local/\n```\n\n1.下载安装文件\n```bash\nwget https://nodejs.org/dist/v6.9.4/node-v6.9.4-linux-x86.tar.xz\n```\n\n2.解压文件\n```bash\nxz -d node-v6.9.4-linux-x86.tar.xz\ntar xvf node-v6.9.4-linux-x86.tar\n```\n3.重命名文件\n```bash\nrm -rf node-v*.tar\nmv node-v* node\n```\n\n\n4.配置环境变量\n```bash\n#编辑系统文件\nvim ~/.bash_profile\n\n#在最顶端添加环境变量地址\nPATH=/usr/local/node/bin:$PATH\n\n#保存后重新启动以生效\nsource ~/.bash_profile\n```\n\n5.验证是否成功，显示版本号即安装成功！\n```bash\nnode -v\n```\n\n### Mongodb 安装\n\n0.进入到待安装位置\n```bash\ncd /usr/local/\n```\n\n1.下载安装文件\n```bash\nwget http://fastdl.mongodb.org/linux/mongodb-linux-x86_64-3.4.2.tgz\n```\n\n2.解压文件\n```bash\ntar zxf mongodb-linux-*.tgz\n```\n\n3.重命名\n```bash\nrm -rf mongodb-*.tgz\nmv mongodb-* mongodb\n```\n\n4.配置环境变量\n```bash\n#编辑系统文件\nvim ~/.bash_profile\n\n#在最顶端添加环境变量地址\nPATH=/usr/local/mongodb/bin:$PATH\n\n#保存后重新启动以生效\nsource ~/.bash_profile\n```\n\n5.验证是否安装成功\n```bash\nmongod --version\n```\n\n6.创建数据库目录和日志目录\n```bash\nmkdir -p /data/db\nmkdir -p /data/logs/mongodb.log\n```\n\n7.新增配置文件 `/data/mongodb.conf`\n```txet\n#数据库文件\ndbpath = /data/\n\n#日志文件\nlogpath = /data/logs/mongodb.log\n\n#默认端口\nport = 27017\n\n#后台运行\nfork = true\n\n#用户授权\nauth = true\n\n#不启用http访问\nnohttpinterface = true\n```\n<div class=\"tip\">\n添加授权后需要在 mongodb 数据库文件的 Users 集合新增用户，才可以正常使用。\n</div>\n\n\n8.在自启动文件 `/etc/rc.local` 中写入 mongod 进程带配置文件启动\n```bash\necho \"/usr/local/mongodb/bin/mongod -f /data/mongodb.conf\" >> /etc/rc.local\n```\n\n9.重启\n```bash\nreboot\n```\n\n\n### Express\n```bash\nnpm i express -g\n```\n","source":"_posts/CentOS-6-x86-Node-js-MongoDB-Express-环境配置笔记.md","raw":"---\ntitle: CentOS 6 x86 Node.js + MongoDB + Express 环境配置笔记\ndate: 2015-1-1 20:18:33\ntags:\ncomments: false\n---\n\n总体来说配置比较顺利，也踩了不少坑 TAT，毕竟不是专业的运维人员，Linux 经验完全在平常项目中一点点积累的。\n<!-- more -->\n\n<div class=\"tip\">\n    重要提示：本文适用于有一定 Linux 基础的童鞋操作，比如懂得 `ls`、`cd`、`vim`等命令基本用法。\n    适用于操作系统：CentOS-6-x86_64，安装 node v6.9.4，mongodb v3.4.2。\n</div>\n\n### Node.js 安装\n0.进入到待安装位置\n```bash\ncd /usr/local/\n```\n\n1.下载安装文件\n```bash\nwget https://nodejs.org/dist/v6.9.4/node-v6.9.4-linux-x86.tar.xz\n```\n\n2.解压文件\n```bash\nxz -d node-v6.9.4-linux-x86.tar.xz\ntar xvf node-v6.9.4-linux-x86.tar\n```\n3.重命名文件\n```bash\nrm -rf node-v*.tar\nmv node-v* node\n```\n\n\n4.配置环境变量\n```bash\n#编辑系统文件\nvim ~/.bash_profile\n\n#在最顶端添加环境变量地址\nPATH=/usr/local/node/bin:$PATH\n\n#保存后重新启动以生效\nsource ~/.bash_profile\n```\n\n5.验证是否成功，显示版本号即安装成功！\n```bash\nnode -v\n```\n\n### Mongodb 安装\n\n0.进入到待安装位置\n```bash\ncd /usr/local/\n```\n\n1.下载安装文件\n```bash\nwget http://fastdl.mongodb.org/linux/mongodb-linux-x86_64-3.4.2.tgz\n```\n\n2.解压文件\n```bash\ntar zxf mongodb-linux-*.tgz\n```\n\n3.重命名\n```bash\nrm -rf mongodb-*.tgz\nmv mongodb-* mongodb\n```\n\n4.配置环境变量\n```bash\n#编辑系统文件\nvim ~/.bash_profile\n\n#在最顶端添加环境变量地址\nPATH=/usr/local/mongodb/bin:$PATH\n\n#保存后重新启动以生效\nsource ~/.bash_profile\n```\n\n5.验证是否安装成功\n```bash\nmongod --version\n```\n\n6.创建数据库目录和日志目录\n```bash\nmkdir -p /data/db\nmkdir -p /data/logs/mongodb.log\n```\n\n7.新增配置文件 `/data/mongodb.conf`\n```txet\n#数据库文件\ndbpath = /data/\n\n#日志文件\nlogpath = /data/logs/mongodb.log\n\n#默认端口\nport = 27017\n\n#后台运行\nfork = true\n\n#用户授权\nauth = true\n\n#不启用http访问\nnohttpinterface = true\n```\n<div class=\"tip\">\n添加授权后需要在 mongodb 数据库文件的 Users 集合新增用户，才可以正常使用。\n</div>\n\n\n8.在自启动文件 `/etc/rc.local` 中写入 mongod 进程带配置文件启动\n```bash\necho \"/usr/local/mongodb/bin/mongod -f /data/mongodb.conf\" >> /etc/rc.local\n```\n\n9.重启\n```bash\nreboot\n```\n\n\n### Express\n```bash\nnpm i express -g\n```\n","slug":"CentOS-6-x86-Node-js-MongoDB-Express-环境配置笔记","published":1,"updated":"2018-06-17T09:49:30.000Z","layout":"post","photos":[],"link":"","_id":"cjiitidi10002u4q9o14v5u0x","content":"<p>总体来说配置比较顺利，也踩了不少坑 TAT，毕竟不是专业的运维人员，Linux 经验完全在平常项目中一点点积累的。<br><a id=\"more\"></a></p>\n<div class=\"tip\"><br>    重要提示：本文适用于有一定 Linux 基础的童鞋操作，比如懂得 <code>ls</code>、<code>cd</code>、<code>vim</code>等命令基本用法。<br>    适用于操作系统：CentOS-6-x86_64，安装 node v6.9.4，mongodb v3.4.2。<br></div>\n\n<h3 id=\"Node-js-安装\"><a href=\"#Node-js-安装\" class=\"headerlink\" title=\"Node.js 安装\"></a>Node.js 安装</h3><p>0.进入到待安装位置<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/</span><br></pre></td></tr></table></figure></p>\n<p>1.下载安装文件<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://nodejs.org/dist/v6.9.4/node-v6.9.4-linux-x86.tar.xz</span><br></pre></td></tr></table></figure></p>\n<p>2.解压文件<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xz -d node-v6.9.4-linux-x86.tar.xz</span><br><span class=\"line\">tar xvf node-v6.9.4-linux-x86.tar</span><br></pre></td></tr></table></figure></p>\n<p>3.重命名文件<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm -rf node-v*.tar</span><br><span class=\"line\">mv node-v* node</span><br></pre></td></tr></table></figure></p>\n<p>4.配置环境变量<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#编辑系统文件</span></span><br><span class=\"line\">vim ~/.bash_profile</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#在最顶端添加环境变量地址</span></span><br><span class=\"line\">PATH=/usr/<span class=\"built_in\">local</span>/node/bin:<span class=\"variable\">$PATH</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#保存后重新启动以生效</span></span><br><span class=\"line\"><span class=\"built_in\">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure></p>\n<p>5.验证是否成功，显示版本号即安装成功！<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node -v</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Mongodb-安装\"><a href=\"#Mongodb-安装\" class=\"headerlink\" title=\"Mongodb 安装\"></a>Mongodb 安装</h3><p>0.进入到待安装位置<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/</span><br></pre></td></tr></table></figure></p>\n<p>1.下载安装文件<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http://fastdl.mongodb.org/linux/mongodb-linux-x86_64-3.4.2.tgz</span><br></pre></td></tr></table></figure></p>\n<p>2.解压文件<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar zxf mongodb-linux-*.tgz</span><br></pre></td></tr></table></figure></p>\n<p>3.重命名<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm -rf mongodb-*.tgz</span><br><span class=\"line\">mv mongodb-* mongodb</span><br></pre></td></tr></table></figure></p>\n<p>4.配置环境变量<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#编辑系统文件</span></span><br><span class=\"line\">vim ~/.bash_profile</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#在最顶端添加环境变量地址</span></span><br><span class=\"line\">PATH=/usr/<span class=\"built_in\">local</span>/mongodb/bin:<span class=\"variable\">$PATH</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#保存后重新启动以生效</span></span><br><span class=\"line\"><span class=\"built_in\">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure></p>\n<p>5.验证是否安装成功<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mongod --version</span><br></pre></td></tr></table></figure></p>\n<p>6.创建数据库目录和日志目录<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir -p /data/db</span><br><span class=\"line\">mkdir -p /data/logs/mongodb.log</span><br></pre></td></tr></table></figure></p>\n<p>7.新增配置文件 <code>/data/mongodb.conf</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#数据库文件</span><br><span class=\"line\">dbpath = /data/</span><br><span class=\"line\"></span><br><span class=\"line\">#日志文件</span><br><span class=\"line\">logpath = /data/logs/mongodb.log</span><br><span class=\"line\"></span><br><span class=\"line\">#默认端口</span><br><span class=\"line\">port = 27017</span><br><span class=\"line\"></span><br><span class=\"line\">#后台运行</span><br><span class=\"line\">fork = true</span><br><span class=\"line\"></span><br><span class=\"line\">#用户授权</span><br><span class=\"line\">auth = true</span><br><span class=\"line\"></span><br><span class=\"line\">#不启用http访问</span><br><span class=\"line\">nohttpinterface = true</span><br></pre></td></tr></table></figure></p>\n<div class=\"tip\"><br>添加授权后需要在 mongodb 数据库文件的 Users 集合新增用户，才可以正常使用。<br></div>\n\n\n<p>8.在自启动文件 <code>/etc/rc.local</code> 中写入 mongod 进程带配置文件启动<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"/usr/local/mongodb/bin/mongod -f /data/mongodb.conf\"</span> &gt;&gt; /etc/rc.local</span><br></pre></td></tr></table></figure></p>\n<p>9.重启<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reboot</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Express\"><a href=\"#Express\" class=\"headerlink\" title=\"Express\"></a>Express</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i express -g</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>总体来说配置比较顺利，也踩了不少坑 TAT，毕竟不是专业的运维人员，Linux 经验完全在平常项目中一点点积累的。<br>","more":"</p>\n<div class=\"tip\"><br>    重要提示：本文适用于有一定 Linux 基础的童鞋操作，比如懂得 <code>ls</code>、<code>cd</code>、<code>vim</code>等命令基本用法。<br>    适用于操作系统：CentOS-6-x86_64，安装 node v6.9.4，mongodb v3.4.2。<br></div>\n\n<h3 id=\"Node-js-安装\"><a href=\"#Node-js-安装\" class=\"headerlink\" title=\"Node.js 安装\"></a>Node.js 安装</h3><p>0.进入到待安装位置<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/</span><br></pre></td></tr></table></figure></p>\n<p>1.下载安装文件<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://nodejs.org/dist/v6.9.4/node-v6.9.4-linux-x86.tar.xz</span><br></pre></td></tr></table></figure></p>\n<p>2.解压文件<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xz -d node-v6.9.4-linux-x86.tar.xz</span><br><span class=\"line\">tar xvf node-v6.9.4-linux-x86.tar</span><br></pre></td></tr></table></figure></p>\n<p>3.重命名文件<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm -rf node-v*.tar</span><br><span class=\"line\">mv node-v* node</span><br></pre></td></tr></table></figure></p>\n<p>4.配置环境变量<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#编辑系统文件</span></span><br><span class=\"line\">vim ~/.bash_profile</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#在最顶端添加环境变量地址</span></span><br><span class=\"line\">PATH=/usr/<span class=\"built_in\">local</span>/node/bin:<span class=\"variable\">$PATH</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#保存后重新启动以生效</span></span><br><span class=\"line\"><span class=\"built_in\">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure></p>\n<p>5.验证是否成功，显示版本号即安装成功！<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node -v</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Mongodb-安装\"><a href=\"#Mongodb-安装\" class=\"headerlink\" title=\"Mongodb 安装\"></a>Mongodb 安装</h3><p>0.进入到待安装位置<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/</span><br></pre></td></tr></table></figure></p>\n<p>1.下载安装文件<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http://fastdl.mongodb.org/linux/mongodb-linux-x86_64-3.4.2.tgz</span><br></pre></td></tr></table></figure></p>\n<p>2.解压文件<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar zxf mongodb-linux-*.tgz</span><br></pre></td></tr></table></figure></p>\n<p>3.重命名<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm -rf mongodb-*.tgz</span><br><span class=\"line\">mv mongodb-* mongodb</span><br></pre></td></tr></table></figure></p>\n<p>4.配置环境变量<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#编辑系统文件</span></span><br><span class=\"line\">vim ~/.bash_profile</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#在最顶端添加环境变量地址</span></span><br><span class=\"line\">PATH=/usr/<span class=\"built_in\">local</span>/mongodb/bin:<span class=\"variable\">$PATH</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#保存后重新启动以生效</span></span><br><span class=\"line\"><span class=\"built_in\">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure></p>\n<p>5.验证是否安装成功<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mongod --version</span><br></pre></td></tr></table></figure></p>\n<p>6.创建数据库目录和日志目录<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir -p /data/db</span><br><span class=\"line\">mkdir -p /data/logs/mongodb.log</span><br></pre></td></tr></table></figure></p>\n<p>7.新增配置文件 <code>/data/mongodb.conf</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#数据库文件</span><br><span class=\"line\">dbpath = /data/</span><br><span class=\"line\"></span><br><span class=\"line\">#日志文件</span><br><span class=\"line\">logpath = /data/logs/mongodb.log</span><br><span class=\"line\"></span><br><span class=\"line\">#默认端口</span><br><span class=\"line\">port = 27017</span><br><span class=\"line\"></span><br><span class=\"line\">#后台运行</span><br><span class=\"line\">fork = true</span><br><span class=\"line\"></span><br><span class=\"line\">#用户授权</span><br><span class=\"line\">auth = true</span><br><span class=\"line\"></span><br><span class=\"line\">#不启用http访问</span><br><span class=\"line\">nohttpinterface = true</span><br></pre></td></tr></table></figure></p>\n<div class=\"tip\"><br>添加授权后需要在 mongodb 数据库文件的 Users 集合新增用户，才可以正常使用。<br></div>\n\n\n<p>8.在自启动文件 <code>/etc/rc.local</code> 中写入 mongod 进程带配置文件启动<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"/usr/local/mongodb/bin/mongod -f /data/mongodb.conf\"</span> &gt;&gt; /etc/rc.local</span><br></pre></td></tr></table></figure></p>\n<p>9.重启<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reboot</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Express\"><a href=\"#Express\" class=\"headerlink\" title=\"Express\"></a>Express</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i express -g</span><br></pre></td></tr></table></figure>"},{"title":"ES6 Promise 简明指南","comments":1,"date":"2018-05-29T14:28:41.000Z","from":"https://codeburst.io/a-simple-guide-to-es6-promises-d71bacd2e13a","_content":"\nPromise 是 JavaScriptES6 中最令人兴奋的新增功能之一. ES5 中使用回调函数来处理异步操作. 过度使用回调则会产生回调地狱和多级嵌套缩带来的问题. Promise 通过将异步代码转化成同步执行的方式, 大大简化了异步编程方式.\n\n<!-- more -->\n\n这篇文章中, 我们来学习一下什么是 Promise 以及在开发中的实践.\n\n### 什么是 Promise\n\n简单来说 Promise 就是一个存放着未来才会有计算结果的占位符. 稍微想想, 你会发现, 这和我们平常在谈话过程中说的承诺很像. 举个例子: 你准备去印度旅行, 你订了一张去印度的机票. 这个机票上写着多少号, 座位号是多少. 这个场景下, 机票就是航空公司给你许下的承诺: 在你准备出发那天给你预留了一个头等舱！😎\n\n还有一个简单的例子, 你承诺你的朋友, 当你读完《计算机编程艺术》这本书后, 你就把这本书还回去. 在这里, 你所说的话就好比是一个占位符, 需要返回的值就是这本书.\n\n你还可以想到其他一些类似承诺的例子, 比如在医生办公室等着、在餐馆点餐、在图书馆写书等等. 都涉及某种形式的承诺.\n\n### 生成一个 Promise\n\n当某项任务的完成时间不确定或太长时, 就可以使用 Promise. 例如, 网络请求可能需要 10ms 到 200ms（或更长）的时间, 具体取决于网速. 我们不想在获取数据时等待. 200 毫秒对你来说可能不太重要, 但对于一台电脑来说, 这是一段很长的时间. Promise 就是要让这种异步变得简单、轻松. 使用 Promise 构造函数, 来实例化一个 myPromise 实例, 像这样:\n\n```js\nconst myPromise = new Promise((resolve, reject) => {\n  if (Math.random() * 100 <= 90) {\n    resolve('Hello, Promises!');\n  }\n  reject(new Error('In 10% of the cases, I fail. Miserably.'));\n});\n```\n\n来看一下这个接收两个参数的函数. `new Promise()` 被称为执行器函数, 它描述了要完成的计算. 它的这两个参数通常被叫做 `resolve` 和 `reject`, 可以理解为 **执行** 和 **拒绝**, 它们用来标记执行器函数最终的计算结果. `resolve` 和 `reject` 本身是一个函数, 它用来返回一个值给我们的 Promise 实例.\n\n当运算结果成功时, 或者未来着这个值准备就绪时, 我们就使用这个 `resolve` 函数来返回一个值, 我们就说: 我践行了当初许下的这个承诺.\n\n同理, 当计算结果失败时, 或者计算过程中遇到了错误, 我们就使用 `reject` 函数, 我们就说: 我拒绝履行这个承诺. `reject` 函数可以接收任何值来作为参数, 但是比较推荐的是我们可以传递一个 `Error` 对象, 即: 抛出一个错误, 用来帮助我们调试代码, 这样就可以根据具体的抛出错误信息去解决问题啦.\n\n在上面的这个例子中, `Math.random()` 用来生成一个随机数, 在 90% 的情况下, 这个 Promise 都应该被执行 (假设等概率分布), 剩余的情况下都是拒绝执行的.\n\n### 如何使用 Promises\n\n在上面的代码例子中, 我们生成了一个 Promise 实例 `myPromise`, 那么如何通过 `resolve` 和 `reject` 函数访问计算完成后的值呢? 所有的 `Promise` 实例都有一个 `.then()` 方法, 我们来瞧瞧:\n\n```js\nconst myPromise = new Promise((resolve, reject) => {\n  if (Math.random() * 100 < 90) {\n    console.log('resolving the promise ...');\n    resolve('Hello, Promises!');\n  }\n  reject(new Error('In 10% of the cases, I fail. Miserably.'));\n});\n\n// Two functions\nconst onResolved = resolvedValue => console.log(resolvedValue);\nconst onRejected = error => console.log(error);\n\nmyPromise.then(onResolved, onRejected);\n\n// Same as above, written concisely\nmyPromise.then(\n  resolvedValue => {\n    console.log(resolvedValue);\n  },\n  error => {\n    console.log(error);\n  }\n);\n\n// Output (in 90% of the cases)\n\n// resolving the promise ...\n// Hello, Promises!\n// Hello, Promises!\n```\n\n`.then()` 方法接收 2 个回调函数, 第一个回调函数是当我们的 Promise 实例被执行 (resolve) 时调用, 第二个则是被拒绝 (reject) 时调用. 在上面的代码中, 我们使用 `onResolved` 和 `onRejected` 定义了这两个函数, 然后把它放到 `.then` 函数里, 当然, 你也可以按照常规写法, 直接在 `.then` 函数里写两个函数, 都是一样的.\n\n在这个例子中, 有几点非常重要, 我们来说一下:\n\n* 一个 `promise` 只能是成功或者失败状态中的一个. 它不能成功或者失败多次. 也不能从成功状态切换到失败状态, 失败反之亦然.\n* 你可以在成功或者失败状态后, 去定义这样一个回调函数. 当他们 `resolve` 或者 `reject` 仍然能正确调用.\n\n这就说明, `Promise` 最终只有一个状态, 即使你多次使用 `.then` 处理函数, 这个状态不能更改 (计算结果也不会重复执行).\n\n为了验证这点, 你可以看到在第 3 行代码中, `console.log` 语句, 当你多次使用 `.then` 处理程序运行上述代码时, `console.log` 的语句只会被打印一次. 这就说明了 Promise 会缓存计算结果的, 当有一些相同的结果时, 缓存结果会被返回.\n\n另一个重要的要注意的是, Promise 是 [及早求值 (evaluated eagerly)](https://zh.wikipedia.org/wiki/%E5%8F%8A%E6%97%A9%E6%B1%82%E5%80%BC) 的: 只要声明并将其赋值到变量上, 它已经开始在内存中执行了. 没有 `.start` 或 `.begin` 方法. 就像它在前面的例子中开始的那样.\n\n为了确保 Promise 能被延迟调用, 我们通常还需要在它的外层包裹一个函数, 稍后的例子中我们会解释这个.\n\n### 捕获 Promise\n\n到目前为止, 我们已经看到了 `resolve` 的场景, 那么当执行函数中出现一个错误时, 会发生什么呢? 在 `.then()` 函数中的第二个参数, 就是上面例子中的 `onRejected` 会被执行, 来看一个例子:\n\n```js\nconst myPromise = new Promise((resolve, reject) => {\n  if (Math.random() * 100 < 90) {\n    reject(new Error('The promise was rejected by using reject function.'));\n  }\n  throw new Error('The promise was rejected by throwing an error');\n});\n\nmyPromise.then(\n  () => console.log('resolved'),\n  error => console.log(error.message)\n);\n\n// Output (in 90% of cases)\n\n// The promise was rejected by using reject function.\n```\n\n和第一个例子一样的, 但是现在 90% 的情况是被 `reject` 的, 另外 10% 的情况则是抛出一个错误语句.\n\n在第一个例子中, 我们分别定义了 `onResolved` 和 `onRejected` 方法, `onRejected` 方法将在错误发生时被调用, 可以看到 `reject` 函数的参数可以直接是错误提示, 没必要必须 `new Error`, 两个写法都一样.\n\n健壮的程序代码离不开错误处理, `.then` 方法的第二个参数给了我们这样一个捷径. 当需要处理一个错误时, 可以用 `.catch(onRejected)` 来代替 `.then(null, () => {...})`, `catch` 方法接收一个回调函数 `onRejected`, 因此, 上面的代码, 可以使用 `catch` 来简化写法:\n\n```js\nmyPromise.catch(error => console.log(error.message));\n```\n\n记住: `.catch` 方法仅仅是 `.then(undefined, onRejected)` 的语法糖而已.\n\n### 链式 Promise\n\n`.then()` 和 `.catch()` 方法永远会返回一个 Promise 实例, 所以你可以链式使用多个 `.then` 一起来调用. 让我们来举个例子理解它.\n\n首先, 我们写一个函数, 来延迟返回一个 Promise 实例. 这个返回的 Promise 将在稍后的时间内 `resolve`. 这里是实现方法:\n\n```js\nconst delay = ms => new Promise(resolve => setTimeout(resolve, ms));\n```\n\n在这个例子中, 我们正在使用一个函数来包裹我们的 Promise 实例, 所以它并不会立即执行. 这个 `delay` 函数接收一个时间来作为参数. 这个执行函数将接收 `ms` 作为他的参数, 它还包含一个 `setTimeout` , 它在 `ms` 毫秒后调用 `resolve` 函数, 从而正确执行. 看这个例子:\n\n```js\ndelay(5000).then(() => console.log('Resolved after 5 seconds'));\n```\n\n`.then` 中的回调语句将在 `delay(5000)` 后执行. 当你执行上面的代码 5 秒后, 你就可以在控制台上看到输出结果了.\n\n这里, 我们可以使用多个 `.then()` 方法来链式调用:\n\n```js\nconst delay = ms => new Promise(resolve => setTimeout(resolve, ms));\n\ndelay(2000)\n  .then(() => {\n    console.log('Resolved after 2 seconds');\n    return delay(1500);\n  })\n  .then(() => {\n    console.log('Resolved after 1.5 seconds');\n    return delay(3000);\n  })\n  .then(() => {\n    console.log('Resolved after 3 seconds');\n    throw new Error();\n  })\n  .catch(() => {\n    console.log('Caught an error.');\n  })\n  .then(() => {\n    console.log('Done.');\n  });\n\n// Resolved after 2 seconds\n// Resolved after 1.5 seconds\n// Resolved after 3 seconds\n// Caught an error.\n// Done.\n```\n\n从第 3 行开始, 它的执行步骤是这样的:\n\n* `delay(2000)` 函数执行, 它返回一个稍后 2 秒即将执行的 Promise 实例.\n* 第 1 个 `.then()` 执行, 它输出语句 `Resolved after 2 seconds`, 然后它执行 `delay(1500)` 又返回一个 Promise 实例, 如果一个 `.then()` 返回了一个 Promise 实例, 那么它的 `resolve` 将被转发给下一个 `.then` 方法调用, 技术上叫: 沉降 (settlement).\n* 只要像这样继续串联下去, 它会继续执行.\n\n注意在第三个 `.then()` 方法时, 我们在 `.then` 中抛出了一个错误. 这意味着当前的 Promise 被拒绝. 然后它会在下一个 `.catch` 语句中被捕获, `Caught an error` 将会被输出. 然而一个 `.catch` 语句它自己永远是被 `resolve` 的, 所以不需要在语句里再写 `reject` (除非你故意抛出一个错误), 这也是为什么在 `.catch` 语句后还可以继续写 `.then` 的原因.\n\n比较推荐的做法是在 `.then` 方法后执行 `.catch` 而不是使用 `onResolved` 和 `onRejected`, 我们来举个例子说明一下:\n\n```js\nconst promiseThatResolves = () =>\n  new Promise((resolve, reject) => {\n    resolve();\n  });\n\n// Leads to UnhandledPromiseRejection\npromiseThatResolves().then(\n  () => {\n    throw new Error();\n  },\n  err => console.log(err)\n);\n\n// Proper error handling\npromiseThatResolves()\n  .then(() => {\n    throw new Error();\n  })\n  .catch(err => console.log(err));\n```\n\n我们创造一个永远能被 `resolve` 的 Promise 实例, 当你执行 `.then` 时, 可以带两个回调函数: `onResolved` 和 `onRejected`, 第一种写法, 在 `then` 种放入两个回调函数, 但是: 如果在第一个回调函数中继续抛出错误, 那么这个错误是不能被捕获的. 😅\n\n第二种写法, 在 `.then` 语句的后面使用 `.catch` 捕获, 不光能捕获到执行函数 `promiseThatResolves` 的错误, 而且在 `.then()` 中的错误也是能被捕获到. 知道这样写的好处了吧!😁\n\n### 总结\n\n你可以执行上面的所有代码片段来更深入的学习. 一种比较好的实践就是, 把所有基于回调的函数都用 Promise 来重新实现. 如果你写 Node.js 的话, 你会发现 `fs` 还有其他模块都是基于回调函数来实现的. 所以会存在一些工具库, 它们把所有基于回调的实现方式使用 Promise 来实现了. 比如 Node.js 的 [util.promisify](https://nodejs.org/api/util.html#util_util_promisify_original) 和 [pify](https://github.com/sindresorhus/pify). 如果你在学习的话, 那么尽可能的尝试自己去实现. 或者说去读这些 Promise 实现库的源代码. 然后你就可以把这些最佳实践用于你的产品中啦!\n\n还有一些关于 Promise 的东西没有完全讲到, 比如 `Promise.all` 和 `Promise.race` 方法, 处理 Promise 中的错误, 以及一些常见的反模式和细节等. 你可以参考下面的链接来学习更多关于 Promise 的知识.\n\n### 参考\n\n* [ECMA Promise Specification](http://www.ecma-international.org/ecma-262/6.0/#sec-promise-objects)\n* [Mozilla Docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)\n* [Google’s Developer’s Guide on Promises written by Jake Archibald](https://developers.google.com/web/fundamentals/primers/promises#promise-api-reference)\n* [Exploring JS’s Chapter on Promises](http://exploringjs.com/es6/ch_promises.html#sec_first-example-promises)\n* [Introduction to Promises](http://jamesknelson.com/grokking-es6-promises-the-four-functions-you-need-to-avoid-callback-hell/)\n","source":"_posts/ES6-Promise-简明指南.md","raw":"---\ntitle: ES6 Promise 简明指南\ncomments: true\ndate: 2018-05-29 22:28:41\ntags:\nfrom: https://codeburst.io/a-simple-guide-to-es6-promises-d71bacd2e13a\n---\n\nPromise 是 JavaScriptES6 中最令人兴奋的新增功能之一. ES5 中使用回调函数来处理异步操作. 过度使用回调则会产生回调地狱和多级嵌套缩带来的问题. Promise 通过将异步代码转化成同步执行的方式, 大大简化了异步编程方式.\n\n<!-- more -->\n\n这篇文章中, 我们来学习一下什么是 Promise 以及在开发中的实践.\n\n### 什么是 Promise\n\n简单来说 Promise 就是一个存放着未来才会有计算结果的占位符. 稍微想想, 你会发现, 这和我们平常在谈话过程中说的承诺很像. 举个例子: 你准备去印度旅行, 你订了一张去印度的机票. 这个机票上写着多少号, 座位号是多少. 这个场景下, 机票就是航空公司给你许下的承诺: 在你准备出发那天给你预留了一个头等舱！😎\n\n还有一个简单的例子, 你承诺你的朋友, 当你读完《计算机编程艺术》这本书后, 你就把这本书还回去. 在这里, 你所说的话就好比是一个占位符, 需要返回的值就是这本书.\n\n你还可以想到其他一些类似承诺的例子, 比如在医生办公室等着、在餐馆点餐、在图书馆写书等等. 都涉及某种形式的承诺.\n\n### 生成一个 Promise\n\n当某项任务的完成时间不确定或太长时, 就可以使用 Promise. 例如, 网络请求可能需要 10ms 到 200ms（或更长）的时间, 具体取决于网速. 我们不想在获取数据时等待. 200 毫秒对你来说可能不太重要, 但对于一台电脑来说, 这是一段很长的时间. Promise 就是要让这种异步变得简单、轻松. 使用 Promise 构造函数, 来实例化一个 myPromise 实例, 像这样:\n\n```js\nconst myPromise = new Promise((resolve, reject) => {\n  if (Math.random() * 100 <= 90) {\n    resolve('Hello, Promises!');\n  }\n  reject(new Error('In 10% of the cases, I fail. Miserably.'));\n});\n```\n\n来看一下这个接收两个参数的函数. `new Promise()` 被称为执行器函数, 它描述了要完成的计算. 它的这两个参数通常被叫做 `resolve` 和 `reject`, 可以理解为 **执行** 和 **拒绝**, 它们用来标记执行器函数最终的计算结果. `resolve` 和 `reject` 本身是一个函数, 它用来返回一个值给我们的 Promise 实例.\n\n当运算结果成功时, 或者未来着这个值准备就绪时, 我们就使用这个 `resolve` 函数来返回一个值, 我们就说: 我践行了当初许下的这个承诺.\n\n同理, 当计算结果失败时, 或者计算过程中遇到了错误, 我们就使用 `reject` 函数, 我们就说: 我拒绝履行这个承诺. `reject` 函数可以接收任何值来作为参数, 但是比较推荐的是我们可以传递一个 `Error` 对象, 即: 抛出一个错误, 用来帮助我们调试代码, 这样就可以根据具体的抛出错误信息去解决问题啦.\n\n在上面的这个例子中, `Math.random()` 用来生成一个随机数, 在 90% 的情况下, 这个 Promise 都应该被执行 (假设等概率分布), 剩余的情况下都是拒绝执行的.\n\n### 如何使用 Promises\n\n在上面的代码例子中, 我们生成了一个 Promise 实例 `myPromise`, 那么如何通过 `resolve` 和 `reject` 函数访问计算完成后的值呢? 所有的 `Promise` 实例都有一个 `.then()` 方法, 我们来瞧瞧:\n\n```js\nconst myPromise = new Promise((resolve, reject) => {\n  if (Math.random() * 100 < 90) {\n    console.log('resolving the promise ...');\n    resolve('Hello, Promises!');\n  }\n  reject(new Error('In 10% of the cases, I fail. Miserably.'));\n});\n\n// Two functions\nconst onResolved = resolvedValue => console.log(resolvedValue);\nconst onRejected = error => console.log(error);\n\nmyPromise.then(onResolved, onRejected);\n\n// Same as above, written concisely\nmyPromise.then(\n  resolvedValue => {\n    console.log(resolvedValue);\n  },\n  error => {\n    console.log(error);\n  }\n);\n\n// Output (in 90% of the cases)\n\n// resolving the promise ...\n// Hello, Promises!\n// Hello, Promises!\n```\n\n`.then()` 方法接收 2 个回调函数, 第一个回调函数是当我们的 Promise 实例被执行 (resolve) 时调用, 第二个则是被拒绝 (reject) 时调用. 在上面的代码中, 我们使用 `onResolved` 和 `onRejected` 定义了这两个函数, 然后把它放到 `.then` 函数里, 当然, 你也可以按照常规写法, 直接在 `.then` 函数里写两个函数, 都是一样的.\n\n在这个例子中, 有几点非常重要, 我们来说一下:\n\n* 一个 `promise` 只能是成功或者失败状态中的一个. 它不能成功或者失败多次. 也不能从成功状态切换到失败状态, 失败反之亦然.\n* 你可以在成功或者失败状态后, 去定义这样一个回调函数. 当他们 `resolve` 或者 `reject` 仍然能正确调用.\n\n这就说明, `Promise` 最终只有一个状态, 即使你多次使用 `.then` 处理函数, 这个状态不能更改 (计算结果也不会重复执行).\n\n为了验证这点, 你可以看到在第 3 行代码中, `console.log` 语句, 当你多次使用 `.then` 处理程序运行上述代码时, `console.log` 的语句只会被打印一次. 这就说明了 Promise 会缓存计算结果的, 当有一些相同的结果时, 缓存结果会被返回.\n\n另一个重要的要注意的是, Promise 是 [及早求值 (evaluated eagerly)](https://zh.wikipedia.org/wiki/%E5%8F%8A%E6%97%A9%E6%B1%82%E5%80%BC) 的: 只要声明并将其赋值到变量上, 它已经开始在内存中执行了. 没有 `.start` 或 `.begin` 方法. 就像它在前面的例子中开始的那样.\n\n为了确保 Promise 能被延迟调用, 我们通常还需要在它的外层包裹一个函数, 稍后的例子中我们会解释这个.\n\n### 捕获 Promise\n\n到目前为止, 我们已经看到了 `resolve` 的场景, 那么当执行函数中出现一个错误时, 会发生什么呢? 在 `.then()` 函数中的第二个参数, 就是上面例子中的 `onRejected` 会被执行, 来看一个例子:\n\n```js\nconst myPromise = new Promise((resolve, reject) => {\n  if (Math.random() * 100 < 90) {\n    reject(new Error('The promise was rejected by using reject function.'));\n  }\n  throw new Error('The promise was rejected by throwing an error');\n});\n\nmyPromise.then(\n  () => console.log('resolved'),\n  error => console.log(error.message)\n);\n\n// Output (in 90% of cases)\n\n// The promise was rejected by using reject function.\n```\n\n和第一个例子一样的, 但是现在 90% 的情况是被 `reject` 的, 另外 10% 的情况则是抛出一个错误语句.\n\n在第一个例子中, 我们分别定义了 `onResolved` 和 `onRejected` 方法, `onRejected` 方法将在错误发生时被调用, 可以看到 `reject` 函数的参数可以直接是错误提示, 没必要必须 `new Error`, 两个写法都一样.\n\n健壮的程序代码离不开错误处理, `.then` 方法的第二个参数给了我们这样一个捷径. 当需要处理一个错误时, 可以用 `.catch(onRejected)` 来代替 `.then(null, () => {...})`, `catch` 方法接收一个回调函数 `onRejected`, 因此, 上面的代码, 可以使用 `catch` 来简化写法:\n\n```js\nmyPromise.catch(error => console.log(error.message));\n```\n\n记住: `.catch` 方法仅仅是 `.then(undefined, onRejected)` 的语法糖而已.\n\n### 链式 Promise\n\n`.then()` 和 `.catch()` 方法永远会返回一个 Promise 实例, 所以你可以链式使用多个 `.then` 一起来调用. 让我们来举个例子理解它.\n\n首先, 我们写一个函数, 来延迟返回一个 Promise 实例. 这个返回的 Promise 将在稍后的时间内 `resolve`. 这里是实现方法:\n\n```js\nconst delay = ms => new Promise(resolve => setTimeout(resolve, ms));\n```\n\n在这个例子中, 我们正在使用一个函数来包裹我们的 Promise 实例, 所以它并不会立即执行. 这个 `delay` 函数接收一个时间来作为参数. 这个执行函数将接收 `ms` 作为他的参数, 它还包含一个 `setTimeout` , 它在 `ms` 毫秒后调用 `resolve` 函数, 从而正确执行. 看这个例子:\n\n```js\ndelay(5000).then(() => console.log('Resolved after 5 seconds'));\n```\n\n`.then` 中的回调语句将在 `delay(5000)` 后执行. 当你执行上面的代码 5 秒后, 你就可以在控制台上看到输出结果了.\n\n这里, 我们可以使用多个 `.then()` 方法来链式调用:\n\n```js\nconst delay = ms => new Promise(resolve => setTimeout(resolve, ms));\n\ndelay(2000)\n  .then(() => {\n    console.log('Resolved after 2 seconds');\n    return delay(1500);\n  })\n  .then(() => {\n    console.log('Resolved after 1.5 seconds');\n    return delay(3000);\n  })\n  .then(() => {\n    console.log('Resolved after 3 seconds');\n    throw new Error();\n  })\n  .catch(() => {\n    console.log('Caught an error.');\n  })\n  .then(() => {\n    console.log('Done.');\n  });\n\n// Resolved after 2 seconds\n// Resolved after 1.5 seconds\n// Resolved after 3 seconds\n// Caught an error.\n// Done.\n```\n\n从第 3 行开始, 它的执行步骤是这样的:\n\n* `delay(2000)` 函数执行, 它返回一个稍后 2 秒即将执行的 Promise 实例.\n* 第 1 个 `.then()` 执行, 它输出语句 `Resolved after 2 seconds`, 然后它执行 `delay(1500)` 又返回一个 Promise 实例, 如果一个 `.then()` 返回了一个 Promise 实例, 那么它的 `resolve` 将被转发给下一个 `.then` 方法调用, 技术上叫: 沉降 (settlement).\n* 只要像这样继续串联下去, 它会继续执行.\n\n注意在第三个 `.then()` 方法时, 我们在 `.then` 中抛出了一个错误. 这意味着当前的 Promise 被拒绝. 然后它会在下一个 `.catch` 语句中被捕获, `Caught an error` 将会被输出. 然而一个 `.catch` 语句它自己永远是被 `resolve` 的, 所以不需要在语句里再写 `reject` (除非你故意抛出一个错误), 这也是为什么在 `.catch` 语句后还可以继续写 `.then` 的原因.\n\n比较推荐的做法是在 `.then` 方法后执行 `.catch` 而不是使用 `onResolved` 和 `onRejected`, 我们来举个例子说明一下:\n\n```js\nconst promiseThatResolves = () =>\n  new Promise((resolve, reject) => {\n    resolve();\n  });\n\n// Leads to UnhandledPromiseRejection\npromiseThatResolves().then(\n  () => {\n    throw new Error();\n  },\n  err => console.log(err)\n);\n\n// Proper error handling\npromiseThatResolves()\n  .then(() => {\n    throw new Error();\n  })\n  .catch(err => console.log(err));\n```\n\n我们创造一个永远能被 `resolve` 的 Promise 实例, 当你执行 `.then` 时, 可以带两个回调函数: `onResolved` 和 `onRejected`, 第一种写法, 在 `then` 种放入两个回调函数, 但是: 如果在第一个回调函数中继续抛出错误, 那么这个错误是不能被捕获的. 😅\n\n第二种写法, 在 `.then` 语句的后面使用 `.catch` 捕获, 不光能捕获到执行函数 `promiseThatResolves` 的错误, 而且在 `.then()` 中的错误也是能被捕获到. 知道这样写的好处了吧!😁\n\n### 总结\n\n你可以执行上面的所有代码片段来更深入的学习. 一种比较好的实践就是, 把所有基于回调的函数都用 Promise 来重新实现. 如果你写 Node.js 的话, 你会发现 `fs` 还有其他模块都是基于回调函数来实现的. 所以会存在一些工具库, 它们把所有基于回调的实现方式使用 Promise 来实现了. 比如 Node.js 的 [util.promisify](https://nodejs.org/api/util.html#util_util_promisify_original) 和 [pify](https://github.com/sindresorhus/pify). 如果你在学习的话, 那么尽可能的尝试自己去实现. 或者说去读这些 Promise 实现库的源代码. 然后你就可以把这些最佳实践用于你的产品中啦!\n\n还有一些关于 Promise 的东西没有完全讲到, 比如 `Promise.all` 和 `Promise.race` 方法, 处理 Promise 中的错误, 以及一些常见的反模式和细节等. 你可以参考下面的链接来学习更多关于 Promise 的知识.\n\n### 参考\n\n* [ECMA Promise Specification](http://www.ecma-international.org/ecma-262/6.0/#sec-promise-objects)\n* [Mozilla Docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)\n* [Google’s Developer’s Guide on Promises written by Jake Archibald](https://developers.google.com/web/fundamentals/primers/promises#promise-api-reference)\n* [Exploring JS’s Chapter on Promises](http://exploringjs.com/es6/ch_promises.html#sec_first-example-promises)\n* [Introduction to Promises](http://jamesknelson.com/grokking-es6-promises-the-four-functions-you-need-to-avoid-callback-hell/)\n","slug":"ES6-Promise-简明指南","published":1,"updated":"2018-06-17T09:49:30.000Z","layout":"post","photos":[],"link":"","_id":"cjiitidi40004u4q92yh7opto","content":"<p>Promise 是 JavaScriptES6 中最令人兴奋的新增功能之一. ES5 中使用回调函数来处理异步操作. 过度使用回调则会产生回调地狱和多级嵌套缩带来的问题. Promise 通过将异步代码转化成同步执行的方式, 大大简化了异步编程方式.</p>\n<a id=\"more\"></a>\n<p>这篇文章中, 我们来学习一下什么是 Promise 以及在开发中的实践.</p>\n<h3 id=\"什么是-Promise\"><a href=\"#什么是-Promise\" class=\"headerlink\" title=\"什么是 Promise\"></a>什么是 Promise</h3><p>简单来说 Promise 就是一个存放着未来才会有计算结果的占位符. 稍微想想, 你会发现, 这和我们平常在谈话过程中说的承诺很像. 举个例子: 你准备去印度旅行, 你订了一张去印度的机票. 这个机票上写着多少号, 座位号是多少. 这个场景下, 机票就是航空公司给你许下的承诺: 在你准备出发那天给你预留了一个头等舱！😎</p>\n<p>还有一个简单的例子, 你承诺你的朋友, 当你读完《计算机编程艺术》这本书后, 你就把这本书还回去. 在这里, 你所说的话就好比是一个占位符, 需要返回的值就是这本书.</p>\n<p>你还可以想到其他一些类似承诺的例子, 比如在医生办公室等着、在餐馆点餐、在图书馆写书等等. 都涉及某种形式的承诺.</p>\n<h3 id=\"生成一个-Promise\"><a href=\"#生成一个-Promise\" class=\"headerlink\" title=\"生成一个 Promise\"></a>生成一个 Promise</h3><p>当某项任务的完成时间不确定或太长时, 就可以使用 Promise. 例如, 网络请求可能需要 10ms 到 200ms（或更长）的时间, 具体取决于网速. 我们不想在获取数据时等待. 200 毫秒对你来说可能不太重要, 但对于一台电脑来说, 这是一段很长的时间. Promise 就是要让这种异步变得简单、轻松. 使用 Promise 构造函数, 来实例化一个 myPromise 实例, 像这样:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myPromise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">Math</span>.random() * <span class=\"number\">100</span> &lt;= <span class=\"number\">90</span>) &#123;</span><br><span class=\"line\">    resolve(<span class=\"string\">'Hello, Promises!'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'In 10% of the cases, I fail. Miserably.'</span>));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>来看一下这个接收两个参数的函数. <code>new Promise()</code> 被称为执行器函数, 它描述了要完成的计算. 它的这两个参数通常被叫做 <code>resolve</code> 和 <code>reject</code>, 可以理解为 <strong>执行</strong> 和 <strong>拒绝</strong>, 它们用来标记执行器函数最终的计算结果. <code>resolve</code> 和 <code>reject</code> 本身是一个函数, 它用来返回一个值给我们的 Promise 实例.</p>\n<p>当运算结果成功时, 或者未来着这个值准备就绪时, 我们就使用这个 <code>resolve</code> 函数来返回一个值, 我们就说: 我践行了当初许下的这个承诺.</p>\n<p>同理, 当计算结果失败时, 或者计算过程中遇到了错误, 我们就使用 <code>reject</code> 函数, 我们就说: 我拒绝履行这个承诺. <code>reject</code> 函数可以接收任何值来作为参数, 但是比较推荐的是我们可以传递一个 <code>Error</code> 对象, 即: 抛出一个错误, 用来帮助我们调试代码, 这样就可以根据具体的抛出错误信息去解决问题啦.</p>\n<p>在上面的这个例子中, <code>Math.random()</code> 用来生成一个随机数, 在 90% 的情况下, 这个 Promise 都应该被执行 (假设等概率分布), 剩余的情况下都是拒绝执行的.</p>\n<h3 id=\"如何使用-Promises\"><a href=\"#如何使用-Promises\" class=\"headerlink\" title=\"如何使用 Promises\"></a>如何使用 Promises</h3><p>在上面的代码例子中, 我们生成了一个 Promise 实例 <code>myPromise</code>, 那么如何通过 <code>resolve</code> 和 <code>reject</code> 函数访问计算完成后的值呢? 所有的 <code>Promise</code> 实例都有一个 <code>.then()</code> 方法, 我们来瞧瞧:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myPromise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">Math</span>.random() * <span class=\"number\">100</span> &lt; <span class=\"number\">90</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'resolving the promise ...'</span>);</span><br><span class=\"line\">    resolve(<span class=\"string\">'Hello, Promises!'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'In 10% of the cases, I fail. Miserably.'</span>));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Two functions</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> onResolved = <span class=\"function\"><span class=\"params\">resolvedValue</span> =&gt;</span> <span class=\"built_in\">console</span>.log(resolvedValue);</span><br><span class=\"line\"><span class=\"keyword\">const</span> onRejected = <span class=\"function\"><span class=\"params\">error</span> =&gt;</span> <span class=\"built_in\">console</span>.log(error);</span><br><span class=\"line\"></span><br><span class=\"line\">myPromise.then(onResolved, onRejected);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Same as above, written concisely</span></span><br><span class=\"line\">myPromise.then(</span><br><span class=\"line\">  resolvedValue =&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(resolvedValue);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  error =&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(error);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Output (in 90% of the cases)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// resolving the promise ...</span></span><br><span class=\"line\"><span class=\"comment\">// Hello, Promises!</span></span><br><span class=\"line\"><span class=\"comment\">// Hello, Promises!</span></span><br></pre></td></tr></table></figure>\n<p><code>.then()</code> 方法接收 2 个回调函数, 第一个回调函数是当我们的 Promise 实例被执行 (resolve) 时调用, 第二个则是被拒绝 (reject) 时调用. 在上面的代码中, 我们使用 <code>onResolved</code> 和 <code>onRejected</code> 定义了这两个函数, 然后把它放到 <code>.then</code> 函数里, 当然, 你也可以按照常规写法, 直接在 <code>.then</code> 函数里写两个函数, 都是一样的.</p>\n<p>在这个例子中, 有几点非常重要, 我们来说一下:</p>\n<ul>\n<li>一个 <code>promise</code> 只能是成功或者失败状态中的一个. 它不能成功或者失败多次. 也不能从成功状态切换到失败状态, 失败反之亦然.</li>\n<li>你可以在成功或者失败状态后, 去定义这样一个回调函数. 当他们 <code>resolve</code> 或者 <code>reject</code> 仍然能正确调用.</li>\n</ul>\n<p>这就说明, <code>Promise</code> 最终只有一个状态, 即使你多次使用 <code>.then</code> 处理函数, 这个状态不能更改 (计算结果也不会重复执行).</p>\n<p>为了验证这点, 你可以看到在第 3 行代码中, <code>console.log</code> 语句, 当你多次使用 <code>.then</code> 处理程序运行上述代码时, <code>console.log</code> 的语句只会被打印一次. 这就说明了 Promise 会缓存计算结果的, 当有一些相同的结果时, 缓存结果会被返回.</p>\n<p>另一个重要的要注意的是, Promise 是 <a href=\"https://zh.wikipedia.org/wiki/%E5%8F%8A%E6%97%A9%E6%B1%82%E5%80%BC\" target=\"_blank\" rel=\"noopener\">及早求值 (evaluated eagerly)</a> 的: 只要声明并将其赋值到变量上, 它已经开始在内存中执行了. 没有 <code>.start</code> 或 <code>.begin</code> 方法. 就像它在前面的例子中开始的那样.</p>\n<p>为了确保 Promise 能被延迟调用, 我们通常还需要在它的外层包裹一个函数, 稍后的例子中我们会解释这个.</p>\n<h3 id=\"捕获-Promise\"><a href=\"#捕获-Promise\" class=\"headerlink\" title=\"捕获 Promise\"></a>捕获 Promise</h3><p>到目前为止, 我们已经看到了 <code>resolve</code> 的场景, 那么当执行函数中出现一个错误时, 会发生什么呢? 在 <code>.then()</code> 函数中的第二个参数, 就是上面例子中的 <code>onRejected</code> 会被执行, 来看一个例子:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myPromise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">Math</span>.random() * <span class=\"number\">100</span> &lt; <span class=\"number\">90</span>) &#123;</span><br><span class=\"line\">    reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'The promise was rejected by using reject function.'</span>));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'The promise was rejected by throwing an error'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">myPromise.then(</span><br><span class=\"line\">  () =&gt; <span class=\"built_in\">console</span>.log(<span class=\"string\">'resolved'</span>),</span><br><span class=\"line\">  error =&gt; <span class=\"built_in\">console</span>.log(error.message)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Output (in 90% of cases)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The promise was rejected by using reject function.</span></span><br></pre></td></tr></table></figure>\n<p>和第一个例子一样的, 但是现在 90% 的情况是被 <code>reject</code> 的, 另外 10% 的情况则是抛出一个错误语句.</p>\n<p>在第一个例子中, 我们分别定义了 <code>onResolved</code> 和 <code>onRejected</code> 方法, <code>onRejected</code> 方法将在错误发生时被调用, 可以看到 <code>reject</code> 函数的参数可以直接是错误提示, 没必要必须 <code>new Error</code>, 两个写法都一样.</p>\n<p>健壮的程序代码离不开错误处理, <code>.then</code> 方法的第二个参数给了我们这样一个捷径. 当需要处理一个错误时, 可以用 <code>.catch(onRejected)</code> 来代替 <code>.then(null, () =&gt; {...})</code>, <code>catch</code> 方法接收一个回调函数 <code>onRejected</code>, 因此, 上面的代码, 可以使用 <code>catch</code> 来简化写法:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myPromise.catch(<span class=\"function\"><span class=\"params\">error</span> =&gt;</span> <span class=\"built_in\">console</span>.log(error.message));</span><br></pre></td></tr></table></figure>\n<p>记住: <code>.catch</code> 方法仅仅是 <code>.then(undefined, onRejected)</code> 的语法糖而已.</p>\n<h3 id=\"链式-Promise\"><a href=\"#链式-Promise\" class=\"headerlink\" title=\"链式 Promise\"></a>链式 Promise</h3><p><code>.then()</code> 和 <code>.catch()</code> 方法永远会返回一个 Promise 实例, 所以你可以链式使用多个 <code>.then</code> 一起来调用. 让我们来举个例子理解它.</p>\n<p>首先, 我们写一个函数, 来延迟返回一个 Promise 实例. 这个返回的 Promise 将在稍后的时间内 <code>resolve</code>. 这里是实现方法:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> delay = <span class=\"function\"><span class=\"params\">ms</span> =&gt;</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> setTimeout(resolve, ms));</span><br></pre></td></tr></table></figure>\n<p>在这个例子中, 我们正在使用一个函数来包裹我们的 Promise 实例, 所以它并不会立即执行. 这个 <code>delay</code> 函数接收一个时间来作为参数. 这个执行函数将接收 <code>ms</code> 作为他的参数, 它还包含一个 <code>setTimeout</code> , 它在 <code>ms</code> 毫秒后调用 <code>resolve</code> 函数, 从而正确执行. 看这个例子:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">delay(<span class=\"number\">5000</span>).then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'Resolved after 5 seconds'</span>));</span><br></pre></td></tr></table></figure>\n<p><code>.then</code> 中的回调语句将在 <code>delay(5000)</code> 后执行. 当你执行上面的代码 5 秒后, 你就可以在控制台上看到输出结果了.</p>\n<p>这里, 我们可以使用多个 <code>.then()</code> 方法来链式调用:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> delay = <span class=\"function\"><span class=\"params\">ms</span> =&gt;</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> setTimeout(resolve, ms));</span><br><span class=\"line\"></span><br><span class=\"line\">delay(<span class=\"number\">2000</span>)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Resolved after 2 seconds'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> delay(<span class=\"number\">1500</span>);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Resolved after 1.5 seconds'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> delay(<span class=\"number\">3000</span>);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Resolved after 3 seconds'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>();</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Caught an error.'</span>);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Done.'</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Resolved after 2 seconds</span></span><br><span class=\"line\"><span class=\"comment\">// Resolved after 1.5 seconds</span></span><br><span class=\"line\"><span class=\"comment\">// Resolved after 3 seconds</span></span><br><span class=\"line\"><span class=\"comment\">// Caught an error.</span></span><br><span class=\"line\"><span class=\"comment\">// Done.</span></span><br></pre></td></tr></table></figure>\n<p>从第 3 行开始, 它的执行步骤是这样的:</p>\n<ul>\n<li><code>delay(2000)</code> 函数执行, 它返回一个稍后 2 秒即将执行的 Promise 实例.</li>\n<li>第 1 个 <code>.then()</code> 执行, 它输出语句 <code>Resolved after 2 seconds</code>, 然后它执行 <code>delay(1500)</code> 又返回一个 Promise 实例, 如果一个 <code>.then()</code> 返回了一个 Promise 实例, 那么它的 <code>resolve</code> 将被转发给下一个 <code>.then</code> 方法调用, 技术上叫: 沉降 (settlement).</li>\n<li>只要像这样继续串联下去, 它会继续执行.</li>\n</ul>\n<p>注意在第三个 <code>.then()</code> 方法时, 我们在 <code>.then</code> 中抛出了一个错误. 这意味着当前的 Promise 被拒绝. 然后它会在下一个 <code>.catch</code> 语句中被捕获, <code>Caught an error</code> 将会被输出. 然而一个 <code>.catch</code> 语句它自己永远是被 <code>resolve</code> 的, 所以不需要在语句里再写 <code>reject</code> (除非你故意抛出一个错误), 这也是为什么在 <code>.catch</code> 语句后还可以继续写 <code>.then</code> 的原因.</p>\n<p>比较推荐的做法是在 <code>.then</code> 方法后执行 <code>.catch</code> 而不是使用 <code>onResolved</code> 和 <code>onRejected</code>, 我们来举个例子说明一下:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> promiseThatResolves = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span></span><br><span class=\"line\">  <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    resolve();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Leads to UnhandledPromiseRejection</span></span><br><span class=\"line\">promiseThatResolves().then(</span><br><span class=\"line\">  () =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>();</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  err =&gt; <span class=\"built_in\">console</span>.log(err)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Proper error handling</span></span><br><span class=\"line\">promiseThatResolves()</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>();</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> <span class=\"built_in\">console</span>.log(err));</span><br></pre></td></tr></table></figure>\n<p>我们创造一个永远能被 <code>resolve</code> 的 Promise 实例, 当你执行 <code>.then</code> 时, 可以带两个回调函数: <code>onResolved</code> 和 <code>onRejected</code>, 第一种写法, 在 <code>then</code> 种放入两个回调函数, 但是: 如果在第一个回调函数中继续抛出错误, 那么这个错误是不能被捕获的. 😅</p>\n<p>第二种写法, 在 <code>.then</code> 语句的后面使用 <code>.catch</code> 捕获, 不光能捕获到执行函数 <code>promiseThatResolves</code> 的错误, 而且在 <code>.then()</code> 中的错误也是能被捕获到. 知道这样写的好处了吧!😁</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>你可以执行上面的所有代码片段来更深入的学习. 一种比较好的实践就是, 把所有基于回调的函数都用 Promise 来重新实现. 如果你写 Node.js 的话, 你会发现 <code>fs</code> 还有其他模块都是基于回调函数来实现的. 所以会存在一些工具库, 它们把所有基于回调的实现方式使用 Promise 来实现了. 比如 Node.js 的 <a href=\"https://nodejs.org/api/util.html#util_util_promisify_original\" target=\"_blank\" rel=\"noopener\">util.promisify</a> 和 <a href=\"https://github.com/sindresorhus/pify\" target=\"_blank\" rel=\"noopener\">pify</a>. 如果你在学习的话, 那么尽可能的尝试自己去实现. 或者说去读这些 Promise 实现库的源代码. 然后你就可以把这些最佳实践用于你的产品中啦!</p>\n<p>还有一些关于 Promise 的东西没有完全讲到, 比如 <code>Promise.all</code> 和 <code>Promise.race</code> 方法, 处理 Promise 中的错误, 以及一些常见的反模式和细节等. 你可以参考下面的链接来学习更多关于 Promise 的知识.</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><a href=\"http://www.ecma-international.org/ecma-262/6.0/#sec-promise-objects\" target=\"_blank\" rel=\"noopener\">ECMA Promise Specification</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\" target=\"_blank\" rel=\"noopener\">Mozilla Docs</a></li>\n<li><a href=\"https://developers.google.com/web/fundamentals/primers/promises#promise-api-reference\" target=\"_blank\" rel=\"noopener\">Google’s Developer’s Guide on Promises written by Jake Archibald</a></li>\n<li><a href=\"http://exploringjs.com/es6/ch_promises.html#sec_first-example-promises\" target=\"_blank\" rel=\"noopener\">Exploring JS’s Chapter on Promises</a></li>\n<li><a href=\"http://jamesknelson.com/grokking-es6-promises-the-four-functions-you-need-to-avoid-callback-hell/\" target=\"_blank\" rel=\"noopener\">Introduction to Promises</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>Promise 是 JavaScriptES6 中最令人兴奋的新增功能之一. ES5 中使用回调函数来处理异步操作. 过度使用回调则会产生回调地狱和多级嵌套缩带来的问题. Promise 通过将异步代码转化成同步执行的方式, 大大简化了异步编程方式.</p>","more":"<p>这篇文章中, 我们来学习一下什么是 Promise 以及在开发中的实践.</p>\n<h3 id=\"什么是-Promise\"><a href=\"#什么是-Promise\" class=\"headerlink\" title=\"什么是 Promise\"></a>什么是 Promise</h3><p>简单来说 Promise 就是一个存放着未来才会有计算结果的占位符. 稍微想想, 你会发现, 这和我们平常在谈话过程中说的承诺很像. 举个例子: 你准备去印度旅行, 你订了一张去印度的机票. 这个机票上写着多少号, 座位号是多少. 这个场景下, 机票就是航空公司给你许下的承诺: 在你准备出发那天给你预留了一个头等舱！😎</p>\n<p>还有一个简单的例子, 你承诺你的朋友, 当你读完《计算机编程艺术》这本书后, 你就把这本书还回去. 在这里, 你所说的话就好比是一个占位符, 需要返回的值就是这本书.</p>\n<p>你还可以想到其他一些类似承诺的例子, 比如在医生办公室等着、在餐馆点餐、在图书馆写书等等. 都涉及某种形式的承诺.</p>\n<h3 id=\"生成一个-Promise\"><a href=\"#生成一个-Promise\" class=\"headerlink\" title=\"生成一个 Promise\"></a>生成一个 Promise</h3><p>当某项任务的完成时间不确定或太长时, 就可以使用 Promise. 例如, 网络请求可能需要 10ms 到 200ms（或更长）的时间, 具体取决于网速. 我们不想在获取数据时等待. 200 毫秒对你来说可能不太重要, 但对于一台电脑来说, 这是一段很长的时间. Promise 就是要让这种异步变得简单、轻松. 使用 Promise 构造函数, 来实例化一个 myPromise 实例, 像这样:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myPromise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">Math</span>.random() * <span class=\"number\">100</span> &lt;= <span class=\"number\">90</span>) &#123;</span><br><span class=\"line\">    resolve(<span class=\"string\">'Hello, Promises!'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'In 10% of the cases, I fail. Miserably.'</span>));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>来看一下这个接收两个参数的函数. <code>new Promise()</code> 被称为执行器函数, 它描述了要完成的计算. 它的这两个参数通常被叫做 <code>resolve</code> 和 <code>reject</code>, 可以理解为 <strong>执行</strong> 和 <strong>拒绝</strong>, 它们用来标记执行器函数最终的计算结果. <code>resolve</code> 和 <code>reject</code> 本身是一个函数, 它用来返回一个值给我们的 Promise 实例.</p>\n<p>当运算结果成功时, 或者未来着这个值准备就绪时, 我们就使用这个 <code>resolve</code> 函数来返回一个值, 我们就说: 我践行了当初许下的这个承诺.</p>\n<p>同理, 当计算结果失败时, 或者计算过程中遇到了错误, 我们就使用 <code>reject</code> 函数, 我们就说: 我拒绝履行这个承诺. <code>reject</code> 函数可以接收任何值来作为参数, 但是比较推荐的是我们可以传递一个 <code>Error</code> 对象, 即: 抛出一个错误, 用来帮助我们调试代码, 这样就可以根据具体的抛出错误信息去解决问题啦.</p>\n<p>在上面的这个例子中, <code>Math.random()</code> 用来生成一个随机数, 在 90% 的情况下, 这个 Promise 都应该被执行 (假设等概率分布), 剩余的情况下都是拒绝执行的.</p>\n<h3 id=\"如何使用-Promises\"><a href=\"#如何使用-Promises\" class=\"headerlink\" title=\"如何使用 Promises\"></a>如何使用 Promises</h3><p>在上面的代码例子中, 我们生成了一个 Promise 实例 <code>myPromise</code>, 那么如何通过 <code>resolve</code> 和 <code>reject</code> 函数访问计算完成后的值呢? 所有的 <code>Promise</code> 实例都有一个 <code>.then()</code> 方法, 我们来瞧瞧:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myPromise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">Math</span>.random() * <span class=\"number\">100</span> &lt; <span class=\"number\">90</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'resolving the promise ...'</span>);</span><br><span class=\"line\">    resolve(<span class=\"string\">'Hello, Promises!'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'In 10% of the cases, I fail. Miserably.'</span>));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Two functions</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> onResolved = <span class=\"function\"><span class=\"params\">resolvedValue</span> =&gt;</span> <span class=\"built_in\">console</span>.log(resolvedValue);</span><br><span class=\"line\"><span class=\"keyword\">const</span> onRejected = <span class=\"function\"><span class=\"params\">error</span> =&gt;</span> <span class=\"built_in\">console</span>.log(error);</span><br><span class=\"line\"></span><br><span class=\"line\">myPromise.then(onResolved, onRejected);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Same as above, written concisely</span></span><br><span class=\"line\">myPromise.then(</span><br><span class=\"line\">  resolvedValue =&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(resolvedValue);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  error =&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(error);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Output (in 90% of the cases)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// resolving the promise ...</span></span><br><span class=\"line\"><span class=\"comment\">// Hello, Promises!</span></span><br><span class=\"line\"><span class=\"comment\">// Hello, Promises!</span></span><br></pre></td></tr></table></figure>\n<p><code>.then()</code> 方法接收 2 个回调函数, 第一个回调函数是当我们的 Promise 实例被执行 (resolve) 时调用, 第二个则是被拒绝 (reject) 时调用. 在上面的代码中, 我们使用 <code>onResolved</code> 和 <code>onRejected</code> 定义了这两个函数, 然后把它放到 <code>.then</code> 函数里, 当然, 你也可以按照常规写法, 直接在 <code>.then</code> 函数里写两个函数, 都是一样的.</p>\n<p>在这个例子中, 有几点非常重要, 我们来说一下:</p>\n<ul>\n<li>一个 <code>promise</code> 只能是成功或者失败状态中的一个. 它不能成功或者失败多次. 也不能从成功状态切换到失败状态, 失败反之亦然.</li>\n<li>你可以在成功或者失败状态后, 去定义这样一个回调函数. 当他们 <code>resolve</code> 或者 <code>reject</code> 仍然能正确调用.</li>\n</ul>\n<p>这就说明, <code>Promise</code> 最终只有一个状态, 即使你多次使用 <code>.then</code> 处理函数, 这个状态不能更改 (计算结果也不会重复执行).</p>\n<p>为了验证这点, 你可以看到在第 3 行代码中, <code>console.log</code> 语句, 当你多次使用 <code>.then</code> 处理程序运行上述代码时, <code>console.log</code> 的语句只会被打印一次. 这就说明了 Promise 会缓存计算结果的, 当有一些相同的结果时, 缓存结果会被返回.</p>\n<p>另一个重要的要注意的是, Promise 是 <a href=\"https://zh.wikipedia.org/wiki/%E5%8F%8A%E6%97%A9%E6%B1%82%E5%80%BC\" target=\"_blank\" rel=\"noopener\">及早求值 (evaluated eagerly)</a> 的: 只要声明并将其赋值到变量上, 它已经开始在内存中执行了. 没有 <code>.start</code> 或 <code>.begin</code> 方法. 就像它在前面的例子中开始的那样.</p>\n<p>为了确保 Promise 能被延迟调用, 我们通常还需要在它的外层包裹一个函数, 稍后的例子中我们会解释这个.</p>\n<h3 id=\"捕获-Promise\"><a href=\"#捕获-Promise\" class=\"headerlink\" title=\"捕获 Promise\"></a>捕获 Promise</h3><p>到目前为止, 我们已经看到了 <code>resolve</code> 的场景, 那么当执行函数中出现一个错误时, 会发生什么呢? 在 <code>.then()</code> 函数中的第二个参数, 就是上面例子中的 <code>onRejected</code> 会被执行, 来看一个例子:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myPromise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">Math</span>.random() * <span class=\"number\">100</span> &lt; <span class=\"number\">90</span>) &#123;</span><br><span class=\"line\">    reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'The promise was rejected by using reject function.'</span>));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'The promise was rejected by throwing an error'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">myPromise.then(</span><br><span class=\"line\">  () =&gt; <span class=\"built_in\">console</span>.log(<span class=\"string\">'resolved'</span>),</span><br><span class=\"line\">  error =&gt; <span class=\"built_in\">console</span>.log(error.message)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Output (in 90% of cases)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The promise was rejected by using reject function.</span></span><br></pre></td></tr></table></figure>\n<p>和第一个例子一样的, 但是现在 90% 的情况是被 <code>reject</code> 的, 另外 10% 的情况则是抛出一个错误语句.</p>\n<p>在第一个例子中, 我们分别定义了 <code>onResolved</code> 和 <code>onRejected</code> 方法, <code>onRejected</code> 方法将在错误发生时被调用, 可以看到 <code>reject</code> 函数的参数可以直接是错误提示, 没必要必须 <code>new Error</code>, 两个写法都一样.</p>\n<p>健壮的程序代码离不开错误处理, <code>.then</code> 方法的第二个参数给了我们这样一个捷径. 当需要处理一个错误时, 可以用 <code>.catch(onRejected)</code> 来代替 <code>.then(null, () =&gt; {...})</code>, <code>catch</code> 方法接收一个回调函数 <code>onRejected</code>, 因此, 上面的代码, 可以使用 <code>catch</code> 来简化写法:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myPromise.catch(<span class=\"function\"><span class=\"params\">error</span> =&gt;</span> <span class=\"built_in\">console</span>.log(error.message));</span><br></pre></td></tr></table></figure>\n<p>记住: <code>.catch</code> 方法仅仅是 <code>.then(undefined, onRejected)</code> 的语法糖而已.</p>\n<h3 id=\"链式-Promise\"><a href=\"#链式-Promise\" class=\"headerlink\" title=\"链式 Promise\"></a>链式 Promise</h3><p><code>.then()</code> 和 <code>.catch()</code> 方法永远会返回一个 Promise 实例, 所以你可以链式使用多个 <code>.then</code> 一起来调用. 让我们来举个例子理解它.</p>\n<p>首先, 我们写一个函数, 来延迟返回一个 Promise 实例. 这个返回的 Promise 将在稍后的时间内 <code>resolve</code>. 这里是实现方法:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> delay = <span class=\"function\"><span class=\"params\">ms</span> =&gt;</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> setTimeout(resolve, ms));</span><br></pre></td></tr></table></figure>\n<p>在这个例子中, 我们正在使用一个函数来包裹我们的 Promise 实例, 所以它并不会立即执行. 这个 <code>delay</code> 函数接收一个时间来作为参数. 这个执行函数将接收 <code>ms</code> 作为他的参数, 它还包含一个 <code>setTimeout</code> , 它在 <code>ms</code> 毫秒后调用 <code>resolve</code> 函数, 从而正确执行. 看这个例子:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">delay(<span class=\"number\">5000</span>).then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'Resolved after 5 seconds'</span>));</span><br></pre></td></tr></table></figure>\n<p><code>.then</code> 中的回调语句将在 <code>delay(5000)</code> 后执行. 当你执行上面的代码 5 秒后, 你就可以在控制台上看到输出结果了.</p>\n<p>这里, 我们可以使用多个 <code>.then()</code> 方法来链式调用:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> delay = <span class=\"function\"><span class=\"params\">ms</span> =&gt;</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> setTimeout(resolve, ms));</span><br><span class=\"line\"></span><br><span class=\"line\">delay(<span class=\"number\">2000</span>)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Resolved after 2 seconds'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> delay(<span class=\"number\">1500</span>);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Resolved after 1.5 seconds'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> delay(<span class=\"number\">3000</span>);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Resolved after 3 seconds'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>();</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Caught an error.'</span>);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Done.'</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Resolved after 2 seconds</span></span><br><span class=\"line\"><span class=\"comment\">// Resolved after 1.5 seconds</span></span><br><span class=\"line\"><span class=\"comment\">// Resolved after 3 seconds</span></span><br><span class=\"line\"><span class=\"comment\">// Caught an error.</span></span><br><span class=\"line\"><span class=\"comment\">// Done.</span></span><br></pre></td></tr></table></figure>\n<p>从第 3 行开始, 它的执行步骤是这样的:</p>\n<ul>\n<li><code>delay(2000)</code> 函数执行, 它返回一个稍后 2 秒即将执行的 Promise 实例.</li>\n<li>第 1 个 <code>.then()</code> 执行, 它输出语句 <code>Resolved after 2 seconds</code>, 然后它执行 <code>delay(1500)</code> 又返回一个 Promise 实例, 如果一个 <code>.then()</code> 返回了一个 Promise 实例, 那么它的 <code>resolve</code> 将被转发给下一个 <code>.then</code> 方法调用, 技术上叫: 沉降 (settlement).</li>\n<li>只要像这样继续串联下去, 它会继续执行.</li>\n</ul>\n<p>注意在第三个 <code>.then()</code> 方法时, 我们在 <code>.then</code> 中抛出了一个错误. 这意味着当前的 Promise 被拒绝. 然后它会在下一个 <code>.catch</code> 语句中被捕获, <code>Caught an error</code> 将会被输出. 然而一个 <code>.catch</code> 语句它自己永远是被 <code>resolve</code> 的, 所以不需要在语句里再写 <code>reject</code> (除非你故意抛出一个错误), 这也是为什么在 <code>.catch</code> 语句后还可以继续写 <code>.then</code> 的原因.</p>\n<p>比较推荐的做法是在 <code>.then</code> 方法后执行 <code>.catch</code> 而不是使用 <code>onResolved</code> 和 <code>onRejected</code>, 我们来举个例子说明一下:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> promiseThatResolves = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span></span><br><span class=\"line\">  <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    resolve();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Leads to UnhandledPromiseRejection</span></span><br><span class=\"line\">promiseThatResolves().then(</span><br><span class=\"line\">  () =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>();</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  err =&gt; <span class=\"built_in\">console</span>.log(err)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Proper error handling</span></span><br><span class=\"line\">promiseThatResolves()</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>();</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> <span class=\"built_in\">console</span>.log(err));</span><br></pre></td></tr></table></figure>\n<p>我们创造一个永远能被 <code>resolve</code> 的 Promise 实例, 当你执行 <code>.then</code> 时, 可以带两个回调函数: <code>onResolved</code> 和 <code>onRejected</code>, 第一种写法, 在 <code>then</code> 种放入两个回调函数, 但是: 如果在第一个回调函数中继续抛出错误, 那么这个错误是不能被捕获的. 😅</p>\n<p>第二种写法, 在 <code>.then</code> 语句的后面使用 <code>.catch</code> 捕获, 不光能捕获到执行函数 <code>promiseThatResolves</code> 的错误, 而且在 <code>.then()</code> 中的错误也是能被捕获到. 知道这样写的好处了吧!😁</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>你可以执行上面的所有代码片段来更深入的学习. 一种比较好的实践就是, 把所有基于回调的函数都用 Promise 来重新实现. 如果你写 Node.js 的话, 你会发现 <code>fs</code> 还有其他模块都是基于回调函数来实现的. 所以会存在一些工具库, 它们把所有基于回调的实现方式使用 Promise 来实现了. 比如 Node.js 的 <a href=\"https://nodejs.org/api/util.html#util_util_promisify_original\" target=\"_blank\" rel=\"noopener\">util.promisify</a> 和 <a href=\"https://github.com/sindresorhus/pify\" target=\"_blank\" rel=\"noopener\">pify</a>. 如果你在学习的话, 那么尽可能的尝试自己去实现. 或者说去读这些 Promise 实现库的源代码. 然后你就可以把这些最佳实践用于你的产品中啦!</p>\n<p>还有一些关于 Promise 的东西没有完全讲到, 比如 <code>Promise.all</code> 和 <code>Promise.race</code> 方法, 处理 Promise 中的错误, 以及一些常见的反模式和细节等. 你可以参考下面的链接来学习更多关于 Promise 的知识.</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><a href=\"http://www.ecma-international.org/ecma-262/6.0/#sec-promise-objects\" target=\"_blank\" rel=\"noopener\">ECMA Promise Specification</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\" target=\"_blank\" rel=\"noopener\">Mozilla Docs</a></li>\n<li><a href=\"https://developers.google.com/web/fundamentals/primers/promises#promise-api-reference\" target=\"_blank\" rel=\"noopener\">Google’s Developer’s Guide on Promises written by Jake Archibald</a></li>\n<li><a href=\"http://exploringjs.com/es6/ch_promises.html#sec_first-example-promises\" target=\"_blank\" rel=\"noopener\">Exploring JS’s Chapter on Promises</a></li>\n<li><a href=\"http://jamesknelson.com/grokking-es6-promises-the-four-functions-you-need-to-avoid-callback-hell/\" target=\"_blank\" rel=\"noopener\">Introduction to Promises</a></li>\n</ul>"},{"title":"Git 操作详细总结","date":"2018-05-11T15:25:56.000Z","from":null,"comments":1,"_content":"\nGit 操作详细总结，以便回顾和查询。理解这些指令，觉得最重要的是理解 Git 的内部原理，比如 Git 的分布式版本控制，分清楚工作区、暂存区、版本库，还有就是理解 Git 跟踪并管理的是修改，而非文件。\n\n<!-- more -->\n\n![image](https://user-images.githubusercontent.com/15377484/39952532-4c0c156e-55cb-11e8-8052-e62c448325fe.png)\n\n## 设置\n\n```bash\ngit config --global user.name \"Your Name\"\ngit config --global user.email \"email@example.com\"\n```\n\n## 提交\n\nGit 追踪的是修改，而不是文件。\n\n![image](https://user-images.githubusercontent.com/15377484/39952534-5c10f236-55cb-11e8-81bf-c4d369d07054.png)\n\n```bash\n# 将 “当前修改” 移动到暂存区 (stage)\ngit add filename.txt\n\n# 将暂存区修改提交\ngit commit -m \"Add filename.txt.\"\n```\n\n## 状态\n\n```bash\ngit status\ngit diff\n```\n\n## 回退\n\n```bash\n# 放弃工作区修改\ngit checkout -- file.name\ngit checkout -- .\n\n# 取消 commit(比如需要重写 commit 信息)\ngit reset --soft HEAD\n\n# 取消 commit、add(重新提交代码和 commit)\ngit reset HEAD\ngit reset --mixed HEAD\n\n# 取消 commit、add、工作区修改 (需要完全重置)\ngit reset --hard HEAD\n```\n\n## 记录\n\n```bash\ngit reflog\ngit log\n```\n\n## 删除\n\n```bash\nrm file.name\ngit rm file.name\ngit commit -m \"Del\"\n```\n\n## 远程操作\n\n```bash\ngit remote add origin git@github.com:ifyour/ifyour.github.io.git\n\n# 第一次推送，-u(--set-upstream) 指定默认上游\ngit push -u origin master\ngit push origin master\n```\n\n## 克隆\n\n```bash\ngit clone https://github.com/ifyour/ifyour.github.io.git path\ngit clone git@github.com:ifyour/ifyour.github.io.git path\n```\n\n## 分支操作\n\n![image](https://user-images.githubusercontent.com/15377484/39952537-6b679758-55cb-11e8-9ff7-87440fcbb4d0.png)\n\n```bash\n# 查看当前分支\ngit branch\n\n# 创建分支\ngit branch dev\n\n# 切换分支\ngit checkout dev\n\n# 创建并 checkout 分支\ngit checkout -b dev\n\n# 合并分支\ngit merge dev\n\n# 删除分支\ngit branch -d dev\n```\n\n## 标签\n\n```bash\ngit tag 0.1.1\ngit push origin --tags\n```\n\n## More\n\n- [Git - 简易指南](http://www.bootcss.com/p/git-guide/)\n","source":"_posts/Git-操作详细总结.md","raw":"---\ntitle: Git 操作详细总结\ndate: 2018-05-11 23:25:56\ntags:\nfrom:\ncomments: true\n---\n\nGit 操作详细总结，以便回顾和查询。理解这些指令，觉得最重要的是理解 Git 的内部原理，比如 Git 的分布式版本控制，分清楚工作区、暂存区、版本库，还有就是理解 Git 跟踪并管理的是修改，而非文件。\n\n<!-- more -->\n\n![image](https://user-images.githubusercontent.com/15377484/39952532-4c0c156e-55cb-11e8-8052-e62c448325fe.png)\n\n## 设置\n\n```bash\ngit config --global user.name \"Your Name\"\ngit config --global user.email \"email@example.com\"\n```\n\n## 提交\n\nGit 追踪的是修改，而不是文件。\n\n![image](https://user-images.githubusercontent.com/15377484/39952534-5c10f236-55cb-11e8-81bf-c4d369d07054.png)\n\n```bash\n# 将 “当前修改” 移动到暂存区 (stage)\ngit add filename.txt\n\n# 将暂存区修改提交\ngit commit -m \"Add filename.txt.\"\n```\n\n## 状态\n\n```bash\ngit status\ngit diff\n```\n\n## 回退\n\n```bash\n# 放弃工作区修改\ngit checkout -- file.name\ngit checkout -- .\n\n# 取消 commit(比如需要重写 commit 信息)\ngit reset --soft HEAD\n\n# 取消 commit、add(重新提交代码和 commit)\ngit reset HEAD\ngit reset --mixed HEAD\n\n# 取消 commit、add、工作区修改 (需要完全重置)\ngit reset --hard HEAD\n```\n\n## 记录\n\n```bash\ngit reflog\ngit log\n```\n\n## 删除\n\n```bash\nrm file.name\ngit rm file.name\ngit commit -m \"Del\"\n```\n\n## 远程操作\n\n```bash\ngit remote add origin git@github.com:ifyour/ifyour.github.io.git\n\n# 第一次推送，-u(--set-upstream) 指定默认上游\ngit push -u origin master\ngit push origin master\n```\n\n## 克隆\n\n```bash\ngit clone https://github.com/ifyour/ifyour.github.io.git path\ngit clone git@github.com:ifyour/ifyour.github.io.git path\n```\n\n## 分支操作\n\n![image](https://user-images.githubusercontent.com/15377484/39952537-6b679758-55cb-11e8-9ff7-87440fcbb4d0.png)\n\n```bash\n# 查看当前分支\ngit branch\n\n# 创建分支\ngit branch dev\n\n# 切换分支\ngit checkout dev\n\n# 创建并 checkout 分支\ngit checkout -b dev\n\n# 合并分支\ngit merge dev\n\n# 删除分支\ngit branch -d dev\n```\n\n## 标签\n\n```bash\ngit tag 0.1.1\ngit push origin --tags\n```\n\n## More\n\n- [Git - 简易指南](http://www.bootcss.com/p/git-guide/)\n","slug":"Git-操作详细总结","published":1,"updated":"2018-06-17T09:49:30.000Z","layout":"post","photos":[],"link":"","_id":"cjiitidi60006u4q9ury1uqbh","content":"<p>Git 操作详细总结，以便回顾和查询。理解这些指令，觉得最重要的是理解 Git 的内部原理，比如 Git 的分布式版本控制，分清楚工作区、暂存区、版本库，还有就是理解 Git 跟踪并管理的是修改，而非文件。</p>\n<a id=\"more\"></a>\n<p><img src=\"https://user-images.githubusercontent.com/15377484/39952532-4c0c156e-55cb-11e8-8052-e62c448325fe.png\" alt=\"image\"></p>\n<h2 id=\"设置\"><a href=\"#设置\" class=\"headerlink\" title=\"设置\"></a>设置</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global user.name <span class=\"string\">\"Your Name\"</span></span><br><span class=\"line\">git config --global user.email <span class=\"string\">\"email@example.com\"</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"提交\"><a href=\"#提交\" class=\"headerlink\" title=\"提交\"></a>提交</h2><p>Git 追踪的是修改，而不是文件。</p>\n<p><img src=\"https://user-images.githubusercontent.com/15377484/39952534-5c10f236-55cb-11e8-81bf-c4d369d07054.png\" alt=\"image\"></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将 “当前修改” 移动到暂存区 (stage)</span></span><br><span class=\"line\">git add filename.txt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将暂存区修改提交</span></span><br><span class=\"line\">git commit -m <span class=\"string\">\"Add filename.txt.\"</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"状态\"><a href=\"#状态\" class=\"headerlink\" title=\"状态\"></a>状态</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git status</span><br><span class=\"line\">git diff</span><br></pre></td></tr></table></figure>\n<h2 id=\"回退\"><a href=\"#回退\" class=\"headerlink\" title=\"回退\"></a>回退</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 放弃工作区修改</span></span><br><span class=\"line\">git checkout -- file.name</span><br><span class=\"line\">git checkout -- .</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 取消 commit(比如需要重写 commit 信息)</span></span><br><span class=\"line\">git reset --soft HEAD</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 取消 commit、add(重新提交代码和 commit)</span></span><br><span class=\"line\">git reset HEAD</span><br><span class=\"line\">git reset --mixed HEAD</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 取消 commit、add、工作区修改 (需要完全重置)</span></span><br><span class=\"line\">git reset --hard HEAD</span><br></pre></td></tr></table></figure>\n<h2 id=\"记录\"><a href=\"#记录\" class=\"headerlink\" title=\"记录\"></a>记录</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reflog</span><br><span class=\"line\">git <span class=\"built_in\">log</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm file.name</span><br><span class=\"line\">git rm file.name</span><br><span class=\"line\">git commit -m <span class=\"string\">\"Del\"</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"远程操作\"><a href=\"#远程操作\" class=\"headerlink\" title=\"远程操作\"></a>远程操作</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add origin git@github.com:ifyour/ifyour.github.io.git</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 第一次推送，-u(--set-upstream) 指定默认上游</span></span><br><span class=\"line\">git push -u origin master</span><br><span class=\"line\">git push origin master</span><br></pre></td></tr></table></figure>\n<h2 id=\"克隆\"><a href=\"#克隆\" class=\"headerlink\" title=\"克隆\"></a>克隆</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/ifyour/ifyour.github.io.git path</span><br><span class=\"line\">git <span class=\"built_in\">clone</span> git@github.com:ifyour/ifyour.github.io.git path</span><br></pre></td></tr></table></figure>\n<h2 id=\"分支操作\"><a href=\"#分支操作\" class=\"headerlink\" title=\"分支操作\"></a>分支操作</h2><p><img src=\"https://user-images.githubusercontent.com/15377484/39952537-6b679758-55cb-11e8-9ff7-87440fcbb4d0.png\" alt=\"image\"></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看当前分支</span></span><br><span class=\"line\">git branch</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建分支</span></span><br><span class=\"line\">git branch dev</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 切换分支</span></span><br><span class=\"line\">git checkout dev</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建并 checkout 分支</span></span><br><span class=\"line\">git checkout -b dev</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 合并分支</span></span><br><span class=\"line\">git merge dev</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除分支</span></span><br><span class=\"line\">git branch -d dev</span><br></pre></td></tr></table></figure>\n<h2 id=\"标签\"><a href=\"#标签\" class=\"headerlink\" title=\"标签\"></a>标签</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag 0.1.1</span><br><span class=\"line\">git push origin --tags</span><br></pre></td></tr></table></figure>\n<h2 id=\"More\"><a href=\"#More\" class=\"headerlink\" title=\"More\"></a>More</h2><ul>\n<li><a href=\"http://www.bootcss.com/p/git-guide/\" target=\"_blank\" rel=\"noopener\">Git - 简易指南</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>Git 操作详细总结，以便回顾和查询。理解这些指令，觉得最重要的是理解 Git 的内部原理，比如 Git 的分布式版本控制，分清楚工作区、暂存区、版本库，还有就是理解 Git 跟踪并管理的是修改，而非文件。</p>","more":"<p><img src=\"https://user-images.githubusercontent.com/15377484/39952532-4c0c156e-55cb-11e8-8052-e62c448325fe.png\" alt=\"image\"></p>\n<h2 id=\"设置\"><a href=\"#设置\" class=\"headerlink\" title=\"设置\"></a>设置</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global user.name <span class=\"string\">\"Your Name\"</span></span><br><span class=\"line\">git config --global user.email <span class=\"string\">\"email@example.com\"</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"提交\"><a href=\"#提交\" class=\"headerlink\" title=\"提交\"></a>提交</h2><p>Git 追踪的是修改，而不是文件。</p>\n<p><img src=\"https://user-images.githubusercontent.com/15377484/39952534-5c10f236-55cb-11e8-81bf-c4d369d07054.png\" alt=\"image\"></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将 “当前修改” 移动到暂存区 (stage)</span></span><br><span class=\"line\">git add filename.txt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将暂存区修改提交</span></span><br><span class=\"line\">git commit -m <span class=\"string\">\"Add filename.txt.\"</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"状态\"><a href=\"#状态\" class=\"headerlink\" title=\"状态\"></a>状态</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git status</span><br><span class=\"line\">git diff</span><br></pre></td></tr></table></figure>\n<h2 id=\"回退\"><a href=\"#回退\" class=\"headerlink\" title=\"回退\"></a>回退</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 放弃工作区修改</span></span><br><span class=\"line\">git checkout -- file.name</span><br><span class=\"line\">git checkout -- .</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 取消 commit(比如需要重写 commit 信息)</span></span><br><span class=\"line\">git reset --soft HEAD</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 取消 commit、add(重新提交代码和 commit)</span></span><br><span class=\"line\">git reset HEAD</span><br><span class=\"line\">git reset --mixed HEAD</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 取消 commit、add、工作区修改 (需要完全重置)</span></span><br><span class=\"line\">git reset --hard HEAD</span><br></pre></td></tr></table></figure>\n<h2 id=\"记录\"><a href=\"#记录\" class=\"headerlink\" title=\"记录\"></a>记录</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reflog</span><br><span class=\"line\">git <span class=\"built_in\">log</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm file.name</span><br><span class=\"line\">git rm file.name</span><br><span class=\"line\">git commit -m <span class=\"string\">\"Del\"</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"远程操作\"><a href=\"#远程操作\" class=\"headerlink\" title=\"远程操作\"></a>远程操作</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add origin git@github.com:ifyour/ifyour.github.io.git</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 第一次推送，-u(--set-upstream) 指定默认上游</span></span><br><span class=\"line\">git push -u origin master</span><br><span class=\"line\">git push origin master</span><br></pre></td></tr></table></figure>\n<h2 id=\"克隆\"><a href=\"#克隆\" class=\"headerlink\" title=\"克隆\"></a>克隆</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/ifyour/ifyour.github.io.git path</span><br><span class=\"line\">git <span class=\"built_in\">clone</span> git@github.com:ifyour/ifyour.github.io.git path</span><br></pre></td></tr></table></figure>\n<h2 id=\"分支操作\"><a href=\"#分支操作\" class=\"headerlink\" title=\"分支操作\"></a>分支操作</h2><p><img src=\"https://user-images.githubusercontent.com/15377484/39952537-6b679758-55cb-11e8-9ff7-87440fcbb4d0.png\" alt=\"image\"></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看当前分支</span></span><br><span class=\"line\">git branch</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建分支</span></span><br><span class=\"line\">git branch dev</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 切换分支</span></span><br><span class=\"line\">git checkout dev</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建并 checkout 分支</span></span><br><span class=\"line\">git checkout -b dev</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 合并分支</span></span><br><span class=\"line\">git merge dev</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除分支</span></span><br><span class=\"line\">git branch -d dev</span><br></pre></td></tr></table></figure>\n<h2 id=\"标签\"><a href=\"#标签\" class=\"headerlink\" title=\"标签\"></a>标签</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag 0.1.1</span><br><span class=\"line\">git push origin --tags</span><br></pre></td></tr></table></figure>\n<h2 id=\"More\"><a href=\"#More\" class=\"headerlink\" title=\"More\"></a>More</h2><ul>\n<li><a href=\"http://www.bootcss.com/p/git-guide/\" target=\"_blank\" rel=\"noopener\">Git - 简易指南</a></li>\n</ul>"},{"title":"JavaScript 中的 this 用法总结","date":"2016-02-19T11:23:36.000Z","comments":0,"_content":"\n`this` 是 Javascript 语言的一个关键字。它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。随着函数使用场合的不同，`this` 的值会发生变化。但是有一个总的原则，那就是 `this` 指的是，调用函数的那个对象。\n\n<!-- more -->\n### 四种情况\n#### 纯粹的函数调用\n\n```js\n// eg:1\nconsole.log(this);// => window 对象\n\n// eg:2\nfunction fun(){\n    this.x = 1;\n}\nconsole.log(x); // => 1\n// this 指向全局对象，即 DOM 中的 window 对象\n```\n\n#### 作为对象方法的调用\n\n```js\nvar user = {\n    count: 1,\n\n    getCount: function() {\n        return this.count;\n    }\n};\n\nconsole.log(user.getCount());// 1\n// this 指向调用 getCount 方法的对象 user\n```\n\n#### 作为构造函数的调用\n```js\nvar x = 2;\n\nfunction fun(){\n    this.x = 1;\n}\n\nvar obj = new fun();\nconsole.log(obj.x); // => 1\nconsole.log(x); // => 2\n//this 就指向构造器创建的新对象 obj\n```\n\n#### apply/call 调用\n`apply()` 是函数对象的一个方法，它的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象，无参数时传入 window 对象。因此，`this` 指的就是这第一个参数。\n```js\nvar x = 0;\n\nfunction fun(){\n    console.log(this.x);\n}\n\nvar obj = {};\nobj.x = 1;\nobj.m = fun;\n\nobj.m(); //           => 1  this 指向调用方法的对象即：obj\nobj.m.apply();  //    => 0  this 指向的是全局对象即：window\nobj.m.apply(obj);//   => 1  this 指向的第一个参数即：obj\nobj.m.call(obj);//    => 1  this 指向的第一个参数即：obj\n```\n\n### 总结\n1. 纯粹的函数调用: `this` 就代表全局对象 Global（浏览器下就是 window）\n2. 作为对象方法的调用: `this` 指向调用方法的对象\n3. 作为构造函数调用：`this` 就指向构造器创建的新对象\n4. `apply`, `call` 调用：`this` 指向就是这些函数的第一个参数\n\n下一篇文章总结一下：`apply`、`call`、`bind` 的用法 :P\n","source":"_posts/JavaScript-中的-this-用法总结.md","raw":"---\ntitle: JavaScript 中的 this 用法总结\ndate: 2016-02-19 19:23:36\ntags:\ncomments: false\n---\n\n`this` 是 Javascript 语言的一个关键字。它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。随着函数使用场合的不同，`this` 的值会发生变化。但是有一个总的原则，那就是 `this` 指的是，调用函数的那个对象。\n\n<!-- more -->\n### 四种情况\n#### 纯粹的函数调用\n\n```js\n// eg:1\nconsole.log(this);// => window 对象\n\n// eg:2\nfunction fun(){\n    this.x = 1;\n}\nconsole.log(x); // => 1\n// this 指向全局对象，即 DOM 中的 window 对象\n```\n\n#### 作为对象方法的调用\n\n```js\nvar user = {\n    count: 1,\n\n    getCount: function() {\n        return this.count;\n    }\n};\n\nconsole.log(user.getCount());// 1\n// this 指向调用 getCount 方法的对象 user\n```\n\n#### 作为构造函数的调用\n```js\nvar x = 2;\n\nfunction fun(){\n    this.x = 1;\n}\n\nvar obj = new fun();\nconsole.log(obj.x); // => 1\nconsole.log(x); // => 2\n//this 就指向构造器创建的新对象 obj\n```\n\n#### apply/call 调用\n`apply()` 是函数对象的一个方法，它的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象，无参数时传入 window 对象。因此，`this` 指的就是这第一个参数。\n```js\nvar x = 0;\n\nfunction fun(){\n    console.log(this.x);\n}\n\nvar obj = {};\nobj.x = 1;\nobj.m = fun;\n\nobj.m(); //           => 1  this 指向调用方法的对象即：obj\nobj.m.apply();  //    => 0  this 指向的是全局对象即：window\nobj.m.apply(obj);//   => 1  this 指向的第一个参数即：obj\nobj.m.call(obj);//    => 1  this 指向的第一个参数即：obj\n```\n\n### 总结\n1. 纯粹的函数调用: `this` 就代表全局对象 Global（浏览器下就是 window）\n2. 作为对象方法的调用: `this` 指向调用方法的对象\n3. 作为构造函数调用：`this` 就指向构造器创建的新对象\n4. `apply`, `call` 调用：`this` 指向就是这些函数的第一个参数\n\n下一篇文章总结一下：`apply`、`call`、`bind` 的用法 :P\n","slug":"JavaScript-中的-this-用法总结","published":1,"updated":"2018-06-17T09:49:30.000Z","layout":"post","photos":[],"link":"","_id":"cjiitidi90008u4q9aafcwebt","content":"<p><code>this</code> 是 Javascript 语言的一个关键字。它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。随着函数使用场合的不同，<code>this</code> 的值会发生变化。但是有一个总的原则，那就是 <code>this</code> 指的是，调用函数的那个对象。</p>\n<a id=\"more\"></a>\n<h3 id=\"四种情况\"><a href=\"#四种情况\" class=\"headerlink\" title=\"四种情况\"></a>四种情况</h3><h4 id=\"纯粹的函数调用\"><a href=\"#纯粹的函数调用\" class=\"headerlink\" title=\"纯粹的函数调用\"></a>纯粹的函数调用</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// eg:1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);<span class=\"comment\">// =&gt; window 对象</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// eg:2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.x = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x); <span class=\"comment\">// =&gt; 1</span></span><br><span class=\"line\"><span class=\"comment\">// this 指向全局对象，即 DOM 中的 window 对象</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"作为对象方法的调用\"><a href=\"#作为对象方法的调用\" class=\"headerlink\" title=\"作为对象方法的调用\"></a>作为对象方法的调用</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> user = &#123;</span><br><span class=\"line\">    count: <span class=\"number\">1</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">    getCount: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user.getCount());<span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// this 指向调用 getCount 方法的对象 user</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"作为构造函数的调用\"><a href=\"#作为构造函数的调用\" class=\"headerlink\" title=\"作为构造函数的调用\"></a>作为构造函数的调用</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.x = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> fun();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.x); <span class=\"comment\">// =&gt; 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x); <span class=\"comment\">// =&gt; 2</span></span><br><span class=\"line\"><span class=\"comment\">//this 就指向构造器创建的新对象 obj</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"apply-call-调用\"><a href=\"#apply-call-调用\" class=\"headerlink\" title=\"apply/call 调用\"></a>apply/call 调用</h4><p><code>apply()</code> 是函数对象的一个方法，它的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象，无参数时传入 window 对象。因此，<code>this</code> 指的就是这第一个参数。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br><span class=\"line\">obj.x = <span class=\"number\">1</span>;</span><br><span class=\"line\">obj.m = fun;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.m(); <span class=\"comment\">//           =&gt; 1  this 指向调用方法的对象即：obj</span></span><br><span class=\"line\">obj.m.apply();  <span class=\"comment\">//    =&gt; 0  this 指向的是全局对象即：window</span></span><br><span class=\"line\">obj.m.apply(obj);<span class=\"comment\">//   =&gt; 1  this 指向的第一个参数即：obj</span></span><br><span class=\"line\">obj.m.call(obj);<span class=\"comment\">//    =&gt; 1  this 指向的第一个参数即：obj</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ol>\n<li>纯粹的函数调用: <code>this</code> 就代表全局对象 Global（浏览器下就是 window）</li>\n<li>作为对象方法的调用: <code>this</code> 指向调用方法的对象</li>\n<li>作为构造函数调用：<code>this</code> 就指向构造器创建的新对象</li>\n<li><code>apply</code>, <code>call</code> 调用：<code>this</code> 指向就是这些函数的第一个参数</li>\n</ol>\n<p>下一篇文章总结一下：<code>apply</code>、<code>call</code>、<code>bind</code> 的用法 :P</p>\n","site":{"data":{}},"excerpt":"<p><code>this</code> 是 Javascript 语言的一个关键字。它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。随着函数使用场合的不同，<code>this</code> 的值会发生变化。但是有一个总的原则，那就是 <code>this</code> 指的是，调用函数的那个对象。</p>","more":"<h3 id=\"四种情况\"><a href=\"#四种情况\" class=\"headerlink\" title=\"四种情况\"></a>四种情况</h3><h4 id=\"纯粹的函数调用\"><a href=\"#纯粹的函数调用\" class=\"headerlink\" title=\"纯粹的函数调用\"></a>纯粹的函数调用</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// eg:1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);<span class=\"comment\">// =&gt; window 对象</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// eg:2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.x = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x); <span class=\"comment\">// =&gt; 1</span></span><br><span class=\"line\"><span class=\"comment\">// this 指向全局对象，即 DOM 中的 window 对象</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"作为对象方法的调用\"><a href=\"#作为对象方法的调用\" class=\"headerlink\" title=\"作为对象方法的调用\"></a>作为对象方法的调用</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> user = &#123;</span><br><span class=\"line\">    count: <span class=\"number\">1</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">    getCount: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user.getCount());<span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// this 指向调用 getCount 方法的对象 user</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"作为构造函数的调用\"><a href=\"#作为构造函数的调用\" class=\"headerlink\" title=\"作为构造函数的调用\"></a>作为构造函数的调用</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.x = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> fun();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.x); <span class=\"comment\">// =&gt; 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x); <span class=\"comment\">// =&gt; 2</span></span><br><span class=\"line\"><span class=\"comment\">//this 就指向构造器创建的新对象 obj</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"apply-call-调用\"><a href=\"#apply-call-调用\" class=\"headerlink\" title=\"apply/call 调用\"></a>apply/call 调用</h4><p><code>apply()</code> 是函数对象的一个方法，它的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象，无参数时传入 window 对象。因此，<code>this</code> 指的就是这第一个参数。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br><span class=\"line\">obj.x = <span class=\"number\">1</span>;</span><br><span class=\"line\">obj.m = fun;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.m(); <span class=\"comment\">//           =&gt; 1  this 指向调用方法的对象即：obj</span></span><br><span class=\"line\">obj.m.apply();  <span class=\"comment\">//    =&gt; 0  this 指向的是全局对象即：window</span></span><br><span class=\"line\">obj.m.apply(obj);<span class=\"comment\">//   =&gt; 1  this 指向的第一个参数即：obj</span></span><br><span class=\"line\">obj.m.call(obj);<span class=\"comment\">//    =&gt; 1  this 指向的第一个参数即：obj</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ol>\n<li>纯粹的函数调用: <code>this</code> 就代表全局对象 Global（浏览器下就是 window）</li>\n<li>作为对象方法的调用: <code>this</code> 指向调用方法的对象</li>\n<li>作为构造函数调用：<code>this</code> 就指向构造器创建的新对象</li>\n<li><code>apply</code>, <code>call</code> 调用：<code>this</code> 指向就是这些函数的第一个参数</li>\n</ol>\n<p>下一篇文章总结一下：<code>apply</code>、<code>call</code>、<code>bind</code> 的用法 :P</p>"},{"title":"Node.JS 学习笔记 [01] -- 入门","date":"2015-01-02T11:00:24.000Z","comments":0,"_content":"\n整理记录 Node.js 学习笔记，作为前端人员，非常有必要了解后端的一些知识，方便与后端的同事协作，提高效率，搞好前端后，也可以尝试往后端发展，成为一名全栈工程师！:P\n<!-- more -->\n![](http://ww4.sinaimg.cn/mw690/6057861cgw1fb6vlzd7i7j20go08cjro.jpg)\n### Node.js 介绍\nNode.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。Node.js 的包管理器 npm，是全球最大的开源库生态系统。\n\n#### Node.js 和 JavaScript 的区别\n- Node.js 是一个可以运行 JavaScript 的平台，基于 ChromeV8 引擎，是对 JavaScript 的增强，使 JavaScript 具备了服务器语言的开发能力，比如操作文件、读取系统信息、网络传输等。\n- JavaScript 是一门编程语言，只要有 JavaScript 引擎就能运行并且如果JavaScript运行在浏览器中，浏览器对JavaScript加入了浏览器和文档操作的接口（方法）。\n\n<div class=\"tip\">\n简单理解：浏览器中 JavaScript 主要是操作 BOM 和 DOM，而 Node.js 则是具有服务端语言处理能力（处理网络请求，保存数据到数据库等）。\n</div>\n\n#### 官方网站\n- 英文社区： https://www.npmjs.com/\n- 中文社区：http://cnodejs.org/\n\n#### Node.js 安装及运行\n在 Node.js 的官方提供的[下载频道](https://nodejs.org/en/download/)选择对应的平台及安装程序安装即可。Node.js 提供了 `REPL（Read-Evaluate-Print-Loop）` 模式，即 ***交互式命令行解析器***，可以直接输入命令行，编写 Node.js 代码。安装成功后，我们可以在终端里输入 `node -v` 获取当前的 Node.js 版本号，能获取表示成功安装。\n\n### Node.js 模块\n模块对于 Node.js 来说是一个非常重要的概念，一个特定功能的文件就是一个模块。模块之间可能会存在一定的依赖关系，比如我写了一个 jQuery 轮播的插件，它就依赖 jQuery 库，在 Node.js 中可以非常方便的表示清楚这种依赖关系。说到模块，还需要说一个就是编写模块的规范。\n\n#### 模块规范\n- ***AMD*** (Asynchronous Module Definition)，这种规范是异步的加载模块，RequireR.js 应用了这一规范,适合客户端浏览器环境。\n- ***CMD*** (Common Module Definition), 是 Sea.js 推崇的规范。\n- ***CommonJS*** , 是诞生比较早的。Node.js 就采用了 CommonJS 的规范来定义模块。但是 CommonJs 采用的是同步加载文件方式，只适用于服务端（Node.js平台）。\n\n#### 使用模块\n模块定义完成后，就可以使用模块，通过命令行参数传递给 Node.js 以启动程序的模块被称为 ***主模块***。主模块负责调度组成整个程序的其它模块完成工作。其实就类似网站中的 `index.html`，Node.js 中的主模块通常是 `main.js` 或者 `index.js`。\n```js\nvar http = require('http');// 通过 require 引入 http 模块\n```\n\n#### 模块组成\n在上条命令中，我们通过 require 引入了一个 http 模块，实际上作为一个单独的模块文件，Node.js 为我们在外层嵌套了一个函数，正因为有了这个函数，在这个文件中声明的变量就是私有变量啦，那么每个模块之间就不会产生干扰了。那么来看看这个函数长什么样子。\n```js\nfunction (exports, require, module, __filename, __dirname) {\n    var http = require('http');// 通过 require 引入 http 模块\n}\n```\n最外层，Node.js 为我们的代码包裹了这样一个函数，这个函数传入了几个参数，我来解释一下：\n- exports ：用于在当前模块中加载和使用别的模块，传入一个模块名，返回一个模块导出对象。\n- require：当前模块的导出对象，用于导出模块公有方法和属性。\n- module：访问到当前模块的一些相关信息，但最多的用途是替换当前模块的导出对象。\n- __filename：当前模块的文件名\n- __dirname：当前模块的目录名\n\n#### 模块分类\nNode.js 提供两种模块类型：\n1. 核心模块：是由 Node.js 平台提供的模块，也可以称为“系统模块”。\n2. 文件模块：以 `..` 或 `.` 和 `/` 开始的标识符，这里都被当做文件模块来处理。\n\n#### node_modules 文件夹\n该文件夹是 Node.js 中的特殊文件夹，用来存放 node 模块，如果一个模块既不是系统模块，也不是文件模块，那么它会被存放在 node_modules 文件夹中。使用 `console.log(module.paths);` 可以打印 Node.js 会遍历的 node_modules 目录。\n```js\n[ '/Users/wangmingming/Documents/Projects/JSstudy/12.26/node_modules',\n  '/Users/wangmingming/Documents/Projects/JSstudy/node_modules',\n  '/Users/wangmingming/Documents/Projects/node_modules',\n  '/Users/wangmingming/Documents/node_modules',\n  '/Users/wangmingming/node_modules',\n  '/Users/node_modules',\n  '/node_modules' ]\n```\n<div class=\"tip\">\n在调用一个模块时，Node.js 沿路径向上逐级递归，直到根目录下的 node_modules 目录。CommonJS 模规范也允许在标识符中不包含文件扩展名，这种情况下，Node 会按 js、json、node 的次序补足扩展名，依次尝试。\n</div>\n\n### 包 (Package)\n把由多个子模块组成的大模块称做包，并把所有子模块放在同一个目录里。在一个包中，会用 `package.json` 文件中的 `main` 属性用来描述这个包的主文件。\n\n#### NPM (Node Package Manager)\n大名鼎鼎的 NPM 实际上就是用来管理包的一个工具，借助 NPM 我们可以快速的安装和管理依赖包。下面是我整理的 npm 常用命令。\n```bash\nnpm init                   #  初始化包，要求填入包名等信息\nnpm install <name>         #  本地安装一个包\nnpm install <name> -g      #  全局安装一个包\nnpm install <name> --save  #  本地安装并写入 package.json 依赖中\nnpm remove <name>          #  移除\nnpm update <name>          #  更新\n\n```\n- 本地安装：将安装包放在 `./node_modules` 下（运行 npm 命令时所在的目录），如果没有 node_modules 目录，会在当前执行 npm 命令的目录下生成 node_modules 目录。可以通过 `require()` 来引入本地安装的包。\n- 全局安装：将安装包放在 `/usr/local` 下或者你 node 的安装目录，可以直接在命令行里使用。\n","source":"_posts/Node.JS-学习笔记-[01]----入门.md","raw":"---\ntitle: 'Node.JS 学习笔记 [01] -- 入门'\ndate: 2015-1-2 19:00:24\ntags:\ncomments: false\n---\n\n整理记录 Node.js 学习笔记，作为前端人员，非常有必要了解后端的一些知识，方便与后端的同事协作，提高效率，搞好前端后，也可以尝试往后端发展，成为一名全栈工程师！:P\n<!-- more -->\n![](http://ww4.sinaimg.cn/mw690/6057861cgw1fb6vlzd7i7j20go08cjro.jpg)\n### Node.js 介绍\nNode.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。Node.js 的包管理器 npm，是全球最大的开源库生态系统。\n\n#### Node.js 和 JavaScript 的区别\n- Node.js 是一个可以运行 JavaScript 的平台，基于 ChromeV8 引擎，是对 JavaScript 的增强，使 JavaScript 具备了服务器语言的开发能力，比如操作文件、读取系统信息、网络传输等。\n- JavaScript 是一门编程语言，只要有 JavaScript 引擎就能运行并且如果JavaScript运行在浏览器中，浏览器对JavaScript加入了浏览器和文档操作的接口（方法）。\n\n<div class=\"tip\">\n简单理解：浏览器中 JavaScript 主要是操作 BOM 和 DOM，而 Node.js 则是具有服务端语言处理能力（处理网络请求，保存数据到数据库等）。\n</div>\n\n#### 官方网站\n- 英文社区： https://www.npmjs.com/\n- 中文社区：http://cnodejs.org/\n\n#### Node.js 安装及运行\n在 Node.js 的官方提供的[下载频道](https://nodejs.org/en/download/)选择对应的平台及安装程序安装即可。Node.js 提供了 `REPL（Read-Evaluate-Print-Loop）` 模式，即 ***交互式命令行解析器***，可以直接输入命令行，编写 Node.js 代码。安装成功后，我们可以在终端里输入 `node -v` 获取当前的 Node.js 版本号，能获取表示成功安装。\n\n### Node.js 模块\n模块对于 Node.js 来说是一个非常重要的概念，一个特定功能的文件就是一个模块。模块之间可能会存在一定的依赖关系，比如我写了一个 jQuery 轮播的插件，它就依赖 jQuery 库，在 Node.js 中可以非常方便的表示清楚这种依赖关系。说到模块，还需要说一个就是编写模块的规范。\n\n#### 模块规范\n- ***AMD*** (Asynchronous Module Definition)，这种规范是异步的加载模块，RequireR.js 应用了这一规范,适合客户端浏览器环境。\n- ***CMD*** (Common Module Definition), 是 Sea.js 推崇的规范。\n- ***CommonJS*** , 是诞生比较早的。Node.js 就采用了 CommonJS 的规范来定义模块。但是 CommonJs 采用的是同步加载文件方式，只适用于服务端（Node.js平台）。\n\n#### 使用模块\n模块定义完成后，就可以使用模块，通过命令行参数传递给 Node.js 以启动程序的模块被称为 ***主模块***。主模块负责调度组成整个程序的其它模块完成工作。其实就类似网站中的 `index.html`，Node.js 中的主模块通常是 `main.js` 或者 `index.js`。\n```js\nvar http = require('http');// 通过 require 引入 http 模块\n```\n\n#### 模块组成\n在上条命令中，我们通过 require 引入了一个 http 模块，实际上作为一个单独的模块文件，Node.js 为我们在外层嵌套了一个函数，正因为有了这个函数，在这个文件中声明的变量就是私有变量啦，那么每个模块之间就不会产生干扰了。那么来看看这个函数长什么样子。\n```js\nfunction (exports, require, module, __filename, __dirname) {\n    var http = require('http');// 通过 require 引入 http 模块\n}\n```\n最外层，Node.js 为我们的代码包裹了这样一个函数，这个函数传入了几个参数，我来解释一下：\n- exports ：用于在当前模块中加载和使用别的模块，传入一个模块名，返回一个模块导出对象。\n- require：当前模块的导出对象，用于导出模块公有方法和属性。\n- module：访问到当前模块的一些相关信息，但最多的用途是替换当前模块的导出对象。\n- __filename：当前模块的文件名\n- __dirname：当前模块的目录名\n\n#### 模块分类\nNode.js 提供两种模块类型：\n1. 核心模块：是由 Node.js 平台提供的模块，也可以称为“系统模块”。\n2. 文件模块：以 `..` 或 `.` 和 `/` 开始的标识符，这里都被当做文件模块来处理。\n\n#### node_modules 文件夹\n该文件夹是 Node.js 中的特殊文件夹，用来存放 node 模块，如果一个模块既不是系统模块，也不是文件模块，那么它会被存放在 node_modules 文件夹中。使用 `console.log(module.paths);` 可以打印 Node.js 会遍历的 node_modules 目录。\n```js\n[ '/Users/wangmingming/Documents/Projects/JSstudy/12.26/node_modules',\n  '/Users/wangmingming/Documents/Projects/JSstudy/node_modules',\n  '/Users/wangmingming/Documents/Projects/node_modules',\n  '/Users/wangmingming/Documents/node_modules',\n  '/Users/wangmingming/node_modules',\n  '/Users/node_modules',\n  '/node_modules' ]\n```\n<div class=\"tip\">\n在调用一个模块时，Node.js 沿路径向上逐级递归，直到根目录下的 node_modules 目录。CommonJS 模规范也允许在标识符中不包含文件扩展名，这种情况下，Node 会按 js、json、node 的次序补足扩展名，依次尝试。\n</div>\n\n### 包 (Package)\n把由多个子模块组成的大模块称做包，并把所有子模块放在同一个目录里。在一个包中，会用 `package.json` 文件中的 `main` 属性用来描述这个包的主文件。\n\n#### NPM (Node Package Manager)\n大名鼎鼎的 NPM 实际上就是用来管理包的一个工具，借助 NPM 我们可以快速的安装和管理依赖包。下面是我整理的 npm 常用命令。\n```bash\nnpm init                   #  初始化包，要求填入包名等信息\nnpm install <name>         #  本地安装一个包\nnpm install <name> -g      #  全局安装一个包\nnpm install <name> --save  #  本地安装并写入 package.json 依赖中\nnpm remove <name>          #  移除\nnpm update <name>          #  更新\n\n```\n- 本地安装：将安装包放在 `./node_modules` 下（运行 npm 命令时所在的目录），如果没有 node_modules 目录，会在当前执行 npm 命令的目录下生成 node_modules 目录。可以通过 `require()` 来引入本地安装的包。\n- 全局安装：将安装包放在 `/usr/local` 下或者你 node 的安装目录，可以直接在命令行里使用。\n","slug":"Node.JS-学习笔记-[01]----入门","published":1,"updated":"2018-06-17T09:49:30.000Z","layout":"post","photos":[],"link":"","_id":"cjiitidib0009u4q9rz5lvwff","content":"<p>整理记录 Node.js 学习笔记，作为前端人员，非常有必要了解后端的一些知识，方便与后端的同事协作，提高效率，搞好前端后，也可以尝试往后端发展，成为一名全栈工程师！:P<br><a id=\"more\"></a><br><img src=\"http://ww4.sinaimg.cn/mw690/6057861cgw1fb6vlzd7i7j20go08cjro.jpg\" alt=\"\"></p>\n<h3 id=\"Node-js-介绍\"><a href=\"#Node-js-介绍\" class=\"headerlink\" title=\"Node.js 介绍\"></a>Node.js 介绍</h3><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。Node.js 的包管理器 npm，是全球最大的开源库生态系统。</p>\n<h4 id=\"Node-js-和-JavaScript-的区别\"><a href=\"#Node-js-和-JavaScript-的区别\" class=\"headerlink\" title=\"Node.js 和 JavaScript 的区别\"></a>Node.js 和 JavaScript 的区别</h4><ul>\n<li>Node.js 是一个可以运行 JavaScript 的平台，基于 ChromeV8 引擎，是对 JavaScript 的增强，使 JavaScript 具备了服务器语言的开发能力，比如操作文件、读取系统信息、网络传输等。</li>\n<li>JavaScript 是一门编程语言，只要有 JavaScript 引擎就能运行并且如果JavaScript运行在浏览器中，浏览器对JavaScript加入了浏览器和文档操作的接口（方法）。</li>\n</ul>\n<div class=\"tip\"><br>简单理解：浏览器中 JavaScript 主要是操作 BOM 和 DOM，而 Node.js 则是具有服务端语言处理能力（处理网络请求，保存数据到数据库等）。<br></div>\n\n<h4 id=\"官方网站\"><a href=\"#官方网站\" class=\"headerlink\" title=\"官方网站\"></a>官方网站</h4><ul>\n<li>英文社区： <a href=\"https://www.npmjs.com/\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/</a></li>\n<li>中文社区：<a href=\"http://cnodejs.org/\" target=\"_blank\" rel=\"noopener\">http://cnodejs.org/</a></li>\n</ul>\n<h4 id=\"Node-js-安装及运行\"><a href=\"#Node-js-安装及运行\" class=\"headerlink\" title=\"Node.js 安装及运行\"></a>Node.js 安装及运行</h4><p>在 Node.js 的官方提供的<a href=\"https://nodejs.org/en/download/\" target=\"_blank\" rel=\"noopener\">下载频道</a>选择对应的平台及安装程序安装即可。Node.js 提供了 <code>REPL（Read-Evaluate-Print-Loop）</code> 模式，即 <strong><em>交互式命令行解析器</em></strong>，可以直接输入命令行，编写 Node.js 代码。安装成功后，我们可以在终端里输入 <code>node -v</code> 获取当前的 Node.js 版本号，能获取表示成功安装。</p>\n<h3 id=\"Node-js-模块\"><a href=\"#Node-js-模块\" class=\"headerlink\" title=\"Node.js 模块\"></a>Node.js 模块</h3><p>模块对于 Node.js 来说是一个非常重要的概念，一个特定功能的文件就是一个模块。模块之间可能会存在一定的依赖关系，比如我写了一个 jQuery 轮播的插件，它就依赖 jQuery 库，在 Node.js 中可以非常方便的表示清楚这种依赖关系。说到模块，还需要说一个就是编写模块的规范。</p>\n<h4 id=\"模块规范\"><a href=\"#模块规范\" class=\"headerlink\" title=\"模块规范\"></a>模块规范</h4><ul>\n<li><strong><em>AMD</em></strong> (Asynchronous Module Definition)，这种规范是异步的加载模块，RequireR.js 应用了这一规范,适合客户端浏览器环境。</li>\n<li><strong><em>CMD</em></strong> (Common Module Definition), 是 Sea.js 推崇的规范。</li>\n<li><strong><em>CommonJS</em></strong> , 是诞生比较早的。Node.js 就采用了 CommonJS 的规范来定义模块。但是 CommonJs 采用的是同步加载文件方式，只适用于服务端（Node.js平台）。</li>\n</ul>\n<h4 id=\"使用模块\"><a href=\"#使用模块\" class=\"headerlink\" title=\"使用模块\"></a>使用模块</h4><p>模块定义完成后，就可以使用模块，通过命令行参数传递给 Node.js 以启动程序的模块被称为 <strong><em>主模块</em></strong>。主模块负责调度组成整个程序的其它模块完成工作。其实就类似网站中的 <code>index.html</code>，Node.js 中的主模块通常是 <code>main.js</code> 或者 <code>index.js</code>。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);<span class=\"comment\">// 通过 require 引入 http 模块</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"模块组成\"><a href=\"#模块组成\" class=\"headerlink\" title=\"模块组成\"></a>模块组成</h4><p>在上条命令中，我们通过 require 引入了一个 http 模块，实际上作为一个单独的模块文件，Node.js 为我们在外层嵌套了一个函数，正因为有了这个函数，在这个文件中声明的变量就是私有变量啦，那么每个模块之间就不会产生干扰了。那么来看看这个函数长什么样子。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">exports, require, module, __filename, __dirname</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);<span class=\"comment\">// 通过 require 引入 http 模块</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>最外层，Node.js 为我们的代码包裹了这样一个函数，这个函数传入了几个参数，我来解释一下：</p>\n<ul>\n<li>exports ：用于在当前模块中加载和使用别的模块，传入一个模块名，返回一个模块导出对象。</li>\n<li>require：当前模块的导出对象，用于导出模块公有方法和属性。</li>\n<li>module：访问到当前模块的一些相关信息，但最多的用途是替换当前模块的导出对象。</li>\n<li>__filename：当前模块的文件名</li>\n<li>__dirname：当前模块的目录名</li>\n</ul>\n<h4 id=\"模块分类\"><a href=\"#模块分类\" class=\"headerlink\" title=\"模块分类\"></a>模块分类</h4><p>Node.js 提供两种模块类型：</p>\n<ol>\n<li>核心模块：是由 Node.js 平台提供的模块，也可以称为“系统模块”。</li>\n<li>文件模块：以 <code>..</code> 或 <code>.</code> 和 <code>/</code> 开始的标识符，这里都被当做文件模块来处理。</li>\n</ol>\n<h4 id=\"node-modules-文件夹\"><a href=\"#node-modules-文件夹\" class=\"headerlink\" title=\"node_modules 文件夹\"></a>node_modules 文件夹</h4><p>该文件夹是 Node.js 中的特殊文件夹，用来存放 node 模块，如果一个模块既不是系统模块，也不是文件模块，那么它会被存放在 node_modules 文件夹中。使用 <code>console.log(module.paths);</code> 可以打印 Node.js 会遍历的 node_modules 目录。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ <span class=\"string\">'/Users/wangmingming/Documents/Projects/JSstudy/12.26/node_modules'</span>,</span><br><span class=\"line\">  <span class=\"string\">'/Users/wangmingming/Documents/Projects/JSstudy/node_modules'</span>,</span><br><span class=\"line\">  <span class=\"string\">'/Users/wangmingming/Documents/Projects/node_modules'</span>,</span><br><span class=\"line\">  <span class=\"string\">'/Users/wangmingming/Documents/node_modules'</span>,</span><br><span class=\"line\">  <span class=\"string\">'/Users/wangmingming/node_modules'</span>,</span><br><span class=\"line\">  <span class=\"string\">'/Users/node_modules'</span>,</span><br><span class=\"line\">  <span class=\"string\">'/node_modules'</span> ]</span><br></pre></td></tr></table></figure></p>\n<div class=\"tip\"><br>在调用一个模块时，Node.js 沿路径向上逐级递归，直到根目录下的 node_modules 目录。CommonJS 模规范也允许在标识符中不包含文件扩展名，这种情况下，Node 会按 js、json、node 的次序补足扩展名，依次尝试。<br></div>\n\n<h3 id=\"包-Package\"><a href=\"#包-Package\" class=\"headerlink\" title=\"包 (Package)\"></a>包 (Package)</h3><p>把由多个子模块组成的大模块称做包，并把所有子模块放在同一个目录里。在一个包中，会用 <code>package.json</code> 文件中的 <code>main</code> 属性用来描述这个包的主文件。</p>\n<h4 id=\"NPM-Node-Package-Manager\"><a href=\"#NPM-Node-Package-Manager\" class=\"headerlink\" title=\"NPM (Node Package Manager)\"></a>NPM (Node Package Manager)</h4><p>大名鼎鼎的 NPM 实际上就是用来管理包的一个工具，借助 NPM 我们可以快速的安装和管理依赖包。下面是我整理的 npm 常用命令。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm init                   <span class=\"comment\">#  初始化包，要求填入包名等信息</span></span><br><span class=\"line\">npm install &lt;name&gt;         <span class=\"comment\">#  本地安装一个包</span></span><br><span class=\"line\">npm install &lt;name&gt; -g      <span class=\"comment\">#  全局安装一个包</span></span><br><span class=\"line\">npm install &lt;name&gt; --save  <span class=\"comment\">#  本地安装并写入 package.json 依赖中</span></span><br><span class=\"line\">npm remove &lt;name&gt;          <span class=\"comment\">#  移除</span></span><br><span class=\"line\">npm update &lt;name&gt;          <span class=\"comment\">#  更新</span></span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>本地安装：将安装包放在 <code>./node_modules</code> 下（运行 npm 命令时所在的目录），如果没有 node_modules 目录，会在当前执行 npm 命令的目录下生成 node_modules 目录。可以通过 <code>require()</code> 来引入本地安装的包。</li>\n<li>全局安装：将安装包放在 <code>/usr/local</code> 下或者你 node 的安装目录，可以直接在命令行里使用。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>整理记录 Node.js 学习笔记，作为前端人员，非常有必要了解后端的一些知识，方便与后端的同事协作，提高效率，搞好前端后，也可以尝试往后端发展，成为一名全栈工程师！:P<br>","more":"<br><img src=\"http://ww4.sinaimg.cn/mw690/6057861cgw1fb6vlzd7i7j20go08cjro.jpg\" alt=\"\"></p>\n<h3 id=\"Node-js-介绍\"><a href=\"#Node-js-介绍\" class=\"headerlink\" title=\"Node.js 介绍\"></a>Node.js 介绍</h3><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。Node.js 的包管理器 npm，是全球最大的开源库生态系统。</p>\n<h4 id=\"Node-js-和-JavaScript-的区别\"><a href=\"#Node-js-和-JavaScript-的区别\" class=\"headerlink\" title=\"Node.js 和 JavaScript 的区别\"></a>Node.js 和 JavaScript 的区别</h4><ul>\n<li>Node.js 是一个可以运行 JavaScript 的平台，基于 ChromeV8 引擎，是对 JavaScript 的增强，使 JavaScript 具备了服务器语言的开发能力，比如操作文件、读取系统信息、网络传输等。</li>\n<li>JavaScript 是一门编程语言，只要有 JavaScript 引擎就能运行并且如果JavaScript运行在浏览器中，浏览器对JavaScript加入了浏览器和文档操作的接口（方法）。</li>\n</ul>\n<div class=\"tip\"><br>简单理解：浏览器中 JavaScript 主要是操作 BOM 和 DOM，而 Node.js 则是具有服务端语言处理能力（处理网络请求，保存数据到数据库等）。<br></div>\n\n<h4 id=\"官方网站\"><a href=\"#官方网站\" class=\"headerlink\" title=\"官方网站\"></a>官方网站</h4><ul>\n<li>英文社区： <a href=\"https://www.npmjs.com/\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/</a></li>\n<li>中文社区：<a href=\"http://cnodejs.org/\" target=\"_blank\" rel=\"noopener\">http://cnodejs.org/</a></li>\n</ul>\n<h4 id=\"Node-js-安装及运行\"><a href=\"#Node-js-安装及运行\" class=\"headerlink\" title=\"Node.js 安装及运行\"></a>Node.js 安装及运行</h4><p>在 Node.js 的官方提供的<a href=\"https://nodejs.org/en/download/\" target=\"_blank\" rel=\"noopener\">下载频道</a>选择对应的平台及安装程序安装即可。Node.js 提供了 <code>REPL（Read-Evaluate-Print-Loop）</code> 模式，即 <strong><em>交互式命令行解析器</em></strong>，可以直接输入命令行，编写 Node.js 代码。安装成功后，我们可以在终端里输入 <code>node -v</code> 获取当前的 Node.js 版本号，能获取表示成功安装。</p>\n<h3 id=\"Node-js-模块\"><a href=\"#Node-js-模块\" class=\"headerlink\" title=\"Node.js 模块\"></a>Node.js 模块</h3><p>模块对于 Node.js 来说是一个非常重要的概念，一个特定功能的文件就是一个模块。模块之间可能会存在一定的依赖关系，比如我写了一个 jQuery 轮播的插件，它就依赖 jQuery 库，在 Node.js 中可以非常方便的表示清楚这种依赖关系。说到模块，还需要说一个就是编写模块的规范。</p>\n<h4 id=\"模块规范\"><a href=\"#模块规范\" class=\"headerlink\" title=\"模块规范\"></a>模块规范</h4><ul>\n<li><strong><em>AMD</em></strong> (Asynchronous Module Definition)，这种规范是异步的加载模块，RequireR.js 应用了这一规范,适合客户端浏览器环境。</li>\n<li><strong><em>CMD</em></strong> (Common Module Definition), 是 Sea.js 推崇的规范。</li>\n<li><strong><em>CommonJS</em></strong> , 是诞生比较早的。Node.js 就采用了 CommonJS 的规范来定义模块。但是 CommonJs 采用的是同步加载文件方式，只适用于服务端（Node.js平台）。</li>\n</ul>\n<h4 id=\"使用模块\"><a href=\"#使用模块\" class=\"headerlink\" title=\"使用模块\"></a>使用模块</h4><p>模块定义完成后，就可以使用模块，通过命令行参数传递给 Node.js 以启动程序的模块被称为 <strong><em>主模块</em></strong>。主模块负责调度组成整个程序的其它模块完成工作。其实就类似网站中的 <code>index.html</code>，Node.js 中的主模块通常是 <code>main.js</code> 或者 <code>index.js</code>。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);<span class=\"comment\">// 通过 require 引入 http 模块</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"模块组成\"><a href=\"#模块组成\" class=\"headerlink\" title=\"模块组成\"></a>模块组成</h4><p>在上条命令中，我们通过 require 引入了一个 http 模块，实际上作为一个单独的模块文件，Node.js 为我们在外层嵌套了一个函数，正因为有了这个函数，在这个文件中声明的变量就是私有变量啦，那么每个模块之间就不会产生干扰了。那么来看看这个函数长什么样子。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">exports, require, module, __filename, __dirname</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);<span class=\"comment\">// 通过 require 引入 http 模块</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>最外层，Node.js 为我们的代码包裹了这样一个函数，这个函数传入了几个参数，我来解释一下：</p>\n<ul>\n<li>exports ：用于在当前模块中加载和使用别的模块，传入一个模块名，返回一个模块导出对象。</li>\n<li>require：当前模块的导出对象，用于导出模块公有方法和属性。</li>\n<li>module：访问到当前模块的一些相关信息，但最多的用途是替换当前模块的导出对象。</li>\n<li>__filename：当前模块的文件名</li>\n<li>__dirname：当前模块的目录名</li>\n</ul>\n<h4 id=\"模块分类\"><a href=\"#模块分类\" class=\"headerlink\" title=\"模块分类\"></a>模块分类</h4><p>Node.js 提供两种模块类型：</p>\n<ol>\n<li>核心模块：是由 Node.js 平台提供的模块，也可以称为“系统模块”。</li>\n<li>文件模块：以 <code>..</code> 或 <code>.</code> 和 <code>/</code> 开始的标识符，这里都被当做文件模块来处理。</li>\n</ol>\n<h4 id=\"node-modules-文件夹\"><a href=\"#node-modules-文件夹\" class=\"headerlink\" title=\"node_modules 文件夹\"></a>node_modules 文件夹</h4><p>该文件夹是 Node.js 中的特殊文件夹，用来存放 node 模块，如果一个模块既不是系统模块，也不是文件模块，那么它会被存放在 node_modules 文件夹中。使用 <code>console.log(module.paths);</code> 可以打印 Node.js 会遍历的 node_modules 目录。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ <span class=\"string\">'/Users/wangmingming/Documents/Projects/JSstudy/12.26/node_modules'</span>,</span><br><span class=\"line\">  <span class=\"string\">'/Users/wangmingming/Documents/Projects/JSstudy/node_modules'</span>,</span><br><span class=\"line\">  <span class=\"string\">'/Users/wangmingming/Documents/Projects/node_modules'</span>,</span><br><span class=\"line\">  <span class=\"string\">'/Users/wangmingming/Documents/node_modules'</span>,</span><br><span class=\"line\">  <span class=\"string\">'/Users/wangmingming/node_modules'</span>,</span><br><span class=\"line\">  <span class=\"string\">'/Users/node_modules'</span>,</span><br><span class=\"line\">  <span class=\"string\">'/node_modules'</span> ]</span><br></pre></td></tr></table></figure></p>\n<div class=\"tip\"><br>在调用一个模块时，Node.js 沿路径向上逐级递归，直到根目录下的 node_modules 目录。CommonJS 模规范也允许在标识符中不包含文件扩展名，这种情况下，Node 会按 js、json、node 的次序补足扩展名，依次尝试。<br></div>\n\n<h3 id=\"包-Package\"><a href=\"#包-Package\" class=\"headerlink\" title=\"包 (Package)\"></a>包 (Package)</h3><p>把由多个子模块组成的大模块称做包，并把所有子模块放在同一个目录里。在一个包中，会用 <code>package.json</code> 文件中的 <code>main</code> 属性用来描述这个包的主文件。</p>\n<h4 id=\"NPM-Node-Package-Manager\"><a href=\"#NPM-Node-Package-Manager\" class=\"headerlink\" title=\"NPM (Node Package Manager)\"></a>NPM (Node Package Manager)</h4><p>大名鼎鼎的 NPM 实际上就是用来管理包的一个工具，借助 NPM 我们可以快速的安装和管理依赖包。下面是我整理的 npm 常用命令。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm init                   <span class=\"comment\">#  初始化包，要求填入包名等信息</span></span><br><span class=\"line\">npm install &lt;name&gt;         <span class=\"comment\">#  本地安装一个包</span></span><br><span class=\"line\">npm install &lt;name&gt; -g      <span class=\"comment\">#  全局安装一个包</span></span><br><span class=\"line\">npm install &lt;name&gt; --save  <span class=\"comment\">#  本地安装并写入 package.json 依赖中</span></span><br><span class=\"line\">npm remove &lt;name&gt;          <span class=\"comment\">#  移除</span></span><br><span class=\"line\">npm update &lt;name&gt;          <span class=\"comment\">#  更新</span></span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>本地安装：将安装包放在 <code>./node_modules</code> 下（运行 npm 命令时所在的目录），如果没有 node_modules 目录，会在当前执行 npm 命令的目录下生成 node_modules 目录。可以通过 <code>require()</code> 来引入本地安装的包。</li>\n<li>全局安装：将安装包放在 <code>/usr/local</code> 下或者你 node 的安装目录，可以直接在命令行里使用。</li>\n</ul>"},{"title":"Mongodb 学习笔记 -- 增删改查","date":"2016-01-05T13:24:40.000Z","comments":0,"_content":"\n记录 Mongodb 的学习之旅，从环境配置，到基础命令行使用，算是一个简单的入门教程，同时也是学习总结，还有把踩到的坑都记录下来，以后遇到同样的问题不至于在同一个地方继续踩坑。\n<!-- more -->\n### Mongodb 介绍\n> MongoDB是一种文档导向***数据库管理系统***，由C++撰写而成，旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。2007年10月，MongoDB由10gen团队所发展。2009年2月首度推出。 --- ***维基百科***\n\nMongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。听着很饶，其实就是非关系数据库。那什么又是 ***关系型数据库*** 呢？关系型数据库以行和列的形式存储数据，这一系列的行和列被称为表，一组表组成了数据库。表与表之间的数据记录有关系。\n\n### Mongodb 安装\n本人的操作系统是：MacOS，且已经安装了 [brew](http://brew.sh/index_zh-cn.html) ，所以图省事，我就使用 brew 一键安装了。没用过 brew 的同学可以去[这里看看](http://www.cnblogs.com/TankXiao/p/3247113.html)，用起来还是挺方便的。\n\n```bash\nbrew install mongodb\n```\n安装速度取决于你的网络情况，这里稍等片刻。brew 默认的安装位置在 `/usr/local/Cellar/` 一会的功夫，我们就能在这里看到，Mongodb 乖乖的躺在这了。因为 Mongodb 会默认读取 `/data/db` 目录下的数据库，所以方便省事，我们把默认的数据库就创建在这个位置，并且给 `/data` 执行权限，执行以下命令即可。\n\n```bash\nsudo mkdir -p /data/db         # sudo 表示以管理员权限运行，-p 表示创建多层目录\nsudo chown -R  UserName /data  # UserName 表示你当前的系统用户名\n```\n安装成功后，就可以在 Mongodb 的安装目录下 找到 `bin` 目录了，这里面放着所有需要用到的命令。\n```bash\ncd /usr/local/Cellar/mongodb/3.4.0/bin\n./mongod   # 执行 Mongodb 进程后，浏览器打开 http://127.0.0.1:27017/\n```\n浏览器显示下面的内容，就表示安装成功啦。\n```text\nIt looks like you are trying to access MongoDB over HTTP on the native driver port.\n```\n接下来打开终端，执行下面的命令，验证我们确实安装成功了。在 Mongodb 的控制台中，可以执行很多命令来操作数据库。\n```bash\ncd /usr/local/Cellar/mongodb/3.4.0/bin\n./mongo\n\n# 进入 MongoDB shell 后，光标会变成下面过的状态，执行 show dbs 后，显示如下则大功告成！\n> show dbs\nadmin  0.000GB\nlocal  0.000GB\n```\n接下来，为了方便下次执行 Mongodb ，我们把 `bin` 目录放到环境变量中，这样下次直接在终端输入 `mongod` 即可启用服务，输入命令 `mongo` 即可进入 shell 控制台。\n\n```bash\n# 添加环境变量，语法：echo \"export PATH=xxxxxx:$PATH\" >> ~/.bash_profile\necho 'export PATH=/usr/local/Cellar/mongodb/3.4.0/bin:$PATH'>>~/.bash_profile\n```\n### Mongodb 使用\n使用之前，在明白几个概念，相比关系型数据库，非关系数据库采用了 ***数据库***、***集合***、***文档***、的概念。其实对比 SQL 数据库，就很容易理解，集合就好比是一张表，文档好比就是一整行数据。库的概念是一致的。就这点区别。在终端输入 `mongo` 进入shell 控制台。\n```bash\nmongo\n```\n#### 基础命令\n新增数据\n- 显示数据库：`show dbs`\n- 使用/创建数据库：`use 数据库名`\n- 显示集合：`show collections`\n- 保存数据：`db.collection.save({\"key\":\"value\",\"key2\":\"value2\"})`\n- 插入数据：`db.collection.insert({\"key\":\"value\",\"key2\":\"value2\"})`\n\n<div class=\"tip\">\n若新增的数据主键已经存在，insert()会不做操作并提示错误，而save()则更改原来的内容为新内容。\n</div>\n\n删除数据\n- 删除所有文档：`db.collection.remove({})`\n- 删除指定文档：`db.collection.remove({\"key\":\"value\"})`\n- 删除集合：`db.collection.drop()` 或者 `db.runCommand({\"drop\":\"collection\"})`\n- 删除数据库：`db.runCommand({\"dropDatabase\": 1})` 注意：1没有引号\n\n查找数据\n- 查找所有数据： `db.collection.find({})`\n- 查到单条数据：`db.collection.findOne({})`\n- 条件查找：`db.collection.find({\"key\":\"value\"})`\n- 条件查找 key < value：`db.collection.find({\"key\":{$lt:value}})`\n- 条件查找 key > value：`db.collection.find({\"key\":{$gt:value}})`\n- 条件查找 key >= value：`db.collection.find({\"key\":{$gte:value}})`\n- 范围查找：`db.collection.find({\"key\":{$gt:value1,$lt:value2 } })`\n- 模运算查找：`db.collection.find({\"key\":{$mod:[10,1]}})`\n- 范围在查找：`db.collection.find({\"key\":{$in:[1,2,3]}})`\n- 范围不在在查找：`db.collection.find({\"key\":{$nin:[1,2,3]}})`\n- 数组长度查找：`db.collection.find({\"key\":{$size:1}})` key 必须是数组\n- 字段存在查找：`db.collection.find({\"key\":{$exists:true|false}})`\n- 多条件查找：`db.collection.find({$or:[{a:1},{b:2}]})`\n- 内嵌对象中的值查找：`db.collection.find({\"key.subkey\":value})`\n- 排序：`db.collection.find({}).sort({\"key1\":1,\"key2\":-1})` 1升序 -1降序\n- 对字段建立索引：`db.collection.find({})ensureIndex({\"key\":1})` 1升序 -1降序\n- 范围控制查找：`db.collection.find().skip(5).limit(5)` 跳过5条，读取5条\n- 查询结果集统计：`db.collection.find().count()`\n- 模糊查找：`db.collection.find({\"key\":/ab/})` 正则\n\n\n更改数据\n- `db.collection.update({\"targetKey\":\"targetValue\"},{\"newKey\":\"newVlue\"})`\n\n#### GUI 工具\n![](http://ww1.sinaimg.cn/large/6057861cgw1fbfwwdbu8qj20zq0dbqah.jpg)\n***Robomongo*** 可视化 Mongodb 数据库管理工具 ，点击[这里](https://robomongo.org/download)下载，官方网站：https://robomongo.org/ 。\n\n###  Mongoose 介绍\n[Mongoose](http://mongoosejs.com/) 简而言之就是在 Node 环境中操作 MongoDB 数据库的一种对象模型工具，Mongoose 将数据库中的数据转换为 JavaScript 对象供开发人员使用。\n\n#### 配置\n安装 Mongoose\n```bash\nnpm install mongoose --save\n```\n引入到项目文件中并创建链接\n```js\n// app.js\nvar mongoose = require('mongoose');\nmongoose.connect('mongodb://localhost/my_database');\n```\n\n#### 新增数据\n```js\n// 引入模块\nvar mongoose = require('mongoose');\n// 连接数据库\nvar db = mongoose.createConnection('mongodb://127.0.0.1:27017/test');\n// 设置数据类型\nvar monSchema = new mongooose.Schema({\n    name:{type:String,default:\"username\"},\n    age：{type:Number},\n    sex:{type:String}\n});\n// 选择集合\nvar monModel = db.model('user',monSchema);\n// 数据集\nvar content = {name:\"Nick\",age:23,sex:'男'};\n// 实例化对象并插入数据\nvar monInsert = new monModel(content);\nmonInsert.save(function(err){\n  if(err){\n    console.log(err);\n  }else{\n    console.log('成功插入数据');\n  }\n  db.close();\n});\n```\n#### 删除数据\n```js\n// 引入模块\nvar mongoose = require('mongoose');\n// 连接数据库\nvar db = mongoose.createConnection('mongodb://127.0.0.1:27017/test');\n// cosole.log(db);\n// 设置数据类型\nvar monSchema = new mongooose.Schema({\n    name:{type:String,default:\"name\"},\n    age：{type:Number},\n    sex:{type:String}\n});\n// 选择集合\nvar monModel = db.model('user',monSchema);\n// 原数据字段值\nvar oldValue  = {name:\"Nick\"};\n// 单条件更新\nvar newData1 = {$set:{name:\"内容\"}};\n// 多条件更新\nvar newData2 = {$set:{name:\"内容\",age:2}};\nmonModel.update(oldValue,newData,function(err,result){\n  if(err){\n    console.log(err);\n  }else{\n    console.log(\"update\");\n  }\n  db.close();\n});\n```\n\n#### 查询数据\n```js\n// 引入模块\nvar mongoose = require('mongoose');\n// 连接数据库\nvar db = mongoose.createConnection('mongodb://127.0.0.1:27017/test');\n// cosole.log(db);\n// 设置数据类型\nvar monSchema = new mongooose.Schema({\n    name:{type:String,default:\"name\"},\n    age：{type:Number},\n    sex:{type:String}\n});\n// 选择集合\nvar monModel = db.model('user',monSchema);\nvar content = {name:\"姓名2\"};\nvar field = {name:1,age:1,sex:1};\nmonModel.find(content,field,function(err,result){\n  if(err){\n    console.log(err);\n  }else{\n    console.log(result);\n  }\n  db.close();\n});\n```\n\n\n#### 修改数据\n```js\n// 引入模块\nvar mongoose = require('mongoose');\n// 连接数据库\nvar db = mongoose.createConnection('mongodb://127.0.0.1:27017/test');\n// cosole.log(db);\n// 设置数据类型\nvar monSchema = new mongooose.Schema({\n    name:{type:String,default:\"name\"},\n    age：{type:Number},\n    sex:{type:String}\n});\n// 选择集合\nvar monModel = db.model('user',monSchema);\n// 原数据字段值\nvar oldValue  = {name:\"Nick\"};\n// 单条件更新\nvar newData1 = {$set:{name:\"内容\"}};\n// 多条件更新\nvar newData2 = {$set:{name:\"内容\",age:2}};\nmonModel.update(oldValue,newData,function(err,result){\n  if(err){\n    console.log(err);\n  }else{\n    console.log(\"update\");\n  }\n  db.close();\n});\n```\n","source":"_posts/Mongodb-学习笔记----增删改查.md","raw":"---\ntitle: 'Mongodb 学习笔记 -- 增删改查'\ndate: 2016-01-05 21:24:40\ntags:\ncomments: false\n---\n\n记录 Mongodb 的学习之旅，从环境配置，到基础命令行使用，算是一个简单的入门教程，同时也是学习总结，还有把踩到的坑都记录下来，以后遇到同样的问题不至于在同一个地方继续踩坑。\n<!-- more -->\n### Mongodb 介绍\n> MongoDB是一种文档导向***数据库管理系统***，由C++撰写而成，旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。2007年10月，MongoDB由10gen团队所发展。2009年2月首度推出。 --- ***维基百科***\n\nMongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。听着很饶，其实就是非关系数据库。那什么又是 ***关系型数据库*** 呢？关系型数据库以行和列的形式存储数据，这一系列的行和列被称为表，一组表组成了数据库。表与表之间的数据记录有关系。\n\n### Mongodb 安装\n本人的操作系统是：MacOS，且已经安装了 [brew](http://brew.sh/index_zh-cn.html) ，所以图省事，我就使用 brew 一键安装了。没用过 brew 的同学可以去[这里看看](http://www.cnblogs.com/TankXiao/p/3247113.html)，用起来还是挺方便的。\n\n```bash\nbrew install mongodb\n```\n安装速度取决于你的网络情况，这里稍等片刻。brew 默认的安装位置在 `/usr/local/Cellar/` 一会的功夫，我们就能在这里看到，Mongodb 乖乖的躺在这了。因为 Mongodb 会默认读取 `/data/db` 目录下的数据库，所以方便省事，我们把默认的数据库就创建在这个位置，并且给 `/data` 执行权限，执行以下命令即可。\n\n```bash\nsudo mkdir -p /data/db         # sudo 表示以管理员权限运行，-p 表示创建多层目录\nsudo chown -R  UserName /data  # UserName 表示你当前的系统用户名\n```\n安装成功后，就可以在 Mongodb 的安装目录下 找到 `bin` 目录了，这里面放着所有需要用到的命令。\n```bash\ncd /usr/local/Cellar/mongodb/3.4.0/bin\n./mongod   # 执行 Mongodb 进程后，浏览器打开 http://127.0.0.1:27017/\n```\n浏览器显示下面的内容，就表示安装成功啦。\n```text\nIt looks like you are trying to access MongoDB over HTTP on the native driver port.\n```\n接下来打开终端，执行下面的命令，验证我们确实安装成功了。在 Mongodb 的控制台中，可以执行很多命令来操作数据库。\n```bash\ncd /usr/local/Cellar/mongodb/3.4.0/bin\n./mongo\n\n# 进入 MongoDB shell 后，光标会变成下面过的状态，执行 show dbs 后，显示如下则大功告成！\n> show dbs\nadmin  0.000GB\nlocal  0.000GB\n```\n接下来，为了方便下次执行 Mongodb ，我们把 `bin` 目录放到环境变量中，这样下次直接在终端输入 `mongod` 即可启用服务，输入命令 `mongo` 即可进入 shell 控制台。\n\n```bash\n# 添加环境变量，语法：echo \"export PATH=xxxxxx:$PATH\" >> ~/.bash_profile\necho 'export PATH=/usr/local/Cellar/mongodb/3.4.0/bin:$PATH'>>~/.bash_profile\n```\n### Mongodb 使用\n使用之前，在明白几个概念，相比关系型数据库，非关系数据库采用了 ***数据库***、***集合***、***文档***、的概念。其实对比 SQL 数据库，就很容易理解，集合就好比是一张表，文档好比就是一整行数据。库的概念是一致的。就这点区别。在终端输入 `mongo` 进入shell 控制台。\n```bash\nmongo\n```\n#### 基础命令\n新增数据\n- 显示数据库：`show dbs`\n- 使用/创建数据库：`use 数据库名`\n- 显示集合：`show collections`\n- 保存数据：`db.collection.save({\"key\":\"value\",\"key2\":\"value2\"})`\n- 插入数据：`db.collection.insert({\"key\":\"value\",\"key2\":\"value2\"})`\n\n<div class=\"tip\">\n若新增的数据主键已经存在，insert()会不做操作并提示错误，而save()则更改原来的内容为新内容。\n</div>\n\n删除数据\n- 删除所有文档：`db.collection.remove({})`\n- 删除指定文档：`db.collection.remove({\"key\":\"value\"})`\n- 删除集合：`db.collection.drop()` 或者 `db.runCommand({\"drop\":\"collection\"})`\n- 删除数据库：`db.runCommand({\"dropDatabase\": 1})` 注意：1没有引号\n\n查找数据\n- 查找所有数据： `db.collection.find({})`\n- 查到单条数据：`db.collection.findOne({})`\n- 条件查找：`db.collection.find({\"key\":\"value\"})`\n- 条件查找 key < value：`db.collection.find({\"key\":{$lt:value}})`\n- 条件查找 key > value：`db.collection.find({\"key\":{$gt:value}})`\n- 条件查找 key >= value：`db.collection.find({\"key\":{$gte:value}})`\n- 范围查找：`db.collection.find({\"key\":{$gt:value1,$lt:value2 } })`\n- 模运算查找：`db.collection.find({\"key\":{$mod:[10,1]}})`\n- 范围在查找：`db.collection.find({\"key\":{$in:[1,2,3]}})`\n- 范围不在在查找：`db.collection.find({\"key\":{$nin:[1,2,3]}})`\n- 数组长度查找：`db.collection.find({\"key\":{$size:1}})` key 必须是数组\n- 字段存在查找：`db.collection.find({\"key\":{$exists:true|false}})`\n- 多条件查找：`db.collection.find({$or:[{a:1},{b:2}]})`\n- 内嵌对象中的值查找：`db.collection.find({\"key.subkey\":value})`\n- 排序：`db.collection.find({}).sort({\"key1\":1,\"key2\":-1})` 1升序 -1降序\n- 对字段建立索引：`db.collection.find({})ensureIndex({\"key\":1})` 1升序 -1降序\n- 范围控制查找：`db.collection.find().skip(5).limit(5)` 跳过5条，读取5条\n- 查询结果集统计：`db.collection.find().count()`\n- 模糊查找：`db.collection.find({\"key\":/ab/})` 正则\n\n\n更改数据\n- `db.collection.update({\"targetKey\":\"targetValue\"},{\"newKey\":\"newVlue\"})`\n\n#### GUI 工具\n![](http://ww1.sinaimg.cn/large/6057861cgw1fbfwwdbu8qj20zq0dbqah.jpg)\n***Robomongo*** 可视化 Mongodb 数据库管理工具 ，点击[这里](https://robomongo.org/download)下载，官方网站：https://robomongo.org/ 。\n\n###  Mongoose 介绍\n[Mongoose](http://mongoosejs.com/) 简而言之就是在 Node 环境中操作 MongoDB 数据库的一种对象模型工具，Mongoose 将数据库中的数据转换为 JavaScript 对象供开发人员使用。\n\n#### 配置\n安装 Mongoose\n```bash\nnpm install mongoose --save\n```\n引入到项目文件中并创建链接\n```js\n// app.js\nvar mongoose = require('mongoose');\nmongoose.connect('mongodb://localhost/my_database');\n```\n\n#### 新增数据\n```js\n// 引入模块\nvar mongoose = require('mongoose');\n// 连接数据库\nvar db = mongoose.createConnection('mongodb://127.0.0.1:27017/test');\n// 设置数据类型\nvar monSchema = new mongooose.Schema({\n    name:{type:String,default:\"username\"},\n    age：{type:Number},\n    sex:{type:String}\n});\n// 选择集合\nvar monModel = db.model('user',monSchema);\n// 数据集\nvar content = {name:\"Nick\",age:23,sex:'男'};\n// 实例化对象并插入数据\nvar monInsert = new monModel(content);\nmonInsert.save(function(err){\n  if(err){\n    console.log(err);\n  }else{\n    console.log('成功插入数据');\n  }\n  db.close();\n});\n```\n#### 删除数据\n```js\n// 引入模块\nvar mongoose = require('mongoose');\n// 连接数据库\nvar db = mongoose.createConnection('mongodb://127.0.0.1:27017/test');\n// cosole.log(db);\n// 设置数据类型\nvar monSchema = new mongooose.Schema({\n    name:{type:String,default:\"name\"},\n    age：{type:Number},\n    sex:{type:String}\n});\n// 选择集合\nvar monModel = db.model('user',monSchema);\n// 原数据字段值\nvar oldValue  = {name:\"Nick\"};\n// 单条件更新\nvar newData1 = {$set:{name:\"内容\"}};\n// 多条件更新\nvar newData2 = {$set:{name:\"内容\",age:2}};\nmonModel.update(oldValue,newData,function(err,result){\n  if(err){\n    console.log(err);\n  }else{\n    console.log(\"update\");\n  }\n  db.close();\n});\n```\n\n#### 查询数据\n```js\n// 引入模块\nvar mongoose = require('mongoose');\n// 连接数据库\nvar db = mongoose.createConnection('mongodb://127.0.0.1:27017/test');\n// cosole.log(db);\n// 设置数据类型\nvar monSchema = new mongooose.Schema({\n    name:{type:String,default:\"name\"},\n    age：{type:Number},\n    sex:{type:String}\n});\n// 选择集合\nvar monModel = db.model('user',monSchema);\nvar content = {name:\"姓名2\"};\nvar field = {name:1,age:1,sex:1};\nmonModel.find(content,field,function(err,result){\n  if(err){\n    console.log(err);\n  }else{\n    console.log(result);\n  }\n  db.close();\n});\n```\n\n\n#### 修改数据\n```js\n// 引入模块\nvar mongoose = require('mongoose');\n// 连接数据库\nvar db = mongoose.createConnection('mongodb://127.0.0.1:27017/test');\n// cosole.log(db);\n// 设置数据类型\nvar monSchema = new mongooose.Schema({\n    name:{type:String,default:\"name\"},\n    age：{type:Number},\n    sex:{type:String}\n});\n// 选择集合\nvar monModel = db.model('user',monSchema);\n// 原数据字段值\nvar oldValue  = {name:\"Nick\"};\n// 单条件更新\nvar newData1 = {$set:{name:\"内容\"}};\n// 多条件更新\nvar newData2 = {$set:{name:\"内容\",age:2}};\nmonModel.update(oldValue,newData,function(err,result){\n  if(err){\n    console.log(err);\n  }else{\n    console.log(\"update\");\n  }\n  db.close();\n});\n```\n","slug":"Mongodb-学习笔记----增删改查","published":1,"updated":"2018-06-17T09:49:30.000Z","layout":"post","photos":[],"link":"","_id":"cjiitidic000au4q9kx3hmnu9","content":"<p>记录 Mongodb 的学习之旅，从环境配置，到基础命令行使用，算是一个简单的入门教程，同时也是学习总结，还有把踩到的坑都记录下来，以后遇到同样的问题不至于在同一个地方继续踩坑。<br><a id=\"more\"></a></p>\n<h3 id=\"Mongodb-介绍\"><a href=\"#Mongodb-介绍\" class=\"headerlink\" title=\"Mongodb 介绍\"></a>Mongodb 介绍</h3><blockquote>\n<p>MongoDB是一种文档导向<strong><em>数据库管理系统</em></strong>，由C++撰写而成，旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。2007年10月，MongoDB由10gen团队所发展。2009年2月首度推出。 — <strong><em>维基百科</em></strong></p>\n</blockquote>\n<p>MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。听着很饶，其实就是非关系数据库。那什么又是 <strong><em>关系型数据库</em></strong> 呢？关系型数据库以行和列的形式存储数据，这一系列的行和列被称为表，一组表组成了数据库。表与表之间的数据记录有关系。</p>\n<h3 id=\"Mongodb-安装\"><a href=\"#Mongodb-安装\" class=\"headerlink\" title=\"Mongodb 安装\"></a>Mongodb 安装</h3><p>本人的操作系统是：MacOS，且已经安装了 <a href=\"http://brew.sh/index_zh-cn.html\" target=\"_blank\" rel=\"noopener\">brew</a> ，所以图省事，我就使用 brew 一键安装了。没用过 brew 的同学可以去<a href=\"http://www.cnblogs.com/TankXiao/p/3247113.html\" target=\"_blank\" rel=\"noopener\">这里看看</a>，用起来还是挺方便的。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install mongodb</span><br></pre></td></tr></table></figure>\n<p>安装速度取决于你的网络情况，这里稍等片刻。brew 默认的安装位置在 <code>/usr/local/Cellar/</code> 一会的功夫，我们就能在这里看到，Mongodb 乖乖的躺在这了。因为 Mongodb 会默认读取 <code>/data/db</code> 目录下的数据库，所以方便省事，我们把默认的数据库就创建在这个位置，并且给 <code>/data</code> 执行权限，执行以下命令即可。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo mkdir -p /data/db         <span class=\"comment\"># sudo 表示以管理员权限运行，-p 表示创建多层目录</span></span><br><span class=\"line\">sudo chown -R  UserName /data  <span class=\"comment\"># UserName 表示你当前的系统用户名</span></span><br></pre></td></tr></table></figure>\n<p>安装成功后，就可以在 Mongodb 的安装目录下 找到 <code>bin</code> 目录了，这里面放着所有需要用到的命令。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/Cellar/mongodb/3.4.0/bin</span><br><span class=\"line\">./mongod   <span class=\"comment\"># 执行 Mongodb 进程后，浏览器打开 http://127.0.0.1:27017/</span></span><br></pre></td></tr></table></figure></p>\n<p>浏览器显示下面的内容，就表示安装成功啦。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">It looks like you are trying to access MongoDB over HTTP on the native driver port.</span><br></pre></td></tr></table></figure></p>\n<p>接下来打开终端，执行下面的命令，验证我们确实安装成功了。在 Mongodb 的控制台中，可以执行很多命令来操作数据库。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/Cellar/mongodb/3.4.0/bin</span><br><span class=\"line\">./mongo</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 进入 MongoDB shell 后，光标会变成下面过的状态，执行 show dbs 后，显示如下则大功告成！</span></span><br><span class=\"line\">&gt; show dbs</span><br><span class=\"line\">admin  0.000GB</span><br><span class=\"line\"><span class=\"built_in\">local</span>  0.000GB</span><br></pre></td></tr></table></figure></p>\n<p>接下来，为了方便下次执行 Mongodb ，我们把 <code>bin</code> 目录放到环境变量中，这样下次直接在终端输入 <code>mongod</code> 即可启用服务，输入命令 <code>mongo</code> 即可进入 shell 控制台。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 添加环境变量，语法：echo \"export PATH=xxxxxx:$PATH\" &gt;&gt; ~/.bash_profile</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">'export PATH=/usr/local/Cellar/mongodb/3.4.0/bin:$PATH'</span>&gt;&gt;~/.bash_profile</span><br></pre></td></tr></table></figure>\n<h3 id=\"Mongodb-使用\"><a href=\"#Mongodb-使用\" class=\"headerlink\" title=\"Mongodb 使用\"></a>Mongodb 使用</h3><p>使用之前，在明白几个概念，相比关系型数据库，非关系数据库采用了 <strong><em>数据库</em></strong>、<strong><em>集合</em></strong>、<strong><em>文档</em></strong>、的概念。其实对比 SQL 数据库，就很容易理解，集合就好比是一张表，文档好比就是一整行数据。库的概念是一致的。就这点区别。在终端输入 <code>mongo</code> 进入shell 控制台。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mongo</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"基础命令\"><a href=\"#基础命令\" class=\"headerlink\" title=\"基础命令\"></a>基础命令</h4><p>新增数据</p>\n<ul>\n<li>显示数据库：<code>show dbs</code></li>\n<li>使用/创建数据库：<code>use 数据库名</code></li>\n<li>显示集合：<code>show collections</code></li>\n<li>保存数据：<code>db.collection.save({&quot;key&quot;:&quot;value&quot;,&quot;key2&quot;:&quot;value2&quot;})</code></li>\n<li>插入数据：<code>db.collection.insert({&quot;key&quot;:&quot;value&quot;,&quot;key2&quot;:&quot;value2&quot;})</code></li>\n</ul>\n<div class=\"tip\"><br>若新增的数据主键已经存在，insert()会不做操作并提示错误，而save()则更改原来的内容为新内容。<br></div>\n\n<p>删除数据</p>\n<ul>\n<li>删除所有文档：<code>db.collection.remove({})</code></li>\n<li>删除指定文档：<code>db.collection.remove({&quot;key&quot;:&quot;value&quot;})</code></li>\n<li>删除集合：<code>db.collection.drop()</code> 或者 <code>db.runCommand({&quot;drop&quot;:&quot;collection&quot;})</code></li>\n<li>删除数据库：<code>db.runCommand({&quot;dropDatabase&quot;: 1})</code> 注意：1没有引号</li>\n</ul>\n<p>查找数据</p>\n<ul>\n<li>查找所有数据： <code>db.collection.find({})</code></li>\n<li>查到单条数据：<code>db.collection.findOne({})</code></li>\n<li>条件查找：<code>db.collection.find({&quot;key&quot;:&quot;value&quot;})</code></li>\n<li>条件查找 key &lt; value：<code>db.collection.find({&quot;key&quot;:{$lt:value}})</code></li>\n<li>条件查找 key &gt; value：<code>db.collection.find({&quot;key&quot;:{$gt:value}})</code></li>\n<li>条件查找 key &gt;= value：<code>db.collection.find({&quot;key&quot;:{$gte:value}})</code></li>\n<li>范围查找：<code>db.collection.find({&quot;key&quot;:{$gt:value1,$lt:value2 } })</code></li>\n<li>模运算查找：<code>db.collection.find({&quot;key&quot;:{$mod:[10,1]}})</code></li>\n<li>范围在查找：<code>db.collection.find({&quot;key&quot;:{$in:[1,2,3]}})</code></li>\n<li>范围不在在查找：<code>db.collection.find({&quot;key&quot;:{$nin:[1,2,3]}})</code></li>\n<li>数组长度查找：<code>db.collection.find({&quot;key&quot;:{$size:1}})</code> key 必须是数组</li>\n<li>字段存在查找：<code>db.collection.find({&quot;key&quot;:{$exists:true|false}})</code></li>\n<li>多条件查找：<code>db.collection.find({$or:[{a:1},{b:2}]})</code></li>\n<li>内嵌对象中的值查找：<code>db.collection.find({&quot;key.subkey&quot;:value})</code></li>\n<li>排序：<code>db.collection.find({}).sort({&quot;key1&quot;:1,&quot;key2&quot;:-1})</code> 1升序 -1降序</li>\n<li>对字段建立索引：<code>db.collection.find({})ensureIndex({&quot;key&quot;:1})</code> 1升序 -1降序</li>\n<li>范围控制查找：<code>db.collection.find().skip(5).limit(5)</code> 跳过5条，读取5条</li>\n<li>查询结果集统计：<code>db.collection.find().count()</code></li>\n<li>模糊查找：<code>db.collection.find({&quot;key&quot;:/ab/})</code> 正则</li>\n</ul>\n<p>更改数据</p>\n<ul>\n<li><code>db.collection.update({&quot;targetKey&quot;:&quot;targetValue&quot;},{&quot;newKey&quot;:&quot;newVlue&quot;})</code></li>\n</ul>\n<h4 id=\"GUI-工具\"><a href=\"#GUI-工具\" class=\"headerlink\" title=\"GUI 工具\"></a>GUI 工具</h4><p><img src=\"http://ww1.sinaimg.cn/large/6057861cgw1fbfwwdbu8qj20zq0dbqah.jpg\" alt=\"\"><br><strong><em>Robomongo</em></strong> 可视化 Mongodb 数据库管理工具 ，点击<a href=\"https://robomongo.org/download\" target=\"_blank\" rel=\"noopener\">这里</a>下载，官方网站：<a href=\"https://robomongo.org/\" target=\"_blank\" rel=\"noopener\">https://robomongo.org/</a> 。</p>\n<h3 id=\"Mongoose-介绍\"><a href=\"#Mongoose-介绍\" class=\"headerlink\" title=\"Mongoose 介绍\"></a>Mongoose 介绍</h3><p><a href=\"http://mongoosejs.com/\" target=\"_blank\" rel=\"noopener\">Mongoose</a> 简而言之就是在 Node 环境中操作 MongoDB 数据库的一种对象模型工具，Mongoose 将数据库中的数据转换为 JavaScript 对象供开发人员使用。</p>\n<h4 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h4><p>安装 Mongoose<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install mongoose --save</span><br></pre></td></tr></table></figure></p>\n<p>引入到项目文件中并创建链接<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// app.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> mongoose = <span class=\"built_in\">require</span>(<span class=\"string\">'mongoose'</span>);</span><br><span class=\"line\">mongoose.connect(<span class=\"string\">'mongodb://localhost/my_database'</span>);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"新增数据\"><a href=\"#新增数据\" class=\"headerlink\" title=\"新增数据\"></a>新增数据</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引入模块</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> mongoose = <span class=\"built_in\">require</span>(<span class=\"string\">'mongoose'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 连接数据库</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> db = mongoose.createConnection(<span class=\"string\">'mongodb://127.0.0.1:27017/test'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 设置数据类型</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> monSchema = <span class=\"keyword\">new</span> mongooose.Schema(&#123;</span><br><span class=\"line\">    name:&#123;<span class=\"attr\">type</span>:<span class=\"built_in\">String</span>,<span class=\"attr\">default</span>:<span class=\"string\">\"username\"</span>&#125;,</span><br><span class=\"line\">    age：&#123;<span class=\"attr\">type</span>:<span class=\"built_in\">Number</span>&#125;,</span><br><span class=\"line\">    sex:&#123;<span class=\"attr\">type</span>:<span class=\"built_in\">String</span>&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 选择集合</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> monModel = db.model(<span class=\"string\">'user'</span>,monSchema);</span><br><span class=\"line\"><span class=\"comment\">// 数据集</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> content = &#123;<span class=\"attr\">name</span>:<span class=\"string\">\"Nick\"</span>,<span class=\"attr\">age</span>:<span class=\"number\">23</span>,<span class=\"attr\">sex</span>:<span class=\"string\">'男'</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 实例化对象并插入数据</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> monInsert = <span class=\"keyword\">new</span> monModel(content);</span><br><span class=\"line\">monInsert.save(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(err)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'成功插入数据'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  db.close();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"删除数据\"><a href=\"#删除数据\" class=\"headerlink\" title=\"删除数据\"></a>删除数据</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引入模块</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> mongoose = <span class=\"built_in\">require</span>(<span class=\"string\">'mongoose'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 连接数据库</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> db = mongoose.createConnection(<span class=\"string\">'mongodb://127.0.0.1:27017/test'</span>);</span><br><span class=\"line\"><span class=\"comment\">// cosole.log(db);</span></span><br><span class=\"line\"><span class=\"comment\">// 设置数据类型</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> monSchema = <span class=\"keyword\">new</span> mongooose.Schema(&#123;</span><br><span class=\"line\">    name:&#123;<span class=\"attr\">type</span>:<span class=\"built_in\">String</span>,<span class=\"attr\">default</span>:<span class=\"string\">\"name\"</span>&#125;,</span><br><span class=\"line\">    age：&#123;<span class=\"attr\">type</span>:<span class=\"built_in\">Number</span>&#125;,</span><br><span class=\"line\">    sex:&#123;<span class=\"attr\">type</span>:<span class=\"built_in\">String</span>&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 选择集合</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> monModel = db.model(<span class=\"string\">'user'</span>,monSchema);</span><br><span class=\"line\"><span class=\"comment\">// 原数据字段值</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> oldValue  = &#123;<span class=\"attr\">name</span>:<span class=\"string\">\"Nick\"</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 单条件更新</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> newData1 = &#123;<span class=\"attr\">$set</span>:&#123;<span class=\"attr\">name</span>:<span class=\"string\">\"内容\"</span>&#125;&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 多条件更新</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> newData2 = &#123;<span class=\"attr\">$set</span>:&#123;<span class=\"attr\">name</span>:<span class=\"string\">\"内容\"</span>,<span class=\"attr\">age</span>:<span class=\"number\">2</span>&#125;&#125;;</span><br><span class=\"line\">monModel.update(oldValue,newData,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err,result</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(err)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"update\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  db.close();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"查询数据\"><a href=\"#查询数据\" class=\"headerlink\" title=\"查询数据\"></a>查询数据</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引入模块</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> mongoose = <span class=\"built_in\">require</span>(<span class=\"string\">'mongoose'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 连接数据库</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> db = mongoose.createConnection(<span class=\"string\">'mongodb://127.0.0.1:27017/test'</span>);</span><br><span class=\"line\"><span class=\"comment\">// cosole.log(db);</span></span><br><span class=\"line\"><span class=\"comment\">// 设置数据类型</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> monSchema = <span class=\"keyword\">new</span> mongooose.Schema(&#123;</span><br><span class=\"line\">    name:&#123;<span class=\"attr\">type</span>:<span class=\"built_in\">String</span>,<span class=\"attr\">default</span>:<span class=\"string\">\"name\"</span>&#125;,</span><br><span class=\"line\">    age：&#123;<span class=\"attr\">type</span>:<span class=\"built_in\">Number</span>&#125;,</span><br><span class=\"line\">    sex:&#123;<span class=\"attr\">type</span>:<span class=\"built_in\">String</span>&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 选择集合</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> monModel = db.model(<span class=\"string\">'user'</span>,monSchema);</span><br><span class=\"line\"><span class=\"keyword\">var</span> content = &#123;<span class=\"attr\">name</span>:<span class=\"string\">\"姓名2\"</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> field = &#123;<span class=\"attr\">name</span>:<span class=\"number\">1</span>,<span class=\"attr\">age</span>:<span class=\"number\">1</span>,<span class=\"attr\">sex</span>:<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">monModel.find(content,field,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err,result</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(err)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(result);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  db.close();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"修改数据\"><a href=\"#修改数据\" class=\"headerlink\" title=\"修改数据\"></a>修改数据</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引入模块</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> mongoose = <span class=\"built_in\">require</span>(<span class=\"string\">'mongoose'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 连接数据库</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> db = mongoose.createConnection(<span class=\"string\">'mongodb://127.0.0.1:27017/test'</span>);</span><br><span class=\"line\"><span class=\"comment\">// cosole.log(db);</span></span><br><span class=\"line\"><span class=\"comment\">// 设置数据类型</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> monSchema = <span class=\"keyword\">new</span> mongooose.Schema(&#123;</span><br><span class=\"line\">    name:&#123;<span class=\"attr\">type</span>:<span class=\"built_in\">String</span>,<span class=\"attr\">default</span>:<span class=\"string\">\"name\"</span>&#125;,</span><br><span class=\"line\">    age：&#123;<span class=\"attr\">type</span>:<span class=\"built_in\">Number</span>&#125;,</span><br><span class=\"line\">    sex:&#123;<span class=\"attr\">type</span>:<span class=\"built_in\">String</span>&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 选择集合</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> monModel = db.model(<span class=\"string\">'user'</span>,monSchema);</span><br><span class=\"line\"><span class=\"comment\">// 原数据字段值</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> oldValue  = &#123;<span class=\"attr\">name</span>:<span class=\"string\">\"Nick\"</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 单条件更新</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> newData1 = &#123;<span class=\"attr\">$set</span>:&#123;<span class=\"attr\">name</span>:<span class=\"string\">\"内容\"</span>&#125;&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 多条件更新</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> newData2 = &#123;<span class=\"attr\">$set</span>:&#123;<span class=\"attr\">name</span>:<span class=\"string\">\"内容\"</span>,<span class=\"attr\">age</span>:<span class=\"number\">2</span>&#125;&#125;;</span><br><span class=\"line\">monModel.update(oldValue,newData,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err,result</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(err)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"update\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  db.close();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>记录 Mongodb 的学习之旅，从环境配置，到基础命令行使用，算是一个简单的入门教程，同时也是学习总结，还有把踩到的坑都记录下来，以后遇到同样的问题不至于在同一个地方继续踩坑。<br>","more":"</p>\n<h3 id=\"Mongodb-介绍\"><a href=\"#Mongodb-介绍\" class=\"headerlink\" title=\"Mongodb 介绍\"></a>Mongodb 介绍</h3><blockquote>\n<p>MongoDB是一种文档导向<strong><em>数据库管理系统</em></strong>，由C++撰写而成，旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。2007年10月，MongoDB由10gen团队所发展。2009年2月首度推出。 — <strong><em>维基百科</em></strong></p>\n</blockquote>\n<p>MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。听着很饶，其实就是非关系数据库。那什么又是 <strong><em>关系型数据库</em></strong> 呢？关系型数据库以行和列的形式存储数据，这一系列的行和列被称为表，一组表组成了数据库。表与表之间的数据记录有关系。</p>\n<h3 id=\"Mongodb-安装\"><a href=\"#Mongodb-安装\" class=\"headerlink\" title=\"Mongodb 安装\"></a>Mongodb 安装</h3><p>本人的操作系统是：MacOS，且已经安装了 <a href=\"http://brew.sh/index_zh-cn.html\" target=\"_blank\" rel=\"noopener\">brew</a> ，所以图省事，我就使用 brew 一键安装了。没用过 brew 的同学可以去<a href=\"http://www.cnblogs.com/TankXiao/p/3247113.html\" target=\"_blank\" rel=\"noopener\">这里看看</a>，用起来还是挺方便的。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install mongodb</span><br></pre></td></tr></table></figure>\n<p>安装速度取决于你的网络情况，这里稍等片刻。brew 默认的安装位置在 <code>/usr/local/Cellar/</code> 一会的功夫，我们就能在这里看到，Mongodb 乖乖的躺在这了。因为 Mongodb 会默认读取 <code>/data/db</code> 目录下的数据库，所以方便省事，我们把默认的数据库就创建在这个位置，并且给 <code>/data</code> 执行权限，执行以下命令即可。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo mkdir -p /data/db         <span class=\"comment\"># sudo 表示以管理员权限运行，-p 表示创建多层目录</span></span><br><span class=\"line\">sudo chown -R  UserName /data  <span class=\"comment\"># UserName 表示你当前的系统用户名</span></span><br></pre></td></tr></table></figure>\n<p>安装成功后，就可以在 Mongodb 的安装目录下 找到 <code>bin</code> 目录了，这里面放着所有需要用到的命令。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/Cellar/mongodb/3.4.0/bin</span><br><span class=\"line\">./mongod   <span class=\"comment\"># 执行 Mongodb 进程后，浏览器打开 http://127.0.0.1:27017/</span></span><br></pre></td></tr></table></figure></p>\n<p>浏览器显示下面的内容，就表示安装成功啦。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">It looks like you are trying to access MongoDB over HTTP on the native driver port.</span><br></pre></td></tr></table></figure></p>\n<p>接下来打开终端，执行下面的命令，验证我们确实安装成功了。在 Mongodb 的控制台中，可以执行很多命令来操作数据库。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/Cellar/mongodb/3.4.0/bin</span><br><span class=\"line\">./mongo</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 进入 MongoDB shell 后，光标会变成下面过的状态，执行 show dbs 后，显示如下则大功告成！</span></span><br><span class=\"line\">&gt; show dbs</span><br><span class=\"line\">admin  0.000GB</span><br><span class=\"line\"><span class=\"built_in\">local</span>  0.000GB</span><br></pre></td></tr></table></figure></p>\n<p>接下来，为了方便下次执行 Mongodb ，我们把 <code>bin</code> 目录放到环境变量中，这样下次直接在终端输入 <code>mongod</code> 即可启用服务，输入命令 <code>mongo</code> 即可进入 shell 控制台。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 添加环境变量，语法：echo \"export PATH=xxxxxx:$PATH\" &gt;&gt; ~/.bash_profile</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">'export PATH=/usr/local/Cellar/mongodb/3.4.0/bin:$PATH'</span>&gt;&gt;~/.bash_profile</span><br></pre></td></tr></table></figure>\n<h3 id=\"Mongodb-使用\"><a href=\"#Mongodb-使用\" class=\"headerlink\" title=\"Mongodb 使用\"></a>Mongodb 使用</h3><p>使用之前，在明白几个概念，相比关系型数据库，非关系数据库采用了 <strong><em>数据库</em></strong>、<strong><em>集合</em></strong>、<strong><em>文档</em></strong>、的概念。其实对比 SQL 数据库，就很容易理解，集合就好比是一张表，文档好比就是一整行数据。库的概念是一致的。就这点区别。在终端输入 <code>mongo</code> 进入shell 控制台。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mongo</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"基础命令\"><a href=\"#基础命令\" class=\"headerlink\" title=\"基础命令\"></a>基础命令</h4><p>新增数据</p>\n<ul>\n<li>显示数据库：<code>show dbs</code></li>\n<li>使用/创建数据库：<code>use 数据库名</code></li>\n<li>显示集合：<code>show collections</code></li>\n<li>保存数据：<code>db.collection.save({&quot;key&quot;:&quot;value&quot;,&quot;key2&quot;:&quot;value2&quot;})</code></li>\n<li>插入数据：<code>db.collection.insert({&quot;key&quot;:&quot;value&quot;,&quot;key2&quot;:&quot;value2&quot;})</code></li>\n</ul>\n<div class=\"tip\"><br>若新增的数据主键已经存在，insert()会不做操作并提示错误，而save()则更改原来的内容为新内容。<br></div>\n\n<p>删除数据</p>\n<ul>\n<li>删除所有文档：<code>db.collection.remove({})</code></li>\n<li>删除指定文档：<code>db.collection.remove({&quot;key&quot;:&quot;value&quot;})</code></li>\n<li>删除集合：<code>db.collection.drop()</code> 或者 <code>db.runCommand({&quot;drop&quot;:&quot;collection&quot;})</code></li>\n<li>删除数据库：<code>db.runCommand({&quot;dropDatabase&quot;: 1})</code> 注意：1没有引号</li>\n</ul>\n<p>查找数据</p>\n<ul>\n<li>查找所有数据： <code>db.collection.find({})</code></li>\n<li>查到单条数据：<code>db.collection.findOne({})</code></li>\n<li>条件查找：<code>db.collection.find({&quot;key&quot;:&quot;value&quot;})</code></li>\n<li>条件查找 key &lt; value：<code>db.collection.find({&quot;key&quot;:{$lt:value}})</code></li>\n<li>条件查找 key &gt; value：<code>db.collection.find({&quot;key&quot;:{$gt:value}})</code></li>\n<li>条件查找 key &gt;= value：<code>db.collection.find({&quot;key&quot;:{$gte:value}})</code></li>\n<li>范围查找：<code>db.collection.find({&quot;key&quot;:{$gt:value1,$lt:value2 } })</code></li>\n<li>模运算查找：<code>db.collection.find({&quot;key&quot;:{$mod:[10,1]}})</code></li>\n<li>范围在查找：<code>db.collection.find({&quot;key&quot;:{$in:[1,2,3]}})</code></li>\n<li>范围不在在查找：<code>db.collection.find({&quot;key&quot;:{$nin:[1,2,3]}})</code></li>\n<li>数组长度查找：<code>db.collection.find({&quot;key&quot;:{$size:1}})</code> key 必须是数组</li>\n<li>字段存在查找：<code>db.collection.find({&quot;key&quot;:{$exists:true|false}})</code></li>\n<li>多条件查找：<code>db.collection.find({$or:[{a:1},{b:2}]})</code></li>\n<li>内嵌对象中的值查找：<code>db.collection.find({&quot;key.subkey&quot;:value})</code></li>\n<li>排序：<code>db.collection.find({}).sort({&quot;key1&quot;:1,&quot;key2&quot;:-1})</code> 1升序 -1降序</li>\n<li>对字段建立索引：<code>db.collection.find({})ensureIndex({&quot;key&quot;:1})</code> 1升序 -1降序</li>\n<li>范围控制查找：<code>db.collection.find().skip(5).limit(5)</code> 跳过5条，读取5条</li>\n<li>查询结果集统计：<code>db.collection.find().count()</code></li>\n<li>模糊查找：<code>db.collection.find({&quot;key&quot;:/ab/})</code> 正则</li>\n</ul>\n<p>更改数据</p>\n<ul>\n<li><code>db.collection.update({&quot;targetKey&quot;:&quot;targetValue&quot;},{&quot;newKey&quot;:&quot;newVlue&quot;})</code></li>\n</ul>\n<h4 id=\"GUI-工具\"><a href=\"#GUI-工具\" class=\"headerlink\" title=\"GUI 工具\"></a>GUI 工具</h4><p><img src=\"http://ww1.sinaimg.cn/large/6057861cgw1fbfwwdbu8qj20zq0dbqah.jpg\" alt=\"\"><br><strong><em>Robomongo</em></strong> 可视化 Mongodb 数据库管理工具 ，点击<a href=\"https://robomongo.org/download\" target=\"_blank\" rel=\"noopener\">这里</a>下载，官方网站：<a href=\"https://robomongo.org/\" target=\"_blank\" rel=\"noopener\">https://robomongo.org/</a> 。</p>\n<h3 id=\"Mongoose-介绍\"><a href=\"#Mongoose-介绍\" class=\"headerlink\" title=\"Mongoose 介绍\"></a>Mongoose 介绍</h3><p><a href=\"http://mongoosejs.com/\" target=\"_blank\" rel=\"noopener\">Mongoose</a> 简而言之就是在 Node 环境中操作 MongoDB 数据库的一种对象模型工具，Mongoose 将数据库中的数据转换为 JavaScript 对象供开发人员使用。</p>\n<h4 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h4><p>安装 Mongoose<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install mongoose --save</span><br></pre></td></tr></table></figure></p>\n<p>引入到项目文件中并创建链接<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// app.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> mongoose = <span class=\"built_in\">require</span>(<span class=\"string\">'mongoose'</span>);</span><br><span class=\"line\">mongoose.connect(<span class=\"string\">'mongodb://localhost/my_database'</span>);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"新增数据\"><a href=\"#新增数据\" class=\"headerlink\" title=\"新增数据\"></a>新增数据</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引入模块</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> mongoose = <span class=\"built_in\">require</span>(<span class=\"string\">'mongoose'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 连接数据库</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> db = mongoose.createConnection(<span class=\"string\">'mongodb://127.0.0.1:27017/test'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 设置数据类型</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> monSchema = <span class=\"keyword\">new</span> mongooose.Schema(&#123;</span><br><span class=\"line\">    name:&#123;<span class=\"attr\">type</span>:<span class=\"built_in\">String</span>,<span class=\"attr\">default</span>:<span class=\"string\">\"username\"</span>&#125;,</span><br><span class=\"line\">    age：&#123;<span class=\"attr\">type</span>:<span class=\"built_in\">Number</span>&#125;,</span><br><span class=\"line\">    sex:&#123;<span class=\"attr\">type</span>:<span class=\"built_in\">String</span>&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 选择集合</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> monModel = db.model(<span class=\"string\">'user'</span>,monSchema);</span><br><span class=\"line\"><span class=\"comment\">// 数据集</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> content = &#123;<span class=\"attr\">name</span>:<span class=\"string\">\"Nick\"</span>,<span class=\"attr\">age</span>:<span class=\"number\">23</span>,<span class=\"attr\">sex</span>:<span class=\"string\">'男'</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 实例化对象并插入数据</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> monInsert = <span class=\"keyword\">new</span> monModel(content);</span><br><span class=\"line\">monInsert.save(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(err)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'成功插入数据'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  db.close();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"删除数据\"><a href=\"#删除数据\" class=\"headerlink\" title=\"删除数据\"></a>删除数据</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引入模块</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> mongoose = <span class=\"built_in\">require</span>(<span class=\"string\">'mongoose'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 连接数据库</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> db = mongoose.createConnection(<span class=\"string\">'mongodb://127.0.0.1:27017/test'</span>);</span><br><span class=\"line\"><span class=\"comment\">// cosole.log(db);</span></span><br><span class=\"line\"><span class=\"comment\">// 设置数据类型</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> monSchema = <span class=\"keyword\">new</span> mongooose.Schema(&#123;</span><br><span class=\"line\">    name:&#123;<span class=\"attr\">type</span>:<span class=\"built_in\">String</span>,<span class=\"attr\">default</span>:<span class=\"string\">\"name\"</span>&#125;,</span><br><span class=\"line\">    age：&#123;<span class=\"attr\">type</span>:<span class=\"built_in\">Number</span>&#125;,</span><br><span class=\"line\">    sex:&#123;<span class=\"attr\">type</span>:<span class=\"built_in\">String</span>&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 选择集合</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> monModel = db.model(<span class=\"string\">'user'</span>,monSchema);</span><br><span class=\"line\"><span class=\"comment\">// 原数据字段值</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> oldValue  = &#123;<span class=\"attr\">name</span>:<span class=\"string\">\"Nick\"</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 单条件更新</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> newData1 = &#123;<span class=\"attr\">$set</span>:&#123;<span class=\"attr\">name</span>:<span class=\"string\">\"内容\"</span>&#125;&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 多条件更新</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> newData2 = &#123;<span class=\"attr\">$set</span>:&#123;<span class=\"attr\">name</span>:<span class=\"string\">\"内容\"</span>,<span class=\"attr\">age</span>:<span class=\"number\">2</span>&#125;&#125;;</span><br><span class=\"line\">monModel.update(oldValue,newData,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err,result</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(err)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"update\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  db.close();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"查询数据\"><a href=\"#查询数据\" class=\"headerlink\" title=\"查询数据\"></a>查询数据</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引入模块</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> mongoose = <span class=\"built_in\">require</span>(<span class=\"string\">'mongoose'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 连接数据库</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> db = mongoose.createConnection(<span class=\"string\">'mongodb://127.0.0.1:27017/test'</span>);</span><br><span class=\"line\"><span class=\"comment\">// cosole.log(db);</span></span><br><span class=\"line\"><span class=\"comment\">// 设置数据类型</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> monSchema = <span class=\"keyword\">new</span> mongooose.Schema(&#123;</span><br><span class=\"line\">    name:&#123;<span class=\"attr\">type</span>:<span class=\"built_in\">String</span>,<span class=\"attr\">default</span>:<span class=\"string\">\"name\"</span>&#125;,</span><br><span class=\"line\">    age：&#123;<span class=\"attr\">type</span>:<span class=\"built_in\">Number</span>&#125;,</span><br><span class=\"line\">    sex:&#123;<span class=\"attr\">type</span>:<span class=\"built_in\">String</span>&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 选择集合</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> monModel = db.model(<span class=\"string\">'user'</span>,monSchema);</span><br><span class=\"line\"><span class=\"keyword\">var</span> content = &#123;<span class=\"attr\">name</span>:<span class=\"string\">\"姓名2\"</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> field = &#123;<span class=\"attr\">name</span>:<span class=\"number\">1</span>,<span class=\"attr\">age</span>:<span class=\"number\">1</span>,<span class=\"attr\">sex</span>:<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">monModel.find(content,field,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err,result</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(err)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(result);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  db.close();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"修改数据\"><a href=\"#修改数据\" class=\"headerlink\" title=\"修改数据\"></a>修改数据</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引入模块</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> mongoose = <span class=\"built_in\">require</span>(<span class=\"string\">'mongoose'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 连接数据库</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> db = mongoose.createConnection(<span class=\"string\">'mongodb://127.0.0.1:27017/test'</span>);</span><br><span class=\"line\"><span class=\"comment\">// cosole.log(db);</span></span><br><span class=\"line\"><span class=\"comment\">// 设置数据类型</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> monSchema = <span class=\"keyword\">new</span> mongooose.Schema(&#123;</span><br><span class=\"line\">    name:&#123;<span class=\"attr\">type</span>:<span class=\"built_in\">String</span>,<span class=\"attr\">default</span>:<span class=\"string\">\"name\"</span>&#125;,</span><br><span class=\"line\">    age：&#123;<span class=\"attr\">type</span>:<span class=\"built_in\">Number</span>&#125;,</span><br><span class=\"line\">    sex:&#123;<span class=\"attr\">type</span>:<span class=\"built_in\">String</span>&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 选择集合</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> monModel = db.model(<span class=\"string\">'user'</span>,monSchema);</span><br><span class=\"line\"><span class=\"comment\">// 原数据字段值</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> oldValue  = &#123;<span class=\"attr\">name</span>:<span class=\"string\">\"Nick\"</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 单条件更新</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> newData1 = &#123;<span class=\"attr\">$set</span>:&#123;<span class=\"attr\">name</span>:<span class=\"string\">\"内容\"</span>&#125;&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 多条件更新</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> newData2 = &#123;<span class=\"attr\">$set</span>:&#123;<span class=\"attr\">name</span>:<span class=\"string\">\"内容\"</span>,<span class=\"attr\">age</span>:<span class=\"number\">2</span>&#125;&#125;;</span><br><span class=\"line\">monModel.update(oldValue,newData,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err,result</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(err)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"update\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  db.close();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>"},{"title":"Node.JS 学习笔记 [02] -- 同步异步","date":"2015-01-03T00:27:02.000Z","comments":0,"_content":"\n在使用 npm 的时候，我发现在速度实在太慢，安装小一点的包确实没啥问题，装大一点的，依赖多一点的包的时候，问题就来了。速度慢，响应迟钝。***nrm*** 是一个非常好的解决方案，安装 nrm 后，可以使用简单的命令快速来切换 npm 源，比如切换到 cnpm、taobao 源等，详细的使用方法可以点[这里](https://github.com/Pana/nrm#install)进去了解下。\n<!-- more -->\n### Node.js 使用\n\n#### Node.js 控制台\n前面说了，Node.js 提供了 REPL 模式来解析输入的每条命令，现在可以实战一下了，打开终端，然后输入 `node` 进入 Node.js 开始敲命令吧！\n```js\nconsole.log('hello,world!'); // 普通输入\nconsole.error('错误消息');    // 错误输出\nconsole.time('time');        // 会计算在这个表达式之间的代码块执行耗时\n// {...}\nconsole.time('time');\nconsole.assert(3>10,'str..');// 断言：表达式不成立，会输出后面的字符串\n```\n\n#### Node.js 作用域\n- 全局作用域：没有使用 `var` 隐式声明的一个变量，会享受全局作用域，或者在 `global` 上挂载的变量，也具有全局作用域的属性，全局变量可以被其它模块使用。\n- 局部作用域：在 Node.js 中一个文件就是一个模块，在这个模块中定义的变量，只能在这个模块中使用。\n\n```js\n// 这些变量都属于全局变量\nname = 'ifyour';\nglobal.age = 18; // Node.js 中的 global 类似 JavaScript 中的 window\n```\n<div class='tip'>\n尽量避免使用全局变量，会造成变量污染。\n</div>\n\n#### 回调函数\nNode.js 中大量使用了回调函数，关于回调函数，我之前在简书写了一篇，我的理解心得，有兴趣的可以[去看看](http://www.jianshu.com/p/1383f4cb9a75)。关于回调函数，我也正是在 Node.js 中对它的理解更为深刻了，Node.js 大量的异步代码都借助回调函数实现，正因如此，性能更高呀。看一个非常简单的例子。\n\n```js\n// 定义回调函数\nfunction cb(){\n  console.log('Hello,callback!');\n}\n\n// 把回调函数的引用（指针）传入该函数，一秒后执行\nsetTimeout(cb,1000);\n```\n借助这个例子，可以看到回调函数的实现机制：\n- 定义一个普通函数（其实它就是回调函数）\n- 将该函数的引用地址作为参数传给调用者，调用者本身也是一个函数，例子中的 `setTimeout`\n- 当特定条件发生时，调用者使用这个引用地址去执行该函数\n\n回调函数的用途很多，比如实现事件注册、异步代码等。在 jQuery 中的动画就是回调函数的经典用法，`animate(x,y,z,function(){...})`,当一个动画执行完成后，执行回调函数。当点击一个按钮时，需要执行的函数块，这些都是回调函数。\n\n### Node.js 事件\nNode.js 中的 event 模块就是提供事件编程的 API，所有具有触发事件的对象都继承或内部包含了 `EventEmitter` 对象。来一个简单的例子吧！\n```js\n//events 模块中的 EventEmitter 对象，定义了事件对象的基础信息和行为\nvar EventEmitter = require('events').EventEmitter;\nvar event = new EventEmitter();// 实例化一个 event 对象\nevent.on('myevent',function(name){ // 绑定 myevent 事件\n    console.log('Hi!' + name);\n});\nevent.emit('myevent','ifyour');// 触发事件\n```\n#### 事件常用方法\n\n|方法                               | 描述                                                     |\n|:---------------------------------|:---------------------------------------------------------|\n|addListener(event, listener)      | 为指定事件添加一个监听器到监听器数组的尾部。与on等价          |\n|on(event, listener)               | 为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数 |\n|once(event, listener)             | 为指定事件注册一个单次监听器                                |\n|removeListener(event,listener)    |移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器  |\n|removeAllListeners([event])       |移除所有事件的所有监听器如果指定事件，则移除该事件的所有监听器  |\n|setMaxListeners(n)                |setMaxListeners 函数用于提高监听器的默认限制的数量，默认是 10 |\n|listeners(event)                  |返回指定事件的监听器数组                                    |\n|emit(event, [arg1], [arg2], [...])|按顺序执行监听器，如果事件有注册监听返回 true，否则返回 false |\n\n\n### Node.js 异步与同步\n\n***同步***：一个任务执行完成后，才能执行下一个任务，执行总时间等于所有任务消耗时间之和。\n***异步***：几个任务同时执行，不限制先后，执行总时间等于执行耗时最长的那个任务的消耗时间。\n\n在 Node.js 中每一个任务有一个或多个回调函数，前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。\n\n#### 异步的实现\n- 回调函数\n- 事件（基于回调函数）\n- Promise （ES6）\n\n前面已经讲了回调函数的实现方式，下面举两个例子来说明 Node.js 中 ***事件*** 和 ***Promise*** 实现异步。\n```js\n// 事件（基于回调函数）实现异步\nvar fs = require('fs');\n\nvar stream = fs.createReadStream('./data');// 调用 fs 模块创建一个读取流对象\nstream.on('data',getData);// 读取事件，每次读取时触发调用回调函数 getData\nstream.on('end',getDataDone);// 读取完毕调用回调函数 getDataDone\n\nfunction getDataDone() {\n    console.log('read done!');\n}\nfunction getData(data) {\n    console.log(data.toString());\n}\n```\n上面的代码中，当读取多个 `data` 文件时，输出的内容的顺序可能不一致，因为事件采用回调函数实现了异步操作。可以看出，事件实现异步，本质上还是回调函数。\n\n> 所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。\n\n下面来看看 `Promise` 的一个实例：\n```js\nvar fs = require('fs');\n\nvar p = new Promise(function (resolve, reject) {// 使用 Promise 生成实例\n    fs.readFile('./1', 'utf-8', function (err, data) {// readFile 是一个异步方法\n        if (!err) {\n            resolve(data);\n        } else {\n            reject(err);\n        }\n    })\n});\n\np.then(function (data) {// 调用实例的 then 方法\n    console.log(data);\n}, function (err) {\n    console.log(err);\n});\n```\nES6 规定，Promise 对象是一个构造函数，用来生成 Promise 实例。Promise 构造函数接受一个函数作为参数，该函数的两个参数分别是 `resolve` 和 `reject`。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。\n\n- resolve : 在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；\n- reject  : 在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。\n\nPromise实例生成以后，可以用 `then` 方法分别指定 Resolved 状态和 Reject 状态的回调函数。\n```js\npromise.then(function(value) {\n  // success\n}, function(error) {\n  // failure\n});\n```\n有了 Promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise 对象提供统一的接口，使得控制异步操作更加容易。\n\n下面这个例子，在未使用 `Promise` 时，我们想要 `p1` 读取完数据后，紧接着 `p2` 、`p3` 读取，就需要在 `p1` 的回调读取成功函数里继续写 `p2` 的读取，类似的 `p3` 也要在 `p2` 的回调函数中写，这就造成了 ***层层嵌套*** 不利于代码阅读。而使用 `Promise` 后，`then` 方法把里面的回调函数统一提取出来， 可读性更好了，也方便理解。\n```js\n// Promise 提供的 then 方法避免层次嵌套，相当于实现 then 的链式操作\n// p1 执行完 then 方法后，通过 return p2 ，让 p2 继续执行 then 方法\np1.then(function(data){\n    console.log(data);\n    return p2;\n},function(err){\n    console.log(err);\n    return p2;\n}).then(function(data){\n    console.log(data);\n    return p3;\n},function(err){\n    console.log(err);\n    return p3;\n}).then(function(data){\n    console.log(data);\n},function(){\n    console.log(err);\n});\n```\n更多 Promise 语法，可以参考阮一峰的《[ECMAScript 6 入门](http://es6.ruanyifeng.com/#docs/promise#基本用法)》。\n","source":"_posts/Node.JS-学习笔记-[02]----同步异步.md","raw":"---\ntitle: 'Node.JS 学习笔记 [02] -- 同步异步'\ndate: 2015-1-3 08:27:02\ncomments: false\n---\n\n在使用 npm 的时候，我发现在速度实在太慢，安装小一点的包确实没啥问题，装大一点的，依赖多一点的包的时候，问题就来了。速度慢，响应迟钝。***nrm*** 是一个非常好的解决方案，安装 nrm 后，可以使用简单的命令快速来切换 npm 源，比如切换到 cnpm、taobao 源等，详细的使用方法可以点[这里](https://github.com/Pana/nrm#install)进去了解下。\n<!-- more -->\n### Node.js 使用\n\n#### Node.js 控制台\n前面说了，Node.js 提供了 REPL 模式来解析输入的每条命令，现在可以实战一下了，打开终端，然后输入 `node` 进入 Node.js 开始敲命令吧！\n```js\nconsole.log('hello,world!'); // 普通输入\nconsole.error('错误消息');    // 错误输出\nconsole.time('time');        // 会计算在这个表达式之间的代码块执行耗时\n// {...}\nconsole.time('time');\nconsole.assert(3>10,'str..');// 断言：表达式不成立，会输出后面的字符串\n```\n\n#### Node.js 作用域\n- 全局作用域：没有使用 `var` 隐式声明的一个变量，会享受全局作用域，或者在 `global` 上挂载的变量，也具有全局作用域的属性，全局变量可以被其它模块使用。\n- 局部作用域：在 Node.js 中一个文件就是一个模块，在这个模块中定义的变量，只能在这个模块中使用。\n\n```js\n// 这些变量都属于全局变量\nname = 'ifyour';\nglobal.age = 18; // Node.js 中的 global 类似 JavaScript 中的 window\n```\n<div class='tip'>\n尽量避免使用全局变量，会造成变量污染。\n</div>\n\n#### 回调函数\nNode.js 中大量使用了回调函数，关于回调函数，我之前在简书写了一篇，我的理解心得，有兴趣的可以[去看看](http://www.jianshu.com/p/1383f4cb9a75)。关于回调函数，我也正是在 Node.js 中对它的理解更为深刻了，Node.js 大量的异步代码都借助回调函数实现，正因如此，性能更高呀。看一个非常简单的例子。\n\n```js\n// 定义回调函数\nfunction cb(){\n  console.log('Hello,callback!');\n}\n\n// 把回调函数的引用（指针）传入该函数，一秒后执行\nsetTimeout(cb,1000);\n```\n借助这个例子，可以看到回调函数的实现机制：\n- 定义一个普通函数（其实它就是回调函数）\n- 将该函数的引用地址作为参数传给调用者，调用者本身也是一个函数，例子中的 `setTimeout`\n- 当特定条件发生时，调用者使用这个引用地址去执行该函数\n\n回调函数的用途很多，比如实现事件注册、异步代码等。在 jQuery 中的动画就是回调函数的经典用法，`animate(x,y,z,function(){...})`,当一个动画执行完成后，执行回调函数。当点击一个按钮时，需要执行的函数块，这些都是回调函数。\n\n### Node.js 事件\nNode.js 中的 event 模块就是提供事件编程的 API，所有具有触发事件的对象都继承或内部包含了 `EventEmitter` 对象。来一个简单的例子吧！\n```js\n//events 模块中的 EventEmitter 对象，定义了事件对象的基础信息和行为\nvar EventEmitter = require('events').EventEmitter;\nvar event = new EventEmitter();// 实例化一个 event 对象\nevent.on('myevent',function(name){ // 绑定 myevent 事件\n    console.log('Hi!' + name);\n});\nevent.emit('myevent','ifyour');// 触发事件\n```\n#### 事件常用方法\n\n|方法                               | 描述                                                     |\n|:---------------------------------|:---------------------------------------------------------|\n|addListener(event, listener)      | 为指定事件添加一个监听器到监听器数组的尾部。与on等价          |\n|on(event, listener)               | 为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数 |\n|once(event, listener)             | 为指定事件注册一个单次监听器                                |\n|removeListener(event,listener)    |移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器  |\n|removeAllListeners([event])       |移除所有事件的所有监听器如果指定事件，则移除该事件的所有监听器  |\n|setMaxListeners(n)                |setMaxListeners 函数用于提高监听器的默认限制的数量，默认是 10 |\n|listeners(event)                  |返回指定事件的监听器数组                                    |\n|emit(event, [arg1], [arg2], [...])|按顺序执行监听器，如果事件有注册监听返回 true，否则返回 false |\n\n\n### Node.js 异步与同步\n\n***同步***：一个任务执行完成后，才能执行下一个任务，执行总时间等于所有任务消耗时间之和。\n***异步***：几个任务同时执行，不限制先后，执行总时间等于执行耗时最长的那个任务的消耗时间。\n\n在 Node.js 中每一个任务有一个或多个回调函数，前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。\n\n#### 异步的实现\n- 回调函数\n- 事件（基于回调函数）\n- Promise （ES6）\n\n前面已经讲了回调函数的实现方式，下面举两个例子来说明 Node.js 中 ***事件*** 和 ***Promise*** 实现异步。\n```js\n// 事件（基于回调函数）实现异步\nvar fs = require('fs');\n\nvar stream = fs.createReadStream('./data');// 调用 fs 模块创建一个读取流对象\nstream.on('data',getData);// 读取事件，每次读取时触发调用回调函数 getData\nstream.on('end',getDataDone);// 读取完毕调用回调函数 getDataDone\n\nfunction getDataDone() {\n    console.log('read done!');\n}\nfunction getData(data) {\n    console.log(data.toString());\n}\n```\n上面的代码中，当读取多个 `data` 文件时，输出的内容的顺序可能不一致，因为事件采用回调函数实现了异步操作。可以看出，事件实现异步，本质上还是回调函数。\n\n> 所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。\n\n下面来看看 `Promise` 的一个实例：\n```js\nvar fs = require('fs');\n\nvar p = new Promise(function (resolve, reject) {// 使用 Promise 生成实例\n    fs.readFile('./1', 'utf-8', function (err, data) {// readFile 是一个异步方法\n        if (!err) {\n            resolve(data);\n        } else {\n            reject(err);\n        }\n    })\n});\n\np.then(function (data) {// 调用实例的 then 方法\n    console.log(data);\n}, function (err) {\n    console.log(err);\n});\n```\nES6 规定，Promise 对象是一个构造函数，用来生成 Promise 实例。Promise 构造函数接受一个函数作为参数，该函数的两个参数分别是 `resolve` 和 `reject`。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。\n\n- resolve : 在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；\n- reject  : 在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。\n\nPromise实例生成以后，可以用 `then` 方法分别指定 Resolved 状态和 Reject 状态的回调函数。\n```js\npromise.then(function(value) {\n  // success\n}, function(error) {\n  // failure\n});\n```\n有了 Promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise 对象提供统一的接口，使得控制异步操作更加容易。\n\n下面这个例子，在未使用 `Promise` 时，我们想要 `p1` 读取完数据后，紧接着 `p2` 、`p3` 读取，就需要在 `p1` 的回调读取成功函数里继续写 `p2` 的读取，类似的 `p3` 也要在 `p2` 的回调函数中写，这就造成了 ***层层嵌套*** 不利于代码阅读。而使用 `Promise` 后，`then` 方法把里面的回调函数统一提取出来， 可读性更好了，也方便理解。\n```js\n// Promise 提供的 then 方法避免层次嵌套，相当于实现 then 的链式操作\n// p1 执行完 then 方法后，通过 return p2 ，让 p2 继续执行 then 方法\np1.then(function(data){\n    console.log(data);\n    return p2;\n},function(err){\n    console.log(err);\n    return p2;\n}).then(function(data){\n    console.log(data);\n    return p3;\n},function(err){\n    console.log(err);\n    return p3;\n}).then(function(data){\n    console.log(data);\n},function(){\n    console.log(err);\n});\n```\n更多 Promise 语法，可以参考阮一峰的《[ECMAScript 6 入门](http://es6.ruanyifeng.com/#docs/promise#基本用法)》。\n","slug":"Node.JS-学习笔记-[02]----同步异步","published":1,"updated":"2018-06-17T09:49:30.000Z","layout":"post","photos":[],"link":"","_id":"cjiitidie000bu4q96jpr81qj","content":"<p>在使用 npm 的时候，我发现在速度实在太慢，安装小一点的包确实没啥问题，装大一点的，依赖多一点的包的时候，问题就来了。速度慢，响应迟钝。<strong><em>nrm</em></strong> 是一个非常好的解决方案，安装 nrm 后，可以使用简单的命令快速来切换 npm 源，比如切换到 cnpm、taobao 源等，详细的使用方法可以点<a href=\"https://github.com/Pana/nrm#install\" target=\"_blank\" rel=\"noopener\">这里</a>进去了解下。<br><a id=\"more\"></a></p>\n<h3 id=\"Node-js-使用\"><a href=\"#Node-js-使用\" class=\"headerlink\" title=\"Node.js 使用\"></a>Node.js 使用</h3><h4 id=\"Node-js-控制台\"><a href=\"#Node-js-控制台\" class=\"headerlink\" title=\"Node.js 控制台\"></a>Node.js 控制台</h4><p>前面说了，Node.js 提供了 REPL 模式来解析输入的每条命令，现在可以实战一下了，打开终端，然后输入 <code>node</code> 进入 Node.js 开始敲命令吧！<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'hello,world!'</span>); <span class=\"comment\">// 普通输入</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.error(<span class=\"string\">'错误消息'</span>);    <span class=\"comment\">// 错误输出</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.time(<span class=\"string\">'time'</span>);        <span class=\"comment\">// 会计算在这个表达式之间的代码块执行耗时</span></span><br><span class=\"line\"><span class=\"comment\">// &#123;...&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.time(<span class=\"string\">'time'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.assert(<span class=\"number\">3</span>&gt;<span class=\"number\">10</span>,<span class=\"string\">'str..'</span>);<span class=\"comment\">// 断言：表达式不成立，会输出后面的字符串</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Node-js-作用域\"><a href=\"#Node-js-作用域\" class=\"headerlink\" title=\"Node.js 作用域\"></a>Node.js 作用域</h4><ul>\n<li>全局作用域：没有使用 <code>var</code> 隐式声明的一个变量，会享受全局作用域，或者在 <code>global</code> 上挂载的变量，也具有全局作用域的属性，全局变量可以被其它模块使用。</li>\n<li>局部作用域：在 Node.js 中一个文件就是一个模块，在这个模块中定义的变量，只能在这个模块中使用。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这些变量都属于全局变量</span></span><br><span class=\"line\">name = <span class=\"string\">'ifyour'</span>;</span><br><span class=\"line\">global.age = <span class=\"number\">18</span>; <span class=\"comment\">// Node.js 中的 global 类似 JavaScript 中的 window</span></span><br></pre></td></tr></table></figure>\n<div class=\"tip\"><br>尽量避免使用全局变量，会造成变量污染。<br></div>\n\n<h4 id=\"回调函数\"><a href=\"#回调函数\" class=\"headerlink\" title=\"回调函数\"></a>回调函数</h4><p>Node.js 中大量使用了回调函数，关于回调函数，我之前在简书写了一篇，我的理解心得，有兴趣的可以<a href=\"http://www.jianshu.com/p/1383f4cb9a75\" target=\"_blank\" rel=\"noopener\">去看看</a>。关于回调函数，我也正是在 Node.js 中对它的理解更为深刻了，Node.js 大量的异步代码都借助回调函数实现，正因如此，性能更高呀。看一个非常简单的例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义回调函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">cb</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hello,callback!'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 把回调函数的引用（指针）传入该函数，一秒后执行</span></span><br><span class=\"line\">setTimeout(cb,<span class=\"number\">1000</span>);</span><br></pre></td></tr></table></figure>\n<p>借助这个例子，可以看到回调函数的实现机制：</p>\n<ul>\n<li>定义一个普通函数（其实它就是回调函数）</li>\n<li>将该函数的引用地址作为参数传给调用者，调用者本身也是一个函数，例子中的 <code>setTimeout</code></li>\n<li>当特定条件发生时，调用者使用这个引用地址去执行该函数</li>\n</ul>\n<p>回调函数的用途很多，比如实现事件注册、异步代码等。在 jQuery 中的动画就是回调函数的经典用法，<code>animate(x,y,z,function(){...})</code>,当一个动画执行完成后，执行回调函数。当点击一个按钮时，需要执行的函数块，这些都是回调函数。</p>\n<h3 id=\"Node-js-事件\"><a href=\"#Node-js-事件\" class=\"headerlink\" title=\"Node.js 事件\"></a>Node.js 事件</h3><p>Node.js 中的 event 模块就是提供事件编程的 API，所有具有触发事件的对象都继承或内部包含了 <code>EventEmitter</code> 对象。来一个简单的例子吧！<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//events 模块中的 EventEmitter 对象，定义了事件对象的基础信息和行为</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> EventEmitter = <span class=\"built_in\">require</span>(<span class=\"string\">'events'</span>).EventEmitter;</span><br><span class=\"line\"><span class=\"keyword\">var</span> event = <span class=\"keyword\">new</span> EventEmitter();<span class=\"comment\">// 实例化一个 event 对象</span></span><br><span class=\"line\">event.on(<span class=\"string\">'myevent'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>)</span>&#123; <span class=\"comment\">// 绑定 myevent 事件</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hi!'</span> + name);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">event.emit(<span class=\"string\">'myevent'</span>,<span class=\"string\">'ifyour'</span>);<span class=\"comment\">// 触发事件</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"事件常用方法\"><a href=\"#事件常用方法\" class=\"headerlink\" title=\"事件常用方法\"></a>事件常用方法</h4><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">方法</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">addListener(event, listener)</td>\n<td style=\"text-align:left\">为指定事件添加一个监听器到监听器数组的尾部。与on等价</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">on(event, listener)</td>\n<td style=\"text-align:left\">为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">once(event, listener)</td>\n<td style=\"text-align:left\">为指定事件注册一个单次监听器</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">removeListener(event,listener)</td>\n<td style=\"text-align:left\">移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">removeAllListeners([event])</td>\n<td style=\"text-align:left\">移除所有事件的所有监听器如果指定事件，则移除该事件的所有监听器</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">setMaxListeners(n)</td>\n<td style=\"text-align:left\">setMaxListeners 函数用于提高监听器的默认限制的数量，默认是 10</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">listeners(event)</td>\n<td style=\"text-align:left\">返回指定事件的监听器数组</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">emit(event, [arg1], [arg2], […])</td>\n<td style=\"text-align:left\">按顺序执行监听器，如果事件有注册监听返回 true，否则返回 false</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Node-js-异步与同步\"><a href=\"#Node-js-异步与同步\" class=\"headerlink\" title=\"Node.js 异步与同步\"></a>Node.js 异步与同步</h3><p><strong><em>同步</em></strong>：一个任务执行完成后，才能执行下一个任务，执行总时间等于所有任务消耗时间之和。<br><strong><em>异步</em></strong>：几个任务同时执行，不限制先后，执行总时间等于执行耗时最长的那个任务的消耗时间。</p>\n<p>在 Node.js 中每一个任务有一个或多个回调函数，前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。</p>\n<h4 id=\"异步的实现\"><a href=\"#异步的实现\" class=\"headerlink\" title=\"异步的实现\"></a>异步的实现</h4><ul>\n<li>回调函数</li>\n<li>事件（基于回调函数）</li>\n<li>Promise （ES6）</li>\n</ul>\n<p>前面已经讲了回调函数的实现方式，下面举两个例子来说明 Node.js 中 <strong><em>事件</em></strong> 和 <strong><em>Promise</em></strong> 实现异步。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 事件（基于回调函数）实现异步</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> stream = fs.createReadStream(<span class=\"string\">'./data'</span>);<span class=\"comment\">// 调用 fs 模块创建一个读取流对象</span></span><br><span class=\"line\">stream.on(<span class=\"string\">'data'</span>,getData);<span class=\"comment\">// 读取事件，每次读取时触发调用回调函数 getData</span></span><br><span class=\"line\">stream.on(<span class=\"string\">'end'</span>,getDataDone);<span class=\"comment\">// 读取完毕调用回调函数 getDataDone</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getDataDone</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'read done!'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getData</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data.toString());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面的代码中，当读取多个 <code>data</code> 文件时，输出的内容的顺序可能不一致，因为事件采用回调函数实现了异步操作。可以看出，事件实现异步，本质上还是回调函数。</p>\n<blockquote>\n<p>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。</p>\n</blockquote>\n<p>下面来看看 <code>Promise</code> 的一个实例：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;<span class=\"comment\">// 使用 Promise 生成实例</span></span><br><span class=\"line\">    fs.readFile(<span class=\"string\">'./1'</span>, <span class=\"string\">'utf-8'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, data</span>) </span>&#123;<span class=\"comment\">// readFile 是一个异步方法</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!err) &#123;</span><br><span class=\"line\">            resolve(data);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            reject(err);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">p.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;<span class=\"comment\">// 调用实例的 then 方法</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>ES6 规定，Promise 对象是一个构造函数，用来生成 Promise 实例。Promise 构造函数接受一个函数作为参数，该函数的两个参数分别是 <code>resolve</code> 和 <code>reject</code>。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</p>\n<ul>\n<li>resolve : 在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；</li>\n<li>reject  : 在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</li>\n</ul>\n<p>Promise实例生成以后，可以用 <code>then</code> 方法分别指定 Resolved 状态和 Reject 状态的回调函数。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// success</span></span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// failure</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>有了 Promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise 对象提供统一的接口，使得控制异步操作更加容易。</p>\n<p>下面这个例子，在未使用 <code>Promise</code> 时，我们想要 <code>p1</code> 读取完数据后，紧接着 <code>p2</code> 、<code>p3</code> 读取，就需要在 <code>p1</code> 的回调读取成功函数里继续写 <code>p2</code> 的读取，类似的 <code>p3</code> 也要在 <code>p2</code> 的回调函数中写，这就造成了 <strong><em>层层嵌套</em></strong> 不利于代码阅读。而使用 <code>Promise</code> 后，<code>then</code> 方法把里面的回调函数统一提取出来， 可读性更好了，也方便理解。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Promise 提供的 then 方法避免层次嵌套，相当于实现 then 的链式操作</span></span><br><span class=\"line\"><span class=\"comment\">// p1 执行完 then 方法后，通过 return p2 ，让 p2 继续执行 then 方法</span></span><br><span class=\"line\">p1.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p2;</span><br><span class=\"line\">&#125;,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p2;</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p3;</span><br><span class=\"line\">&#125;,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p3;</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">&#125;,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>更多 Promise 语法，可以参考阮一峰的《<a href=\"http://es6.ruanyifeng.com/#docs/promise#基本用法\" target=\"_blank\" rel=\"noopener\">ECMAScript 6 入门</a>》。</p>\n","site":{"data":{}},"excerpt":"<p>在使用 npm 的时候，我发现在速度实在太慢，安装小一点的包确实没啥问题，装大一点的，依赖多一点的包的时候，问题就来了。速度慢，响应迟钝。<strong><em>nrm</em></strong> 是一个非常好的解决方案，安装 nrm 后，可以使用简单的命令快速来切换 npm 源，比如切换到 cnpm、taobao 源等，详细的使用方法可以点<a href=\"https://github.com/Pana/nrm#install\" target=\"_blank\" rel=\"noopener\">这里</a>进去了解下。<br>","more":"</p>\n<h3 id=\"Node-js-使用\"><a href=\"#Node-js-使用\" class=\"headerlink\" title=\"Node.js 使用\"></a>Node.js 使用</h3><h4 id=\"Node-js-控制台\"><a href=\"#Node-js-控制台\" class=\"headerlink\" title=\"Node.js 控制台\"></a>Node.js 控制台</h4><p>前面说了，Node.js 提供了 REPL 模式来解析输入的每条命令，现在可以实战一下了，打开终端，然后输入 <code>node</code> 进入 Node.js 开始敲命令吧！<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'hello,world!'</span>); <span class=\"comment\">// 普通输入</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.error(<span class=\"string\">'错误消息'</span>);    <span class=\"comment\">// 错误输出</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.time(<span class=\"string\">'time'</span>);        <span class=\"comment\">// 会计算在这个表达式之间的代码块执行耗时</span></span><br><span class=\"line\"><span class=\"comment\">// &#123;...&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.time(<span class=\"string\">'time'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.assert(<span class=\"number\">3</span>&gt;<span class=\"number\">10</span>,<span class=\"string\">'str..'</span>);<span class=\"comment\">// 断言：表达式不成立，会输出后面的字符串</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Node-js-作用域\"><a href=\"#Node-js-作用域\" class=\"headerlink\" title=\"Node.js 作用域\"></a>Node.js 作用域</h4><ul>\n<li>全局作用域：没有使用 <code>var</code> 隐式声明的一个变量，会享受全局作用域，或者在 <code>global</code> 上挂载的变量，也具有全局作用域的属性，全局变量可以被其它模块使用。</li>\n<li>局部作用域：在 Node.js 中一个文件就是一个模块，在这个模块中定义的变量，只能在这个模块中使用。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这些变量都属于全局变量</span></span><br><span class=\"line\">name = <span class=\"string\">'ifyour'</span>;</span><br><span class=\"line\">global.age = <span class=\"number\">18</span>; <span class=\"comment\">// Node.js 中的 global 类似 JavaScript 中的 window</span></span><br></pre></td></tr></table></figure>\n<div class=\"tip\"><br>尽量避免使用全局变量，会造成变量污染。<br></div>\n\n<h4 id=\"回调函数\"><a href=\"#回调函数\" class=\"headerlink\" title=\"回调函数\"></a>回调函数</h4><p>Node.js 中大量使用了回调函数，关于回调函数，我之前在简书写了一篇，我的理解心得，有兴趣的可以<a href=\"http://www.jianshu.com/p/1383f4cb9a75\" target=\"_blank\" rel=\"noopener\">去看看</a>。关于回调函数，我也正是在 Node.js 中对它的理解更为深刻了，Node.js 大量的异步代码都借助回调函数实现，正因如此，性能更高呀。看一个非常简单的例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义回调函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">cb</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hello,callback!'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 把回调函数的引用（指针）传入该函数，一秒后执行</span></span><br><span class=\"line\">setTimeout(cb,<span class=\"number\">1000</span>);</span><br></pre></td></tr></table></figure>\n<p>借助这个例子，可以看到回调函数的实现机制：</p>\n<ul>\n<li>定义一个普通函数（其实它就是回调函数）</li>\n<li>将该函数的引用地址作为参数传给调用者，调用者本身也是一个函数，例子中的 <code>setTimeout</code></li>\n<li>当特定条件发生时，调用者使用这个引用地址去执行该函数</li>\n</ul>\n<p>回调函数的用途很多，比如实现事件注册、异步代码等。在 jQuery 中的动画就是回调函数的经典用法，<code>animate(x,y,z,function(){...})</code>,当一个动画执行完成后，执行回调函数。当点击一个按钮时，需要执行的函数块，这些都是回调函数。</p>\n<h3 id=\"Node-js-事件\"><a href=\"#Node-js-事件\" class=\"headerlink\" title=\"Node.js 事件\"></a>Node.js 事件</h3><p>Node.js 中的 event 模块就是提供事件编程的 API，所有具有触发事件的对象都继承或内部包含了 <code>EventEmitter</code> 对象。来一个简单的例子吧！<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//events 模块中的 EventEmitter 对象，定义了事件对象的基础信息和行为</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> EventEmitter = <span class=\"built_in\">require</span>(<span class=\"string\">'events'</span>).EventEmitter;</span><br><span class=\"line\"><span class=\"keyword\">var</span> event = <span class=\"keyword\">new</span> EventEmitter();<span class=\"comment\">// 实例化一个 event 对象</span></span><br><span class=\"line\">event.on(<span class=\"string\">'myevent'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>)</span>&#123; <span class=\"comment\">// 绑定 myevent 事件</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hi!'</span> + name);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">event.emit(<span class=\"string\">'myevent'</span>,<span class=\"string\">'ifyour'</span>);<span class=\"comment\">// 触发事件</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"事件常用方法\"><a href=\"#事件常用方法\" class=\"headerlink\" title=\"事件常用方法\"></a>事件常用方法</h4><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">方法</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">addListener(event, listener)</td>\n<td style=\"text-align:left\">为指定事件添加一个监听器到监听器数组的尾部。与on等价</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">on(event, listener)</td>\n<td style=\"text-align:left\">为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">once(event, listener)</td>\n<td style=\"text-align:left\">为指定事件注册一个单次监听器</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">removeListener(event,listener)</td>\n<td style=\"text-align:left\">移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">removeAllListeners([event])</td>\n<td style=\"text-align:left\">移除所有事件的所有监听器如果指定事件，则移除该事件的所有监听器</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">setMaxListeners(n)</td>\n<td style=\"text-align:left\">setMaxListeners 函数用于提高监听器的默认限制的数量，默认是 10</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">listeners(event)</td>\n<td style=\"text-align:left\">返回指定事件的监听器数组</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">emit(event, [arg1], [arg2], […])</td>\n<td style=\"text-align:left\">按顺序执行监听器，如果事件有注册监听返回 true，否则返回 false</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Node-js-异步与同步\"><a href=\"#Node-js-异步与同步\" class=\"headerlink\" title=\"Node.js 异步与同步\"></a>Node.js 异步与同步</h3><p><strong><em>同步</em></strong>：一个任务执行完成后，才能执行下一个任务，执行总时间等于所有任务消耗时间之和。<br><strong><em>异步</em></strong>：几个任务同时执行，不限制先后，执行总时间等于执行耗时最长的那个任务的消耗时间。</p>\n<p>在 Node.js 中每一个任务有一个或多个回调函数，前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。</p>\n<h4 id=\"异步的实现\"><a href=\"#异步的实现\" class=\"headerlink\" title=\"异步的实现\"></a>异步的实现</h4><ul>\n<li>回调函数</li>\n<li>事件（基于回调函数）</li>\n<li>Promise （ES6）</li>\n</ul>\n<p>前面已经讲了回调函数的实现方式，下面举两个例子来说明 Node.js 中 <strong><em>事件</em></strong> 和 <strong><em>Promise</em></strong> 实现异步。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 事件（基于回调函数）实现异步</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> stream = fs.createReadStream(<span class=\"string\">'./data'</span>);<span class=\"comment\">// 调用 fs 模块创建一个读取流对象</span></span><br><span class=\"line\">stream.on(<span class=\"string\">'data'</span>,getData);<span class=\"comment\">// 读取事件，每次读取时触发调用回调函数 getData</span></span><br><span class=\"line\">stream.on(<span class=\"string\">'end'</span>,getDataDone);<span class=\"comment\">// 读取完毕调用回调函数 getDataDone</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getDataDone</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'read done!'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getData</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data.toString());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面的代码中，当读取多个 <code>data</code> 文件时，输出的内容的顺序可能不一致，因为事件采用回调函数实现了异步操作。可以看出，事件实现异步，本质上还是回调函数。</p>\n<blockquote>\n<p>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。</p>\n</blockquote>\n<p>下面来看看 <code>Promise</code> 的一个实例：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;<span class=\"comment\">// 使用 Promise 生成实例</span></span><br><span class=\"line\">    fs.readFile(<span class=\"string\">'./1'</span>, <span class=\"string\">'utf-8'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, data</span>) </span>&#123;<span class=\"comment\">// readFile 是一个异步方法</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!err) &#123;</span><br><span class=\"line\">            resolve(data);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            reject(err);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">p.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;<span class=\"comment\">// 调用实例的 then 方法</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>ES6 规定，Promise 对象是一个构造函数，用来生成 Promise 实例。Promise 构造函数接受一个函数作为参数，该函数的两个参数分别是 <code>resolve</code> 和 <code>reject</code>。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</p>\n<ul>\n<li>resolve : 在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；</li>\n<li>reject  : 在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</li>\n</ul>\n<p>Promise实例生成以后，可以用 <code>then</code> 方法分别指定 Resolved 状态和 Reject 状态的回调函数。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// success</span></span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// failure</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>有了 Promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise 对象提供统一的接口，使得控制异步操作更加容易。</p>\n<p>下面这个例子，在未使用 <code>Promise</code> 时，我们想要 <code>p1</code> 读取完数据后，紧接着 <code>p2</code> 、<code>p3</code> 读取，就需要在 <code>p1</code> 的回调读取成功函数里继续写 <code>p2</code> 的读取，类似的 <code>p3</code> 也要在 <code>p2</code> 的回调函数中写，这就造成了 <strong><em>层层嵌套</em></strong> 不利于代码阅读。而使用 <code>Promise</code> 后，<code>then</code> 方法把里面的回调函数统一提取出来， 可读性更好了，也方便理解。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Promise 提供的 then 方法避免层次嵌套，相当于实现 then 的链式操作</span></span><br><span class=\"line\"><span class=\"comment\">// p1 执行完 then 方法后，通过 return p2 ，让 p2 继续执行 then 方法</span></span><br><span class=\"line\">p1.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p2;</span><br><span class=\"line\">&#125;,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p2;</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p3;</span><br><span class=\"line\">&#125;,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p3;</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">&#125;,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>更多 Promise 语法，可以参考阮一峰的《<a href=\"http://es6.ruanyifeng.com/#docs/promise#基本用法\" target=\"_blank\" rel=\"noopener\">ECMAScript 6 入门</a>》。</p>"},{"title":"Node.JS 学习笔记 [03] -- Buffer fs path","date":"2015-01-04T13:57:05.000Z","comments":0,"_content":"\n今天学习了 Node.js 的缓冲区（Buffer）、文件系统（fs）、路径（path）模块，感受了一下 Node.js 作为 JavaScript 的扩展在后台方面的一些功能。给我最多的感受是，大量的异步代码和回调函数，让 Node.js 性能非常出色。来总结下今天学习的内容吧。\n<!-- more -->\n### 缓冲区 (Buffer)\nJavaScript 语言自身只有字符串数据类型，没有二进制数据类型。但在处理像 TCP 流或文件流时，必须使用到二进制数据。因此在 Node.js 中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。按照我的理解，Buffer 类很像我们的整数数组。有对应的索引，存储方式也和数组类似。来看看 Buffer 类是如何创建的。\n#### 创建 Buffer 类\n```js\n// 方法1\n// 创建长度为10字节的 Buffer 类\nvar buf = new Buffer(10); // 构造函数，注意这种创建形式\n\n// 方法2\n// 直接通过数组赋值的形式创建\nvar buf2 = new Buffer([1,2,3,4,5]);\n\n// 方法3\n// 通过字符串来创建\nvar buf3 = new Buffer('ifyour','utf-8');// utf-8 默认编码，可以省略\n```\n从代码我们可以看出这个 Buffer 类是一个构造函数，通过实例化一个 Buffer 对象，让它具有一些 Buffer 类的方法，总得来说常用的方法有下面三种。\n#### 写入缓冲区\n```js\n// 语法：  buf.write(string[, offset[, length]][, encoding])\n// 实例：\n\nvar b4 = new Buffer(14);\nlen = b4.write('this is buffer');\nconsole.log('Buffer 写入了 ' + len + ' 字节，内容为：' + b4.toString());\n// Buffer 写入了 14字节，内容为：this is buffer\n```\n#### 缓冲区读取\n```js\n// 语法： buf.toString([encoding[, start[, end]]])\n// 实例：\nbuf = new Buffer(26);\nfor (var i = 0 ; i < 26 ; i++) {\n  buf[i] = i + 97;\n}\n\nconsole.log( buf.toString('ascii'));       // 输出: abcdefghijklmnopqrstuvwxyz\nconsole.log( buf.toString('ascii',0,5));   // 输出: abcde\nconsole.log( buf.toString('utf8',0,5));    // 输出: abcde\nconsole.log( buf.toString(undefined,0,5)); // 使用 'utf8' 编码, 并输出: abcde\n```\n\n#### 缓冲区拷贝\n```js\n//语法： buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]])\n//实例：\nvar b5 = new Buffer([1,2,3,4,5]);\nvar b6 = new  Buffer(5);\n\nb5.copy(b6,1,0,2);// 把 b5 中的索引 0-2 （不包括2） 的值复制给 b6 的第 1 位置\nconsole.log(b6);\n```\n### 文件系统 (fs)\nNode.js 文件系统（fs 模块）模块中的方法均有异步和同步版本，例如读取文件内容的函数有异步的 `fs.readFile()` 和同步的 `fs.readFileSync()`。异步的方法函数最后一个参数为回调函数，回调函数的第一个参数包含了错误信息 (error)。相比同步，异步效率更高，性能更好，没有阻塞，但是在实际使用中，一定要处理好先后顺序。\n\n#### 文件读写方式\n文件读取方式，举个简单例子，好比先把整个数据源完整拿出来放到内存中，再使用 `writeFile` 方法或 `writeFileSync` 方法写入文件内容。显然，如果数据源非常大（10GB）使用这种方式，效率就很低了。说不定就死机了。:) 这时候，就需要下一节讲到的 ***流读取***。\n\n```Text\n// data.txt\nHello,Node.js!\n```\n```js\nvar fs = require(\"fs\");\n\n// 异步读取\nfs.readFile('data.txt', function (err, data) {\n   if (err) {\n       return console.error(err);\n   }\n   console.log(\"异步读取: \" + data.toString());\n});\n\n// 同步读取\nvar data = fs.readFileSync('data.txt');\nconsole.log(\"同步读取: \" + data.toString());\n\nconsole.log(\"程序执行完毕。\");\n```\n\n```Text\n同步读取: Hello,Node.js!\n程序执行完毕。\n\n异步读取: Hello,Node.js!\n```\n\n<div class=\"tip\">\nNode.js 中，先执行同步代码，后执行异步代码，异步代码会将回调函数放入调用 ***队列***，以 ***先进先出*** 的形式依次调用。\n</div>\n\n```js\nvar fs = require('fs');\n// 异步写入\nfs.writeFile('./data/d2.txt','我是一条数据',function (err) {\n    if (!err){\n        console.log('文件写入成功');\n    }else {\n        console.log('写入失败');\n    }\n});\n\n// 同步写入\nfs.writeFileSync('./data/d3','我是一条数据');\n\nvar data = fs.readFileSync('./data/d3');\n\nconsole.log(data.toString());// 我是一条数据\n```\n\n\n#### 流读写方式\n应用程序中，流是一组有序的、有起点和终点的 ***字节数据的传输方式***。在应用程序中各种对象之间交换与传输数据的时候，总是先将该对象中所包含的数据转换为各种形式的流数据（即字节数据），再通过流的传输，到达目的对象后再将流数据转换为该对象中可以使用的数据。\n\n```js\nvar fs = require('fs');\nvar data = '';\n// 流读取\nvar stream = fs.createReadStream('./data/d1.txt','utf-8');\nstream.on('data',function (result) {\n    data += result;\n});\n// data end 事件表示连贯的行为，字节流需要起点和终点。\nstream.on('end',function () {\n    console.log(data);\n});\n\nstream.on('error',function (err) {\n    console.log(err.stack);\n});\n\n// 流写入\nvar stream = fs.createWriteStream('./data/123.txt','utf-8');\nstream.write('hello','utf-8');\n\nstream.end();\n\nstream.on('finish',function () {// finish 事件触发，必须等 end 事件结束才可以\n   console.log('写入完成！');\n});\n\nstream.on('error', function(err){\n    console.log(err.stack);\n});\n```\n<div class=\"tip\">\n流读取会依次触发事件： data -> end -> error ,每个事件发生会有对应的回调函数处理。\n流写入会依次触发事件： end -> finish -> error ,每个事件发生会有对应的回调函数处理。\n</div>\n\n#### 管道流读写\n管道(pipe) 提供了一个输出流到输入流的机制。通常我们用于从一个流中获取数据并将数据传递到另外一个流中。通过管道，我们就可以实现大文件流入另外一个文件的复制过程。\n```js\nvar fs = require('fs');\n\nvar readStream = fs.createReadStream('./data/d1.txt');\n\nvar writeStrem = fs.createWriteStream('./data/d3.txt');\n\nreadStream.pipe(writeStrem);// 实现了 d1.txt 到 d3.txt 的传输过程\n```\n\n#### 链式流读写\n链式是通过连接输出流到另外一个流并创建多个对个流操作链的机制。链式流一般用于管道操作。接下来我们就是用管道和链式来压缩和解压文件。\n```js\n// compress.js\nvar fs = require('fs');\nvar zlib = require('zlib'); // 引入压缩模块\n\nfs.createReadStream('./data/123.txt')\n    .pipe(zlib.createGzip())\n    .pipe(fs.createWriteStream('./data/123.txt.gz'));// 链式操作\nconsole.log('文件压缩完成');\n```\n#### 文件、文件夹删除\n```js\nvar fs = require(\"fs\");\n// 文件目录读取，返回一个数组，包含文件及文件夹\nfs.readdir(\"./testdir\",function(err,files){\n    if (!err){\n        console.log(files);// [ 'index.html', 'main.css', 'subdir' ]\n    }else {\n        console.log(err);\n    }\n});\n\n// 文件删除\nconsole.log(\"准备删除文件！\");\nfs.unlink('./data/123.txt.gz', function(err) {\n    if (err) {\n        return err;\n    }\n    console.log(\"文件删除成功！\");\n});\n\n// 空文件夹删除\nfs.rmdir('./data',function (err) {\n    if (!err){\n        console.log('删除成功！');\n    }else {\n        console.log(err);\n    }\n});\n\n```\n一个递归删除的小练习，把前面的综合运用一下。\n```js\ndelDir('./testdir');\n\n// 传入一个文件夹路径，删除掉该文件夹所有内容\n// @param pathStr string 传入一个路径\nfunction delDir(pathStr) {\n    var fs = require('fs');\n    if (fs.existsSync(pathStr)){\n        var files = fs.readdirSync(pathStr);\n        for (var i = 0; i < files.length; i++) {\n            var curPath = pathStr + '/' + files[i];\n            var stats = fs.statSync(curPath);\n            if (stats.isFile()){\n                fs.unlink(curPath);\n            }else if(stats.isDirectory()){\n                delDir(curPath);// 递归调用，最终删除掉所有文件，只剩空目录\n            }\n        }\n        fs.rmdirSync(pathStr);// 收尾，删掉空目录\n    }else {\n        console.log('文件夹不存在');\n    }\n}\n```\n<div class=\"tip\">\n文件、文件夹的操作，都有同步和异步的代码，比如 `fs.unlink()` 和 `fs.unlinkSync()`,默认都是异步代码，异步代码会调用回调函数进行操作，同步代码会返回一个对象，进行后续的操作，可以认真观察上面代码的区别。使用异步代码的时候，一定注意执行顺序。\n</div>\n\n\n### 路径 (path)\npath 模块包含一套用于 ***处理和转换文件路径*** 的工具集，用于处理目录的对象，提高开发效率。用 Node.js 的 path 命令，与使用 Linux 下的 shell 脚本命令相似。几乎所有的方法仅对字符串进行转换，文件系统是不会检查路径是否真实有效。\n```js\n// 引入path对象\nvar path = require('path');\n\n/*\n* 格式化路径  path.normalize(p)\n* 特点：将不符合规范的路径格式化，简化开发人员中处理各种复杂的路径判断\n* */\npath.normalize('/foo/bar//baz/asdf/quux/..');\n// returns\n'/foo/bar/baz/asdf'\n\n/*\n* 路径联合 path.join([path1], [path2], [...])\n* 特点：将所有名称用path.seq串联起来，然后用normailze格式化\n* */\npath.join('///foo', 'bar', '//baz/asdf', 'quux', '..');\n// returns\n'/foo/bar/baz/asdf'\n\n/*\n* 路径寻航 path.resolve([from ...], to)\n* 特点：相当于不断的调用系统的cd命令\n* */\npath.resolve('foo/bar', '/tmp/file/', '..', 'a/../subfile');\n// 相当于终端命令：\n// cd foo/bar\n// cd /tmp/file/\n// cd ..\n// cd a/../subfile\n// pwd\n\n/*\n* 相对路径 path.relative(from, to)\n* 特点：返回某个路径下相对于另一个路径的相对位置串，\n* 相当于：path.resolve(from, path.relative(from, to)) == path.resolve(to)\n* */\n//简单理解： 地址一执行怎样的 shell 命令，到达地址二\npath.relative('/data/orandea/test/aaa', '/data/orandea/impl/bbb')\n// returns\n'../../impl/bbb'\n\n/*\n* 文件夹名称 path.dirname(p)\n* 特点：返回路径的上级路径\n* */\npath.dirname('/foo/bar/baz/asdf/quux')\n// returns\n'/foo/bar/baz/asdf'\n\n/*\n* 文件名称 path.basename(p, [ext])\n* 特点：返回指定的文件名，返回结果可去掉[ext]后缀字符串\n* */\npath.basename('/foo/bar/baz/asdf/quux.html')\n// returns\n'quux.html'\n\npath.basename('/foo/bar/baz/asdf/quux.html', '.html')\n// returns\n'quux'\n\n/*\n* 扩展名称 path.extname(p)\n* 特点：返回指定文件名的扩展名称\n* */\npath.extname('index.html')\n// returns\n'.html'\n\npath.extname('index.')\n// returns\n'.'\n\npath.extname('index')\n// returns\n''\n\n/*\n* 路径分隔符 path.sep\n* 特点：获取文件路径的分隔符，主要是与操作系统相关\n* 注意调用方式\n* */\n'foo/bar/baz'.split(path.sep)\n// returns\n['foo', 'bar', 'baz']\n```\n","source":"_posts/Node.JS-学习笔记-[03]----Buffer-fs-path.md","raw":"---\ntitle: 'Node.JS 学习笔记 [03] -- Buffer fs path'\ndate: 2015-1-4 21:57:05\ntags:\ncomments: false\n---\n\n今天学习了 Node.js 的缓冲区（Buffer）、文件系统（fs）、路径（path）模块，感受了一下 Node.js 作为 JavaScript 的扩展在后台方面的一些功能。给我最多的感受是，大量的异步代码和回调函数，让 Node.js 性能非常出色。来总结下今天学习的内容吧。\n<!-- more -->\n### 缓冲区 (Buffer)\nJavaScript 语言自身只有字符串数据类型，没有二进制数据类型。但在处理像 TCP 流或文件流时，必须使用到二进制数据。因此在 Node.js 中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。按照我的理解，Buffer 类很像我们的整数数组。有对应的索引，存储方式也和数组类似。来看看 Buffer 类是如何创建的。\n#### 创建 Buffer 类\n```js\n// 方法1\n// 创建长度为10字节的 Buffer 类\nvar buf = new Buffer(10); // 构造函数，注意这种创建形式\n\n// 方法2\n// 直接通过数组赋值的形式创建\nvar buf2 = new Buffer([1,2,3,4,5]);\n\n// 方法3\n// 通过字符串来创建\nvar buf3 = new Buffer('ifyour','utf-8');// utf-8 默认编码，可以省略\n```\n从代码我们可以看出这个 Buffer 类是一个构造函数，通过实例化一个 Buffer 对象，让它具有一些 Buffer 类的方法，总得来说常用的方法有下面三种。\n#### 写入缓冲区\n```js\n// 语法：  buf.write(string[, offset[, length]][, encoding])\n// 实例：\n\nvar b4 = new Buffer(14);\nlen = b4.write('this is buffer');\nconsole.log('Buffer 写入了 ' + len + ' 字节，内容为：' + b4.toString());\n// Buffer 写入了 14字节，内容为：this is buffer\n```\n#### 缓冲区读取\n```js\n// 语法： buf.toString([encoding[, start[, end]]])\n// 实例：\nbuf = new Buffer(26);\nfor (var i = 0 ; i < 26 ; i++) {\n  buf[i] = i + 97;\n}\n\nconsole.log( buf.toString('ascii'));       // 输出: abcdefghijklmnopqrstuvwxyz\nconsole.log( buf.toString('ascii',0,5));   // 输出: abcde\nconsole.log( buf.toString('utf8',0,5));    // 输出: abcde\nconsole.log( buf.toString(undefined,0,5)); // 使用 'utf8' 编码, 并输出: abcde\n```\n\n#### 缓冲区拷贝\n```js\n//语法： buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]])\n//实例：\nvar b5 = new Buffer([1,2,3,4,5]);\nvar b6 = new  Buffer(5);\n\nb5.copy(b6,1,0,2);// 把 b5 中的索引 0-2 （不包括2） 的值复制给 b6 的第 1 位置\nconsole.log(b6);\n```\n### 文件系统 (fs)\nNode.js 文件系统（fs 模块）模块中的方法均有异步和同步版本，例如读取文件内容的函数有异步的 `fs.readFile()` 和同步的 `fs.readFileSync()`。异步的方法函数最后一个参数为回调函数，回调函数的第一个参数包含了错误信息 (error)。相比同步，异步效率更高，性能更好，没有阻塞，但是在实际使用中，一定要处理好先后顺序。\n\n#### 文件读写方式\n文件读取方式，举个简单例子，好比先把整个数据源完整拿出来放到内存中，再使用 `writeFile` 方法或 `writeFileSync` 方法写入文件内容。显然，如果数据源非常大（10GB）使用这种方式，效率就很低了。说不定就死机了。:) 这时候，就需要下一节讲到的 ***流读取***。\n\n```Text\n// data.txt\nHello,Node.js!\n```\n```js\nvar fs = require(\"fs\");\n\n// 异步读取\nfs.readFile('data.txt', function (err, data) {\n   if (err) {\n       return console.error(err);\n   }\n   console.log(\"异步读取: \" + data.toString());\n});\n\n// 同步读取\nvar data = fs.readFileSync('data.txt');\nconsole.log(\"同步读取: \" + data.toString());\n\nconsole.log(\"程序执行完毕。\");\n```\n\n```Text\n同步读取: Hello,Node.js!\n程序执行完毕。\n\n异步读取: Hello,Node.js!\n```\n\n<div class=\"tip\">\nNode.js 中，先执行同步代码，后执行异步代码，异步代码会将回调函数放入调用 ***队列***，以 ***先进先出*** 的形式依次调用。\n</div>\n\n```js\nvar fs = require('fs');\n// 异步写入\nfs.writeFile('./data/d2.txt','我是一条数据',function (err) {\n    if (!err){\n        console.log('文件写入成功');\n    }else {\n        console.log('写入失败');\n    }\n});\n\n// 同步写入\nfs.writeFileSync('./data/d3','我是一条数据');\n\nvar data = fs.readFileSync('./data/d3');\n\nconsole.log(data.toString());// 我是一条数据\n```\n\n\n#### 流读写方式\n应用程序中，流是一组有序的、有起点和终点的 ***字节数据的传输方式***。在应用程序中各种对象之间交换与传输数据的时候，总是先将该对象中所包含的数据转换为各种形式的流数据（即字节数据），再通过流的传输，到达目的对象后再将流数据转换为该对象中可以使用的数据。\n\n```js\nvar fs = require('fs');\nvar data = '';\n// 流读取\nvar stream = fs.createReadStream('./data/d1.txt','utf-8');\nstream.on('data',function (result) {\n    data += result;\n});\n// data end 事件表示连贯的行为，字节流需要起点和终点。\nstream.on('end',function () {\n    console.log(data);\n});\n\nstream.on('error',function (err) {\n    console.log(err.stack);\n});\n\n// 流写入\nvar stream = fs.createWriteStream('./data/123.txt','utf-8');\nstream.write('hello','utf-8');\n\nstream.end();\n\nstream.on('finish',function () {// finish 事件触发，必须等 end 事件结束才可以\n   console.log('写入完成！');\n});\n\nstream.on('error', function(err){\n    console.log(err.stack);\n});\n```\n<div class=\"tip\">\n流读取会依次触发事件： data -> end -> error ,每个事件发生会有对应的回调函数处理。\n流写入会依次触发事件： end -> finish -> error ,每个事件发生会有对应的回调函数处理。\n</div>\n\n#### 管道流读写\n管道(pipe) 提供了一个输出流到输入流的机制。通常我们用于从一个流中获取数据并将数据传递到另外一个流中。通过管道，我们就可以实现大文件流入另外一个文件的复制过程。\n```js\nvar fs = require('fs');\n\nvar readStream = fs.createReadStream('./data/d1.txt');\n\nvar writeStrem = fs.createWriteStream('./data/d3.txt');\n\nreadStream.pipe(writeStrem);// 实现了 d1.txt 到 d3.txt 的传输过程\n```\n\n#### 链式流读写\n链式是通过连接输出流到另外一个流并创建多个对个流操作链的机制。链式流一般用于管道操作。接下来我们就是用管道和链式来压缩和解压文件。\n```js\n// compress.js\nvar fs = require('fs');\nvar zlib = require('zlib'); // 引入压缩模块\n\nfs.createReadStream('./data/123.txt')\n    .pipe(zlib.createGzip())\n    .pipe(fs.createWriteStream('./data/123.txt.gz'));// 链式操作\nconsole.log('文件压缩完成');\n```\n#### 文件、文件夹删除\n```js\nvar fs = require(\"fs\");\n// 文件目录读取，返回一个数组，包含文件及文件夹\nfs.readdir(\"./testdir\",function(err,files){\n    if (!err){\n        console.log(files);// [ 'index.html', 'main.css', 'subdir' ]\n    }else {\n        console.log(err);\n    }\n});\n\n// 文件删除\nconsole.log(\"准备删除文件！\");\nfs.unlink('./data/123.txt.gz', function(err) {\n    if (err) {\n        return err;\n    }\n    console.log(\"文件删除成功！\");\n});\n\n// 空文件夹删除\nfs.rmdir('./data',function (err) {\n    if (!err){\n        console.log('删除成功！');\n    }else {\n        console.log(err);\n    }\n});\n\n```\n一个递归删除的小练习，把前面的综合运用一下。\n```js\ndelDir('./testdir');\n\n// 传入一个文件夹路径，删除掉该文件夹所有内容\n// @param pathStr string 传入一个路径\nfunction delDir(pathStr) {\n    var fs = require('fs');\n    if (fs.existsSync(pathStr)){\n        var files = fs.readdirSync(pathStr);\n        for (var i = 0; i < files.length; i++) {\n            var curPath = pathStr + '/' + files[i];\n            var stats = fs.statSync(curPath);\n            if (stats.isFile()){\n                fs.unlink(curPath);\n            }else if(stats.isDirectory()){\n                delDir(curPath);// 递归调用，最终删除掉所有文件，只剩空目录\n            }\n        }\n        fs.rmdirSync(pathStr);// 收尾，删掉空目录\n    }else {\n        console.log('文件夹不存在');\n    }\n}\n```\n<div class=\"tip\">\n文件、文件夹的操作，都有同步和异步的代码，比如 `fs.unlink()` 和 `fs.unlinkSync()`,默认都是异步代码，异步代码会调用回调函数进行操作，同步代码会返回一个对象，进行后续的操作，可以认真观察上面代码的区别。使用异步代码的时候，一定注意执行顺序。\n</div>\n\n\n### 路径 (path)\npath 模块包含一套用于 ***处理和转换文件路径*** 的工具集，用于处理目录的对象，提高开发效率。用 Node.js 的 path 命令，与使用 Linux 下的 shell 脚本命令相似。几乎所有的方法仅对字符串进行转换，文件系统是不会检查路径是否真实有效。\n```js\n// 引入path对象\nvar path = require('path');\n\n/*\n* 格式化路径  path.normalize(p)\n* 特点：将不符合规范的路径格式化，简化开发人员中处理各种复杂的路径判断\n* */\npath.normalize('/foo/bar//baz/asdf/quux/..');\n// returns\n'/foo/bar/baz/asdf'\n\n/*\n* 路径联合 path.join([path1], [path2], [...])\n* 特点：将所有名称用path.seq串联起来，然后用normailze格式化\n* */\npath.join('///foo', 'bar', '//baz/asdf', 'quux', '..');\n// returns\n'/foo/bar/baz/asdf'\n\n/*\n* 路径寻航 path.resolve([from ...], to)\n* 特点：相当于不断的调用系统的cd命令\n* */\npath.resolve('foo/bar', '/tmp/file/', '..', 'a/../subfile');\n// 相当于终端命令：\n// cd foo/bar\n// cd /tmp/file/\n// cd ..\n// cd a/../subfile\n// pwd\n\n/*\n* 相对路径 path.relative(from, to)\n* 特点：返回某个路径下相对于另一个路径的相对位置串，\n* 相当于：path.resolve(from, path.relative(from, to)) == path.resolve(to)\n* */\n//简单理解： 地址一执行怎样的 shell 命令，到达地址二\npath.relative('/data/orandea/test/aaa', '/data/orandea/impl/bbb')\n// returns\n'../../impl/bbb'\n\n/*\n* 文件夹名称 path.dirname(p)\n* 特点：返回路径的上级路径\n* */\npath.dirname('/foo/bar/baz/asdf/quux')\n// returns\n'/foo/bar/baz/asdf'\n\n/*\n* 文件名称 path.basename(p, [ext])\n* 特点：返回指定的文件名，返回结果可去掉[ext]后缀字符串\n* */\npath.basename('/foo/bar/baz/asdf/quux.html')\n// returns\n'quux.html'\n\npath.basename('/foo/bar/baz/asdf/quux.html', '.html')\n// returns\n'quux'\n\n/*\n* 扩展名称 path.extname(p)\n* 特点：返回指定文件名的扩展名称\n* */\npath.extname('index.html')\n// returns\n'.html'\n\npath.extname('index.')\n// returns\n'.'\n\npath.extname('index')\n// returns\n''\n\n/*\n* 路径分隔符 path.sep\n* 特点：获取文件路径的分隔符，主要是与操作系统相关\n* 注意调用方式\n* */\n'foo/bar/baz'.split(path.sep)\n// returns\n['foo', 'bar', 'baz']\n```\n","slug":"Node.JS-学习笔记-[03]----Buffer-fs-path","published":1,"updated":"2018-06-17T09:49:30.000Z","layout":"post","photos":[],"link":"","_id":"cjiitidil000cu4q94ipaepx1","content":"<p>今天学习了 Node.js 的缓冲区（Buffer）、文件系统（fs）、路径（path）模块，感受了一下 Node.js 作为 JavaScript 的扩展在后台方面的一些功能。给我最多的感受是，大量的异步代码和回调函数，让 Node.js 性能非常出色。来总结下今天学习的内容吧。<br><a id=\"more\"></a></p>\n<h3 id=\"缓冲区-Buffer\"><a href=\"#缓冲区-Buffer\" class=\"headerlink\" title=\"缓冲区 (Buffer)\"></a>缓冲区 (Buffer)</h3><p>JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。但在处理像 TCP 流或文件流时，必须使用到二进制数据。因此在 Node.js 中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。按照我的理解，Buffer 类很像我们的整数数组。有对应的索引，存储方式也和数组类似。来看看 Buffer 类是如何创建的。</p>\n<h4 id=\"创建-Buffer-类\"><a href=\"#创建-Buffer-类\" class=\"headerlink\" title=\"创建 Buffer 类\"></a>创建 Buffer 类</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法1</span></span><br><span class=\"line\"><span class=\"comment\">// 创建长度为10字节的 Buffer 类</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> buf = <span class=\"keyword\">new</span> Buffer(<span class=\"number\">10</span>); <span class=\"comment\">// 构造函数，注意这种创建形式</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法2</span></span><br><span class=\"line\"><span class=\"comment\">// 直接通过数组赋值的形式创建</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> buf2 = <span class=\"keyword\">new</span> Buffer([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法3</span></span><br><span class=\"line\"><span class=\"comment\">// 通过字符串来创建</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> buf3 = <span class=\"keyword\">new</span> Buffer(<span class=\"string\">'ifyour'</span>,<span class=\"string\">'utf-8'</span>);<span class=\"comment\">// utf-8 默认编码，可以省略</span></span><br></pre></td></tr></table></figure>\n<p>从代码我们可以看出这个 Buffer 类是一个构造函数，通过实例化一个 Buffer 对象，让它具有一些 Buffer 类的方法，总得来说常用的方法有下面三种。</p>\n<h4 id=\"写入缓冲区\"><a href=\"#写入缓冲区\" class=\"headerlink\" title=\"写入缓冲区\"></a>写入缓冲区</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 语法：  buf.write(string[, offset[, length]][, encoding])</span></span><br><span class=\"line\"><span class=\"comment\">// 实例：</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b4 = <span class=\"keyword\">new</span> Buffer(<span class=\"number\">14</span>);</span><br><span class=\"line\">len = b4.write(<span class=\"string\">'this is buffer'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Buffer 写入了 '</span> + len + <span class=\"string\">' 字节，内容为：'</span> + b4.toString());</span><br><span class=\"line\"><span class=\"comment\">// Buffer 写入了 14字节，内容为：this is buffer</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"缓冲区读取\"><a href=\"#缓冲区读取\" class=\"headerlink\" title=\"缓冲区读取\"></a>缓冲区读取</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 语法： buf.toString([encoding[, start[, end]]])</span></span><br><span class=\"line\"><span class=\"comment\">// 实例：</span></span><br><span class=\"line\">buf = <span class=\"keyword\">new</span> Buffer(<span class=\"number\">26</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">26</span> ; i++) &#123;</span><br><span class=\"line\">  buf[i] = i + <span class=\"number\">97</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( buf.toString(<span class=\"string\">'ascii'</span>));       <span class=\"comment\">// 输出: abcdefghijklmnopqrstuvwxyz</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( buf.toString(<span class=\"string\">'ascii'</span>,<span class=\"number\">0</span>,<span class=\"number\">5</span>));   <span class=\"comment\">// 输出: abcde</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( buf.toString(<span class=\"string\">'utf8'</span>,<span class=\"number\">0</span>,<span class=\"number\">5</span>));    <span class=\"comment\">// 输出: abcde</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( buf.toString(<span class=\"literal\">undefined</span>,<span class=\"number\">0</span>,<span class=\"number\">5</span>)); <span class=\"comment\">// 使用 'utf8' 编码, 并输出: abcde</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"缓冲区拷贝\"><a href=\"#缓冲区拷贝\" class=\"headerlink\" title=\"缓冲区拷贝\"></a>缓冲区拷贝</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//语法： buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]])</span></span><br><span class=\"line\"><span class=\"comment\">//实例：</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b5 = <span class=\"keyword\">new</span> Buffer([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>]);</span><br><span class=\"line\"><span class=\"keyword\">var</span> b6 = <span class=\"keyword\">new</span>  Buffer(<span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">b5.copy(b6,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">2</span>);<span class=\"comment\">// 把 b5 中的索引 0-2 （不包括2） 的值复制给 b6 的第 1 位置</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b6);</span><br></pre></td></tr></table></figure>\n<h3 id=\"文件系统-fs\"><a href=\"#文件系统-fs\" class=\"headerlink\" title=\"文件系统 (fs)\"></a>文件系统 (fs)</h3><p>Node.js 文件系统（fs 模块）模块中的方法均有异步和同步版本，例如读取文件内容的函数有异步的 <code>fs.readFile()</code> 和同步的 <code>fs.readFileSync()</code>。异步的方法函数最后一个参数为回调函数，回调函数的第一个参数包含了错误信息 (error)。相比同步，异步效率更高，性能更好，没有阻塞，但是在实际使用中，一定要处理好先后顺序。</p>\n<h4 id=\"文件读写方式\"><a href=\"#文件读写方式\" class=\"headerlink\" title=\"文件读写方式\"></a>文件读写方式</h4><p>文件读取方式，举个简单例子，好比先把整个数据源完整拿出来放到内存中，再使用 <code>writeFile</code> 方法或 <code>writeFileSync</code> 方法写入文件内容。显然，如果数据源非常大（10GB）使用这种方式，效率就很低了。说不定就死机了。:) 这时候，就需要下一节讲到的 <strong><em>流读取</em></strong>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// data.txt</span><br><span class=\"line\">Hello,Node.js!</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">\"fs\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 异步读取</span></span><br><span class=\"line\">fs.readFile(<span class=\"string\">'data.txt'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, data</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"built_in\">console</span>.error(err);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(<span class=\"string\">\"异步读取: \"</span> + data.toString());</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 同步读取</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> data = fs.readFileSync(<span class=\"string\">'data.txt'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"同步读取: \"</span> + data.toString());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"程序执行完毕。\"</span>);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">同步读取: Hello,Node.js!</span><br><span class=\"line\">程序执行完毕。</span><br><span class=\"line\"></span><br><span class=\"line\">异步读取: Hello,Node.js!</span><br></pre></td></tr></table></figure>\n<div class=\"tip\"><br>Node.js 中，先执行同步代码，后执行异步代码，异步代码会将回调函数放入调用 <strong><em>队列</em></strong>，以 <strong><em>先进先出</em></strong> 的形式依次调用。<br></div>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 异步写入</span></span><br><span class=\"line\">fs.writeFile(<span class=\"string\">'./data/d2.txt'</span>,<span class=\"string\">'我是一条数据'</span>,<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!err)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'文件写入成功'</span>);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'写入失败'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 同步写入</span></span><br><span class=\"line\">fs.writeFileSync(<span class=\"string\">'./data/d3'</span>,<span class=\"string\">'我是一条数据'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> data = fs.readFileSync(<span class=\"string\">'./data/d3'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(data.toString());<span class=\"comment\">// 我是一条数据</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"流读写方式\"><a href=\"#流读写方式\" class=\"headerlink\" title=\"流读写方式\"></a>流读写方式</h4><p>应用程序中，流是一组有序的、有起点和终点的 <strong><em>字节数据的传输方式</em></strong>。在应用程序中各种对象之间交换与传输数据的时候，总是先将该对象中所包含的数据转换为各种形式的流数据（即字节数据），再通过流的传输，到达目的对象后再将流数据转换为该对象中可以使用的数据。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> data = <span class=\"string\">''</span>;</span><br><span class=\"line\"><span class=\"comment\">// 流读取</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> stream = fs.createReadStream(<span class=\"string\">'./data/d1.txt'</span>,<span class=\"string\">'utf-8'</span>);</span><br><span class=\"line\">stream.on(<span class=\"string\">'data'</span>,<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">result</span>) </span>&#123;</span><br><span class=\"line\">    data += result;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// data end 事件表示连贯的行为，字节流需要起点和终点。</span></span><br><span class=\"line\">stream.on(<span class=\"string\">'end'</span>,<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">stream.on(<span class=\"string\">'error'</span>,<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err.stack);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 流写入</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> stream = fs.createWriteStream(<span class=\"string\">'./data/123.txt'</span>,<span class=\"string\">'utf-8'</span>);</span><br><span class=\"line\">stream.write(<span class=\"string\">'hello'</span>,<span class=\"string\">'utf-8'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">stream.end();</span><br><span class=\"line\"></span><br><span class=\"line\">stream.on(<span class=\"string\">'finish'</span>,<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;<span class=\"comment\">// finish 事件触发，必须等 end 事件结束才可以</span></span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(<span class=\"string\">'写入完成！'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">stream.on(<span class=\"string\">'error'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err.stack);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<div class=\"tip\"><br>流读取会依次触发事件： data -&gt; end -&gt; error ,每个事件发生会有对应的回调函数处理。<br>流写入会依次触发事件： end -&gt; finish -&gt; error ,每个事件发生会有对应的回调函数处理。<br></div>\n\n<h4 id=\"管道流读写\"><a href=\"#管道流读写\" class=\"headerlink\" title=\"管道流读写\"></a>管道流读写</h4><p>管道(pipe) 提供了一个输出流到输入流的机制。通常我们用于从一个流中获取数据并将数据传递到另外一个流中。通过管道，我们就可以实现大文件流入另外一个文件的复制过程。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> readStream = fs.createReadStream(<span class=\"string\">'./data/d1.txt'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> writeStrem = fs.createWriteStream(<span class=\"string\">'./data/d3.txt'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">readStream.pipe(writeStrem);<span class=\"comment\">// 实现了 d1.txt 到 d3.txt 的传输过程</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"链式流读写\"><a href=\"#链式流读写\" class=\"headerlink\" title=\"链式流读写\"></a>链式流读写</h4><p>链式是通过连接输出流到另外一个流并创建多个对个流操作链的机制。链式流一般用于管道操作。接下来我们就是用管道和链式来压缩和解压文件。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// compress.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> zlib = <span class=\"built_in\">require</span>(<span class=\"string\">'zlib'</span>); <span class=\"comment\">// 引入压缩模块</span></span><br><span class=\"line\"></span><br><span class=\"line\">fs.createReadStream(<span class=\"string\">'./data/123.txt'</span>)</span><br><span class=\"line\">    .pipe(zlib.createGzip())</span><br><span class=\"line\">    .pipe(fs.createWriteStream(<span class=\"string\">'./data/123.txt.gz'</span>));<span class=\"comment\">// 链式操作</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'文件压缩完成'</span>);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"文件、文件夹删除\"><a href=\"#文件、文件夹删除\" class=\"headerlink\" title=\"文件、文件夹删除\"></a>文件、文件夹删除</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">\"fs\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// 文件目录读取，返回一个数组，包含文件及文件夹</span></span><br><span class=\"line\">fs.readdir(<span class=\"string\">\"./testdir\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err,files</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!err)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(files);<span class=\"comment\">// [ 'index.html', 'main.css', 'subdir' ]</span></span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 文件删除</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"准备删除文件！\"</span>);</span><br><span class=\"line\">fs.unlink(<span class=\"string\">'./data/123.txt.gz'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> err;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"文件删除成功！\"</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 空文件夹删除</span></span><br><span class=\"line\">fs.rmdir(<span class=\"string\">'./data'</span>,<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!err)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'删除成功！'</span>);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>一个递归删除的小练习，把前面的综合运用一下。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">delDir(<span class=\"string\">'./testdir'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 传入一个文件夹路径，删除掉该文件夹所有内容</span></span><br><span class=\"line\"><span class=\"comment\">// @param pathStr string 传入一个路径</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">delDir</span>(<span class=\"params\">pathStr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fs.existsSync(pathStr))&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> files = fs.readdirSync(pathStr);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; files.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> curPath = pathStr + <span class=\"string\">'/'</span> + files[i];</span><br><span class=\"line\">            <span class=\"keyword\">var</span> stats = fs.statSync(curPath);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (stats.isFile())&#123;</span><br><span class=\"line\">                fs.unlink(curPath);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(stats.isDirectory())&#123;</span><br><span class=\"line\">                delDir(curPath);<span class=\"comment\">// 递归调用，最终删除掉所有文件，只剩空目录</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        fs.rmdirSync(pathStr);<span class=\"comment\">// 收尾，删掉空目录</span></span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'文件夹不存在'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<div class=\"tip\"><br>文件、文件夹的操作，都有同步和异步的代码，比如 <code>fs.unlink()</code> 和 <code>fs.unlinkSync()</code>,默认都是异步代码，异步代码会调用回调函数进行操作，同步代码会返回一个对象，进行后续的操作，可以认真观察上面代码的区别。使用异步代码的时候，一定注意执行顺序。<br></div>\n\n\n<h3 id=\"路径-path\"><a href=\"#路径-path\" class=\"headerlink\" title=\"路径 (path)\"></a>路径 (path)</h3><p>path 模块包含一套用于 <strong><em>处理和转换文件路径</em></strong> 的工具集，用于处理目录的对象，提高开发效率。用 Node.js 的 path 命令，与使用 Linux 下的 shell 脚本命令相似。几乎所有的方法仅对字符串进行转换，文件系统是不会检查路径是否真实有效。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引入path对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 格式化路径  path.normalize(p)</span></span><br><span class=\"line\"><span class=\"comment\">* 特点：将不符合规范的路径格式化，简化开发人员中处理各种复杂的路径判断</span></span><br><span class=\"line\"><span class=\"comment\">* */</span></span><br><span class=\"line\">path.normalize(<span class=\"string\">'/foo/bar//baz/asdf/quux/..'</span>);</span><br><span class=\"line\"><span class=\"comment\">// returns</span></span><br><span class=\"line\"><span class=\"string\">'/foo/bar/baz/asdf'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 路径联合 path.join([path1], [path2], [...])</span></span><br><span class=\"line\"><span class=\"comment\">* 特点：将所有名称用path.seq串联起来，然后用normailze格式化</span></span><br><span class=\"line\"><span class=\"comment\">* */</span></span><br><span class=\"line\">path.join(<span class=\"string\">'///foo'</span>, <span class=\"string\">'bar'</span>, <span class=\"string\">'//baz/asdf'</span>, <span class=\"string\">'quux'</span>, <span class=\"string\">'..'</span>);</span><br><span class=\"line\"><span class=\"comment\">// returns</span></span><br><span class=\"line\"><span class=\"string\">'/foo/bar/baz/asdf'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 路径寻航 path.resolve([from ...], to)</span></span><br><span class=\"line\"><span class=\"comment\">* 特点：相当于不断的调用系统的cd命令</span></span><br><span class=\"line\"><span class=\"comment\">* */</span></span><br><span class=\"line\">path.resolve(<span class=\"string\">'foo/bar'</span>, <span class=\"string\">'/tmp/file/'</span>, <span class=\"string\">'..'</span>, <span class=\"string\">'a/../subfile'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 相当于终端命令：</span></span><br><span class=\"line\"><span class=\"comment\">// cd foo/bar</span></span><br><span class=\"line\"><span class=\"comment\">// cd /tmp/file/</span></span><br><span class=\"line\"><span class=\"comment\">// cd ..</span></span><br><span class=\"line\"><span class=\"comment\">// cd a/../subfile</span></span><br><span class=\"line\"><span class=\"comment\">// pwd</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 相对路径 path.relative(from, to)</span></span><br><span class=\"line\"><span class=\"comment\">* 特点：返回某个路径下相对于另一个路径的相对位置串，</span></span><br><span class=\"line\"><span class=\"comment\">* 相当于：path.resolve(from, path.relative(from, to)) == path.resolve(to)</span></span><br><span class=\"line\"><span class=\"comment\">* */</span></span><br><span class=\"line\"><span class=\"comment\">//简单理解： 地址一执行怎样的 shell 命令，到达地址二</span></span><br><span class=\"line\">path.relative(<span class=\"string\">'/data/orandea/test/aaa'</span>, <span class=\"string\">'/data/orandea/impl/bbb'</span>)</span><br><span class=\"line\"><span class=\"comment\">// returns</span></span><br><span class=\"line\"><span class=\"string\">'../../impl/bbb'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 文件夹名称 path.dirname(p)</span></span><br><span class=\"line\"><span class=\"comment\">* 特点：返回路径的上级路径</span></span><br><span class=\"line\"><span class=\"comment\">* */</span></span><br><span class=\"line\">path.dirname(<span class=\"string\">'/foo/bar/baz/asdf/quux'</span>)</span><br><span class=\"line\"><span class=\"comment\">// returns</span></span><br><span class=\"line\"><span class=\"string\">'/foo/bar/baz/asdf'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 文件名称 path.basename(p, [ext])</span></span><br><span class=\"line\"><span class=\"comment\">* 特点：返回指定的文件名，返回结果可去掉[ext]后缀字符串</span></span><br><span class=\"line\"><span class=\"comment\">* */</span></span><br><span class=\"line\">path.basename(<span class=\"string\">'/foo/bar/baz/asdf/quux.html'</span>)</span><br><span class=\"line\"><span class=\"comment\">// returns</span></span><br><span class=\"line\"><span class=\"string\">'quux.html'</span></span><br><span class=\"line\"></span><br><span class=\"line\">path.basename(<span class=\"string\">'/foo/bar/baz/asdf/quux.html'</span>, <span class=\"string\">'.html'</span>)</span><br><span class=\"line\"><span class=\"comment\">// returns</span></span><br><span class=\"line\"><span class=\"string\">'quux'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 扩展名称 path.extname(p)</span></span><br><span class=\"line\"><span class=\"comment\">* 特点：返回指定文件名的扩展名称</span></span><br><span class=\"line\"><span class=\"comment\">* */</span></span><br><span class=\"line\">path.extname(<span class=\"string\">'index.html'</span>)</span><br><span class=\"line\"><span class=\"comment\">// returns</span></span><br><span class=\"line\"><span class=\"string\">'.html'</span></span><br><span class=\"line\"></span><br><span class=\"line\">path.extname(<span class=\"string\">'index.'</span>)</span><br><span class=\"line\"><span class=\"comment\">// returns</span></span><br><span class=\"line\"><span class=\"string\">'.'</span></span><br><span class=\"line\"></span><br><span class=\"line\">path.extname(<span class=\"string\">'index'</span>)</span><br><span class=\"line\"><span class=\"comment\">// returns</span></span><br><span class=\"line\"><span class=\"string\">''</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 路径分隔符 path.sep</span></span><br><span class=\"line\"><span class=\"comment\">* 特点：获取文件路径的分隔符，主要是与操作系统相关</span></span><br><span class=\"line\"><span class=\"comment\">* 注意调用方式</span></span><br><span class=\"line\"><span class=\"comment\">* */</span></span><br><span class=\"line\"><span class=\"string\">'foo/bar/baz'</span>.split(path.sep)</span><br><span class=\"line\"><span class=\"comment\">// returns</span></span><br><span class=\"line\">[<span class=\"string\">'foo'</span>, <span class=\"string\">'bar'</span>, <span class=\"string\">'baz'</span>]</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>今天学习了 Node.js 的缓冲区（Buffer）、文件系统（fs）、路径（path）模块，感受了一下 Node.js 作为 JavaScript 的扩展在后台方面的一些功能。给我最多的感受是，大量的异步代码和回调函数，让 Node.js 性能非常出色。来总结下今天学习的内容吧。<br>","more":"</p>\n<h3 id=\"缓冲区-Buffer\"><a href=\"#缓冲区-Buffer\" class=\"headerlink\" title=\"缓冲区 (Buffer)\"></a>缓冲区 (Buffer)</h3><p>JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。但在处理像 TCP 流或文件流时，必须使用到二进制数据。因此在 Node.js 中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。按照我的理解，Buffer 类很像我们的整数数组。有对应的索引，存储方式也和数组类似。来看看 Buffer 类是如何创建的。</p>\n<h4 id=\"创建-Buffer-类\"><a href=\"#创建-Buffer-类\" class=\"headerlink\" title=\"创建 Buffer 类\"></a>创建 Buffer 类</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法1</span></span><br><span class=\"line\"><span class=\"comment\">// 创建长度为10字节的 Buffer 类</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> buf = <span class=\"keyword\">new</span> Buffer(<span class=\"number\">10</span>); <span class=\"comment\">// 构造函数，注意这种创建形式</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法2</span></span><br><span class=\"line\"><span class=\"comment\">// 直接通过数组赋值的形式创建</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> buf2 = <span class=\"keyword\">new</span> Buffer([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法3</span></span><br><span class=\"line\"><span class=\"comment\">// 通过字符串来创建</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> buf3 = <span class=\"keyword\">new</span> Buffer(<span class=\"string\">'ifyour'</span>,<span class=\"string\">'utf-8'</span>);<span class=\"comment\">// utf-8 默认编码，可以省略</span></span><br></pre></td></tr></table></figure>\n<p>从代码我们可以看出这个 Buffer 类是一个构造函数，通过实例化一个 Buffer 对象，让它具有一些 Buffer 类的方法，总得来说常用的方法有下面三种。</p>\n<h4 id=\"写入缓冲区\"><a href=\"#写入缓冲区\" class=\"headerlink\" title=\"写入缓冲区\"></a>写入缓冲区</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 语法：  buf.write(string[, offset[, length]][, encoding])</span></span><br><span class=\"line\"><span class=\"comment\">// 实例：</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b4 = <span class=\"keyword\">new</span> Buffer(<span class=\"number\">14</span>);</span><br><span class=\"line\">len = b4.write(<span class=\"string\">'this is buffer'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Buffer 写入了 '</span> + len + <span class=\"string\">' 字节，内容为：'</span> + b4.toString());</span><br><span class=\"line\"><span class=\"comment\">// Buffer 写入了 14字节，内容为：this is buffer</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"缓冲区读取\"><a href=\"#缓冲区读取\" class=\"headerlink\" title=\"缓冲区读取\"></a>缓冲区读取</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 语法： buf.toString([encoding[, start[, end]]])</span></span><br><span class=\"line\"><span class=\"comment\">// 实例：</span></span><br><span class=\"line\">buf = <span class=\"keyword\">new</span> Buffer(<span class=\"number\">26</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">26</span> ; i++) &#123;</span><br><span class=\"line\">  buf[i] = i + <span class=\"number\">97</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( buf.toString(<span class=\"string\">'ascii'</span>));       <span class=\"comment\">// 输出: abcdefghijklmnopqrstuvwxyz</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( buf.toString(<span class=\"string\">'ascii'</span>,<span class=\"number\">0</span>,<span class=\"number\">5</span>));   <span class=\"comment\">// 输出: abcde</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( buf.toString(<span class=\"string\">'utf8'</span>,<span class=\"number\">0</span>,<span class=\"number\">5</span>));    <span class=\"comment\">// 输出: abcde</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( buf.toString(<span class=\"literal\">undefined</span>,<span class=\"number\">0</span>,<span class=\"number\">5</span>)); <span class=\"comment\">// 使用 'utf8' 编码, 并输出: abcde</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"缓冲区拷贝\"><a href=\"#缓冲区拷贝\" class=\"headerlink\" title=\"缓冲区拷贝\"></a>缓冲区拷贝</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//语法： buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]])</span></span><br><span class=\"line\"><span class=\"comment\">//实例：</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b5 = <span class=\"keyword\">new</span> Buffer([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>]);</span><br><span class=\"line\"><span class=\"keyword\">var</span> b6 = <span class=\"keyword\">new</span>  Buffer(<span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">b5.copy(b6,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">2</span>);<span class=\"comment\">// 把 b5 中的索引 0-2 （不包括2） 的值复制给 b6 的第 1 位置</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b6);</span><br></pre></td></tr></table></figure>\n<h3 id=\"文件系统-fs\"><a href=\"#文件系统-fs\" class=\"headerlink\" title=\"文件系统 (fs)\"></a>文件系统 (fs)</h3><p>Node.js 文件系统（fs 模块）模块中的方法均有异步和同步版本，例如读取文件内容的函数有异步的 <code>fs.readFile()</code> 和同步的 <code>fs.readFileSync()</code>。异步的方法函数最后一个参数为回调函数，回调函数的第一个参数包含了错误信息 (error)。相比同步，异步效率更高，性能更好，没有阻塞，但是在实际使用中，一定要处理好先后顺序。</p>\n<h4 id=\"文件读写方式\"><a href=\"#文件读写方式\" class=\"headerlink\" title=\"文件读写方式\"></a>文件读写方式</h4><p>文件读取方式，举个简单例子，好比先把整个数据源完整拿出来放到内存中，再使用 <code>writeFile</code> 方法或 <code>writeFileSync</code> 方法写入文件内容。显然，如果数据源非常大（10GB）使用这种方式，效率就很低了。说不定就死机了。:) 这时候，就需要下一节讲到的 <strong><em>流读取</em></strong>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// data.txt</span><br><span class=\"line\">Hello,Node.js!</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">\"fs\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 异步读取</span></span><br><span class=\"line\">fs.readFile(<span class=\"string\">'data.txt'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, data</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"built_in\">console</span>.error(err);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(<span class=\"string\">\"异步读取: \"</span> + data.toString());</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 同步读取</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> data = fs.readFileSync(<span class=\"string\">'data.txt'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"同步读取: \"</span> + data.toString());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"程序执行完毕。\"</span>);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">同步读取: Hello,Node.js!</span><br><span class=\"line\">程序执行完毕。</span><br><span class=\"line\"></span><br><span class=\"line\">异步读取: Hello,Node.js!</span><br></pre></td></tr></table></figure>\n<div class=\"tip\"><br>Node.js 中，先执行同步代码，后执行异步代码，异步代码会将回调函数放入调用 <strong><em>队列</em></strong>，以 <strong><em>先进先出</em></strong> 的形式依次调用。<br></div>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 异步写入</span></span><br><span class=\"line\">fs.writeFile(<span class=\"string\">'./data/d2.txt'</span>,<span class=\"string\">'我是一条数据'</span>,<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!err)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'文件写入成功'</span>);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'写入失败'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 同步写入</span></span><br><span class=\"line\">fs.writeFileSync(<span class=\"string\">'./data/d3'</span>,<span class=\"string\">'我是一条数据'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> data = fs.readFileSync(<span class=\"string\">'./data/d3'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(data.toString());<span class=\"comment\">// 我是一条数据</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"流读写方式\"><a href=\"#流读写方式\" class=\"headerlink\" title=\"流读写方式\"></a>流读写方式</h4><p>应用程序中，流是一组有序的、有起点和终点的 <strong><em>字节数据的传输方式</em></strong>。在应用程序中各种对象之间交换与传输数据的时候，总是先将该对象中所包含的数据转换为各种形式的流数据（即字节数据），再通过流的传输，到达目的对象后再将流数据转换为该对象中可以使用的数据。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> data = <span class=\"string\">''</span>;</span><br><span class=\"line\"><span class=\"comment\">// 流读取</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> stream = fs.createReadStream(<span class=\"string\">'./data/d1.txt'</span>,<span class=\"string\">'utf-8'</span>);</span><br><span class=\"line\">stream.on(<span class=\"string\">'data'</span>,<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">result</span>) </span>&#123;</span><br><span class=\"line\">    data += result;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// data end 事件表示连贯的行为，字节流需要起点和终点。</span></span><br><span class=\"line\">stream.on(<span class=\"string\">'end'</span>,<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">stream.on(<span class=\"string\">'error'</span>,<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err.stack);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 流写入</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> stream = fs.createWriteStream(<span class=\"string\">'./data/123.txt'</span>,<span class=\"string\">'utf-8'</span>);</span><br><span class=\"line\">stream.write(<span class=\"string\">'hello'</span>,<span class=\"string\">'utf-8'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">stream.end();</span><br><span class=\"line\"></span><br><span class=\"line\">stream.on(<span class=\"string\">'finish'</span>,<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;<span class=\"comment\">// finish 事件触发，必须等 end 事件结束才可以</span></span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(<span class=\"string\">'写入完成！'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">stream.on(<span class=\"string\">'error'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err.stack);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<div class=\"tip\"><br>流读取会依次触发事件： data -&gt; end -&gt; error ,每个事件发生会有对应的回调函数处理。<br>流写入会依次触发事件： end -&gt; finish -&gt; error ,每个事件发生会有对应的回调函数处理。<br></div>\n\n<h4 id=\"管道流读写\"><a href=\"#管道流读写\" class=\"headerlink\" title=\"管道流读写\"></a>管道流读写</h4><p>管道(pipe) 提供了一个输出流到输入流的机制。通常我们用于从一个流中获取数据并将数据传递到另外一个流中。通过管道，我们就可以实现大文件流入另外一个文件的复制过程。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> readStream = fs.createReadStream(<span class=\"string\">'./data/d1.txt'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> writeStrem = fs.createWriteStream(<span class=\"string\">'./data/d3.txt'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">readStream.pipe(writeStrem);<span class=\"comment\">// 实现了 d1.txt 到 d3.txt 的传输过程</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"链式流读写\"><a href=\"#链式流读写\" class=\"headerlink\" title=\"链式流读写\"></a>链式流读写</h4><p>链式是通过连接输出流到另外一个流并创建多个对个流操作链的机制。链式流一般用于管道操作。接下来我们就是用管道和链式来压缩和解压文件。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// compress.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> zlib = <span class=\"built_in\">require</span>(<span class=\"string\">'zlib'</span>); <span class=\"comment\">// 引入压缩模块</span></span><br><span class=\"line\"></span><br><span class=\"line\">fs.createReadStream(<span class=\"string\">'./data/123.txt'</span>)</span><br><span class=\"line\">    .pipe(zlib.createGzip())</span><br><span class=\"line\">    .pipe(fs.createWriteStream(<span class=\"string\">'./data/123.txt.gz'</span>));<span class=\"comment\">// 链式操作</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'文件压缩完成'</span>);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"文件、文件夹删除\"><a href=\"#文件、文件夹删除\" class=\"headerlink\" title=\"文件、文件夹删除\"></a>文件、文件夹删除</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">\"fs\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// 文件目录读取，返回一个数组，包含文件及文件夹</span></span><br><span class=\"line\">fs.readdir(<span class=\"string\">\"./testdir\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err,files</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!err)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(files);<span class=\"comment\">// [ 'index.html', 'main.css', 'subdir' ]</span></span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 文件删除</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"准备删除文件！\"</span>);</span><br><span class=\"line\">fs.unlink(<span class=\"string\">'./data/123.txt.gz'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> err;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"文件删除成功！\"</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 空文件夹删除</span></span><br><span class=\"line\">fs.rmdir(<span class=\"string\">'./data'</span>,<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!err)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'删除成功！'</span>);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>一个递归删除的小练习，把前面的综合运用一下。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">delDir(<span class=\"string\">'./testdir'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 传入一个文件夹路径，删除掉该文件夹所有内容</span></span><br><span class=\"line\"><span class=\"comment\">// @param pathStr string 传入一个路径</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">delDir</span>(<span class=\"params\">pathStr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fs.existsSync(pathStr))&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> files = fs.readdirSync(pathStr);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; files.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> curPath = pathStr + <span class=\"string\">'/'</span> + files[i];</span><br><span class=\"line\">            <span class=\"keyword\">var</span> stats = fs.statSync(curPath);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (stats.isFile())&#123;</span><br><span class=\"line\">                fs.unlink(curPath);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(stats.isDirectory())&#123;</span><br><span class=\"line\">                delDir(curPath);<span class=\"comment\">// 递归调用，最终删除掉所有文件，只剩空目录</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        fs.rmdirSync(pathStr);<span class=\"comment\">// 收尾，删掉空目录</span></span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'文件夹不存在'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<div class=\"tip\"><br>文件、文件夹的操作，都有同步和异步的代码，比如 <code>fs.unlink()</code> 和 <code>fs.unlinkSync()</code>,默认都是异步代码，异步代码会调用回调函数进行操作，同步代码会返回一个对象，进行后续的操作，可以认真观察上面代码的区别。使用异步代码的时候，一定注意执行顺序。<br></div>\n\n\n<h3 id=\"路径-path\"><a href=\"#路径-path\" class=\"headerlink\" title=\"路径 (path)\"></a>路径 (path)</h3><p>path 模块包含一套用于 <strong><em>处理和转换文件路径</em></strong> 的工具集，用于处理目录的对象，提高开发效率。用 Node.js 的 path 命令，与使用 Linux 下的 shell 脚本命令相似。几乎所有的方法仅对字符串进行转换，文件系统是不会检查路径是否真实有效。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引入path对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 格式化路径  path.normalize(p)</span></span><br><span class=\"line\"><span class=\"comment\">* 特点：将不符合规范的路径格式化，简化开发人员中处理各种复杂的路径判断</span></span><br><span class=\"line\"><span class=\"comment\">* */</span></span><br><span class=\"line\">path.normalize(<span class=\"string\">'/foo/bar//baz/asdf/quux/..'</span>);</span><br><span class=\"line\"><span class=\"comment\">// returns</span></span><br><span class=\"line\"><span class=\"string\">'/foo/bar/baz/asdf'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 路径联合 path.join([path1], [path2], [...])</span></span><br><span class=\"line\"><span class=\"comment\">* 特点：将所有名称用path.seq串联起来，然后用normailze格式化</span></span><br><span class=\"line\"><span class=\"comment\">* */</span></span><br><span class=\"line\">path.join(<span class=\"string\">'///foo'</span>, <span class=\"string\">'bar'</span>, <span class=\"string\">'//baz/asdf'</span>, <span class=\"string\">'quux'</span>, <span class=\"string\">'..'</span>);</span><br><span class=\"line\"><span class=\"comment\">// returns</span></span><br><span class=\"line\"><span class=\"string\">'/foo/bar/baz/asdf'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 路径寻航 path.resolve([from ...], to)</span></span><br><span class=\"line\"><span class=\"comment\">* 特点：相当于不断的调用系统的cd命令</span></span><br><span class=\"line\"><span class=\"comment\">* */</span></span><br><span class=\"line\">path.resolve(<span class=\"string\">'foo/bar'</span>, <span class=\"string\">'/tmp/file/'</span>, <span class=\"string\">'..'</span>, <span class=\"string\">'a/../subfile'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 相当于终端命令：</span></span><br><span class=\"line\"><span class=\"comment\">// cd foo/bar</span></span><br><span class=\"line\"><span class=\"comment\">// cd /tmp/file/</span></span><br><span class=\"line\"><span class=\"comment\">// cd ..</span></span><br><span class=\"line\"><span class=\"comment\">// cd a/../subfile</span></span><br><span class=\"line\"><span class=\"comment\">// pwd</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 相对路径 path.relative(from, to)</span></span><br><span class=\"line\"><span class=\"comment\">* 特点：返回某个路径下相对于另一个路径的相对位置串，</span></span><br><span class=\"line\"><span class=\"comment\">* 相当于：path.resolve(from, path.relative(from, to)) == path.resolve(to)</span></span><br><span class=\"line\"><span class=\"comment\">* */</span></span><br><span class=\"line\"><span class=\"comment\">//简单理解： 地址一执行怎样的 shell 命令，到达地址二</span></span><br><span class=\"line\">path.relative(<span class=\"string\">'/data/orandea/test/aaa'</span>, <span class=\"string\">'/data/orandea/impl/bbb'</span>)</span><br><span class=\"line\"><span class=\"comment\">// returns</span></span><br><span class=\"line\"><span class=\"string\">'../../impl/bbb'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 文件夹名称 path.dirname(p)</span></span><br><span class=\"line\"><span class=\"comment\">* 特点：返回路径的上级路径</span></span><br><span class=\"line\"><span class=\"comment\">* */</span></span><br><span class=\"line\">path.dirname(<span class=\"string\">'/foo/bar/baz/asdf/quux'</span>)</span><br><span class=\"line\"><span class=\"comment\">// returns</span></span><br><span class=\"line\"><span class=\"string\">'/foo/bar/baz/asdf'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 文件名称 path.basename(p, [ext])</span></span><br><span class=\"line\"><span class=\"comment\">* 特点：返回指定的文件名，返回结果可去掉[ext]后缀字符串</span></span><br><span class=\"line\"><span class=\"comment\">* */</span></span><br><span class=\"line\">path.basename(<span class=\"string\">'/foo/bar/baz/asdf/quux.html'</span>)</span><br><span class=\"line\"><span class=\"comment\">// returns</span></span><br><span class=\"line\"><span class=\"string\">'quux.html'</span></span><br><span class=\"line\"></span><br><span class=\"line\">path.basename(<span class=\"string\">'/foo/bar/baz/asdf/quux.html'</span>, <span class=\"string\">'.html'</span>)</span><br><span class=\"line\"><span class=\"comment\">// returns</span></span><br><span class=\"line\"><span class=\"string\">'quux'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 扩展名称 path.extname(p)</span></span><br><span class=\"line\"><span class=\"comment\">* 特点：返回指定文件名的扩展名称</span></span><br><span class=\"line\"><span class=\"comment\">* */</span></span><br><span class=\"line\">path.extname(<span class=\"string\">'index.html'</span>)</span><br><span class=\"line\"><span class=\"comment\">// returns</span></span><br><span class=\"line\"><span class=\"string\">'.html'</span></span><br><span class=\"line\"></span><br><span class=\"line\">path.extname(<span class=\"string\">'index.'</span>)</span><br><span class=\"line\"><span class=\"comment\">// returns</span></span><br><span class=\"line\"><span class=\"string\">'.'</span></span><br><span class=\"line\"></span><br><span class=\"line\">path.extname(<span class=\"string\">'index'</span>)</span><br><span class=\"line\"><span class=\"comment\">// returns</span></span><br><span class=\"line\"><span class=\"string\">''</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 路径分隔符 path.sep</span></span><br><span class=\"line\"><span class=\"comment\">* 特点：获取文件路径的分隔符，主要是与操作系统相关</span></span><br><span class=\"line\"><span class=\"comment\">* 注意调用方式</span></span><br><span class=\"line\"><span class=\"comment\">* */</span></span><br><span class=\"line\"><span class=\"string\">'foo/bar/baz'</span>.split(path.sep)</span><br><span class=\"line\"><span class=\"comment\">// returns</span></span><br><span class=\"line\">[<span class=\"string\">'foo'</span>, <span class=\"string\">'bar'</span>, <span class=\"string\">'baz'</span>]</span><br></pre></td></tr></table></figure></p>"},{"title":"Node.JS 学习笔记 [04] -- HTTP","date":"2015-01-05T07:05:10.000Z","comments":0,"_content":"\n本次的学习内容是 Node.js Web 模块，介绍了什么是 web 服务器，以及常见的几种模式，比如 B/S 模式（Browser/Server，浏览器/服务器模式），C/S 模式（Client/Server，客户端/服务器模式）等。Web 客户端通过使用 HTTP 协议就能访问到 Web 服务器上的数据，Web 服务器响应客户端的请求。\n<!-- more -->\n### HTTP\n#### HTTP 协议\n***HTTP***  协议是 Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网服务器传输超文本到本地浏览器的传送协议。用于定义 Web 浏览器与 Web 服务器之间交换数据的过程以及数据本身的格式。\n\n简单理解其实就是一种规范，以何种方式请求，以何种方式应答。特点嘛，***一次请求（Request）对应一次响应（Response）***。来看一个简单例子，访问 Google 首页的请求和应答。\n![](http://ww3.sinaimg.cn/large/6057861cgw1fbb9dlv1ylj20xy0ts7ct.jpg)\n\n在第一栏 General 中可以看到本次的请求目标，来解释一下这几个参数代表啥意思。\n\n- Request URL:https://www.google.com/  请求的 URL，这里我们访问的是 Google 首页。\n- Request Method:GET 请求方式，这里采用的是 GET 方式请求。\n- Status Code:200  状态码200 ，表示 OK。\n- Remote Address:127.0.0.1:1080 这里表示请求的远端 IP 地址及端口，因为我是科学上网，这里才显示了一个回路地址。\n\n#### Node.js 搭建 http 服务器\nNode.js 提供了 http 模块，使用 HTTP 服务器或客户端功能必须调用 http 模块，Node.js 搭建一个 http 服务器非常简单，只需要几行代码，来看看把。:P\n```js\n// 引入 http 模块\nvar http = require('http');\n\n// 创建服务，回调函数处理请求（Request）和响应（Response），监听8080端口\nhttp.createServer(function (req, res) {\n    res.write('hello,world!');\n    res.end();\n}).listen(8080, function () {\n    console.log('Server running at http://127.0.0.1:8080/');\n});\n```\n打开浏览器，输入 http://127.0.0.1:8080/ 就可以看到刚刚创建的服务成功啦。\n![](http://ww4.sinaimg.cn/large/6057861cgw1fbbabbplavj20tg08mmyp.jpg)\n\n#### HTTP 响应内容\n问题来了，那么如何根据不同的 URL 来响应不同的内容呢？答案很简单，http 服务器在处理 URL 的时候，会根据 URL 的参数来分辨不同的请求内容，根据请求的内容来响应与之对应的内容。一个完整的 URL 长这个样子。\n```Text\nscheme://host.domain:port/path/filename?queryName=queryValue\n```\n- scheme：定义服务类型，常见的如 http\n- host：定义域主机，http 通常是 www\n- domain：定义域名，比如 google.com\n- :port：定义主机的端口号，默认是80\n- path：定义路径，省略 `/` 表示根目录\n- filename：定义文件名\n- ?queryName=queryValue：查询字符串\n\n可以看出，想要响应不同的内容，就需要分析出 URL 中的 `path` 和 `filename` 以及对应的查询字符串。来看个简单的例子。\n```js\nvar http = require('http');\nvar fs = require('fs');\nvar url = require('url');// 引入 url 模块用于处理地址\nvar querystring = require('querystring'); // 引入 querystring 模块\n\nhttp.createServer(function (req, res) {\n    // 首页\n    var path = url.parse(req.url).pathname;\n    if (path == '/') {\n        fs.readFile('./html/index.html', 'utf-8', function (err, result) {\n            if (!err) {\n                res.write(result);\n                res.end();\n            }\n        });\n    }\n    // 登录\n    if (path == '/login'){\n        //{...}\n    }\n    // 登录验证\n    if (path == '/checkLogin') {\n        var queryObj = querystring.parse(url.parse(req.url).query);\n        // querystring.parse() 把查询字符串转成对象，{ usr: 'admin', pwd: '123' }\n        if (queryObj.usr == 'admin' && queryObj.pwd == '123') {\n            res.write('Login Success!');\n            res.end();\n        }\n    }\n}).listen(8080, function () {\n    console.log('Server running at http://127.0.0.1:8080/');\n});\n```\n\n#### HTTP 响应状态码\nHTTP 状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP 状态码共分为5种类型：\n\n|分类   |分类描述                                   |\n|:-----|:------------------------------------------|\n|1**   |信息，服务器收到请求，需要请求者继续执行操作   |\n|2**   |成功，操作被成功接收并处理                   |\n|3**   |重定向，需要进一步的操作以完成请求            |\n|4**   |客户端错误，请求包含语法错误或无法完成请求     |\n|5**   |服务器错误，服务器在处理请求的过程中发生了错误 |\n\n需要记住常见的几种就可以了，另外的可以[查手册](http://tools.jb51.net/table/http_status_code)找到非常详细的解释。\n- 200\tOK\t请求成功。一般用于 GET 与 POST 请求。\n- 304\tNot Modified\t未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。\n- 404\tNot Found\t服务器无法根据客户端的请求找到资源（网页）。\n- 500\tInternal Server Error\t服务器内部错误，无法完成请求。\n\n#### HTTP 响应不同的数据类型\n服务器具有返回各种数据的能力，但是返回数据时，应告诉浏览器返回的是一个什么文件。通过 `Content-Type` 可以设置，响应的数据类型。来看个简单的例子。\n```js\nvar http = require('http');\nvar fs = require('fs');\n\nhttp.createServer(function (req, res) {\n    // 设置响应的状态码，数据类型\n    res.writeHeader('200', {'Content-Type': 'image/png;charset=utf-8'});\n    fs.readFile('./hello.png', function (err, result) {\n        if (!err) {\n            res.write(result);\n            res.end();\n        }\n    })\n}).listen(8080, function () {\n    console.log('Server running at http://127.0.0.1:8080/');\n});\n```\n可以通过 [node-mime](https://github.com/broofa/node-mime) 来查询各种文件的数据类型。先用 npm 安装。\n```bash\nnpm install mime --save\n```\n```js\nvar mime = require('mime');\n\nconsole.log(mime.lookup('test.txt'));   // text/plain\nconsole.log(mime.lookup('test.html'));  // text/html\nconsole.log(mime.lookup('test.css'));   // text/css\nconsole.log(mime.lookup('test.js'));    // application/javascript\nconsole.log(mime.lookup('test.mp3'));   // audio/mpeg\n```\n### Web 客户端数据传递\n\n#### 通过 URL 传递\n```Text\nscheme://host.domain:port/path/filename?queryName=queryValue\n```\n其中 `?queryName=queryValue` 就是通过 URL 传递的数据，举个例子：`?usr=admin&pwd=123` 就表示传递一个 `usr` 为 `admin` ，`pwd` 为 `123` 的数据到后台。\n#### 通过表单传递\n```html\n<form action=\"/user\" method=\"get\">\n    用户名：<input type=\"text\" name=\"username\"/><br/>\n    密 码：<input type=\"password\" name=\"password\"><br/>\n    <input type=\"submit\" value=\"提交\"/>\n</form>\n```\n- action：提交到服务器处理程序的url地址\n- method：提交方式有 `GET` 和 `POST`\n- GET：会把表单数据作为 URL 的一部分显示在地址栏中，URL 长度有限制不能提交大量数据\n- POST：会把表单数据放到 HTTP 请求体中，相对安全，而且可以提交大量数据（比如文件）\n\n#### 数据类型\n前面讲了，在服务器端，返回给浏览器数据时，会通过 `Content-Type` 指定数据类型，同样的，浏览器向服务器传递数据时，也需要指定数据类型。在这两种数据传递方式中，表单传递数据时，`POST` 方式，必须指定数据类型，举个简单的例子。\n```html\n<form action=\"/user\" method=\"post\" enctype=\"multipart/form-data\">\n    <input type=\"file\">\n    <input type=\"submit\" value=\"上传\">\n</form>\n```\n`enctype` 指定 POST 的数据类型，默认是 `application/x-www-form-urlencoded`，上传文件时，就需要 `multipart/form-data` 类型了。\n","source":"_posts/Node.JS-学习笔记-[04]----HTTP.md","raw":"---\ntitle: 'Node.JS 学习笔记 [04] -- HTTP'\ndate: 2015-01-05 15:05:10\ntags:\ncomments: false\n---\n\n本次的学习内容是 Node.js Web 模块，介绍了什么是 web 服务器，以及常见的几种模式，比如 B/S 模式（Browser/Server，浏览器/服务器模式），C/S 模式（Client/Server，客户端/服务器模式）等。Web 客户端通过使用 HTTP 协议就能访问到 Web 服务器上的数据，Web 服务器响应客户端的请求。\n<!-- more -->\n### HTTP\n#### HTTP 协议\n***HTTP***  协议是 Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网服务器传输超文本到本地浏览器的传送协议。用于定义 Web 浏览器与 Web 服务器之间交换数据的过程以及数据本身的格式。\n\n简单理解其实就是一种规范，以何种方式请求，以何种方式应答。特点嘛，***一次请求（Request）对应一次响应（Response）***。来看一个简单例子，访问 Google 首页的请求和应答。\n![](http://ww3.sinaimg.cn/large/6057861cgw1fbb9dlv1ylj20xy0ts7ct.jpg)\n\n在第一栏 General 中可以看到本次的请求目标，来解释一下这几个参数代表啥意思。\n\n- Request URL:https://www.google.com/  请求的 URL，这里我们访问的是 Google 首页。\n- Request Method:GET 请求方式，这里采用的是 GET 方式请求。\n- Status Code:200  状态码200 ，表示 OK。\n- Remote Address:127.0.0.1:1080 这里表示请求的远端 IP 地址及端口，因为我是科学上网，这里才显示了一个回路地址。\n\n#### Node.js 搭建 http 服务器\nNode.js 提供了 http 模块，使用 HTTP 服务器或客户端功能必须调用 http 模块，Node.js 搭建一个 http 服务器非常简单，只需要几行代码，来看看把。:P\n```js\n// 引入 http 模块\nvar http = require('http');\n\n// 创建服务，回调函数处理请求（Request）和响应（Response），监听8080端口\nhttp.createServer(function (req, res) {\n    res.write('hello,world!');\n    res.end();\n}).listen(8080, function () {\n    console.log('Server running at http://127.0.0.1:8080/');\n});\n```\n打开浏览器，输入 http://127.0.0.1:8080/ 就可以看到刚刚创建的服务成功啦。\n![](http://ww4.sinaimg.cn/large/6057861cgw1fbbabbplavj20tg08mmyp.jpg)\n\n#### HTTP 响应内容\n问题来了，那么如何根据不同的 URL 来响应不同的内容呢？答案很简单，http 服务器在处理 URL 的时候，会根据 URL 的参数来分辨不同的请求内容，根据请求的内容来响应与之对应的内容。一个完整的 URL 长这个样子。\n```Text\nscheme://host.domain:port/path/filename?queryName=queryValue\n```\n- scheme：定义服务类型，常见的如 http\n- host：定义域主机，http 通常是 www\n- domain：定义域名，比如 google.com\n- :port：定义主机的端口号，默认是80\n- path：定义路径，省略 `/` 表示根目录\n- filename：定义文件名\n- ?queryName=queryValue：查询字符串\n\n可以看出，想要响应不同的内容，就需要分析出 URL 中的 `path` 和 `filename` 以及对应的查询字符串。来看个简单的例子。\n```js\nvar http = require('http');\nvar fs = require('fs');\nvar url = require('url');// 引入 url 模块用于处理地址\nvar querystring = require('querystring'); // 引入 querystring 模块\n\nhttp.createServer(function (req, res) {\n    // 首页\n    var path = url.parse(req.url).pathname;\n    if (path == '/') {\n        fs.readFile('./html/index.html', 'utf-8', function (err, result) {\n            if (!err) {\n                res.write(result);\n                res.end();\n            }\n        });\n    }\n    // 登录\n    if (path == '/login'){\n        //{...}\n    }\n    // 登录验证\n    if (path == '/checkLogin') {\n        var queryObj = querystring.parse(url.parse(req.url).query);\n        // querystring.parse() 把查询字符串转成对象，{ usr: 'admin', pwd: '123' }\n        if (queryObj.usr == 'admin' && queryObj.pwd == '123') {\n            res.write('Login Success!');\n            res.end();\n        }\n    }\n}).listen(8080, function () {\n    console.log('Server running at http://127.0.0.1:8080/');\n});\n```\n\n#### HTTP 响应状态码\nHTTP 状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP 状态码共分为5种类型：\n\n|分类   |分类描述                                   |\n|:-----|:------------------------------------------|\n|1**   |信息，服务器收到请求，需要请求者继续执行操作   |\n|2**   |成功，操作被成功接收并处理                   |\n|3**   |重定向，需要进一步的操作以完成请求            |\n|4**   |客户端错误，请求包含语法错误或无法完成请求     |\n|5**   |服务器错误，服务器在处理请求的过程中发生了错误 |\n\n需要记住常见的几种就可以了，另外的可以[查手册](http://tools.jb51.net/table/http_status_code)找到非常详细的解释。\n- 200\tOK\t请求成功。一般用于 GET 与 POST 请求。\n- 304\tNot Modified\t未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。\n- 404\tNot Found\t服务器无法根据客户端的请求找到资源（网页）。\n- 500\tInternal Server Error\t服务器内部错误，无法完成请求。\n\n#### HTTP 响应不同的数据类型\n服务器具有返回各种数据的能力，但是返回数据时，应告诉浏览器返回的是一个什么文件。通过 `Content-Type` 可以设置，响应的数据类型。来看个简单的例子。\n```js\nvar http = require('http');\nvar fs = require('fs');\n\nhttp.createServer(function (req, res) {\n    // 设置响应的状态码，数据类型\n    res.writeHeader('200', {'Content-Type': 'image/png;charset=utf-8'});\n    fs.readFile('./hello.png', function (err, result) {\n        if (!err) {\n            res.write(result);\n            res.end();\n        }\n    })\n}).listen(8080, function () {\n    console.log('Server running at http://127.0.0.1:8080/');\n});\n```\n可以通过 [node-mime](https://github.com/broofa/node-mime) 来查询各种文件的数据类型。先用 npm 安装。\n```bash\nnpm install mime --save\n```\n```js\nvar mime = require('mime');\n\nconsole.log(mime.lookup('test.txt'));   // text/plain\nconsole.log(mime.lookup('test.html'));  // text/html\nconsole.log(mime.lookup('test.css'));   // text/css\nconsole.log(mime.lookup('test.js'));    // application/javascript\nconsole.log(mime.lookup('test.mp3'));   // audio/mpeg\n```\n### Web 客户端数据传递\n\n#### 通过 URL 传递\n```Text\nscheme://host.domain:port/path/filename?queryName=queryValue\n```\n其中 `?queryName=queryValue` 就是通过 URL 传递的数据，举个例子：`?usr=admin&pwd=123` 就表示传递一个 `usr` 为 `admin` ，`pwd` 为 `123` 的数据到后台。\n#### 通过表单传递\n```html\n<form action=\"/user\" method=\"get\">\n    用户名：<input type=\"text\" name=\"username\"/><br/>\n    密 码：<input type=\"password\" name=\"password\"><br/>\n    <input type=\"submit\" value=\"提交\"/>\n</form>\n```\n- action：提交到服务器处理程序的url地址\n- method：提交方式有 `GET` 和 `POST`\n- GET：会把表单数据作为 URL 的一部分显示在地址栏中，URL 长度有限制不能提交大量数据\n- POST：会把表单数据放到 HTTP 请求体中，相对安全，而且可以提交大量数据（比如文件）\n\n#### 数据类型\n前面讲了，在服务器端，返回给浏览器数据时，会通过 `Content-Type` 指定数据类型，同样的，浏览器向服务器传递数据时，也需要指定数据类型。在这两种数据传递方式中，表单传递数据时，`POST` 方式，必须指定数据类型，举个简单的例子。\n```html\n<form action=\"/user\" method=\"post\" enctype=\"multipart/form-data\">\n    <input type=\"file\">\n    <input type=\"submit\" value=\"上传\">\n</form>\n```\n`enctype` 指定 POST 的数据类型，默认是 `application/x-www-form-urlencoded`，上传文件时，就需要 `multipart/form-data` 类型了。\n","slug":"Node.JS-学习笔记-[04]----HTTP","published":1,"updated":"2018-06-17T09:49:30.000Z","layout":"post","photos":[],"link":"","_id":"cjiitidiv000du4q9g3wavmtu","content":"<p>本次的学习内容是 Node.js Web 模块，介绍了什么是 web 服务器，以及常见的几种模式，比如 B/S 模式（Browser/Server，浏览器/服务器模式），C/S 模式（Client/Server，客户端/服务器模式）等。Web 客户端通过使用 HTTP 协议就能访问到 Web 服务器上的数据，Web 服务器响应客户端的请求。<br><a id=\"more\"></a></p>\n<h3 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h3><h4 id=\"HTTP-协议\"><a href=\"#HTTP-协议\" class=\"headerlink\" title=\"HTTP 协议\"></a>HTTP 协议</h4><p><strong><em>HTTP</em></strong>  协议是 Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网服务器传输超文本到本地浏览器的传送协议。用于定义 Web 浏览器与 Web 服务器之间交换数据的过程以及数据本身的格式。</p>\n<p>简单理解其实就是一种规范，以何种方式请求，以何种方式应答。特点嘛，<strong><em>一次请求（Request）对应一次响应（Response）</em></strong>。来看一个简单例子，访问 Google 首页的请求和应答。<br><img src=\"http://ww3.sinaimg.cn/large/6057861cgw1fbb9dlv1ylj20xy0ts7ct.jpg\" alt=\"\"></p>\n<p>在第一栏 General 中可以看到本次的请求目标，来解释一下这几个参数代表啥意思。</p>\n<ul>\n<li>Request URL:<a href=\"https://www.google.com/\" target=\"_blank\" rel=\"noopener\">https://www.google.com/</a>  请求的 URL，这里我们访问的是 Google 首页。</li>\n<li>Request Method:GET 请求方式，这里采用的是 GET 方式请求。</li>\n<li>Status Code:200  状态码200 ，表示 OK。</li>\n<li>Remote Address:127.0.0.1:1080 这里表示请求的远端 IP 地址及端口，因为我是科学上网，这里才显示了一个回路地址。</li>\n</ul>\n<h4 id=\"Node-js-搭建-http-服务器\"><a href=\"#Node-js-搭建-http-服务器\" class=\"headerlink\" title=\"Node.js 搭建 http 服务器\"></a>Node.js 搭建 http 服务器</h4><p>Node.js 提供了 http 模块，使用 HTTP 服务器或客户端功能必须调用 http 模块，Node.js 搭建一个 http 服务器非常简单，只需要几行代码，来看看把。:P<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引入 http 模块</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建服务，回调函数处理请求（Request）和响应（Response），监听8080端口</span></span><br><span class=\"line\">http.createServer(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">    res.write(<span class=\"string\">'hello,world!'</span>);</span><br><span class=\"line\">    res.end();</span><br><span class=\"line\">&#125;).listen(<span class=\"number\">8080</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Server running at http://127.0.0.1:8080/'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>打开浏览器，输入 <a href=\"http://127.0.0.1:8080/\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:8080/</a> 就可以看到刚刚创建的服务成功啦。<br><img src=\"http://ww4.sinaimg.cn/large/6057861cgw1fbbabbplavj20tg08mmyp.jpg\" alt=\"\"></p>\n<h4 id=\"HTTP-响应内容\"><a href=\"#HTTP-响应内容\" class=\"headerlink\" title=\"HTTP 响应内容\"></a>HTTP 响应内容</h4><p>问题来了，那么如何根据不同的 URL 来响应不同的内容呢？答案很简单，http 服务器在处理 URL 的时候，会根据 URL 的参数来分辨不同的请求内容，根据请求的内容来响应与之对应的内容。一个完整的 URL 长这个样子。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scheme://host.domain:port/path/filename?queryName=queryValue</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>scheme：定义服务类型，常见的如 http</li>\n<li>host：定义域主机，http 通常是 www</li>\n<li>domain：定义域名，比如 google.com</li>\n<li>:port：定义主机的端口号，默认是80</li>\n<li>path：定义路径，省略 <code>/</code> 表示根目录</li>\n<li>filename：定义文件名</li>\n<li>?queryName=queryValue：查询字符串</li>\n</ul>\n<p>可以看出，想要响应不同的内容，就需要分析出 URL 中的 <code>path</code> 和 <code>filename</code> 以及对应的查询字符串。来看个简单的例子。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"built_in\">require</span>(<span class=\"string\">'url'</span>);<span class=\"comment\">// 引入 url 模块用于处理地址</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> querystring = <span class=\"built_in\">require</span>(<span class=\"string\">'querystring'</span>); <span class=\"comment\">// 引入 querystring 模块</span></span><br><span class=\"line\"></span><br><span class=\"line\">http.createServer(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 首页</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> path = url.parse(req.url).pathname;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (path == <span class=\"string\">'/'</span>) &#123;</span><br><span class=\"line\">        fs.readFile(<span class=\"string\">'./html/index.html'</span>, <span class=\"string\">'utf-8'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, result</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!err) &#123;</span><br><span class=\"line\">                res.write(result);</span><br><span class=\"line\">                res.end();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 登录</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (path == <span class=\"string\">'/login'</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//&#123;...&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 登录验证</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (path == <span class=\"string\">'/checkLogin'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> queryObj = querystring.parse(url.parse(req.url).query);</span><br><span class=\"line\">        <span class=\"comment\">// querystring.parse() 把查询字符串转成对象，&#123; usr: 'admin', pwd: '123' &#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (queryObj.usr == <span class=\"string\">'admin'</span> &amp;&amp; queryObj.pwd == <span class=\"string\">'123'</span>) &#123;</span><br><span class=\"line\">            res.write(<span class=\"string\">'Login Success!'</span>);</span><br><span class=\"line\">            res.end();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;).listen(<span class=\"number\">8080</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Server running at http://127.0.0.1:8080/'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"HTTP-响应状态码\"><a href=\"#HTTP-响应状态码\" class=\"headerlink\" title=\"HTTP 响应状态码\"></a>HTTP 响应状态码</h4><p>HTTP 状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP 状态码共分为5种类型：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">分类</th>\n<th style=\"text-align:left\">分类描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">1**</td>\n<td style=\"text-align:left\">信息，服务器收到请求，需要请求者继续执行操作</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2**</td>\n<td style=\"text-align:left\">成功，操作被成功接收并处理</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3**</td>\n<td style=\"text-align:left\">重定向，需要进一步的操作以完成请求</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">4**</td>\n<td style=\"text-align:left\">客户端错误，请求包含语法错误或无法完成请求</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">5**</td>\n<td style=\"text-align:left\">服务器错误，服务器在处理请求的过程中发生了错误</td>\n</tr>\n</tbody>\n</table>\n<p>需要记住常见的几种就可以了，另外的可以<a href=\"http://tools.jb51.net/table/http_status_code\" target=\"_blank\" rel=\"noopener\">查手册</a>找到非常详细的解释。</p>\n<ul>\n<li>200    OK    请求成功。一般用于 GET 与 POST 请求。</li>\n<li>304    Not Modified    未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。</li>\n<li>404    Not Found    服务器无法根据客户端的请求找到资源（网页）。</li>\n<li>500    Internal Server Error    服务器内部错误，无法完成请求。</li>\n</ul>\n<h4 id=\"HTTP-响应不同的数据类型\"><a href=\"#HTTP-响应不同的数据类型\" class=\"headerlink\" title=\"HTTP 响应不同的数据类型\"></a>HTTP 响应不同的数据类型</h4><p>服务器具有返回各种数据的能力，但是返回数据时，应告诉浏览器返回的是一个什么文件。通过 <code>Content-Type</code> 可以设置，响应的数据类型。来看个简单的例子。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">http.createServer(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 设置响应的状态码，数据类型</span></span><br><span class=\"line\">    res.writeHeader(<span class=\"string\">'200'</span>, &#123;<span class=\"string\">'Content-Type'</span>: <span class=\"string\">'image/png;charset=utf-8'</span>&#125;);</span><br><span class=\"line\">    fs.readFile(<span class=\"string\">'./hello.png'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, result</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!err) &#123;</span><br><span class=\"line\">            res.write(result);</span><br><span class=\"line\">            res.end();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;).listen(<span class=\"number\">8080</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Server running at http://127.0.0.1:8080/'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>可以通过 <a href=\"https://github.com/broofa/node-mime\" target=\"_blank\" rel=\"noopener\">node-mime</a> 来查询各种文件的数据类型。先用 npm 安装。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install mime --save</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mime = <span class=\"built_in\">require</span>(<span class=\"string\">'mime'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(mime.lookup(<span class=\"string\">'test.txt'</span>));   <span class=\"comment\">// text/plain</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(mime.lookup(<span class=\"string\">'test.html'</span>));  <span class=\"comment\">// text/html</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(mime.lookup(<span class=\"string\">'test.css'</span>));   <span class=\"comment\">// text/css</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(mime.lookup(<span class=\"string\">'test.js'</span>));    <span class=\"comment\">// application/javascript</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(mime.lookup(<span class=\"string\">'test.mp3'</span>));   <span class=\"comment\">// audio/mpeg</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Web-客户端数据传递\"><a href=\"#Web-客户端数据传递\" class=\"headerlink\" title=\"Web 客户端数据传递\"></a>Web 客户端数据传递</h3><h4 id=\"通过-URL-传递\"><a href=\"#通过-URL-传递\" class=\"headerlink\" title=\"通过 URL 传递\"></a>通过 URL 传递</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scheme://host.domain:port/path/filename?queryName=queryValue</span><br></pre></td></tr></table></figure>\n<p>其中 <code>?queryName=queryValue</code> 就是通过 URL 传递的数据，举个例子：<code>?usr=admin&amp;pwd=123</code> 就表示传递一个 <code>usr</code> 为 <code>admin</code> ，<code>pwd</code> 为 <code>123</code> 的数据到后台。</p>\n<h4 id=\"通过表单传递\"><a href=\"#通过表单传递\" class=\"headerlink\" title=\"通过表单传递\"></a>通过表单传递</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">\"/user\"</span> <span class=\"attr\">method</span>=<span class=\"string\">\"get\"</span>&gt;</span></span><br><span class=\"line\">    用户名：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"username\"</span>/&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>/&gt;</span></span><br><span class=\"line\">    密 码：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"password\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"password\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"submit\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"提交\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>action：提交到服务器处理程序的url地址</li>\n<li>method：提交方式有 <code>GET</code> 和 <code>POST</code></li>\n<li>GET：会把表单数据作为 URL 的一部分显示在地址栏中，URL 长度有限制不能提交大量数据</li>\n<li>POST：会把表单数据放到 HTTP 请求体中，相对安全，而且可以提交大量数据（比如文件）</li>\n</ul>\n<h4 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h4><p>前面讲了，在服务器端，返回给浏览器数据时，会通过 <code>Content-Type</code> 指定数据类型，同样的，浏览器向服务器传递数据时，也需要指定数据类型。在这两种数据传递方式中，表单传递数据时，<code>POST</code> 方式，必须指定数据类型，举个简单的例子。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">\"/user\"</span> <span class=\"attr\">method</span>=<span class=\"string\">\"post\"</span> <span class=\"attr\">enctype</span>=<span class=\"string\">\"multipart/form-data\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"file\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"submit\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"上传\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p><code>enctype</code> 指定 POST 的数据类型，默认是 <code>application/x-www-form-urlencoded</code>，上传文件时，就需要 <code>multipart/form-data</code> 类型了。</p>\n","site":{"data":{}},"excerpt":"<p>本次的学习内容是 Node.js Web 模块，介绍了什么是 web 服务器，以及常见的几种模式，比如 B/S 模式（Browser/Server，浏览器/服务器模式），C/S 模式（Client/Server，客户端/服务器模式）等。Web 客户端通过使用 HTTP 协议就能访问到 Web 服务器上的数据，Web 服务器响应客户端的请求。<br>","more":"</p>\n<h3 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h3><h4 id=\"HTTP-协议\"><a href=\"#HTTP-协议\" class=\"headerlink\" title=\"HTTP 协议\"></a>HTTP 协议</h4><p><strong><em>HTTP</em></strong>  协议是 Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网服务器传输超文本到本地浏览器的传送协议。用于定义 Web 浏览器与 Web 服务器之间交换数据的过程以及数据本身的格式。</p>\n<p>简单理解其实就是一种规范，以何种方式请求，以何种方式应答。特点嘛，<strong><em>一次请求（Request）对应一次响应（Response）</em></strong>。来看一个简单例子，访问 Google 首页的请求和应答。<br><img src=\"http://ww3.sinaimg.cn/large/6057861cgw1fbb9dlv1ylj20xy0ts7ct.jpg\" alt=\"\"></p>\n<p>在第一栏 General 中可以看到本次的请求目标，来解释一下这几个参数代表啥意思。</p>\n<ul>\n<li>Request URL:<a href=\"https://www.google.com/\" target=\"_blank\" rel=\"noopener\">https://www.google.com/</a>  请求的 URL，这里我们访问的是 Google 首页。</li>\n<li>Request Method:GET 请求方式，这里采用的是 GET 方式请求。</li>\n<li>Status Code:200  状态码200 ，表示 OK。</li>\n<li>Remote Address:127.0.0.1:1080 这里表示请求的远端 IP 地址及端口，因为我是科学上网，这里才显示了一个回路地址。</li>\n</ul>\n<h4 id=\"Node-js-搭建-http-服务器\"><a href=\"#Node-js-搭建-http-服务器\" class=\"headerlink\" title=\"Node.js 搭建 http 服务器\"></a>Node.js 搭建 http 服务器</h4><p>Node.js 提供了 http 模块，使用 HTTP 服务器或客户端功能必须调用 http 模块，Node.js 搭建一个 http 服务器非常简单，只需要几行代码，来看看把。:P<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引入 http 模块</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建服务，回调函数处理请求（Request）和响应（Response），监听8080端口</span></span><br><span class=\"line\">http.createServer(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">    res.write(<span class=\"string\">'hello,world!'</span>);</span><br><span class=\"line\">    res.end();</span><br><span class=\"line\">&#125;).listen(<span class=\"number\">8080</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Server running at http://127.0.0.1:8080/'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>打开浏览器，输入 <a href=\"http://127.0.0.1:8080/\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:8080/</a> 就可以看到刚刚创建的服务成功啦。<br><img src=\"http://ww4.sinaimg.cn/large/6057861cgw1fbbabbplavj20tg08mmyp.jpg\" alt=\"\"></p>\n<h4 id=\"HTTP-响应内容\"><a href=\"#HTTP-响应内容\" class=\"headerlink\" title=\"HTTP 响应内容\"></a>HTTP 响应内容</h4><p>问题来了，那么如何根据不同的 URL 来响应不同的内容呢？答案很简单，http 服务器在处理 URL 的时候，会根据 URL 的参数来分辨不同的请求内容，根据请求的内容来响应与之对应的内容。一个完整的 URL 长这个样子。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scheme://host.domain:port/path/filename?queryName=queryValue</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>scheme：定义服务类型，常见的如 http</li>\n<li>host：定义域主机，http 通常是 www</li>\n<li>domain：定义域名，比如 google.com</li>\n<li>:port：定义主机的端口号，默认是80</li>\n<li>path：定义路径，省略 <code>/</code> 表示根目录</li>\n<li>filename：定义文件名</li>\n<li>?queryName=queryValue：查询字符串</li>\n</ul>\n<p>可以看出，想要响应不同的内容，就需要分析出 URL 中的 <code>path</code> 和 <code>filename</code> 以及对应的查询字符串。来看个简单的例子。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"built_in\">require</span>(<span class=\"string\">'url'</span>);<span class=\"comment\">// 引入 url 模块用于处理地址</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> querystring = <span class=\"built_in\">require</span>(<span class=\"string\">'querystring'</span>); <span class=\"comment\">// 引入 querystring 模块</span></span><br><span class=\"line\"></span><br><span class=\"line\">http.createServer(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 首页</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> path = url.parse(req.url).pathname;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (path == <span class=\"string\">'/'</span>) &#123;</span><br><span class=\"line\">        fs.readFile(<span class=\"string\">'./html/index.html'</span>, <span class=\"string\">'utf-8'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, result</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!err) &#123;</span><br><span class=\"line\">                res.write(result);</span><br><span class=\"line\">                res.end();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 登录</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (path == <span class=\"string\">'/login'</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//&#123;...&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 登录验证</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (path == <span class=\"string\">'/checkLogin'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> queryObj = querystring.parse(url.parse(req.url).query);</span><br><span class=\"line\">        <span class=\"comment\">// querystring.parse() 把查询字符串转成对象，&#123; usr: 'admin', pwd: '123' &#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (queryObj.usr == <span class=\"string\">'admin'</span> &amp;&amp; queryObj.pwd == <span class=\"string\">'123'</span>) &#123;</span><br><span class=\"line\">            res.write(<span class=\"string\">'Login Success!'</span>);</span><br><span class=\"line\">            res.end();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;).listen(<span class=\"number\">8080</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Server running at http://127.0.0.1:8080/'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"HTTP-响应状态码\"><a href=\"#HTTP-响应状态码\" class=\"headerlink\" title=\"HTTP 响应状态码\"></a>HTTP 响应状态码</h4><p>HTTP 状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP 状态码共分为5种类型：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">分类</th>\n<th style=\"text-align:left\">分类描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">1**</td>\n<td style=\"text-align:left\">信息，服务器收到请求，需要请求者继续执行操作</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2**</td>\n<td style=\"text-align:left\">成功，操作被成功接收并处理</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3**</td>\n<td style=\"text-align:left\">重定向，需要进一步的操作以完成请求</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">4**</td>\n<td style=\"text-align:left\">客户端错误，请求包含语法错误或无法完成请求</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">5**</td>\n<td style=\"text-align:left\">服务器错误，服务器在处理请求的过程中发生了错误</td>\n</tr>\n</tbody>\n</table>\n<p>需要记住常见的几种就可以了，另外的可以<a href=\"http://tools.jb51.net/table/http_status_code\" target=\"_blank\" rel=\"noopener\">查手册</a>找到非常详细的解释。</p>\n<ul>\n<li>200    OK    请求成功。一般用于 GET 与 POST 请求。</li>\n<li>304    Not Modified    未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。</li>\n<li>404    Not Found    服务器无法根据客户端的请求找到资源（网页）。</li>\n<li>500    Internal Server Error    服务器内部错误，无法完成请求。</li>\n</ul>\n<h4 id=\"HTTP-响应不同的数据类型\"><a href=\"#HTTP-响应不同的数据类型\" class=\"headerlink\" title=\"HTTP 响应不同的数据类型\"></a>HTTP 响应不同的数据类型</h4><p>服务器具有返回各种数据的能力，但是返回数据时，应告诉浏览器返回的是一个什么文件。通过 <code>Content-Type</code> 可以设置，响应的数据类型。来看个简单的例子。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">http.createServer(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 设置响应的状态码，数据类型</span></span><br><span class=\"line\">    res.writeHeader(<span class=\"string\">'200'</span>, &#123;<span class=\"string\">'Content-Type'</span>: <span class=\"string\">'image/png;charset=utf-8'</span>&#125;);</span><br><span class=\"line\">    fs.readFile(<span class=\"string\">'./hello.png'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, result</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!err) &#123;</span><br><span class=\"line\">            res.write(result);</span><br><span class=\"line\">            res.end();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;).listen(<span class=\"number\">8080</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Server running at http://127.0.0.1:8080/'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>可以通过 <a href=\"https://github.com/broofa/node-mime\" target=\"_blank\" rel=\"noopener\">node-mime</a> 来查询各种文件的数据类型。先用 npm 安装。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install mime --save</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mime = <span class=\"built_in\">require</span>(<span class=\"string\">'mime'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(mime.lookup(<span class=\"string\">'test.txt'</span>));   <span class=\"comment\">// text/plain</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(mime.lookup(<span class=\"string\">'test.html'</span>));  <span class=\"comment\">// text/html</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(mime.lookup(<span class=\"string\">'test.css'</span>));   <span class=\"comment\">// text/css</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(mime.lookup(<span class=\"string\">'test.js'</span>));    <span class=\"comment\">// application/javascript</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(mime.lookup(<span class=\"string\">'test.mp3'</span>));   <span class=\"comment\">// audio/mpeg</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Web-客户端数据传递\"><a href=\"#Web-客户端数据传递\" class=\"headerlink\" title=\"Web 客户端数据传递\"></a>Web 客户端数据传递</h3><h4 id=\"通过-URL-传递\"><a href=\"#通过-URL-传递\" class=\"headerlink\" title=\"通过 URL 传递\"></a>通过 URL 传递</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scheme://host.domain:port/path/filename?queryName=queryValue</span><br></pre></td></tr></table></figure>\n<p>其中 <code>?queryName=queryValue</code> 就是通过 URL 传递的数据，举个例子：<code>?usr=admin&amp;pwd=123</code> 就表示传递一个 <code>usr</code> 为 <code>admin</code> ，<code>pwd</code> 为 <code>123</code> 的数据到后台。</p>\n<h4 id=\"通过表单传递\"><a href=\"#通过表单传递\" class=\"headerlink\" title=\"通过表单传递\"></a>通过表单传递</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">\"/user\"</span> <span class=\"attr\">method</span>=<span class=\"string\">\"get\"</span>&gt;</span></span><br><span class=\"line\">    用户名：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"username\"</span>/&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>/&gt;</span></span><br><span class=\"line\">    密 码：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"password\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"password\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"submit\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"提交\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>action：提交到服务器处理程序的url地址</li>\n<li>method：提交方式有 <code>GET</code> 和 <code>POST</code></li>\n<li>GET：会把表单数据作为 URL 的一部分显示在地址栏中，URL 长度有限制不能提交大量数据</li>\n<li>POST：会把表单数据放到 HTTP 请求体中，相对安全，而且可以提交大量数据（比如文件）</li>\n</ul>\n<h4 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h4><p>前面讲了，在服务器端，返回给浏览器数据时，会通过 <code>Content-Type</code> 指定数据类型，同样的，浏览器向服务器传递数据时，也需要指定数据类型。在这两种数据传递方式中，表单传递数据时，<code>POST</code> 方式，必须指定数据类型，举个简单的例子。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">\"/user\"</span> <span class=\"attr\">method</span>=<span class=\"string\">\"post\"</span> <span class=\"attr\">enctype</span>=<span class=\"string\">\"multipart/form-data\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"file\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"submit\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"上传\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p><code>enctype</code> 指定 POST 的数据类型，默认是 <code>application/x-www-form-urlencoded</code>，上传文件时，就需要 <code>multipart/form-data</code> 类型了。</p>"},{"title":"ProxyChains-NG + ShadowSocks 实现终端代理","date":"2016-03-23T00:25:31.000Z","comments":0,"_content":"\n经常在终端下执行一些网络命令，例如 `wget` 、`git`、`ssh` 等命令，速度慢的不行，说白了，有些是因为 GFW 的原因，有些则是访问国外的服务器本来速度就很慢，而我们的 ShadowSocks 提供的是 `socks5` 代理，终端无法享用。这个时候 **ProxyChains-NG** 应势而生。\n<!-- more -->\n### 安装\n使用 [brew](http://brew.sh/index_zh-cn.html) 快速安装 ProxyChains-NG，想详细了解 ProxyChains-NG 可以去他们[项目主页](https://github.com/rofl0r/proxychains-ng)。\n```bash\nbrew install proxychains-ng\n```\n\n配置\n```bash\nvi /usr/local/etc/proxychains.conf\n```\n\n添加代理\n```bash\nsocks5  127.0.0.1 1080\n```\n\n### 使用\n到此为止，整个命令安装完成，用法 `proxychains4 需要执行的命令`。举个例子：执行下面的命令后，可以看到是 ss 的 IP 了。\n```bash\nproxychains4 curl ip.cn\n```\n\n\n### 优化\n这个命令太长了，我想换一个！我使用的是 zsh，来给 `proxychains4` 配置一个别名吧！:P\n编辑 zsh 配置文件\n```bash\nvi ~/.zshrc\n```\n\n添加别名\n```bash\nalias myss='proxychains4'\n```\n\n让配置生效\n```bash\nsource ~/.zshrc\n```\n\n再执行之前查看 ip 的命令\n```bash\nmyss curl ip.cn\n```\n\nHave done! :)\n\n### 测速\n使用 speedtest 的命令行工具，来测上行宽带和下行宽度。\n```bash\n# 下载 speedtest-cli\nwget -O speedtest-cli https://raw.githubusercontent.com/sivel/speedtest-cli/master/speedtest.py\n\n# 给执行权限\nchmod +x speedtest-cli\n\n# 运行\n./speedtest-cli\n\n# 测试下代理的速度\nmyss ./speedtest-cli\n```\n\n#### 附：brew 常用命令\n\n|命令          |含义                       |\n|:------------|:--------------------------|\n|安装包        |brew install `<PackageName>`|\n|搜索包        |brew search `<PackageName>` |\n|查询包信息    |brew info `<PackageName>`   |\n|升级指定包    |brew upgrade `<PackageName>`|\n|更新自己      |brew update                |\n|检查过时包    |brew outdated              |\n|升级所有包    |brew upgrade               |\n|清理缓存      |brew cleanup               |\n","source":"_posts/ProxyChains-NG + ShadowSocks 实现终端代理.md","raw":"---\ntitle: ProxyChains-NG + ShadowSocks 实现终端代理\ndate: 2016-03-23 08:25:31\ntags:\ncomments: false\n---\n\n经常在终端下执行一些网络命令，例如 `wget` 、`git`、`ssh` 等命令，速度慢的不行，说白了，有些是因为 GFW 的原因，有些则是访问国外的服务器本来速度就很慢，而我们的 ShadowSocks 提供的是 `socks5` 代理，终端无法享用。这个时候 **ProxyChains-NG** 应势而生。\n<!-- more -->\n### 安装\n使用 [brew](http://brew.sh/index_zh-cn.html) 快速安装 ProxyChains-NG，想详细了解 ProxyChains-NG 可以去他们[项目主页](https://github.com/rofl0r/proxychains-ng)。\n```bash\nbrew install proxychains-ng\n```\n\n配置\n```bash\nvi /usr/local/etc/proxychains.conf\n```\n\n添加代理\n```bash\nsocks5  127.0.0.1 1080\n```\n\n### 使用\n到此为止，整个命令安装完成，用法 `proxychains4 需要执行的命令`。举个例子：执行下面的命令后，可以看到是 ss 的 IP 了。\n```bash\nproxychains4 curl ip.cn\n```\n\n\n### 优化\n这个命令太长了，我想换一个！我使用的是 zsh，来给 `proxychains4` 配置一个别名吧！:P\n编辑 zsh 配置文件\n```bash\nvi ~/.zshrc\n```\n\n添加别名\n```bash\nalias myss='proxychains4'\n```\n\n让配置生效\n```bash\nsource ~/.zshrc\n```\n\n再执行之前查看 ip 的命令\n```bash\nmyss curl ip.cn\n```\n\nHave done! :)\n\n### 测速\n使用 speedtest 的命令行工具，来测上行宽带和下行宽度。\n```bash\n# 下载 speedtest-cli\nwget -O speedtest-cli https://raw.githubusercontent.com/sivel/speedtest-cli/master/speedtest.py\n\n# 给执行权限\nchmod +x speedtest-cli\n\n# 运行\n./speedtest-cli\n\n# 测试下代理的速度\nmyss ./speedtest-cli\n```\n\n#### 附：brew 常用命令\n\n|命令          |含义                       |\n|:------------|:--------------------------|\n|安装包        |brew install `<PackageName>`|\n|搜索包        |brew search `<PackageName>` |\n|查询包信息    |brew info `<PackageName>`   |\n|升级指定包    |brew upgrade `<PackageName>`|\n|更新自己      |brew update                |\n|检查过时包    |brew outdated              |\n|升级所有包    |brew upgrade               |\n|清理缓存      |brew cleanup               |\n","slug":"ProxyChains-NG + ShadowSocks 实现终端代理","published":1,"updated":"2018-06-17T09:49:30.000Z","layout":"post","photos":[],"link":"","_id":"cjiitidix000eu4q9szsucf65","content":"<p>经常在终端下执行一些网络命令，例如 <code>wget</code> 、<code>git</code>、<code>ssh</code> 等命令，速度慢的不行，说白了，有些是因为 GFW 的原因，有些则是访问国外的服务器本来速度就很慢，而我们的 ShadowSocks 提供的是 <code>socks5</code> 代理，终端无法享用。这个时候 <strong>ProxyChains-NG</strong> 应势而生。<br><a id=\"more\"></a></p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>使用 <a href=\"http://brew.sh/index_zh-cn.html\" target=\"_blank\" rel=\"noopener\">brew</a> 快速安装 ProxyChains-NG，想详细了解 ProxyChains-NG 可以去他们<a href=\"https://github.com/rofl0r/proxychains-ng\" target=\"_blank\" rel=\"noopener\">项目主页</a>。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install proxychains-ng</span><br></pre></td></tr></table></figure></p>\n<p>配置<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi /usr/<span class=\"built_in\">local</span>/etc/proxychains.conf</span><br></pre></td></tr></table></figure></p>\n<p>添加代理<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">socks5  127.0.0.1 1080</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>到此为止，整个命令安装完成，用法 <code>proxychains4 需要执行的命令</code>。举个例子：执行下面的命令后，可以看到是 ss 的 IP 了。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">proxychains4 curl ip.cn</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h3><p>这个命令太长了，我想换一个！我使用的是 zsh，来给 <code>proxychains4</code> 配置一个别名吧！:P<br>编辑 zsh 配置文件<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi ~/.zshrc</span><br></pre></td></tr></table></figure></p>\n<p>添加别名<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">alias</span> myss=<span class=\"string\">'proxychains4'</span></span><br></pre></td></tr></table></figure></p>\n<p>让配置生效<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure></p>\n<p>再执行之前查看 ip 的命令<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myss curl ip.cn</span><br></pre></td></tr></table></figure></p>\n<p>Have done! :)</p>\n<h3 id=\"测速\"><a href=\"#测速\" class=\"headerlink\" title=\"测速\"></a>测速</h3><p>使用 speedtest 的命令行工具，来测上行宽带和下行宽度。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 下载 speedtest-cli</span></span><br><span class=\"line\">wget -O speedtest-cli https://raw.githubusercontent.com/sivel/speedtest-cli/master/speedtest.py</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 给执行权限</span></span><br><span class=\"line\">chmod +x speedtest-cli</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 运行</span></span><br><span class=\"line\">./speedtest-cli</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 测试下代理的速度</span></span><br><span class=\"line\">myss ./speedtest-cli</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"附：brew-常用命令\"><a href=\"#附：brew-常用命令\" class=\"headerlink\" title=\"附：brew 常用命令\"></a>附：brew 常用命令</h4><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">命令</th>\n<th style=\"text-align:left\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">安装包</td>\n<td style=\"text-align:left\">brew install <code>&lt;PackageName&gt;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">搜索包</td>\n<td style=\"text-align:left\">brew search <code>&lt;PackageName&gt;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">查询包信息</td>\n<td style=\"text-align:left\">brew info <code>&lt;PackageName&gt;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">升级指定包</td>\n<td style=\"text-align:left\">brew upgrade <code>&lt;PackageName&gt;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">更新自己</td>\n<td style=\"text-align:left\">brew update</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">检查过时包</td>\n<td style=\"text-align:left\">brew outdated</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">升级所有包</td>\n<td style=\"text-align:left\">brew upgrade</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">清理缓存</td>\n<td style=\"text-align:left\">brew cleanup</td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"<p>经常在终端下执行一些网络命令，例如 <code>wget</code> 、<code>git</code>、<code>ssh</code> 等命令，速度慢的不行，说白了，有些是因为 GFW 的原因，有些则是访问国外的服务器本来速度就很慢，而我们的 ShadowSocks 提供的是 <code>socks5</code> 代理，终端无法享用。这个时候 <strong>ProxyChains-NG</strong> 应势而生。<br>","more":"</p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>使用 <a href=\"http://brew.sh/index_zh-cn.html\" target=\"_blank\" rel=\"noopener\">brew</a> 快速安装 ProxyChains-NG，想详细了解 ProxyChains-NG 可以去他们<a href=\"https://github.com/rofl0r/proxychains-ng\" target=\"_blank\" rel=\"noopener\">项目主页</a>。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install proxychains-ng</span><br></pre></td></tr></table></figure></p>\n<p>配置<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi /usr/<span class=\"built_in\">local</span>/etc/proxychains.conf</span><br></pre></td></tr></table></figure></p>\n<p>添加代理<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">socks5  127.0.0.1 1080</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>到此为止，整个命令安装完成，用法 <code>proxychains4 需要执行的命令</code>。举个例子：执行下面的命令后，可以看到是 ss 的 IP 了。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">proxychains4 curl ip.cn</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h3><p>这个命令太长了，我想换一个！我使用的是 zsh，来给 <code>proxychains4</code> 配置一个别名吧！:P<br>编辑 zsh 配置文件<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi ~/.zshrc</span><br></pre></td></tr></table></figure></p>\n<p>添加别名<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">alias</span> myss=<span class=\"string\">'proxychains4'</span></span><br></pre></td></tr></table></figure></p>\n<p>让配置生效<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure></p>\n<p>再执行之前查看 ip 的命令<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myss curl ip.cn</span><br></pre></td></tr></table></figure></p>\n<p>Have done! :)</p>\n<h3 id=\"测速\"><a href=\"#测速\" class=\"headerlink\" title=\"测速\"></a>测速</h3><p>使用 speedtest 的命令行工具，来测上行宽带和下行宽度。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 下载 speedtest-cli</span></span><br><span class=\"line\">wget -O speedtest-cli https://raw.githubusercontent.com/sivel/speedtest-cli/master/speedtest.py</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 给执行权限</span></span><br><span class=\"line\">chmod +x speedtest-cli</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 运行</span></span><br><span class=\"line\">./speedtest-cli</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 测试下代理的速度</span></span><br><span class=\"line\">myss ./speedtest-cli</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"附：brew-常用命令\"><a href=\"#附：brew-常用命令\" class=\"headerlink\" title=\"附：brew 常用命令\"></a>附：brew 常用命令</h4><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">命令</th>\n<th style=\"text-align:left\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">安装包</td>\n<td style=\"text-align:left\">brew install <code>&lt;PackageName&gt;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">搜索包</td>\n<td style=\"text-align:left\">brew search <code>&lt;PackageName&gt;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">查询包信息</td>\n<td style=\"text-align:left\">brew info <code>&lt;PackageName&gt;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">升级指定包</td>\n<td style=\"text-align:left\">brew upgrade <code>&lt;PackageName&gt;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">更新自己</td>\n<td style=\"text-align:left\">brew update</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">检查过时包</td>\n<td style=\"text-align:left\">brew outdated</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">升级所有包</td>\n<td style=\"text-align:left\">brew upgrade</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">清理缓存</td>\n<td style=\"text-align:left\">brew cleanup</td>\n</tr>\n</tbody>\n</table>"},{"title":"Node.JS 学习笔记 [05] -- Express","date":"2015-01-06T13:24:40.000Z","comments":0,"_content":"\n***Express*** 是一个基于 Node.js 平台的极简、灵活的 Web 应用开发框架，它提供一系列强大的特性，帮助你创建各种 Web 和移动设备应用。Express的核心特性可以概括以下三点。\n<!-- more -->\n\n- 可以设置中间件来响应 HTTP 请求。\n- 定义了路由表用于执行不同的 HTTP 请求动作。\n- 可以通过向模板传递参数来动态渲染 HTML 页面。\n\n下面学习的知识点，都会围绕这几个特性展开。\n\n### Express 安装\n#### 在项目中引入 Express\n```bash\ncd projectName              # 进入新建的 Node.js 项目\nnpm init                    # 初始化项目配置文件\nnpm install express --save  # 安装 Express 模块到项目配置文件中\n```\n通过上门的命令，就可以完成 Express 的安装，下面在 `app.js` 中使用 Express 吧！\n```js\nvar express = require('express');\nvar app = express();\n\napp.get('/', function (req, res) {\n    res.send('Hello,Express!');\n});\n\napp.listen(8080, function () {\n    console.log('Express running at http://127.0.0.1:8080/');\n});\n```\n\n#### 使用 Express-generator\n为了方便开发者，更便捷的使用 Express 生成项目，官方提供的快速的生成工具 `Express-generator`，虽然生成非常快速方便，但是作为初学者，还是要弄清楚里面每条命令所代表的含义，最后再使用官方提供的工具快速生成。打开终端，因为我是 MacOS，所以安装的时候要加上 `sudo` 否则会报错提示权限不够。\n```bash\nsudo npm install express-generator -g  # 全局安装\nexpress mywebapp                       # 创建 mywebapp 项目\ncd mywebapp && npm install             # 安装依赖文件\nnpm start                              # 启动项目\n```\n启动项目后，就可以在浏览器中预览了，访问地址：http://127.0.0.1:3000/ 。\n\n<div class=\"tip\">\n启动前需要关闭其它已经启用的 Web 服务，否则可能会导致端口占用启动不成功。\n</div>\n\n### Express 路由\n> 路由是指如何定义应用的端点（URLs）以及如何响应客户端的请求。\n\n#### 基础用法\n简单理解，其实就是根据不同的请求，来响应与之对应的页面。比如，当用户访问 http://localhost/images/ 时，根据 URL 可以看出，请求的是 `/images` 这个目录，那么通过路由，找到这个页面并返回给请求的用户，这个过程就叫路由。来看一个简单的例子。\n```js\nvar express = require('express');\nvar app = express();\n\n// 当用户请求访问 / 时，响应一个 Hello,Express! 字符串，这就是一个简单路由\napp.get('/', function (req, res) {\n    res.send('Hello,Express!');\n});\n```\n这里需要注意 `app.all()` ,它是一个特殊的路由方法，没有任何 HTTP 方法与其对应，它的作用是对于一个路径上的所有请求加载中间件。 all 相当于既可以处理 `GET`，也可以处理 `POST` 。\n\n#### Router 方法\n通过 `express.Router` 类可以创建独立模块的路由模块，它是一个可以挂载的路由对象，把路由模块分离出项目，让整个项目结构清晰、方便管理，这里光说还是挺抽象，举个例子。\n```bash\n# 目录结构\n.\n├── index.js\n├── node_modules\n│   ├── body-parser\n│   └── express\n├── package.json\n├── router\n│   ├── admin.js\n│   └── home.js\n└── views\n    ├── admin\n    └── home\n```\n```js\n// index.js\nvar express = require('express');\nvar bodyparser = require('body-parser');\n// 引入外部路由模块\nvar home = require('./router/home');\nvar admin = require('./router/admin');\nvar app = express();\n\n// 使用中间件 bodyparser ，后面可以在 req.body 中分析出 POST 请求体的内容\napp.use(bodyparser.urlencoded({extended:false}));\n\n// 使用外部路由模块\napp.use('/',home);\napp.use('/admin',admin);\n\napp.listen(8080,function () {\n   console.log('visit http://127.0.0.1:8080/');\n});\n```\n\n```js\n// admin.js\nvar express = require('express');\nvar router = express.Router();// 用 Router 构造函数实例化 router 对象\nvar path = require('path');\n\nrouter.get('/login.html', function (req, res) {\n    res.sendFile(path.resolve(__dirname + '/../views/admin/' + 'login.html'));\n});\n\nrouter.get('/user.html', function (req, res) {\n    res.sendFile(path.resolve(__dirname + '/../views/admin/' + 'user.html'));\n});\n\nrouter.post('/login.html', function (req, res) {// /admin/login.html\n    res.sendFile(path.resolve(__dirname + '/../views/admin/' + 'login.html'));\n});\n\nmodule.exports = router;// 暴露给外部调用该路由\n```\n\n### Express 响应对象\n通过响应（Response）对象，服务器可以返回一个来自客户端（浏览器）的 `Request` ,最终返回给用户的其实就是一个经过业务逻辑层处理的 `res` 对象。来了解下 Express 的响应对象吧。\n\n#### send()\nExpress 已经封装过了原生 Node.js 的响应方法，在原生 Node.js 中，通过 `res.write()` 方法可以返回字符串和 Buffer。而 Express 中的 `send()` 可以返回任意数据类型，如流、数据、普通文本等，来看个例子。\n```js\nres.send(new Buffer('ifyour')); // Buffer\nres.send({\"name\": \"ifyour\"});   // JSON\nres.send('<p>some html</p>');   // HTML\nres.status(404).send('404 Not Find'); // 设置状态码并返回提示\n//...\n```\n\n#### json()\n通过 `json()` 方法可以返回一个 `JSON` 对象，用于 Ajax 等。\n```js\nres.json(null);\nres.json({\"user\": \"ifyour\"});\nres.status(500).json({\"error\": \"message\"});\n```\n\n#### render()\n`render` 用于渲染模板引擎，比如在使用 [ejs](https://github.com/tj/ejs) 模板引擎时，响应用户请求就可以使用 `res.render()` 返回给用户一个渲染好的页面。这个用的比较多，我来举个例子。\n```bash\n# 目录结构\n.\n├── index.js\n├── node_modules\n│   ├── ejs\n│   └── express\n├── package.json\n└── views\n    └── login.html\n```\n```html\n<!-- ejs 模板引擎，定义了 /login.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n<!-- 注意 ejs 模板中变量的写法 -->\n<h1>欢迎你，<%=name%></h1>\n</body>\n</html>\n```\n```js\n// index.js\nvar express = require('express');\nvar ejs = require('ejs'); // 引入 ejs 模板引擎\nvar path = require('path');\nvar app = express();\n\nvar viewsPath = path.join(__dirname, 'views');// views 是模板目录\n// 设置 express views 层，模板根路径\napp.set('views', viewsPath);\n\n// 设置 express 实例的模板语言\napp.set('view engine', 'html');\n\n// 把 express 实例的模板引擎和 ejs 模板引擎关联\napp.engine('html', ejs.__express);\n\napp.get('/login.html', function (req, res) {\n    res.render('login', {name: \"ifyour\"});// 替换到模板变量中的 name 为 ifyour\n});\n\napp.listen(8080, function () {\n    console.log('visit http://127.0.0.1:8080/');\n});\n```\n<div class=\"tip\">\n`__dirname` 是 Node.js 中定义的 `global` 全局变量，获取当前文件的绝对路径，返回 `string` 类型。\n</div>\n\n#### download()\n```js\nres.download('./123.doc'); // 下载当前目录下面的123.doc文件。\nres.download('./123.doc','books.doc'); // 下载当前目录下面的123.doc文件，重命名为 books.doc\n```\n#### redirect()\n```js\n// 重定向到指定的 URL 路径\nres.redirect('/404.html');\nres.redirect('https://www.google.com/');\n```\n\n更多响应对象的方法，参考 [Express 官方API](http://www.expressjs.com.cn/4x/api.html#res)。\n### Express 请求对象\nExpress 中的 `Request` 对象，包含了一次请求中的所有数据，比如请求头、路径、Cookies 等，获取请求头中的信息，服务器根据这些信息处理业务逻辑层，最终将处理过后的数据返回给用户。这里总结了常用的请求对象方法。\n\n#### URL 中的参数\n```js\n// 方式一： req.query.参数名\n// e.g.  http://localhost:3000/user?name=ifyour\nconsole.log(req.query.name);\n// => ifyour\n\n// 方式二：req.params.参数名\n//e.g.  http://localhost/post/123123\nrouter.get('/post/:id', function (req, res) {\n    console.log(req.params.id);\n    // => 123123\n});\n```\n\n#### 表单中的参数\n```js\n// 方式一：语法：req.param.参数名  注意这里没加 s\n// e.g. <input type=\"text\" name=\"user\">\nconsole.log(req.param('user'));\n\n\n// 方式二：使用 body-parser 中间件\n// e.g. <input type=\"text\" name=\"user\">\nvar bodyparser = require('body-parser');\nconsole.console.log(req.boy.user);\n```\n\n### Express 中间件\nExpress 是一个自身功能极简，完全是由路由和中间件构成一个的 Web 开发框架：从本质上来说，一个 Express 应用就是在调用各种中间件。\n![](http://ww3.sinaimg.cn/large/6057861cgw1fbcrpk71zxj20sg03kaaa.jpg)\n如图，中间件（Middleware）位于客户端和路由之间，它好比是一个漏斗，经过这个漏斗的 `Request` 对象和 `Response` 对象以及循环流程中的 `Next` 会被处理，比如正确性校验、业务逻辑处理等。\n\n- 执行任何代码\n- 修改请求和响应对象\n- 终结请求-响应循环\n- 调用堆栈中的下一个中间件\n\n<div class=\"tip\">\n如果当前中间件没有终结请求-响应循环，则必须调用 next() 方法将控制权交给下一个中间件，否则请求就会挂起。\n</div>\n举个例子来说明一下，如何通过 `next()` 方法把控制权交给下一个中间件。\n```js\nvar app = express();\napp.use(function (req, res, next) {\n   var accessToken = req.query.accessToken;\n   //检查请求中是否含有“认证牌”，存在就继续执行。\n   if(accessToken){\n       next(); // 执行下一个中间件\n       }else{\n          res.send(“请求必须包含token”);\n        }\n});\n// ...\n```\n\n#### 应用级中间件\n应用级中间件就是绑定到用 `express()` 生成的对象 `app` 身上的，比如 `app.use()` 中的 `use` 方法，以及 `app.post()` 、`app.get()` 中的 `POST` 和 `GET` 方法等。\n#### 内置中间件\n```js\n// 设置公共静态目录，用于存放 css js image 等文件，项目目录里有 images 目录存放 1.png\n// 那么访问：http://localhost/images/1.png 获取\napp.use(express.static('public'));\n```\n#### 第三方中间件\n中间件可以说是整个 Express 的精华所在了，使用中间件可以几大的扩展项目的功能。使用方法都差不多，这里介绍几个常用的，具体使用方式需要看官方的文档了。\n- 解析客户端请求的 body 中的内容：body-parser\n- cookie 解析中间件：cookie-parser\n- 文件上传中间件：multer\n\n使用命令 `npm i 包名称 --save` 安装到项目中，然后引入项目使用即可。\n","source":"_posts/Node.JS-学习笔记-[05]----Express.md","raw":"---\ntitle: 'Node.JS 学习笔记 [05] -- Express'\ndate: 2015-01-06 21:24:40\ntags:\ncomments: false\n---\n\n***Express*** 是一个基于 Node.js 平台的极简、灵活的 Web 应用开发框架，它提供一系列强大的特性，帮助你创建各种 Web 和移动设备应用。Express的核心特性可以概括以下三点。\n<!-- more -->\n\n- 可以设置中间件来响应 HTTP 请求。\n- 定义了路由表用于执行不同的 HTTP 请求动作。\n- 可以通过向模板传递参数来动态渲染 HTML 页面。\n\n下面学习的知识点，都会围绕这几个特性展开。\n\n### Express 安装\n#### 在项目中引入 Express\n```bash\ncd projectName              # 进入新建的 Node.js 项目\nnpm init                    # 初始化项目配置文件\nnpm install express --save  # 安装 Express 模块到项目配置文件中\n```\n通过上门的命令，就可以完成 Express 的安装，下面在 `app.js` 中使用 Express 吧！\n```js\nvar express = require('express');\nvar app = express();\n\napp.get('/', function (req, res) {\n    res.send('Hello,Express!');\n});\n\napp.listen(8080, function () {\n    console.log('Express running at http://127.0.0.1:8080/');\n});\n```\n\n#### 使用 Express-generator\n为了方便开发者，更便捷的使用 Express 生成项目，官方提供的快速的生成工具 `Express-generator`，虽然生成非常快速方便，但是作为初学者，还是要弄清楚里面每条命令所代表的含义，最后再使用官方提供的工具快速生成。打开终端，因为我是 MacOS，所以安装的时候要加上 `sudo` 否则会报错提示权限不够。\n```bash\nsudo npm install express-generator -g  # 全局安装\nexpress mywebapp                       # 创建 mywebapp 项目\ncd mywebapp && npm install             # 安装依赖文件\nnpm start                              # 启动项目\n```\n启动项目后，就可以在浏览器中预览了，访问地址：http://127.0.0.1:3000/ 。\n\n<div class=\"tip\">\n启动前需要关闭其它已经启用的 Web 服务，否则可能会导致端口占用启动不成功。\n</div>\n\n### Express 路由\n> 路由是指如何定义应用的端点（URLs）以及如何响应客户端的请求。\n\n#### 基础用法\n简单理解，其实就是根据不同的请求，来响应与之对应的页面。比如，当用户访问 http://localhost/images/ 时，根据 URL 可以看出，请求的是 `/images` 这个目录，那么通过路由，找到这个页面并返回给请求的用户，这个过程就叫路由。来看一个简单的例子。\n```js\nvar express = require('express');\nvar app = express();\n\n// 当用户请求访问 / 时，响应一个 Hello,Express! 字符串，这就是一个简单路由\napp.get('/', function (req, res) {\n    res.send('Hello,Express!');\n});\n```\n这里需要注意 `app.all()` ,它是一个特殊的路由方法，没有任何 HTTP 方法与其对应，它的作用是对于一个路径上的所有请求加载中间件。 all 相当于既可以处理 `GET`，也可以处理 `POST` 。\n\n#### Router 方法\n通过 `express.Router` 类可以创建独立模块的路由模块，它是一个可以挂载的路由对象，把路由模块分离出项目，让整个项目结构清晰、方便管理，这里光说还是挺抽象，举个例子。\n```bash\n# 目录结构\n.\n├── index.js\n├── node_modules\n│   ├── body-parser\n│   └── express\n├── package.json\n├── router\n│   ├── admin.js\n│   └── home.js\n└── views\n    ├── admin\n    └── home\n```\n```js\n// index.js\nvar express = require('express');\nvar bodyparser = require('body-parser');\n// 引入外部路由模块\nvar home = require('./router/home');\nvar admin = require('./router/admin');\nvar app = express();\n\n// 使用中间件 bodyparser ，后面可以在 req.body 中分析出 POST 请求体的内容\napp.use(bodyparser.urlencoded({extended:false}));\n\n// 使用外部路由模块\napp.use('/',home);\napp.use('/admin',admin);\n\napp.listen(8080,function () {\n   console.log('visit http://127.0.0.1:8080/');\n});\n```\n\n```js\n// admin.js\nvar express = require('express');\nvar router = express.Router();// 用 Router 构造函数实例化 router 对象\nvar path = require('path');\n\nrouter.get('/login.html', function (req, res) {\n    res.sendFile(path.resolve(__dirname + '/../views/admin/' + 'login.html'));\n});\n\nrouter.get('/user.html', function (req, res) {\n    res.sendFile(path.resolve(__dirname + '/../views/admin/' + 'user.html'));\n});\n\nrouter.post('/login.html', function (req, res) {// /admin/login.html\n    res.sendFile(path.resolve(__dirname + '/../views/admin/' + 'login.html'));\n});\n\nmodule.exports = router;// 暴露给外部调用该路由\n```\n\n### Express 响应对象\n通过响应（Response）对象，服务器可以返回一个来自客户端（浏览器）的 `Request` ,最终返回给用户的其实就是一个经过业务逻辑层处理的 `res` 对象。来了解下 Express 的响应对象吧。\n\n#### send()\nExpress 已经封装过了原生 Node.js 的响应方法，在原生 Node.js 中，通过 `res.write()` 方法可以返回字符串和 Buffer。而 Express 中的 `send()` 可以返回任意数据类型，如流、数据、普通文本等，来看个例子。\n```js\nres.send(new Buffer('ifyour')); // Buffer\nres.send({\"name\": \"ifyour\"});   // JSON\nres.send('<p>some html</p>');   // HTML\nres.status(404).send('404 Not Find'); // 设置状态码并返回提示\n//...\n```\n\n#### json()\n通过 `json()` 方法可以返回一个 `JSON` 对象，用于 Ajax 等。\n```js\nres.json(null);\nres.json({\"user\": \"ifyour\"});\nres.status(500).json({\"error\": \"message\"});\n```\n\n#### render()\n`render` 用于渲染模板引擎，比如在使用 [ejs](https://github.com/tj/ejs) 模板引擎时，响应用户请求就可以使用 `res.render()` 返回给用户一个渲染好的页面。这个用的比较多，我来举个例子。\n```bash\n# 目录结构\n.\n├── index.js\n├── node_modules\n│   ├── ejs\n│   └── express\n├── package.json\n└── views\n    └── login.html\n```\n```html\n<!-- ejs 模板引擎，定义了 /login.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n<!-- 注意 ejs 模板中变量的写法 -->\n<h1>欢迎你，<%=name%></h1>\n</body>\n</html>\n```\n```js\n// index.js\nvar express = require('express');\nvar ejs = require('ejs'); // 引入 ejs 模板引擎\nvar path = require('path');\nvar app = express();\n\nvar viewsPath = path.join(__dirname, 'views');// views 是模板目录\n// 设置 express views 层，模板根路径\napp.set('views', viewsPath);\n\n// 设置 express 实例的模板语言\napp.set('view engine', 'html');\n\n// 把 express 实例的模板引擎和 ejs 模板引擎关联\napp.engine('html', ejs.__express);\n\napp.get('/login.html', function (req, res) {\n    res.render('login', {name: \"ifyour\"});// 替换到模板变量中的 name 为 ifyour\n});\n\napp.listen(8080, function () {\n    console.log('visit http://127.0.0.1:8080/');\n});\n```\n<div class=\"tip\">\n`__dirname` 是 Node.js 中定义的 `global` 全局变量，获取当前文件的绝对路径，返回 `string` 类型。\n</div>\n\n#### download()\n```js\nres.download('./123.doc'); // 下载当前目录下面的123.doc文件。\nres.download('./123.doc','books.doc'); // 下载当前目录下面的123.doc文件，重命名为 books.doc\n```\n#### redirect()\n```js\n// 重定向到指定的 URL 路径\nres.redirect('/404.html');\nres.redirect('https://www.google.com/');\n```\n\n更多响应对象的方法，参考 [Express 官方API](http://www.expressjs.com.cn/4x/api.html#res)。\n### Express 请求对象\nExpress 中的 `Request` 对象，包含了一次请求中的所有数据，比如请求头、路径、Cookies 等，获取请求头中的信息，服务器根据这些信息处理业务逻辑层，最终将处理过后的数据返回给用户。这里总结了常用的请求对象方法。\n\n#### URL 中的参数\n```js\n// 方式一： req.query.参数名\n// e.g.  http://localhost:3000/user?name=ifyour\nconsole.log(req.query.name);\n// => ifyour\n\n// 方式二：req.params.参数名\n//e.g.  http://localhost/post/123123\nrouter.get('/post/:id', function (req, res) {\n    console.log(req.params.id);\n    // => 123123\n});\n```\n\n#### 表单中的参数\n```js\n// 方式一：语法：req.param.参数名  注意这里没加 s\n// e.g. <input type=\"text\" name=\"user\">\nconsole.log(req.param('user'));\n\n\n// 方式二：使用 body-parser 中间件\n// e.g. <input type=\"text\" name=\"user\">\nvar bodyparser = require('body-parser');\nconsole.console.log(req.boy.user);\n```\n\n### Express 中间件\nExpress 是一个自身功能极简，完全是由路由和中间件构成一个的 Web 开发框架：从本质上来说，一个 Express 应用就是在调用各种中间件。\n![](http://ww3.sinaimg.cn/large/6057861cgw1fbcrpk71zxj20sg03kaaa.jpg)\n如图，中间件（Middleware）位于客户端和路由之间，它好比是一个漏斗，经过这个漏斗的 `Request` 对象和 `Response` 对象以及循环流程中的 `Next` 会被处理，比如正确性校验、业务逻辑处理等。\n\n- 执行任何代码\n- 修改请求和响应对象\n- 终结请求-响应循环\n- 调用堆栈中的下一个中间件\n\n<div class=\"tip\">\n如果当前中间件没有终结请求-响应循环，则必须调用 next() 方法将控制权交给下一个中间件，否则请求就会挂起。\n</div>\n举个例子来说明一下，如何通过 `next()` 方法把控制权交给下一个中间件。\n```js\nvar app = express();\napp.use(function (req, res, next) {\n   var accessToken = req.query.accessToken;\n   //检查请求中是否含有“认证牌”，存在就继续执行。\n   if(accessToken){\n       next(); // 执行下一个中间件\n       }else{\n          res.send(“请求必须包含token”);\n        }\n});\n// ...\n```\n\n#### 应用级中间件\n应用级中间件就是绑定到用 `express()` 生成的对象 `app` 身上的，比如 `app.use()` 中的 `use` 方法，以及 `app.post()` 、`app.get()` 中的 `POST` 和 `GET` 方法等。\n#### 内置中间件\n```js\n// 设置公共静态目录，用于存放 css js image 等文件，项目目录里有 images 目录存放 1.png\n// 那么访问：http://localhost/images/1.png 获取\napp.use(express.static('public'));\n```\n#### 第三方中间件\n中间件可以说是整个 Express 的精华所在了，使用中间件可以几大的扩展项目的功能。使用方法都差不多，这里介绍几个常用的，具体使用方式需要看官方的文档了。\n- 解析客户端请求的 body 中的内容：body-parser\n- cookie 解析中间件：cookie-parser\n- 文件上传中间件：multer\n\n使用命令 `npm i 包名称 --save` 安装到项目中，然后引入项目使用即可。\n","slug":"Node.JS-学习笔记-[05]----Express","published":1,"updated":"2018-06-17T09:49:30.000Z","layout":"post","photos":[],"link":"","_id":"cjiitidiz000fu4q9c5kjfze9","content":"<p><strong><em>Express</em></strong> 是一个基于 Node.js 平台的极简、灵活的 Web 应用开发框架，它提供一系列强大的特性，帮助你创建各种 Web 和移动设备应用。Express的核心特性可以概括以下三点。<br><a id=\"more\"></a></p>\n<ul>\n<li>可以设置中间件来响应 HTTP 请求。</li>\n<li>定义了路由表用于执行不同的 HTTP 请求动作。</li>\n<li>可以通过向模板传递参数来动态渲染 HTML 页面。</li>\n</ul>\n<p>下面学习的知识点，都会围绕这几个特性展开。</p>\n<h3 id=\"Express-安装\"><a href=\"#Express-安装\" class=\"headerlink\" title=\"Express 安装\"></a>Express 安装</h3><h4 id=\"在项目中引入-Express\"><a href=\"#在项目中引入-Express\" class=\"headerlink\" title=\"在项目中引入 Express\"></a>在项目中引入 Express</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> projectName              <span class=\"comment\"># 进入新建的 Node.js 项目</span></span><br><span class=\"line\">npm init                    <span class=\"comment\"># 初始化项目配置文件</span></span><br><span class=\"line\">npm install express --save  <span class=\"comment\"># 安装 Express 模块到项目配置文件中</span></span><br></pre></td></tr></table></figure>\n<p>通过上门的命令，就可以完成 Express 的安装，下面在 <code>app.js</code> 中使用 Express 吧！<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> app = express();</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(<span class=\"string\">'/'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">    res.send(<span class=\"string\">'Hello,Express!'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">8080</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Express running at http://127.0.0.1:8080/'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"使用-Express-generator\"><a href=\"#使用-Express-generator\" class=\"headerlink\" title=\"使用 Express-generator\"></a>使用 Express-generator</h4><p>为了方便开发者，更便捷的使用 Express 生成项目，官方提供的快速的生成工具 <code>Express-generator</code>，虽然生成非常快速方便，但是作为初学者，还是要弄清楚里面每条命令所代表的含义，最后再使用官方提供的工具快速生成。打开终端，因为我是 MacOS，所以安装的时候要加上 <code>sudo</code> 否则会报错提示权限不够。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo npm install express-generator -g  <span class=\"comment\"># 全局安装</span></span><br><span class=\"line\">express mywebapp                       <span class=\"comment\"># 创建 mywebapp 项目</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> mywebapp &amp;&amp; npm install             <span class=\"comment\"># 安装依赖文件</span></span><br><span class=\"line\">npm start                              <span class=\"comment\"># 启动项目</span></span><br></pre></td></tr></table></figure></p>\n<p>启动项目后，就可以在浏览器中预览了，访问地址：<a href=\"http://127.0.0.1:3000/\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:3000/</a> 。</p>\n<div class=\"tip\"><br>启动前需要关闭其它已经启用的 Web 服务，否则可能会导致端口占用启动不成功。<br></div>\n\n<h3 id=\"Express-路由\"><a href=\"#Express-路由\" class=\"headerlink\" title=\"Express 路由\"></a>Express 路由</h3><blockquote>\n<p>路由是指如何定义应用的端点（URLs）以及如何响应客户端的请求。</p>\n</blockquote>\n<h4 id=\"基础用法\"><a href=\"#基础用法\" class=\"headerlink\" title=\"基础用法\"></a>基础用法</h4><p>简单理解，其实就是根据不同的请求，来响应与之对应的页面。比如，当用户访问 <a href=\"http://localhost/images/\" target=\"_blank\" rel=\"noopener\">http://localhost/images/</a> 时，根据 URL 可以看出，请求的是 <code>/images</code> 这个目录，那么通过路由，找到这个页面并返回给请求的用户，这个过程就叫路由。来看一个简单的例子。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> app = express();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 当用户请求访问 / 时，响应一个 Hello,Express! 字符串，这就是一个简单路由</span></span><br><span class=\"line\">app.get(<span class=\"string\">'/'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">    res.send(<span class=\"string\">'Hello,Express!'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>这里需要注意 <code>app.all()</code> ,它是一个特殊的路由方法，没有任何 HTTP 方法与其对应，它的作用是对于一个路径上的所有请求加载中间件。 all 相当于既可以处理 <code>GET</code>，也可以处理 <code>POST</code> 。</p>\n<h4 id=\"Router-方法\"><a href=\"#Router-方法\" class=\"headerlink\" title=\"Router 方法\"></a>Router 方法</h4><p>通过 <code>express.Router</code> 类可以创建独立模块的路由模块，它是一个可以挂载的路由对象，把路由模块分离出项目，让整个项目结构清晰、方便管理，这里光说还是挺抽象，举个例子。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 目录结构</span></span><br><span class=\"line\">.</span><br><span class=\"line\">├── index.js</span><br><span class=\"line\">├── node_modules</span><br><span class=\"line\">│   ├── body-parser</span><br><span class=\"line\">│   └── express</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">├── router</span><br><span class=\"line\">│   ├── admin.js</span><br><span class=\"line\">│   └── home.js</span><br><span class=\"line\">└── views</span><br><span class=\"line\">    ├── admin</span><br><span class=\"line\">    └── home</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// index.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> bodyparser = <span class=\"built_in\">require</span>(<span class=\"string\">'body-parser'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 引入外部路由模块</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> home = <span class=\"built_in\">require</span>(<span class=\"string\">'./router/home'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> admin = <span class=\"built_in\">require</span>(<span class=\"string\">'./router/admin'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> app = express();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用中间件 bodyparser ，后面可以在 req.body 中分析出 POST 请求体的内容</span></span><br><span class=\"line\">app.use(bodyparser.urlencoded(&#123;<span class=\"attr\">extended</span>:<span class=\"literal\">false</span>&#125;));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用外部路由模块</span></span><br><span class=\"line\">app.use(<span class=\"string\">'/'</span>,home);</span><br><span class=\"line\">app.use(<span class=\"string\">'/admin'</span>,admin);</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">8080</span>,<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(<span class=\"string\">'visit http://127.0.0.1:8080/'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// admin.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> router = express.Router();<span class=\"comment\">// 用 Router 构造函数实例化 router 对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">router.get(<span class=\"string\">'/login.html'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">    res.sendFile(path.resolve(__dirname + <span class=\"string\">'/../views/admin/'</span> + <span class=\"string\">'login.html'</span>));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">router.get(<span class=\"string\">'/user.html'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">    res.sendFile(path.resolve(__dirname + <span class=\"string\">'/../views/admin/'</span> + <span class=\"string\">'user.html'</span>));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">router.post(<span class=\"string\">'/login.html'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;<span class=\"comment\">// /admin/login.html</span></span><br><span class=\"line\">    res.sendFile(path.resolve(__dirname + <span class=\"string\">'/../views/admin/'</span> + <span class=\"string\">'login.html'</span>));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = router;<span class=\"comment\">// 暴露给外部调用该路由</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Express-响应对象\"><a href=\"#Express-响应对象\" class=\"headerlink\" title=\"Express 响应对象\"></a>Express 响应对象</h3><p>通过响应（Response）对象，服务器可以返回一个来自客户端（浏览器）的 <code>Request</code> ,最终返回给用户的其实就是一个经过业务逻辑层处理的 <code>res</code> 对象。来了解下 Express 的响应对象吧。</p>\n<h4 id=\"send\"><a href=\"#send\" class=\"headerlink\" title=\"send()\"></a>send()</h4><p>Express 已经封装过了原生 Node.js 的响应方法，在原生 Node.js 中，通过 <code>res.write()</code> 方法可以返回字符串和 Buffer。而 Express 中的 <code>send()</code> 可以返回任意数据类型，如流、数据、普通文本等，来看个例子。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">res.send(<span class=\"keyword\">new</span> Buffer(<span class=\"string\">'ifyour'</span>)); <span class=\"comment\">// Buffer</span></span><br><span class=\"line\">res.send(&#123;<span class=\"string\">\"name\"</span>: <span class=\"string\">\"ifyour\"</span>&#125;);   <span class=\"comment\">// JSON</span></span><br><span class=\"line\">res.send(<span class=\"string\">'&lt;p&gt;some html&lt;/p&gt;'</span>);   <span class=\"comment\">// HTML</span></span><br><span class=\"line\">res.status(<span class=\"number\">404</span>).send(<span class=\"string\">'404 Not Find'</span>); <span class=\"comment\">// 设置状态码并返回提示</span></span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"json\"><a href=\"#json\" class=\"headerlink\" title=\"json()\"></a>json()</h4><p>通过 <code>json()</code> 方法可以返回一个 <code>JSON</code> 对象，用于 Ajax 等。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">res.json(<span class=\"literal\">null</span>);</span><br><span class=\"line\">res.json(&#123;<span class=\"string\">\"user\"</span>: <span class=\"string\">\"ifyour\"</span>&#125;);</span><br><span class=\"line\">res.status(<span class=\"number\">500</span>).json(&#123;<span class=\"string\">\"error\"</span>: <span class=\"string\">\"message\"</span>&#125;);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"render\"><a href=\"#render\" class=\"headerlink\" title=\"render()\"></a>render()</h4><p><code>render</code> 用于渲染模板引擎，比如在使用 <a href=\"https://github.com/tj/ejs\" target=\"_blank\" rel=\"noopener\">ejs</a> 模板引擎时，响应用户请求就可以使用 <code>res.render()</code> 返回给用户一个渲染好的页面。这个用的比较多，我来举个例子。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 目录结构</span></span><br><span class=\"line\">.</span><br><span class=\"line\">├── index.js</span><br><span class=\"line\">├── node_modules</span><br><span class=\"line\">│   ├── ejs</span><br><span class=\"line\">│   └── express</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">└── views</span><br><span class=\"line\">    └── login.html</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- ejs 模板引擎，定义了 /login.html --&gt;</span></span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Title<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 注意 ejs 模板中变量的写法 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>欢迎你，<span class=\"tag\">&lt;<span class=\"name\">%=name%</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// index.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> ejs = <span class=\"built_in\">require</span>(<span class=\"string\">'ejs'</span>); <span class=\"comment\">// 引入 ejs 模板引擎</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> app = express();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> viewsPath = path.join(__dirname, <span class=\"string\">'views'</span>);<span class=\"comment\">// views 是模板目录</span></span><br><span class=\"line\"><span class=\"comment\">// 设置 express views 层，模板根路径</span></span><br><span class=\"line\">app.set(<span class=\"string\">'views'</span>, viewsPath);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置 express 实例的模板语言</span></span><br><span class=\"line\">app.set(<span class=\"string\">'view engine'</span>, <span class=\"string\">'html'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 把 express 实例的模板引擎和 ejs 模板引擎关联</span></span><br><span class=\"line\">app.engine(<span class=\"string\">'html'</span>, ejs.__express);</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(<span class=\"string\">'/login.html'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">    res.render(<span class=\"string\">'login'</span>, &#123;<span class=\"attr\">name</span>: <span class=\"string\">\"ifyour\"</span>&#125;);<span class=\"comment\">// 替换到模板变量中的 name 为 ifyour</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">8080</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'visit http://127.0.0.1:8080/'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<div class=\"tip\"><br><code>__dirname</code> 是 Node.js 中定义的 <code>global</code> 全局变量，获取当前文件的绝对路径，返回 <code>string</code> 类型。<br></div>\n\n<h4 id=\"download\"><a href=\"#download\" class=\"headerlink\" title=\"download()\"></a>download()</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">res.download(<span class=\"string\">'./123.doc'</span>); <span class=\"comment\">// 下载当前目录下面的123.doc文件。</span></span><br><span class=\"line\">res.download(<span class=\"string\">'./123.doc'</span>,<span class=\"string\">'books.doc'</span>); <span class=\"comment\">// 下载当前目录下面的123.doc文件，重命名为 books.doc</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"redirect\"><a href=\"#redirect\" class=\"headerlink\" title=\"redirect()\"></a>redirect()</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 重定向到指定的 URL 路径</span></span><br><span class=\"line\">res.redirect(<span class=\"string\">'/404.html'</span>);</span><br><span class=\"line\">res.redirect(<span class=\"string\">'https://www.google.com/'</span>);</span><br></pre></td></tr></table></figure>\n<p>更多响应对象的方法，参考 <a href=\"http://www.expressjs.com.cn/4x/api.html#res\" target=\"_blank\" rel=\"noopener\">Express 官方API</a>。</p>\n<h3 id=\"Express-请求对象\"><a href=\"#Express-请求对象\" class=\"headerlink\" title=\"Express 请求对象\"></a>Express 请求对象</h3><p>Express 中的 <code>Request</code> 对象，包含了一次请求中的所有数据，比如请求头、路径、Cookies 等，获取请求头中的信息，服务器根据这些信息处理业务逻辑层，最终将处理过后的数据返回给用户。这里总结了常用的请求对象方法。</p>\n<h4 id=\"URL-中的参数\"><a href=\"#URL-中的参数\" class=\"headerlink\" title=\"URL 中的参数\"></a>URL 中的参数</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方式一： req.query.参数名</span></span><br><span class=\"line\"><span class=\"comment\">// e.g.  http://localhost:3000/user?name=ifyour</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(req.query.name);</span><br><span class=\"line\"><span class=\"comment\">// =&gt; ifyour</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方式二：req.params.参数名</span></span><br><span class=\"line\"><span class=\"comment\">//e.g.  http://localhost/post/123123</span></span><br><span class=\"line\">router.get(<span class=\"string\">'/post/:id'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(req.params.id);</span><br><span class=\"line\">    <span class=\"comment\">// =&gt; 123123</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"表单中的参数\"><a href=\"#表单中的参数\" class=\"headerlink\" title=\"表单中的参数\"></a>表单中的参数</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方式一：语法：req.param.参数名  注意这里没加 s</span></span><br><span class=\"line\"><span class=\"comment\">// e.g. &lt;input type=\"text\" name=\"user\"&gt;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(req.param(<span class=\"string\">'user'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方式二：使用 body-parser 中间件</span></span><br><span class=\"line\"><span class=\"comment\">// e.g. &lt;input type=\"text\" name=\"user\"&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bodyparser = <span class=\"built_in\">require</span>(<span class=\"string\">'body-parser'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.console.log(req.boy.user);</span><br></pre></td></tr></table></figure>\n<h3 id=\"Express-中间件\"><a href=\"#Express-中间件\" class=\"headerlink\" title=\"Express 中间件\"></a>Express 中间件</h3><p>Express 是一个自身功能极简，完全是由路由和中间件构成一个的 Web 开发框架：从本质上来说，一个 Express 应用就是在调用各种中间件。<br><img src=\"http://ww3.sinaimg.cn/large/6057861cgw1fbcrpk71zxj20sg03kaaa.jpg\" alt=\"\"><br>如图，中间件（Middleware）位于客户端和路由之间，它好比是一个漏斗，经过这个漏斗的 <code>Request</code> 对象和 <code>Response</code> 对象以及循环流程中的 <code>Next</code> 会被处理，比如正确性校验、业务逻辑处理等。</p>\n<ul>\n<li>执行任何代码</li>\n<li>修改请求和响应对象</li>\n<li>终结请求-响应循环</li>\n<li>调用堆栈中的下一个中间件</li>\n</ul>\n<p><div class=\"tip\"><br>如果当前中间件没有终结请求-响应循环，则必须调用 next() 方法将控制权交给下一个中间件，否则请求就会挂起。<br></div><br>举个例子来说明一下，如何通过 <code>next()</code> 方法把控制权交给下一个中间件。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> app = express();</span><br><span class=\"line\">app.use(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res, next</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> accessToken = req.query.accessToken;</span><br><span class=\"line\">   <span class=\"comment\">//检查请求中是否含有“认证牌”，存在就继续执行。</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span>(accessToken)&#123;</span><br><span class=\"line\">       next(); <span class=\"comment\">// 执行下一个中间件</span></span><br><span class=\"line\">       &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">          res.send(“请求必须包含token”);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"应用级中间件\"><a href=\"#应用级中间件\" class=\"headerlink\" title=\"应用级中间件\"></a>应用级中间件</h4><p>应用级中间件就是绑定到用 <code>express()</code> 生成的对象 <code>app</code> 身上的，比如 <code>app.use()</code> 中的 <code>use</code> 方法，以及 <code>app.post()</code> 、<code>app.get()</code> 中的 <code>POST</code> 和 <code>GET</code> 方法等。</p>\n<h4 id=\"内置中间件\"><a href=\"#内置中间件\" class=\"headerlink\" title=\"内置中间件\"></a>内置中间件</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 设置公共静态目录，用于存放 css js image 等文件，项目目录里有 images 目录存放 1.png</span></span><br><span class=\"line\"><span class=\"comment\">// 那么访问：http://localhost/images/1.png 获取</span></span><br><span class=\"line\">app.use(express.static(<span class=\"string\">'public'</span>));</span><br></pre></td></tr></table></figure>\n<h4 id=\"第三方中间件\"><a href=\"#第三方中间件\" class=\"headerlink\" title=\"第三方中间件\"></a>第三方中间件</h4><p>中间件可以说是整个 Express 的精华所在了，使用中间件可以几大的扩展项目的功能。使用方法都差不多，这里介绍几个常用的，具体使用方式需要看官方的文档了。</p>\n<ul>\n<li>解析客户端请求的 body 中的内容：body-parser</li>\n<li>cookie 解析中间件：cookie-parser</li>\n<li>文件上传中间件：multer</li>\n</ul>\n<p>使用命令 <code>npm i 包名称 --save</code> 安装到项目中，然后引入项目使用即可。</p>\n","site":{"data":{}},"excerpt":"<p><strong><em>Express</em></strong> 是一个基于 Node.js 平台的极简、灵活的 Web 应用开发框架，它提供一系列强大的特性，帮助你创建各种 Web 和移动设备应用。Express的核心特性可以概括以下三点。<br>","more":"</p>\n<ul>\n<li>可以设置中间件来响应 HTTP 请求。</li>\n<li>定义了路由表用于执行不同的 HTTP 请求动作。</li>\n<li>可以通过向模板传递参数来动态渲染 HTML 页面。</li>\n</ul>\n<p>下面学习的知识点，都会围绕这几个特性展开。</p>\n<h3 id=\"Express-安装\"><a href=\"#Express-安装\" class=\"headerlink\" title=\"Express 安装\"></a>Express 安装</h3><h4 id=\"在项目中引入-Express\"><a href=\"#在项目中引入-Express\" class=\"headerlink\" title=\"在项目中引入 Express\"></a>在项目中引入 Express</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> projectName              <span class=\"comment\"># 进入新建的 Node.js 项目</span></span><br><span class=\"line\">npm init                    <span class=\"comment\"># 初始化项目配置文件</span></span><br><span class=\"line\">npm install express --save  <span class=\"comment\"># 安装 Express 模块到项目配置文件中</span></span><br></pre></td></tr></table></figure>\n<p>通过上门的命令，就可以完成 Express 的安装，下面在 <code>app.js</code> 中使用 Express 吧！<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> app = express();</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(<span class=\"string\">'/'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">    res.send(<span class=\"string\">'Hello,Express!'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">8080</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Express running at http://127.0.0.1:8080/'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"使用-Express-generator\"><a href=\"#使用-Express-generator\" class=\"headerlink\" title=\"使用 Express-generator\"></a>使用 Express-generator</h4><p>为了方便开发者，更便捷的使用 Express 生成项目，官方提供的快速的生成工具 <code>Express-generator</code>，虽然生成非常快速方便，但是作为初学者，还是要弄清楚里面每条命令所代表的含义，最后再使用官方提供的工具快速生成。打开终端，因为我是 MacOS，所以安装的时候要加上 <code>sudo</code> 否则会报错提示权限不够。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo npm install express-generator -g  <span class=\"comment\"># 全局安装</span></span><br><span class=\"line\">express mywebapp                       <span class=\"comment\"># 创建 mywebapp 项目</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> mywebapp &amp;&amp; npm install             <span class=\"comment\"># 安装依赖文件</span></span><br><span class=\"line\">npm start                              <span class=\"comment\"># 启动项目</span></span><br></pre></td></tr></table></figure></p>\n<p>启动项目后，就可以在浏览器中预览了，访问地址：<a href=\"http://127.0.0.1:3000/\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:3000/</a> 。</p>\n<div class=\"tip\"><br>启动前需要关闭其它已经启用的 Web 服务，否则可能会导致端口占用启动不成功。<br></div>\n\n<h3 id=\"Express-路由\"><a href=\"#Express-路由\" class=\"headerlink\" title=\"Express 路由\"></a>Express 路由</h3><blockquote>\n<p>路由是指如何定义应用的端点（URLs）以及如何响应客户端的请求。</p>\n</blockquote>\n<h4 id=\"基础用法\"><a href=\"#基础用法\" class=\"headerlink\" title=\"基础用法\"></a>基础用法</h4><p>简单理解，其实就是根据不同的请求，来响应与之对应的页面。比如，当用户访问 <a href=\"http://localhost/images/\" target=\"_blank\" rel=\"noopener\">http://localhost/images/</a> 时，根据 URL 可以看出，请求的是 <code>/images</code> 这个目录，那么通过路由，找到这个页面并返回给请求的用户，这个过程就叫路由。来看一个简单的例子。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> app = express();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 当用户请求访问 / 时，响应一个 Hello,Express! 字符串，这就是一个简单路由</span></span><br><span class=\"line\">app.get(<span class=\"string\">'/'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">    res.send(<span class=\"string\">'Hello,Express!'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>这里需要注意 <code>app.all()</code> ,它是一个特殊的路由方法，没有任何 HTTP 方法与其对应，它的作用是对于一个路径上的所有请求加载中间件。 all 相当于既可以处理 <code>GET</code>，也可以处理 <code>POST</code> 。</p>\n<h4 id=\"Router-方法\"><a href=\"#Router-方法\" class=\"headerlink\" title=\"Router 方法\"></a>Router 方法</h4><p>通过 <code>express.Router</code> 类可以创建独立模块的路由模块，它是一个可以挂载的路由对象，把路由模块分离出项目，让整个项目结构清晰、方便管理，这里光说还是挺抽象，举个例子。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 目录结构</span></span><br><span class=\"line\">.</span><br><span class=\"line\">├── index.js</span><br><span class=\"line\">├── node_modules</span><br><span class=\"line\">│   ├── body-parser</span><br><span class=\"line\">│   └── express</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">├── router</span><br><span class=\"line\">│   ├── admin.js</span><br><span class=\"line\">│   └── home.js</span><br><span class=\"line\">└── views</span><br><span class=\"line\">    ├── admin</span><br><span class=\"line\">    └── home</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// index.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> bodyparser = <span class=\"built_in\">require</span>(<span class=\"string\">'body-parser'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 引入外部路由模块</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> home = <span class=\"built_in\">require</span>(<span class=\"string\">'./router/home'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> admin = <span class=\"built_in\">require</span>(<span class=\"string\">'./router/admin'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> app = express();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用中间件 bodyparser ，后面可以在 req.body 中分析出 POST 请求体的内容</span></span><br><span class=\"line\">app.use(bodyparser.urlencoded(&#123;<span class=\"attr\">extended</span>:<span class=\"literal\">false</span>&#125;));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用外部路由模块</span></span><br><span class=\"line\">app.use(<span class=\"string\">'/'</span>,home);</span><br><span class=\"line\">app.use(<span class=\"string\">'/admin'</span>,admin);</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">8080</span>,<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(<span class=\"string\">'visit http://127.0.0.1:8080/'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// admin.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> router = express.Router();<span class=\"comment\">// 用 Router 构造函数实例化 router 对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">router.get(<span class=\"string\">'/login.html'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">    res.sendFile(path.resolve(__dirname + <span class=\"string\">'/../views/admin/'</span> + <span class=\"string\">'login.html'</span>));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">router.get(<span class=\"string\">'/user.html'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">    res.sendFile(path.resolve(__dirname + <span class=\"string\">'/../views/admin/'</span> + <span class=\"string\">'user.html'</span>));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">router.post(<span class=\"string\">'/login.html'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;<span class=\"comment\">// /admin/login.html</span></span><br><span class=\"line\">    res.sendFile(path.resolve(__dirname + <span class=\"string\">'/../views/admin/'</span> + <span class=\"string\">'login.html'</span>));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = router;<span class=\"comment\">// 暴露给外部调用该路由</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Express-响应对象\"><a href=\"#Express-响应对象\" class=\"headerlink\" title=\"Express 响应对象\"></a>Express 响应对象</h3><p>通过响应（Response）对象，服务器可以返回一个来自客户端（浏览器）的 <code>Request</code> ,最终返回给用户的其实就是一个经过业务逻辑层处理的 <code>res</code> 对象。来了解下 Express 的响应对象吧。</p>\n<h4 id=\"send\"><a href=\"#send\" class=\"headerlink\" title=\"send()\"></a>send()</h4><p>Express 已经封装过了原生 Node.js 的响应方法，在原生 Node.js 中，通过 <code>res.write()</code> 方法可以返回字符串和 Buffer。而 Express 中的 <code>send()</code> 可以返回任意数据类型，如流、数据、普通文本等，来看个例子。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">res.send(<span class=\"keyword\">new</span> Buffer(<span class=\"string\">'ifyour'</span>)); <span class=\"comment\">// Buffer</span></span><br><span class=\"line\">res.send(&#123;<span class=\"string\">\"name\"</span>: <span class=\"string\">\"ifyour\"</span>&#125;);   <span class=\"comment\">// JSON</span></span><br><span class=\"line\">res.send(<span class=\"string\">'&lt;p&gt;some html&lt;/p&gt;'</span>);   <span class=\"comment\">// HTML</span></span><br><span class=\"line\">res.status(<span class=\"number\">404</span>).send(<span class=\"string\">'404 Not Find'</span>); <span class=\"comment\">// 设置状态码并返回提示</span></span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"json\"><a href=\"#json\" class=\"headerlink\" title=\"json()\"></a>json()</h4><p>通过 <code>json()</code> 方法可以返回一个 <code>JSON</code> 对象，用于 Ajax 等。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">res.json(<span class=\"literal\">null</span>);</span><br><span class=\"line\">res.json(&#123;<span class=\"string\">\"user\"</span>: <span class=\"string\">\"ifyour\"</span>&#125;);</span><br><span class=\"line\">res.status(<span class=\"number\">500</span>).json(&#123;<span class=\"string\">\"error\"</span>: <span class=\"string\">\"message\"</span>&#125;);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"render\"><a href=\"#render\" class=\"headerlink\" title=\"render()\"></a>render()</h4><p><code>render</code> 用于渲染模板引擎，比如在使用 <a href=\"https://github.com/tj/ejs\" target=\"_blank\" rel=\"noopener\">ejs</a> 模板引擎时，响应用户请求就可以使用 <code>res.render()</code> 返回给用户一个渲染好的页面。这个用的比较多，我来举个例子。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 目录结构</span></span><br><span class=\"line\">.</span><br><span class=\"line\">├── index.js</span><br><span class=\"line\">├── node_modules</span><br><span class=\"line\">│   ├── ejs</span><br><span class=\"line\">│   └── express</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">└── views</span><br><span class=\"line\">    └── login.html</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- ejs 模板引擎，定义了 /login.html --&gt;</span></span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Title<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 注意 ejs 模板中变量的写法 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>欢迎你，<span class=\"tag\">&lt;<span class=\"name\">%=name%</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// index.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> ejs = <span class=\"built_in\">require</span>(<span class=\"string\">'ejs'</span>); <span class=\"comment\">// 引入 ejs 模板引擎</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> app = express();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> viewsPath = path.join(__dirname, <span class=\"string\">'views'</span>);<span class=\"comment\">// views 是模板目录</span></span><br><span class=\"line\"><span class=\"comment\">// 设置 express views 层，模板根路径</span></span><br><span class=\"line\">app.set(<span class=\"string\">'views'</span>, viewsPath);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置 express 实例的模板语言</span></span><br><span class=\"line\">app.set(<span class=\"string\">'view engine'</span>, <span class=\"string\">'html'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 把 express 实例的模板引擎和 ejs 模板引擎关联</span></span><br><span class=\"line\">app.engine(<span class=\"string\">'html'</span>, ejs.__express);</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(<span class=\"string\">'/login.html'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">    res.render(<span class=\"string\">'login'</span>, &#123;<span class=\"attr\">name</span>: <span class=\"string\">\"ifyour\"</span>&#125;);<span class=\"comment\">// 替换到模板变量中的 name 为 ifyour</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">8080</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'visit http://127.0.0.1:8080/'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<div class=\"tip\"><br><code>__dirname</code> 是 Node.js 中定义的 <code>global</code> 全局变量，获取当前文件的绝对路径，返回 <code>string</code> 类型。<br></div>\n\n<h4 id=\"download\"><a href=\"#download\" class=\"headerlink\" title=\"download()\"></a>download()</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">res.download(<span class=\"string\">'./123.doc'</span>); <span class=\"comment\">// 下载当前目录下面的123.doc文件。</span></span><br><span class=\"line\">res.download(<span class=\"string\">'./123.doc'</span>,<span class=\"string\">'books.doc'</span>); <span class=\"comment\">// 下载当前目录下面的123.doc文件，重命名为 books.doc</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"redirect\"><a href=\"#redirect\" class=\"headerlink\" title=\"redirect()\"></a>redirect()</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 重定向到指定的 URL 路径</span></span><br><span class=\"line\">res.redirect(<span class=\"string\">'/404.html'</span>);</span><br><span class=\"line\">res.redirect(<span class=\"string\">'https://www.google.com/'</span>);</span><br></pre></td></tr></table></figure>\n<p>更多响应对象的方法，参考 <a href=\"http://www.expressjs.com.cn/4x/api.html#res\" target=\"_blank\" rel=\"noopener\">Express 官方API</a>。</p>\n<h3 id=\"Express-请求对象\"><a href=\"#Express-请求对象\" class=\"headerlink\" title=\"Express 请求对象\"></a>Express 请求对象</h3><p>Express 中的 <code>Request</code> 对象，包含了一次请求中的所有数据，比如请求头、路径、Cookies 等，获取请求头中的信息，服务器根据这些信息处理业务逻辑层，最终将处理过后的数据返回给用户。这里总结了常用的请求对象方法。</p>\n<h4 id=\"URL-中的参数\"><a href=\"#URL-中的参数\" class=\"headerlink\" title=\"URL 中的参数\"></a>URL 中的参数</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方式一： req.query.参数名</span></span><br><span class=\"line\"><span class=\"comment\">// e.g.  http://localhost:3000/user?name=ifyour</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(req.query.name);</span><br><span class=\"line\"><span class=\"comment\">// =&gt; ifyour</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方式二：req.params.参数名</span></span><br><span class=\"line\"><span class=\"comment\">//e.g.  http://localhost/post/123123</span></span><br><span class=\"line\">router.get(<span class=\"string\">'/post/:id'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(req.params.id);</span><br><span class=\"line\">    <span class=\"comment\">// =&gt; 123123</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"表单中的参数\"><a href=\"#表单中的参数\" class=\"headerlink\" title=\"表单中的参数\"></a>表单中的参数</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方式一：语法：req.param.参数名  注意这里没加 s</span></span><br><span class=\"line\"><span class=\"comment\">// e.g. &lt;input type=\"text\" name=\"user\"&gt;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(req.param(<span class=\"string\">'user'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方式二：使用 body-parser 中间件</span></span><br><span class=\"line\"><span class=\"comment\">// e.g. &lt;input type=\"text\" name=\"user\"&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bodyparser = <span class=\"built_in\">require</span>(<span class=\"string\">'body-parser'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.console.log(req.boy.user);</span><br></pre></td></tr></table></figure>\n<h3 id=\"Express-中间件\"><a href=\"#Express-中间件\" class=\"headerlink\" title=\"Express 中间件\"></a>Express 中间件</h3><p>Express 是一个自身功能极简，完全是由路由和中间件构成一个的 Web 开发框架：从本质上来说，一个 Express 应用就是在调用各种中间件。<br><img src=\"http://ww3.sinaimg.cn/large/6057861cgw1fbcrpk71zxj20sg03kaaa.jpg\" alt=\"\"><br>如图，中间件（Middleware）位于客户端和路由之间，它好比是一个漏斗，经过这个漏斗的 <code>Request</code> 对象和 <code>Response</code> 对象以及循环流程中的 <code>Next</code> 会被处理，比如正确性校验、业务逻辑处理等。</p>\n<ul>\n<li>执行任何代码</li>\n<li>修改请求和响应对象</li>\n<li>终结请求-响应循环</li>\n<li>调用堆栈中的下一个中间件</li>\n</ul>\n<p><div class=\"tip\"><br>如果当前中间件没有终结请求-响应循环，则必须调用 next() 方法将控制权交给下一个中间件，否则请求就会挂起。<br></div><br>举个例子来说明一下，如何通过 <code>next()</code> 方法把控制权交给下一个中间件。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> app = express();</span><br><span class=\"line\">app.use(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res, next</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> accessToken = req.query.accessToken;</span><br><span class=\"line\">   <span class=\"comment\">//检查请求中是否含有“认证牌”，存在就继续执行。</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span>(accessToken)&#123;</span><br><span class=\"line\">       next(); <span class=\"comment\">// 执行下一个中间件</span></span><br><span class=\"line\">       &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">          res.send(“请求必须包含token”);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"应用级中间件\"><a href=\"#应用级中间件\" class=\"headerlink\" title=\"应用级中间件\"></a>应用级中间件</h4><p>应用级中间件就是绑定到用 <code>express()</code> 生成的对象 <code>app</code> 身上的，比如 <code>app.use()</code> 中的 <code>use</code> 方法，以及 <code>app.post()</code> 、<code>app.get()</code> 中的 <code>POST</code> 和 <code>GET</code> 方法等。</p>\n<h4 id=\"内置中间件\"><a href=\"#内置中间件\" class=\"headerlink\" title=\"内置中间件\"></a>内置中间件</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 设置公共静态目录，用于存放 css js image 等文件，项目目录里有 images 目录存放 1.png</span></span><br><span class=\"line\"><span class=\"comment\">// 那么访问：http://localhost/images/1.png 获取</span></span><br><span class=\"line\">app.use(express.static(<span class=\"string\">'public'</span>));</span><br></pre></td></tr></table></figure>\n<h4 id=\"第三方中间件\"><a href=\"#第三方中间件\" class=\"headerlink\" title=\"第三方中间件\"></a>第三方中间件</h4><p>中间件可以说是整个 Express 的精华所在了，使用中间件可以几大的扩展项目的功能。使用方法都差不多，这里介绍几个常用的，具体使用方式需要看官方的文档了。</p>\n<ul>\n<li>解析客户端请求的 body 中的内容：body-parser</li>\n<li>cookie 解析中间件：cookie-parser</li>\n<li>文件上传中间件：multer</li>\n</ul>\n<p>使用命令 <code>npm i 包名称 --save</code> 安装到项目中，然后引入项目使用即可。</p>"},{"title":"React 组件模式","comments":1,"date":"2018-05-15T16:33:40.000Z","from":"https://levelup.gitconnected.com/react-component-patterns-ab1f09be2c82","_content":"\n使用 React 已经有一段时间了， React 是 Facebook 公司开发的用于构建网页界面的 UI 库。本文试图总结实践中所学到的一些模式，同时希望能够帮助到即将迈入组件世界的开发者。\n\n<!-- more -->\n\n### 概要\n\n* 有状态组件 vs 无状态组件\n* 容器组件 vs 展示组件\n* 高阶组件 vs 回调渲染组件\n\n![image](https://user-images.githubusercontent.com/15377484/40128970-a333542c-5965-11e8-8505-d1284d2759b1.png)\n\n### 有状态组件 vs 无状态组件\n\n正如 WEB 服务有静态和动态之分，React 组件也有有状态和无状态的区分。\n\n* 有状态组件：在应用中组件可以拥有自身状态并操纵它；\n* 无状态组件：只接收属性进行效果呈现。\n\n一个简单的无状态组件，只受属性控制:\n\n```jsx\nconst Button = props => (\n  <button onClick={props.onClick}>\n    {props.text}\n  </button>\n);\n```\n\n一个具有计数功能的按钮组件 (复用上面 Button 组件)\n\n```jsx\nclass ButtonCounter extends React.Component {\n  constructor() {\n    super()\n    this.state = {clicks: 0}\n    this.handleClick = this.handleClick.bind(this)\n  }\n\n  handleClick() {\n    this.setState({clicks: this.state.clicks + 1})\n  }\n\n  render() {\n    return (\n      <Button\n        onClick={this.handleClick}\n        text={`You've clicked me ${this.state.clicks} times!`}\n      />\n    )\n  }\n}\n```\n\n正如上面两个 Demo 所示，第二个组件的 `constructor` 具有状态的定义，第一个组件只是单纯地渲染属性文字。有状态组件和无状态组件的划分看起来非常简单，但是它对于组件复用具有重大意义。\n\n### 容器组件 vs 展示组件\n\n当组件需要获取外部数据时，我们又可以将组件划分为两种新的类型。容器组件负责获取数据，它常常是超出了 React 范畴的，如使用 Redux 或 Relay 进行了绑定。对比而言，展示型组件不依赖于程序其他部分，它只和自身状态或属性有关。下面我们实现一个用户列表的展示组件:\n\n```jsx\nconst UserList = props =>\n  <ul>\n    {props.users.map(u => (\n      <li>{u.name} — {u.age} years old</li>\n    ))}\n  </ul>\n```\n\n容器组件可以用来更新用户列表的展示:\n\n```jsx\nclass UserListContainer extends React.Component {\n  constructor() {\n    super()\n    this.state = {users: [] }\n  }\n\n  componentDidMount() {\n    fetchUsers(users => this.setState({ users }))\n  }\n\n  render() {\n    return <UserList users={this.state.users} />\n  }\n}\n```\n\n这种分类将数据获取和渲染的逻辑分开，进而使用户列表组件可以复用。\n\n如果你想了解更多该模式的信息，[这篇文章](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0)对它进行了详细的解释。\n\n### 高阶组件\n\n当你想复用组件逻辑时，高阶组件非常有用。高阶组件：是将组件作为参数并返回新组件的 JS 函数。\n\n假设你需要构建一个可扩展菜单组件，当用户点击时，它会显示隐藏子组件内容。因此，你可以使用高阶组件来实现:\n\n```jsx\nfunction makeToggleable(Clickable) {\n  return class extends React.Component {\n    constructor() {\n      super()\n      this.toggle = this.toggle.bind(this)\n      this.state = {show: false}\n    }\n\n    toggle() {\n      this.setState(prevState => ({ show: !prevState.show }))\n    }\n\n    render() {\n      return (\n        <div>\n          <Clickable\n            {...this.props}\n            onClick={this.toggle}\n          />\n          {this.state.show && this.props.children}\n        </div>\n      )\n    }\n  }\n}\n```\n\n这种方法允许我们使用 ES7 装饰器语法将逻辑应用于 ToggleableMenu 组件:\n\n```jsx\n@makeToggleable\nclass ToggleableMenu extends React.Component {\n  render() {\n    return (\n      <div onClick={this.props.onClick}>\n        <h1>{this.props.title}</h1>\n      </div>\n    )\n  }\n}\n```\n\n现在，我们可以将任何子组件传递给 ToggleableMenu 组件:\n\n```jsx\nclass Menu extends React.Component {\n  render() {\n    return (\n      <div>\n        <ToggleableMenu title=\"First Menu\">\n          <p>Some content</p>\n        </ToggleableMenu>\n        <ToggleableMenu title=\"Second Menu\">\n          <p>Another content</p>\n        </ToggleableMenu>\n        <ToggleableMenu title=\"Third Menu\">\n          <p>More content</p>\n        </ToggleableMenu>\n      </div>\n    )\n  }\n}\n```\n\n如果你熟悉 Redux 的 connect 函数或者 React Router 的 withRouter 函数，那么你已经使用过高阶组件了。\n\n### 回调渲染组件\n\n另一个比较高端的复用组件逻辑的方法是将函数作为组件的 `props.children`，该方法也称为 **Function as Child Components**。我们将使用** 渲染回调 **来重新实现上面的可扩展 Menu:\n\n```jsx\nclass Toggleable extends React.Component {\n  constructor() {\n    super()\n    this.toggle = this.toggle.bind(this)\n    this.state = {show: false}\n  }\n\n  toggle() {\n    this.setState(prevState => ({ show: !prevState.show }))\n  }\n\n  render() {\n    return this.props.children(this.state.show, this.toggle)\n  }\n}\n```\n\n现在，我们可以将函数作为组件的子级进行传递:\n\n```jsx\n<Toggleable>\n  {(show, onClick) => (\n    <div>\n      <div onClick={onClick}>\n        <h1>{props.title}</h1>\n      </div>\n      {show && props.children}\n    </div>\n  )}\n</Toggleable>\n```\n\n上面的代码已经将一个函数作为** 子组件 **，但是，若我们想复用上述逻辑，我们需要创建一个转换逻辑的新组件：\n\n```jsx\nconst ToggleableMenu = props =>\n  <Toggleable>\n    {(show, onClick) => (\n      <div>\n        <div onClick={onClick}>\n          <h1>{props.title}</h1>\n        </div>\n        {show && props.children}\n      </div>\n    )}\n  </Toggleable>\n```\n\n我们使用 Render Callbacks 实现的可扩展的 Menu 组件如下:\n\n```jsx\nclass Menu extends React.Component {\n  render() {\n    return (\n      <div>\n        <ToggleableMenu title=\"First Menu\">\n          <p>Some content</p>\n        </ToggleableMenu>\n        <ToggleableMenu title=\"Second Menu\">\n          <p>Another content</p>\n        </ToggleableMenu>\n        <ToggleableMenu title=\"Third Menu\">\n          <p>More content</p>\n        </ToggleableMenu>\n      </div>\n    )\n  }\n}\n```\n\n回调渲染组件 (Render Callbacks) 和高阶函数使我们的组件更加灵活，掌握和适应起来具有一定的难度，需要反复学习和消化。\n","source":"_posts/React-组件模式.md","raw":"---\ntitle: React 组件模式\ncomments: true\ndate: 2018-05-16 00:33:40\ntags:\nfrom: https://levelup.gitconnected.com/react-component-patterns-ab1f09be2c82\n---\n\n使用 React 已经有一段时间了， React 是 Facebook 公司开发的用于构建网页界面的 UI 库。本文试图总结实践中所学到的一些模式，同时希望能够帮助到即将迈入组件世界的开发者。\n\n<!-- more -->\n\n### 概要\n\n* 有状态组件 vs 无状态组件\n* 容器组件 vs 展示组件\n* 高阶组件 vs 回调渲染组件\n\n![image](https://user-images.githubusercontent.com/15377484/40128970-a333542c-5965-11e8-8505-d1284d2759b1.png)\n\n### 有状态组件 vs 无状态组件\n\n正如 WEB 服务有静态和动态之分，React 组件也有有状态和无状态的区分。\n\n* 有状态组件：在应用中组件可以拥有自身状态并操纵它；\n* 无状态组件：只接收属性进行效果呈现。\n\n一个简单的无状态组件，只受属性控制:\n\n```jsx\nconst Button = props => (\n  <button onClick={props.onClick}>\n    {props.text}\n  </button>\n);\n```\n\n一个具有计数功能的按钮组件 (复用上面 Button 组件)\n\n```jsx\nclass ButtonCounter extends React.Component {\n  constructor() {\n    super()\n    this.state = {clicks: 0}\n    this.handleClick = this.handleClick.bind(this)\n  }\n\n  handleClick() {\n    this.setState({clicks: this.state.clicks + 1})\n  }\n\n  render() {\n    return (\n      <Button\n        onClick={this.handleClick}\n        text={`You've clicked me ${this.state.clicks} times!`}\n      />\n    )\n  }\n}\n```\n\n正如上面两个 Demo 所示，第二个组件的 `constructor` 具有状态的定义，第一个组件只是单纯地渲染属性文字。有状态组件和无状态组件的划分看起来非常简单，但是它对于组件复用具有重大意义。\n\n### 容器组件 vs 展示组件\n\n当组件需要获取外部数据时，我们又可以将组件划分为两种新的类型。容器组件负责获取数据，它常常是超出了 React 范畴的，如使用 Redux 或 Relay 进行了绑定。对比而言，展示型组件不依赖于程序其他部分，它只和自身状态或属性有关。下面我们实现一个用户列表的展示组件:\n\n```jsx\nconst UserList = props =>\n  <ul>\n    {props.users.map(u => (\n      <li>{u.name} — {u.age} years old</li>\n    ))}\n  </ul>\n```\n\n容器组件可以用来更新用户列表的展示:\n\n```jsx\nclass UserListContainer extends React.Component {\n  constructor() {\n    super()\n    this.state = {users: [] }\n  }\n\n  componentDidMount() {\n    fetchUsers(users => this.setState({ users }))\n  }\n\n  render() {\n    return <UserList users={this.state.users} />\n  }\n}\n```\n\n这种分类将数据获取和渲染的逻辑分开，进而使用户列表组件可以复用。\n\n如果你想了解更多该模式的信息，[这篇文章](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0)对它进行了详细的解释。\n\n### 高阶组件\n\n当你想复用组件逻辑时，高阶组件非常有用。高阶组件：是将组件作为参数并返回新组件的 JS 函数。\n\n假设你需要构建一个可扩展菜单组件，当用户点击时，它会显示隐藏子组件内容。因此，你可以使用高阶组件来实现:\n\n```jsx\nfunction makeToggleable(Clickable) {\n  return class extends React.Component {\n    constructor() {\n      super()\n      this.toggle = this.toggle.bind(this)\n      this.state = {show: false}\n    }\n\n    toggle() {\n      this.setState(prevState => ({ show: !prevState.show }))\n    }\n\n    render() {\n      return (\n        <div>\n          <Clickable\n            {...this.props}\n            onClick={this.toggle}\n          />\n          {this.state.show && this.props.children}\n        </div>\n      )\n    }\n  }\n}\n```\n\n这种方法允许我们使用 ES7 装饰器语法将逻辑应用于 ToggleableMenu 组件:\n\n```jsx\n@makeToggleable\nclass ToggleableMenu extends React.Component {\n  render() {\n    return (\n      <div onClick={this.props.onClick}>\n        <h1>{this.props.title}</h1>\n      </div>\n    )\n  }\n}\n```\n\n现在，我们可以将任何子组件传递给 ToggleableMenu 组件:\n\n```jsx\nclass Menu extends React.Component {\n  render() {\n    return (\n      <div>\n        <ToggleableMenu title=\"First Menu\">\n          <p>Some content</p>\n        </ToggleableMenu>\n        <ToggleableMenu title=\"Second Menu\">\n          <p>Another content</p>\n        </ToggleableMenu>\n        <ToggleableMenu title=\"Third Menu\">\n          <p>More content</p>\n        </ToggleableMenu>\n      </div>\n    )\n  }\n}\n```\n\n如果你熟悉 Redux 的 connect 函数或者 React Router 的 withRouter 函数，那么你已经使用过高阶组件了。\n\n### 回调渲染组件\n\n另一个比较高端的复用组件逻辑的方法是将函数作为组件的 `props.children`，该方法也称为 **Function as Child Components**。我们将使用** 渲染回调 **来重新实现上面的可扩展 Menu:\n\n```jsx\nclass Toggleable extends React.Component {\n  constructor() {\n    super()\n    this.toggle = this.toggle.bind(this)\n    this.state = {show: false}\n  }\n\n  toggle() {\n    this.setState(prevState => ({ show: !prevState.show }))\n  }\n\n  render() {\n    return this.props.children(this.state.show, this.toggle)\n  }\n}\n```\n\n现在，我们可以将函数作为组件的子级进行传递:\n\n```jsx\n<Toggleable>\n  {(show, onClick) => (\n    <div>\n      <div onClick={onClick}>\n        <h1>{props.title}</h1>\n      </div>\n      {show && props.children}\n    </div>\n  )}\n</Toggleable>\n```\n\n上面的代码已经将一个函数作为** 子组件 **，但是，若我们想复用上述逻辑，我们需要创建一个转换逻辑的新组件：\n\n```jsx\nconst ToggleableMenu = props =>\n  <Toggleable>\n    {(show, onClick) => (\n      <div>\n        <div onClick={onClick}>\n          <h1>{props.title}</h1>\n        </div>\n        {show && props.children}\n      </div>\n    )}\n  </Toggleable>\n```\n\n我们使用 Render Callbacks 实现的可扩展的 Menu 组件如下:\n\n```jsx\nclass Menu extends React.Component {\n  render() {\n    return (\n      <div>\n        <ToggleableMenu title=\"First Menu\">\n          <p>Some content</p>\n        </ToggleableMenu>\n        <ToggleableMenu title=\"Second Menu\">\n          <p>Another content</p>\n        </ToggleableMenu>\n        <ToggleableMenu title=\"Third Menu\">\n          <p>More content</p>\n        </ToggleableMenu>\n      </div>\n    )\n  }\n}\n```\n\n回调渲染组件 (Render Callbacks) 和高阶函数使我们的组件更加灵活，掌握和适应起来具有一定的难度，需要反复学习和消化。\n","slug":"React-组件模式","published":1,"updated":"2018-06-17T09:49:30.000Z","layout":"post","photos":[],"link":"","_id":"cjiitidj3000gu4q9ne5hmg1x","content":"<p>使用 React 已经有一段时间了， React 是 Facebook 公司开发的用于构建网页界面的 UI 库。本文试图总结实践中所学到的一些模式，同时希望能够帮助到即将迈入组件世界的开发者。</p>\n<a id=\"more\"></a>\n<h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><ul>\n<li>有状态组件 vs 无状态组件</li>\n<li>容器组件 vs 展示组件</li>\n<li>高阶组件 vs 回调渲染组件</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/15377484/40128970-a333542c-5965-11e8-8505-d1284d2759b1.png\" alt=\"image\"></p>\n<h3 id=\"有状态组件-vs-无状态组件\"><a href=\"#有状态组件-vs-无状态组件\" class=\"headerlink\" title=\"有状态组件 vs 无状态组件\"></a>有状态组件 vs 无状态组件</h3><p>正如 WEB 服务有静态和动态之分，React 组件也有有状态和无状态的区分。</p>\n<ul>\n<li>有状态组件：在应用中组件可以拥有自身状态并操纵它；</li>\n<li>无状态组件：只接收属性进行效果呈现。</li>\n</ul>\n<p>一个简单的无状态组件，只受属性控制:</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Button = <span class=\"function\"><span class=\"params\">props</span> =&gt;</span> (</span><br><span class=\"line\">  &lt;button onClick=&#123;props.onClick&#125;&gt;</span><br><span class=\"line\">    &#123;props.text&#125;</span><br><span class=\"line\">  &lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">);</span></span><br></pre></td></tr></table></figure>\n<p>一个具有计数功能的按钮组件 (复用上面 Button 组件)</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ButtonCounter</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>()</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;<span class=\"attr\">clicks</span>: <span class=\"number\">0</span>&#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.handleClick = <span class=\"keyword\">this</span>.handleClick.bind(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  handleClick() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">clicks</span>: <span class=\"keyword\">this</span>.state.clicks + <span class=\"number\">1</span>&#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;Button</span><br><span class=\"line\">        onClick=&#123;<span class=\"keyword\">this</span>.handleClick&#125;</span><br><span class=\"line\">        text=&#123;<span class=\"string\">`You've clicked me <span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.state.clicks&#125;</span> times!`</span>&#125;</span><br><span class=\"line\">      /&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>正如上面两个 Demo 所示，第二个组件的 <code>constructor</code> 具有状态的定义，第一个组件只是单纯地渲染属性文字。有状态组件和无状态组件的划分看起来非常简单，但是它对于组件复用具有重大意义。</p>\n<h3 id=\"容器组件-vs-展示组件\"><a href=\"#容器组件-vs-展示组件\" class=\"headerlink\" title=\"容器组件 vs 展示组件\"></a>容器组件 vs 展示组件</h3><p>当组件需要获取外部数据时，我们又可以将组件划分为两种新的类型。容器组件负责获取数据，它常常是超出了 React 范畴的，如使用 Redux 或 Relay 进行了绑定。对比而言，展示型组件不依赖于程序其他部分，它只和自身状态或属性有关。下面我们实现一个用户列表的展示组件:</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> UserList = <span class=\"function\"><span class=\"params\">props</span> =&gt;</span></span><br><span class=\"line\">  &lt;ul&gt;</span><br><span class=\"line\">    &#123;props.users.map(<span class=\"function\"><span class=\"params\">u</span> =&gt;</span> (</span><br><span class=\"line\">      &lt;li&gt;&#123;u.name&#125; — &#123;u.age&#125; years old&lt;<span class=\"regexp\">/li&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    ))&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;/u</span>l&gt;</span><br></pre></td></tr></table></figure>\n<p>容器组件可以用来更新用户列表的展示:</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserListContainer</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>()</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;<span class=\"attr\">users</span>: [] &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  componentDidMount() &#123;</span><br><span class=\"line\">    fetchUsers(<span class=\"function\"><span class=\"params\">users</span> =&gt;</span> <span class=\"keyword\">this</span>.setState(&#123; users &#125;))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">UserList</span> <span class=\"attr\">users</span>=<span class=\"string\">&#123;this.state.users&#125;</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">  &#125;</span></span><br><span class=\"line\"><span class=\"xml\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>这种分类将数据获取和渲染的逻辑分开，进而使用户列表组件可以复用。</p>\n<p>如果你想了解更多该模式的信息，<a href=\"https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0\" target=\"_blank\" rel=\"noopener\">这篇文章</a>对它进行了详细的解释。</p>\n<h3 id=\"高阶组件\"><a href=\"#高阶组件\" class=\"headerlink\" title=\"高阶组件\"></a>高阶组件</h3><p>当你想复用组件逻辑时，高阶组件非常有用。高阶组件：是将组件作为参数并返回新组件的 JS 函数。</p>\n<p>假设你需要构建一个可扩展菜单组件，当用户点击时，它会显示隐藏子组件内容。因此，你可以使用高阶组件来实现:</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">makeToggleable</span>(<span class=\"params\">Clickable</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>()</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.toggle = <span class=\"keyword\">this</span>.toggle.bind(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.state = &#123;<span class=\"attr\">show</span>: <span class=\"literal\">false</span>&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    toggle() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.setState(<span class=\"function\"><span class=\"params\">prevState</span> =&gt;</span> (&#123; <span class=\"attr\">show</span>: !prevState.show &#125;))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">          &lt;Clickable</span><br><span class=\"line\">            &#123;...this.props&#125;</span><br><span class=\"line\">            onClick=&#123;<span class=\"keyword\">this</span>.toggle&#125;</span><br><span class=\"line\">          /&gt;</span><br><span class=\"line\">          &#123;<span class=\"keyword\">this</span>.state.show &amp;&amp; <span class=\"keyword\">this</span>.props.children&#125;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      )</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>这种方法允许我们使用 ES7 装饰器语法将逻辑应用于 ToggleableMenu 组件:</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@makeToggleable</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ToggleableMenu</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div onClick=&#123;<span class=\"keyword\">this</span>.props.onClick&#125;&gt;</span><br><span class=\"line\">        &lt;h1&gt;&#123;<span class=\"keyword\">this</span>.props.title&#125;&lt;<span class=\"regexp\">/h1&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在，我们可以将任何子组件传递给 ToggleableMenu 组件:</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Menu</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;ToggleableMenu title=<span class=\"string\">\"First Menu\"</span>&gt;</span><br><span class=\"line\">          &lt;p&gt;Some content&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>ToggleableMenu&gt;</span><br><span class=\"line\">        &lt;ToggleableMenu title=<span class=\"string\">\"Second Menu\"</span>&gt;</span><br><span class=\"line\">          &lt;p&gt;Another content&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>ToggleableMenu&gt;</span><br><span class=\"line\">        &lt;ToggleableMenu title=<span class=\"string\">\"Third Menu\"</span>&gt;</span><br><span class=\"line\">          &lt;p&gt;More content&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>ToggleableMenu&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    )</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>如果你熟悉 Redux 的 connect 函数或者 React Router 的 withRouter 函数，那么你已经使用过高阶组件了。</p>\n<h3 id=\"回调渲染组件\"><a href=\"#回调渲染组件\" class=\"headerlink\" title=\"回调渲染组件\"></a>回调渲染组件</h3><p>另一个比较高端的复用组件逻辑的方法是将函数作为组件的 <code>props.children</code>，该方法也称为 <strong>Function as Child Components</strong>。我们将使用<strong> 渲染回调 </strong>来重新实现上面的可扩展 Menu:</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Toggleable</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>()</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.toggle = <span class=\"keyword\">this</span>.toggle.bind(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;<span class=\"attr\">show</span>: <span class=\"literal\">false</span>&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  toggle() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(<span class=\"function\"><span class=\"params\">prevState</span> =&gt;</span> (&#123; <span class=\"attr\">show</span>: !prevState.show &#125;))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.props.children(<span class=\"keyword\">this</span>.state.show, <span class=\"keyword\">this</span>.toggle)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在，我们可以将函数作为组件的子级进行传递:</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Toggleable&gt;</span><br><span class=\"line\">  &#123;(show, onClick) =&gt; (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;div onClick=&#123;onClick&#125;&gt;</span><br><span class=\"line\">        &lt;h1&gt;&#123;props.title&#125;&lt;<span class=\"regexp\">/h1&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">      &#123;show &amp;&amp; props.children&#125;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  )&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/</span>Toggleable&gt;</span><br></pre></td></tr></table></figure>\n<p>上面的代码已经将一个函数作为<strong> 子组件 </strong>，但是，若我们想复用上述逻辑，我们需要创建一个转换逻辑的新组件：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ToggleableMenu = <span class=\"function\"><span class=\"params\">props</span> =&gt;</span></span><br><span class=\"line\">  &lt;Toggleable&gt;</span><br><span class=\"line\">    &#123;(show, onClick) =&gt; (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;div onClick=&#123;onClick&#125;&gt;</span><br><span class=\"line\">          &lt;h1&gt;&#123;props.title&#125;&lt;<span class=\"regexp\">/h1&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>div&gt;</span><br><span class=\"line\">        &#123;show &amp;&amp; props.children&#125;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    )&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;/</span>Toggleable&gt;</span><br></pre></td></tr></table></figure>\n<p>我们使用 Render Callbacks 实现的可扩展的 Menu 组件如下:</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Menu</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;ToggleableMenu title=<span class=\"string\">\"First Menu\"</span>&gt;</span><br><span class=\"line\">          &lt;p&gt;Some content&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>ToggleableMenu&gt;</span><br><span class=\"line\">        &lt;ToggleableMenu title=<span class=\"string\">\"Second Menu\"</span>&gt;</span><br><span class=\"line\">          &lt;p&gt;Another content&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>ToggleableMenu&gt;</span><br><span class=\"line\">        &lt;ToggleableMenu title=<span class=\"string\">\"Third Menu\"</span>&gt;</span><br><span class=\"line\">          &lt;p&gt;More content&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>ToggleableMenu&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    )</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>回调渲染组件 (Render Callbacks) 和高阶函数使我们的组件更加灵活，掌握和适应起来具有一定的难度，需要反复学习和消化。</p>\n","site":{"data":{}},"excerpt":"<p>使用 React 已经有一段时间了， React 是 Facebook 公司开发的用于构建网页界面的 UI 库。本文试图总结实践中所学到的一些模式，同时希望能够帮助到即将迈入组件世界的开发者。</p>","more":"<h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><ul>\n<li>有状态组件 vs 无状态组件</li>\n<li>容器组件 vs 展示组件</li>\n<li>高阶组件 vs 回调渲染组件</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/15377484/40128970-a333542c-5965-11e8-8505-d1284d2759b1.png\" alt=\"image\"></p>\n<h3 id=\"有状态组件-vs-无状态组件\"><a href=\"#有状态组件-vs-无状态组件\" class=\"headerlink\" title=\"有状态组件 vs 无状态组件\"></a>有状态组件 vs 无状态组件</h3><p>正如 WEB 服务有静态和动态之分，React 组件也有有状态和无状态的区分。</p>\n<ul>\n<li>有状态组件：在应用中组件可以拥有自身状态并操纵它；</li>\n<li>无状态组件：只接收属性进行效果呈现。</li>\n</ul>\n<p>一个简单的无状态组件，只受属性控制:</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Button = <span class=\"function\"><span class=\"params\">props</span> =&gt;</span> (</span><br><span class=\"line\">  &lt;button onClick=&#123;props.onClick&#125;&gt;</span><br><span class=\"line\">    &#123;props.text&#125;</span><br><span class=\"line\">  &lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">);</span></span><br></pre></td></tr></table></figure>\n<p>一个具有计数功能的按钮组件 (复用上面 Button 组件)</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ButtonCounter</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>()</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;<span class=\"attr\">clicks</span>: <span class=\"number\">0</span>&#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.handleClick = <span class=\"keyword\">this</span>.handleClick.bind(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  handleClick() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">clicks</span>: <span class=\"keyword\">this</span>.state.clicks + <span class=\"number\">1</span>&#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;Button</span><br><span class=\"line\">        onClick=&#123;<span class=\"keyword\">this</span>.handleClick&#125;</span><br><span class=\"line\">        text=&#123;<span class=\"string\">`You've clicked me <span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.state.clicks&#125;</span> times!`</span>&#125;</span><br><span class=\"line\">      /&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>正如上面两个 Demo 所示，第二个组件的 <code>constructor</code> 具有状态的定义，第一个组件只是单纯地渲染属性文字。有状态组件和无状态组件的划分看起来非常简单，但是它对于组件复用具有重大意义。</p>\n<h3 id=\"容器组件-vs-展示组件\"><a href=\"#容器组件-vs-展示组件\" class=\"headerlink\" title=\"容器组件 vs 展示组件\"></a>容器组件 vs 展示组件</h3><p>当组件需要获取外部数据时，我们又可以将组件划分为两种新的类型。容器组件负责获取数据，它常常是超出了 React 范畴的，如使用 Redux 或 Relay 进行了绑定。对比而言，展示型组件不依赖于程序其他部分，它只和自身状态或属性有关。下面我们实现一个用户列表的展示组件:</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> UserList = <span class=\"function\"><span class=\"params\">props</span> =&gt;</span></span><br><span class=\"line\">  &lt;ul&gt;</span><br><span class=\"line\">    &#123;props.users.map(<span class=\"function\"><span class=\"params\">u</span> =&gt;</span> (</span><br><span class=\"line\">      &lt;li&gt;&#123;u.name&#125; — &#123;u.age&#125; years old&lt;<span class=\"regexp\">/li&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    ))&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;/u</span>l&gt;</span><br></pre></td></tr></table></figure>\n<p>容器组件可以用来更新用户列表的展示:</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserListContainer</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>()</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;<span class=\"attr\">users</span>: [] &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  componentDidMount() &#123;</span><br><span class=\"line\">    fetchUsers(<span class=\"function\"><span class=\"params\">users</span> =&gt;</span> <span class=\"keyword\">this</span>.setState(&#123; users &#125;))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">UserList</span> <span class=\"attr\">users</span>=<span class=\"string\">&#123;this.state.users&#125;</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">  &#125;</span></span><br><span class=\"line\"><span class=\"xml\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>这种分类将数据获取和渲染的逻辑分开，进而使用户列表组件可以复用。</p>\n<p>如果你想了解更多该模式的信息，<a href=\"https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0\" target=\"_blank\" rel=\"noopener\">这篇文章</a>对它进行了详细的解释。</p>\n<h3 id=\"高阶组件\"><a href=\"#高阶组件\" class=\"headerlink\" title=\"高阶组件\"></a>高阶组件</h3><p>当你想复用组件逻辑时，高阶组件非常有用。高阶组件：是将组件作为参数并返回新组件的 JS 函数。</p>\n<p>假设你需要构建一个可扩展菜单组件，当用户点击时，它会显示隐藏子组件内容。因此，你可以使用高阶组件来实现:</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">makeToggleable</span>(<span class=\"params\">Clickable</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>()</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.toggle = <span class=\"keyword\">this</span>.toggle.bind(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.state = &#123;<span class=\"attr\">show</span>: <span class=\"literal\">false</span>&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    toggle() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.setState(<span class=\"function\"><span class=\"params\">prevState</span> =&gt;</span> (&#123; <span class=\"attr\">show</span>: !prevState.show &#125;))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">          &lt;Clickable</span><br><span class=\"line\">            &#123;...this.props&#125;</span><br><span class=\"line\">            onClick=&#123;<span class=\"keyword\">this</span>.toggle&#125;</span><br><span class=\"line\">          /&gt;</span><br><span class=\"line\">          &#123;<span class=\"keyword\">this</span>.state.show &amp;&amp; <span class=\"keyword\">this</span>.props.children&#125;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      )</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>这种方法允许我们使用 ES7 装饰器语法将逻辑应用于 ToggleableMenu 组件:</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@makeToggleable</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ToggleableMenu</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div onClick=&#123;<span class=\"keyword\">this</span>.props.onClick&#125;&gt;</span><br><span class=\"line\">        &lt;h1&gt;&#123;<span class=\"keyword\">this</span>.props.title&#125;&lt;<span class=\"regexp\">/h1&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在，我们可以将任何子组件传递给 ToggleableMenu 组件:</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Menu</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;ToggleableMenu title=<span class=\"string\">\"First Menu\"</span>&gt;</span><br><span class=\"line\">          &lt;p&gt;Some content&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>ToggleableMenu&gt;</span><br><span class=\"line\">        &lt;ToggleableMenu title=<span class=\"string\">\"Second Menu\"</span>&gt;</span><br><span class=\"line\">          &lt;p&gt;Another content&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>ToggleableMenu&gt;</span><br><span class=\"line\">        &lt;ToggleableMenu title=<span class=\"string\">\"Third Menu\"</span>&gt;</span><br><span class=\"line\">          &lt;p&gt;More content&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>ToggleableMenu&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    )</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>如果你熟悉 Redux 的 connect 函数或者 React Router 的 withRouter 函数，那么你已经使用过高阶组件了。</p>\n<h3 id=\"回调渲染组件\"><a href=\"#回调渲染组件\" class=\"headerlink\" title=\"回调渲染组件\"></a>回调渲染组件</h3><p>另一个比较高端的复用组件逻辑的方法是将函数作为组件的 <code>props.children</code>，该方法也称为 <strong>Function as Child Components</strong>。我们将使用<strong> 渲染回调 </strong>来重新实现上面的可扩展 Menu:</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Toggleable</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>()</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.toggle = <span class=\"keyword\">this</span>.toggle.bind(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;<span class=\"attr\">show</span>: <span class=\"literal\">false</span>&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  toggle() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(<span class=\"function\"><span class=\"params\">prevState</span> =&gt;</span> (&#123; <span class=\"attr\">show</span>: !prevState.show &#125;))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.props.children(<span class=\"keyword\">this</span>.state.show, <span class=\"keyword\">this</span>.toggle)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在，我们可以将函数作为组件的子级进行传递:</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Toggleable&gt;</span><br><span class=\"line\">  &#123;(show, onClick) =&gt; (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;div onClick=&#123;onClick&#125;&gt;</span><br><span class=\"line\">        &lt;h1&gt;&#123;props.title&#125;&lt;<span class=\"regexp\">/h1&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">      &#123;show &amp;&amp; props.children&#125;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  )&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/</span>Toggleable&gt;</span><br></pre></td></tr></table></figure>\n<p>上面的代码已经将一个函数作为<strong> 子组件 </strong>，但是，若我们想复用上述逻辑，我们需要创建一个转换逻辑的新组件：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ToggleableMenu = <span class=\"function\"><span class=\"params\">props</span> =&gt;</span></span><br><span class=\"line\">  &lt;Toggleable&gt;</span><br><span class=\"line\">    &#123;(show, onClick) =&gt; (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;div onClick=&#123;onClick&#125;&gt;</span><br><span class=\"line\">          &lt;h1&gt;&#123;props.title&#125;&lt;<span class=\"regexp\">/h1&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>div&gt;</span><br><span class=\"line\">        &#123;show &amp;&amp; props.children&#125;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    )&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;/</span>Toggleable&gt;</span><br></pre></td></tr></table></figure>\n<p>我们使用 Render Callbacks 实现的可扩展的 Menu 组件如下:</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Menu</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;ToggleableMenu title=<span class=\"string\">\"First Menu\"</span>&gt;</span><br><span class=\"line\">          &lt;p&gt;Some content&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>ToggleableMenu&gt;</span><br><span class=\"line\">        &lt;ToggleableMenu title=<span class=\"string\">\"Second Menu\"</span>&gt;</span><br><span class=\"line\">          &lt;p&gt;Another content&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>ToggleableMenu&gt;</span><br><span class=\"line\">        &lt;ToggleableMenu title=<span class=\"string\">\"Third Menu\"</span>&gt;</span><br><span class=\"line\">          &lt;p&gt;More content&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>ToggleableMenu&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    )</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>回调渲染组件 (Render Callbacks) 和高阶函数使我们的组件更加灵活，掌握和适应起来具有一定的难度，需要反复学习和消化。</p>"},{"title":"Why Immutable Data?","date":"2018-05-05T13:14:23.000Z","comments":1,"_content":"什么是不可变数据, 如何理解不可变数据, 不可变数据在项目中的实践. 弄清楚了这些问题, 你才能更好的处理项目中一些调优问题. 比如 React 性能优化等. 一起来学习下吧! 👨🏼‍💻\n\n<!-- more -->\n## What\n\n> ***Immutable Data*** 是指一旦被创造后就不可以被改变的数据, 通过使用 Immutable Data, 可以让我们更容易的去处理缓存、回退、数据变化检测等问题, 简化我们的开发.\n\n\n![image](https://user-images.githubusercontent.com/15377484/39663322-c4bb61ae-50a3-11e8-8267-4c2a80c00af7.png)\n\n\n## Why\n在原生 JS 中, 存在两种数据类型:\n\n- 静态数据类型\n- 引用数据类型\n\n引用类型数据结构非常灵活, 节约内存, 能给开发带来不少便利. 但与此同时也产生了一些副作用:\n\n#### Case 1:\n```js\nlet obj = { count: 1 };\nlet copyObj = obj;\ncopyObj.count = 2;\n\nconsole.log(copyObj.count); // => 2\nconsole.log(obj.count); // => 2, 这并不是我们期望的\n```\n#### Case 2:\n```js\nlet obj2 = { count: 1 };\n\n// 团队协作, 大家都在用这个 obj2\nunKnowFunction(obj2);\nconsole.log(obj2.count); // 能保证这个结果一定是1吗?\n```\n\n针对以上引用类型产生的副作用, 有人提出了 ***深度拷贝*** (Deep Clone)的方法, 实现代码如下:\n```js\nfunction isObject(obj) {\n  return typeof obj === 'object';\n}\n\nfunction isArray(arr) {\n  return Array.isArray(arr);\n}\n\nfunction deepClone(obj) {\n  if (!isObject(obj))  return obj;\n  var cloneObj = isArray(obj) ? [] : {};\n\n  for(var key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      var value = obj[key];\n      var copy = value;\n\n      if (isObject(value)) {\n        // 这里使用了递归\n        cloneObj[key] = deepClone(value);\n      } else {\n        cloneObj[key] = value;\n      }\n    }\n  }\n  return cloneObj;\n}\n```\n\n现在我们可以使用 `deepClone` 这个方法来解决文章一开头的问题了:\n```js\nlet obj = {\n  age: 5,\n  list: [1, 2, 3]\n}\n\n// 深拷贝一个新的对象, 两者互相独立, 不存在引用关系\nlet trueCopyObj = deepClone(obj);\nconsole.log(obj.list === trueCopyObj.list); // => false, 这是我们期望的\n\n// 但是又有一个问题, 我只是想拷贝一个新的对象, 改一下 `age`\nlet obj2 = deepClone(obj);\nobj2.age = 6;\n// 难不成剩下的一堆引用类型的属性都要递归做一次深拷贝?\n// 所以这明显是多余的, 并且存在严重的性能问题\n```\n\n在原生 JavaScript 中实现数据不可变, 有2个办法:\n\n- ES6: `const`\n- ES5: `Object.freeze`\n\n但是这两种都是浅处理, 遇到深层次的数据结构, 就需要递归处理, 又会存在性能上的问题.\n\n## How\n\n针对以上一系列需求, 我们完全可以使用不可变数据结构来处理, 对应的实现库有:\n- [facebook/immutable-js](https://github.com/facebook/immutable-js)\n- [rtfeldman/seamless-immutable](https://github.com/rtfeldman/seamless-immutable)\n\n\nImmutable.js 主要特点:\n- 稳定数据结构 (Persistent Data Structure), 每次返回新的对象, 不存在引用\n- 结构共享 (Structural Sharing), 基于哈希映射树, 可以实现部分结构共享\n- 支持延迟操作 (Support Lazy Operation)\n- 强大的 API (Power API)\n\n针对以上特点, 我们用一些代码实例来说明一下:\n```js\n/**\n * 稳定数据结构\n */\n\nlet obj = {count: 1};\nlet map = Immutable.fromJS(obj);\nlet map2 = map.set('count', 2);\n\nconsole.log(map.get('count')); // => 1\nconsole.log(map2.get('count')); // => 2\n```\n\n```js\n/**\n * 结构共享\n */\n\nlet obj = {\n  count: 1,\n  list: [1, 2, 3, 4, 5]\n}\nlet map1 = Immutable.fromJS(obj);\nlet map2 = map1.set('count', 2);\n\nconsole.log(map1.list === map2.list); // true\n```\n\n<div style=\"width: 300px; \">![image](https://user-images.githubusercontent.com/15377484/39665040-d92a0764-50bf-11e8-84e3-ad83cf758acd.gif)</div>\n\n这张 GIF 很形象的解释了 `结构共享` 👍\n\n```js\n/**\n * 强大的 API\n */\n\nlet obj = {\n  a: {\n    b: {\n      list: [1, 2, 3]\n    }\n  }\n};\nlet map = Immutable.fromJS(obj);\nlet map2 = Immutable.updateIn(['a', 'b', 'list'], (list) => {\n  return list.push(4);\n});\n\nconsole.log(map2.getIn(['a', 'b', 'list'])); // => List [ 1, 2, 3, 4 ]\n```\n\n还有一个特点就不举例子了, 超纲! 😁\n\n## 参考\n- [Immutable 详解及 React 中实践](https://github.com/camsong/blog/issues/3)\n- [浅合并 (shallow merge) 例子](https://stackoverflow.com/questions/27936772/how-to-deep-merge-instead-of-shallow-merge/28248548)\n- [Lodash merge 方法](https://lodash.com/docs/4.17.10#merge)\n","source":"_posts/Why-Immutable-Data.md","raw":"---\ntitle: Why Immutable Data?\ndate: 2018-05-05 21:14:23\ntags:\ncomments: true\n---\n什么是不可变数据, 如何理解不可变数据, 不可变数据在项目中的实践. 弄清楚了这些问题, 你才能更好的处理项目中一些调优问题. 比如 React 性能优化等. 一起来学习下吧! 👨🏼‍💻\n\n<!-- more -->\n## What\n\n> ***Immutable Data*** 是指一旦被创造后就不可以被改变的数据, 通过使用 Immutable Data, 可以让我们更容易的去处理缓存、回退、数据变化检测等问题, 简化我们的开发.\n\n\n![image](https://user-images.githubusercontent.com/15377484/39663322-c4bb61ae-50a3-11e8-8267-4c2a80c00af7.png)\n\n\n## Why\n在原生 JS 中, 存在两种数据类型:\n\n- 静态数据类型\n- 引用数据类型\n\n引用类型数据结构非常灵活, 节约内存, 能给开发带来不少便利. 但与此同时也产生了一些副作用:\n\n#### Case 1:\n```js\nlet obj = { count: 1 };\nlet copyObj = obj;\ncopyObj.count = 2;\n\nconsole.log(copyObj.count); // => 2\nconsole.log(obj.count); // => 2, 这并不是我们期望的\n```\n#### Case 2:\n```js\nlet obj2 = { count: 1 };\n\n// 团队协作, 大家都在用这个 obj2\nunKnowFunction(obj2);\nconsole.log(obj2.count); // 能保证这个结果一定是1吗?\n```\n\n针对以上引用类型产生的副作用, 有人提出了 ***深度拷贝*** (Deep Clone)的方法, 实现代码如下:\n```js\nfunction isObject(obj) {\n  return typeof obj === 'object';\n}\n\nfunction isArray(arr) {\n  return Array.isArray(arr);\n}\n\nfunction deepClone(obj) {\n  if (!isObject(obj))  return obj;\n  var cloneObj = isArray(obj) ? [] : {};\n\n  for(var key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      var value = obj[key];\n      var copy = value;\n\n      if (isObject(value)) {\n        // 这里使用了递归\n        cloneObj[key] = deepClone(value);\n      } else {\n        cloneObj[key] = value;\n      }\n    }\n  }\n  return cloneObj;\n}\n```\n\n现在我们可以使用 `deepClone` 这个方法来解决文章一开头的问题了:\n```js\nlet obj = {\n  age: 5,\n  list: [1, 2, 3]\n}\n\n// 深拷贝一个新的对象, 两者互相独立, 不存在引用关系\nlet trueCopyObj = deepClone(obj);\nconsole.log(obj.list === trueCopyObj.list); // => false, 这是我们期望的\n\n// 但是又有一个问题, 我只是想拷贝一个新的对象, 改一下 `age`\nlet obj2 = deepClone(obj);\nobj2.age = 6;\n// 难不成剩下的一堆引用类型的属性都要递归做一次深拷贝?\n// 所以这明显是多余的, 并且存在严重的性能问题\n```\n\n在原生 JavaScript 中实现数据不可变, 有2个办法:\n\n- ES6: `const`\n- ES5: `Object.freeze`\n\n但是这两种都是浅处理, 遇到深层次的数据结构, 就需要递归处理, 又会存在性能上的问题.\n\n## How\n\n针对以上一系列需求, 我们完全可以使用不可变数据结构来处理, 对应的实现库有:\n- [facebook/immutable-js](https://github.com/facebook/immutable-js)\n- [rtfeldman/seamless-immutable](https://github.com/rtfeldman/seamless-immutable)\n\n\nImmutable.js 主要特点:\n- 稳定数据结构 (Persistent Data Structure), 每次返回新的对象, 不存在引用\n- 结构共享 (Structural Sharing), 基于哈希映射树, 可以实现部分结构共享\n- 支持延迟操作 (Support Lazy Operation)\n- 强大的 API (Power API)\n\n针对以上特点, 我们用一些代码实例来说明一下:\n```js\n/**\n * 稳定数据结构\n */\n\nlet obj = {count: 1};\nlet map = Immutable.fromJS(obj);\nlet map2 = map.set('count', 2);\n\nconsole.log(map.get('count')); // => 1\nconsole.log(map2.get('count')); // => 2\n```\n\n```js\n/**\n * 结构共享\n */\n\nlet obj = {\n  count: 1,\n  list: [1, 2, 3, 4, 5]\n}\nlet map1 = Immutable.fromJS(obj);\nlet map2 = map1.set('count', 2);\n\nconsole.log(map1.list === map2.list); // true\n```\n\n<div style=\"width: 300px; \">![image](https://user-images.githubusercontent.com/15377484/39665040-d92a0764-50bf-11e8-84e3-ad83cf758acd.gif)</div>\n\n这张 GIF 很形象的解释了 `结构共享` 👍\n\n```js\n/**\n * 强大的 API\n */\n\nlet obj = {\n  a: {\n    b: {\n      list: [1, 2, 3]\n    }\n  }\n};\nlet map = Immutable.fromJS(obj);\nlet map2 = Immutable.updateIn(['a', 'b', 'list'], (list) => {\n  return list.push(4);\n});\n\nconsole.log(map2.getIn(['a', 'b', 'list'])); // => List [ 1, 2, 3, 4 ]\n```\n\n还有一个特点就不举例子了, 超纲! 😁\n\n## 参考\n- [Immutable 详解及 React 中实践](https://github.com/camsong/blog/issues/3)\n- [浅合并 (shallow merge) 例子](https://stackoverflow.com/questions/27936772/how-to-deep-merge-instead-of-shallow-merge/28248548)\n- [Lodash merge 方法](https://lodash.com/docs/4.17.10#merge)\n","slug":"Why-Immutable-Data","published":1,"updated":"2018-06-17T09:49:30.000Z","layout":"post","photos":[],"link":"","_id":"cjiitidj5000hu4q9rsgkw9sf","content":"<p>什么是不可变数据, 如何理解不可变数据, 不可变数据在项目中的实践. 弄清楚了这些问题, 你才能更好的处理项目中一些调优问题. 比如 React 性能优化等. 一起来学习下吧! 👨🏼‍💻</p>\n<a id=\"more\"></a>\n<h2 id=\"What\"><a href=\"#What\" class=\"headerlink\" title=\"What\"></a>What</h2><blockquote>\n<p><strong><em>Immutable Data</em></strong> 是指一旦被创造后就不可以被改变的数据, 通过使用 Immutable Data, 可以让我们更容易的去处理缓存、回退、数据变化检测等问题, 简化我们的开发.</p>\n</blockquote>\n<p><img src=\"https://user-images.githubusercontent.com/15377484/39663322-c4bb61ae-50a3-11e8-8267-4c2a80c00af7.png\" alt=\"image\"></p>\n<h2 id=\"Why\"><a href=\"#Why\" class=\"headerlink\" title=\"Why\"></a>Why</h2><p>在原生 JS 中, 存在两种数据类型:</p>\n<ul>\n<li>静态数据类型</li>\n<li>引用数据类型</li>\n</ul>\n<p>引用类型数据结构非常灵活, 节约内存, 能给开发带来不少便利. 但与此同时也产生了一些副作用:</p>\n<h4 id=\"Case-1\"><a href=\"#Case-1\" class=\"headerlink\" title=\"Case 1:\"></a>Case 1:</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123; <span class=\"attr\">count</span>: <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> copyObj = obj;</span><br><span class=\"line\">copyObj.count = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(copyObj.count); <span class=\"comment\">// =&gt; 2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.count); <span class=\"comment\">// =&gt; 2, 这并不是我们期望的</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"Case-2\"><a href=\"#Case-2\" class=\"headerlink\" title=\"Case 2:\"></a>Case 2:</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj2 = &#123; <span class=\"attr\">count</span>: <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 团队协作, 大家都在用这个 obj2</span></span><br><span class=\"line\">unKnowFunction(obj2);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj2.count); <span class=\"comment\">// 能保证这个结果一定是1吗?</span></span><br></pre></td></tr></table></figure>\n<p>针对以上引用类型产生的副作用, 有人提出了 <strong><em>深度拷贝</em></strong> (Deep Clone)的方法, 实现代码如下:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isObject</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> obj === <span class=\"string\">'object'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isArray</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.isArray(arr);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deepClone</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!isObject(obj))  <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> cloneObj = isArray(obj) ? [] : &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> obj) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> value = obj[key];</span><br><span class=\"line\">      <span class=\"keyword\">var</span> copy = value;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (isObject(value)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里使用了递归</span></span><br><span class=\"line\">        cloneObj[key] = deepClone(value);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        cloneObj[key] = value;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> cloneObj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>现在我们可以使用 <code>deepClone</code> 这个方法来解决文章一开头的问题了:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">  age: <span class=\"number\">5</span>,</span><br><span class=\"line\">  list: [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 深拷贝一个新的对象, 两者互相独立, 不存在引用关系</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> trueCopyObj = deepClone(obj);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.list === trueCopyObj.list); <span class=\"comment\">// =&gt; false, 这是我们期望的</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 但是又有一个问题, 我只是想拷贝一个新的对象, 改一下 `age`</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj2 = deepClone(obj);</span><br><span class=\"line\">obj2.age = <span class=\"number\">6</span>;</span><br><span class=\"line\"><span class=\"comment\">// 难不成剩下的一堆引用类型的属性都要递归做一次深拷贝?</span></span><br><span class=\"line\"><span class=\"comment\">// 所以这明显是多余的, 并且存在严重的性能问题</span></span><br></pre></td></tr></table></figure></p>\n<p>在原生 JavaScript 中实现数据不可变, 有2个办法:</p>\n<ul>\n<li>ES6: <code>const</code></li>\n<li>ES5: <code>Object.freeze</code></li>\n</ul>\n<p>但是这两种都是浅处理, 遇到深层次的数据结构, 就需要递归处理, 又会存在性能上的问题.</p>\n<h2 id=\"How\"><a href=\"#How\" class=\"headerlink\" title=\"How\"></a>How</h2><p>针对以上一系列需求, 我们完全可以使用不可变数据结构来处理, 对应的实现库有:</p>\n<ul>\n<li><a href=\"https://github.com/facebook/immutable-js\" target=\"_blank\" rel=\"noopener\">facebook/immutable-js</a></li>\n<li><a href=\"https://github.com/rtfeldman/seamless-immutable\" target=\"_blank\" rel=\"noopener\">rtfeldman/seamless-immutable</a></li>\n</ul>\n<p>Immutable.js 主要特点:</p>\n<ul>\n<li>稳定数据结构 (Persistent Data Structure), 每次返回新的对象, 不存在引用</li>\n<li>结构共享 (Structural Sharing), 基于哈希映射树, 可以实现部分结构共享</li>\n<li>支持延迟操作 (Support Lazy Operation)</li>\n<li>强大的 API (Power API)</li>\n</ul>\n<p>针对以上特点, 我们用一些代码实例来说明一下:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 稳定数据结构</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;<span class=\"attr\">count</span>: <span class=\"number\">1</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> map = Immutable.fromJS(obj);</span><br><span class=\"line\"><span class=\"keyword\">let</span> map2 = map.set(<span class=\"string\">'count'</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map.get(<span class=\"string\">'count'</span>)); <span class=\"comment\">// =&gt; 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map2.get(<span class=\"string\">'count'</span>)); <span class=\"comment\">// =&gt; 2</span></span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 结构共享</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">  count: <span class=\"number\">1</span>,</span><br><span class=\"line\">  list: [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> map1 = Immutable.fromJS(obj);</span><br><span class=\"line\"><span class=\"keyword\">let</span> map2 = map1.set(<span class=\"string\">'count'</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map1.list === map2.list); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<div style=\"width: 300px; \"><img src=\"https://user-images.githubusercontent.com/15377484/39665040-d92a0764-50bf-11e8-84e3-ad83cf758acd.gif\" alt=\"image\"></div>\n\n<p>这张 GIF 很形象的解释了 <code>结构共享</code> 👍</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 强大的 API</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">  a: &#123;</span><br><span class=\"line\">    b: &#123;</span><br><span class=\"line\">      list: [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> map = Immutable.fromJS(obj);</span><br><span class=\"line\"><span class=\"keyword\">let</span> map2 = Immutable.updateIn([<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'list'</span>], (list) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> list.push(<span class=\"number\">4</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map2.getIn([<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'list'</span>])); <span class=\"comment\">// =&gt; List [ 1, 2, 3, 4 ]</span></span><br></pre></td></tr></table></figure>\n<p>还有一个特点就不举例子了, 超纲! 😁</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://github.com/camsong/blog/issues/3\" target=\"_blank\" rel=\"noopener\">Immutable 详解及 React 中实践</a></li>\n<li><a href=\"https://stackoverflow.com/questions/27936772/how-to-deep-merge-instead-of-shallow-merge/28248548\" target=\"_blank\" rel=\"noopener\">浅合并 (shallow merge) 例子</a></li>\n<li><a href=\"https://lodash.com/docs/4.17.10#merge\" target=\"_blank\" rel=\"noopener\">Lodash merge 方法</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>什么是不可变数据, 如何理解不可变数据, 不可变数据在项目中的实践. 弄清楚了这些问题, 你才能更好的处理项目中一些调优问题. 比如 React 性能优化等. 一起来学习下吧! 👨🏼‍💻</p>","more":"<h2 id=\"What\"><a href=\"#What\" class=\"headerlink\" title=\"What\"></a>What</h2><blockquote>\n<p><strong><em>Immutable Data</em></strong> 是指一旦被创造后就不可以被改变的数据, 通过使用 Immutable Data, 可以让我们更容易的去处理缓存、回退、数据变化检测等问题, 简化我们的开发.</p>\n</blockquote>\n<p><img src=\"https://user-images.githubusercontent.com/15377484/39663322-c4bb61ae-50a3-11e8-8267-4c2a80c00af7.png\" alt=\"image\"></p>\n<h2 id=\"Why\"><a href=\"#Why\" class=\"headerlink\" title=\"Why\"></a>Why</h2><p>在原生 JS 中, 存在两种数据类型:</p>\n<ul>\n<li>静态数据类型</li>\n<li>引用数据类型</li>\n</ul>\n<p>引用类型数据结构非常灵活, 节约内存, 能给开发带来不少便利. 但与此同时也产生了一些副作用:</p>\n<h4 id=\"Case-1\"><a href=\"#Case-1\" class=\"headerlink\" title=\"Case 1:\"></a>Case 1:</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123; <span class=\"attr\">count</span>: <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> copyObj = obj;</span><br><span class=\"line\">copyObj.count = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(copyObj.count); <span class=\"comment\">// =&gt; 2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.count); <span class=\"comment\">// =&gt; 2, 这并不是我们期望的</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"Case-2\"><a href=\"#Case-2\" class=\"headerlink\" title=\"Case 2:\"></a>Case 2:</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj2 = &#123; <span class=\"attr\">count</span>: <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 团队协作, 大家都在用这个 obj2</span></span><br><span class=\"line\">unKnowFunction(obj2);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj2.count); <span class=\"comment\">// 能保证这个结果一定是1吗?</span></span><br></pre></td></tr></table></figure>\n<p>针对以上引用类型产生的副作用, 有人提出了 <strong><em>深度拷贝</em></strong> (Deep Clone)的方法, 实现代码如下:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isObject</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> obj === <span class=\"string\">'object'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isArray</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.isArray(arr);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deepClone</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!isObject(obj))  <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> cloneObj = isArray(obj) ? [] : &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> obj) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> value = obj[key];</span><br><span class=\"line\">      <span class=\"keyword\">var</span> copy = value;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (isObject(value)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里使用了递归</span></span><br><span class=\"line\">        cloneObj[key] = deepClone(value);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        cloneObj[key] = value;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> cloneObj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>现在我们可以使用 <code>deepClone</code> 这个方法来解决文章一开头的问题了:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">  age: <span class=\"number\">5</span>,</span><br><span class=\"line\">  list: [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 深拷贝一个新的对象, 两者互相独立, 不存在引用关系</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> trueCopyObj = deepClone(obj);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.list === trueCopyObj.list); <span class=\"comment\">// =&gt; false, 这是我们期望的</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 但是又有一个问题, 我只是想拷贝一个新的对象, 改一下 `age`</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj2 = deepClone(obj);</span><br><span class=\"line\">obj2.age = <span class=\"number\">6</span>;</span><br><span class=\"line\"><span class=\"comment\">// 难不成剩下的一堆引用类型的属性都要递归做一次深拷贝?</span></span><br><span class=\"line\"><span class=\"comment\">// 所以这明显是多余的, 并且存在严重的性能问题</span></span><br></pre></td></tr></table></figure></p>\n<p>在原生 JavaScript 中实现数据不可变, 有2个办法:</p>\n<ul>\n<li>ES6: <code>const</code></li>\n<li>ES5: <code>Object.freeze</code></li>\n</ul>\n<p>但是这两种都是浅处理, 遇到深层次的数据结构, 就需要递归处理, 又会存在性能上的问题.</p>\n<h2 id=\"How\"><a href=\"#How\" class=\"headerlink\" title=\"How\"></a>How</h2><p>针对以上一系列需求, 我们完全可以使用不可变数据结构来处理, 对应的实现库有:</p>\n<ul>\n<li><a href=\"https://github.com/facebook/immutable-js\" target=\"_blank\" rel=\"noopener\">facebook/immutable-js</a></li>\n<li><a href=\"https://github.com/rtfeldman/seamless-immutable\" target=\"_blank\" rel=\"noopener\">rtfeldman/seamless-immutable</a></li>\n</ul>\n<p>Immutable.js 主要特点:</p>\n<ul>\n<li>稳定数据结构 (Persistent Data Structure), 每次返回新的对象, 不存在引用</li>\n<li>结构共享 (Structural Sharing), 基于哈希映射树, 可以实现部分结构共享</li>\n<li>支持延迟操作 (Support Lazy Operation)</li>\n<li>强大的 API (Power API)</li>\n</ul>\n<p>针对以上特点, 我们用一些代码实例来说明一下:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 稳定数据结构</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;<span class=\"attr\">count</span>: <span class=\"number\">1</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> map = Immutable.fromJS(obj);</span><br><span class=\"line\"><span class=\"keyword\">let</span> map2 = map.set(<span class=\"string\">'count'</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map.get(<span class=\"string\">'count'</span>)); <span class=\"comment\">// =&gt; 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map2.get(<span class=\"string\">'count'</span>)); <span class=\"comment\">// =&gt; 2</span></span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 结构共享</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">  count: <span class=\"number\">1</span>,</span><br><span class=\"line\">  list: [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> map1 = Immutable.fromJS(obj);</span><br><span class=\"line\"><span class=\"keyword\">let</span> map2 = map1.set(<span class=\"string\">'count'</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map1.list === map2.list); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<div style=\"width: 300px; \"><img src=\"https://user-images.githubusercontent.com/15377484/39665040-d92a0764-50bf-11e8-84e3-ad83cf758acd.gif\" alt=\"image\"></div>\n\n<p>这张 GIF 很形象的解释了 <code>结构共享</code> 👍</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 强大的 API</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">  a: &#123;</span><br><span class=\"line\">    b: &#123;</span><br><span class=\"line\">      list: [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> map = Immutable.fromJS(obj);</span><br><span class=\"line\"><span class=\"keyword\">let</span> map2 = Immutable.updateIn([<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'list'</span>], (list) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> list.push(<span class=\"number\">4</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map2.getIn([<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'list'</span>])); <span class=\"comment\">// =&gt; List [ 1, 2, 3, 4 ]</span></span><br></pre></td></tr></table></figure>\n<p>还有一个特点就不举例子了, 超纲! 😁</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://github.com/camsong/blog/issues/3\" target=\"_blank\" rel=\"noopener\">Immutable 详解及 React 中实践</a></li>\n<li><a href=\"https://stackoverflow.com/questions/27936772/how-to-deep-merge-instead-of-shallow-merge/28248548\" target=\"_blank\" rel=\"noopener\">浅合并 (shallow merge) 例子</a></li>\n<li><a href=\"https://lodash.com/docs/4.17.10#merge\" target=\"_blank\" rel=\"noopener\">Lodash merge 方法</a></li>\n</ul>"},{"title":"代码重构","comments":1,"date":"2018-06-16T14:46:36.000Z","from":null,"_content":"\n今天读了曾探的[《设计模式》](https://book.douban.com/subject/26382780/)中的代码重构这一章节, 知识点不多却非常使用, 在实际项目中除了使用设计模式重构代码外, 还有一些容易忽略的细节. 这些细节也是重构的重要手段. 写这篇文章总结一下.\n\n<!-- more -->\n\n> 代码是写给人看的, 顺便给机器运行. 优雅的代码应该是简单、易维护、可扩展的.\n\n### 概述\n\n1. [提炼函数](#提炼函数)\n2. [合并重复的条件片段](#合并重复的条件片段)\n3. [把条件分支语句提炼成函数](#把条件分支语句提炼成函数)\n4. [合理的使用循环](#合理的使用循环)\n5. [提前让函数退出代替嵌套条件分支](#提前让函数退出代替嵌套条件分支)\n6. [传递对象参数代替过长的参数列表](#传递对象参数代替过长的参数列表)\n7. [尽量减少参数数量](#尽量减少参数数量)\n8. [少用三目运算](#少用三目运算)\n9. [合理使用链式调用](#合理使用链式调用)\n10. [分解大型类](#分解大型类)\n11. [退出多重循环](#退出多重循环)\n\n### 提炼函数\n\n如果一个函数过长, 而且需要注释才清楚它是如何工作的, 那么需要考虑把它独立出来. 这样做的好处是:\n\n* 避免超大函数, 作用域过大变量不好维护\n* 抽离公共逻辑, 易于复用和覆写\n* 良好的命名起到了注释作用\n\n**例子:**\n\n```js\nconst getUserInfo = () => {\n  fetch('https://xxx.com/userInfo', (data) => {\n    console.log(`\n      userId: ${data.userId}\\n\n      userName: ${data.userName}\\n\n      nickName: ${data.NickName}\n    `);\n  });\n};\n```\n\n重构如下:\n\n```js\nconst printDetail = (data) => {\n    console.log(`\n    userId: ${data.userId}\\n\n    userName: ${data.userName}\\n\n    nickName: ${data.NickName}\n  `);\n}\n\nconst getUserInfo = () => {\n  fetch('https://xxx.com/userInfo', (data) => {\n    printDetail(data);\n  });\n};\n```\n\n[⤴️Go Top](#概述)\n\n### 合并重复的条件片段\n\n如果一个函数体内有一些条件分支, 而且这些条件分支内散布了一些重复的代码, 这个时候就有必要进行合并去重操作.\n\n**例子:**\n\n```js\nconst paging = (currPage) => {\n  if (currPage <= 0) {\n    currPage = 0;\n    jump(currPage); // 跳转\n  } else if (currPage >= totalPage) {\n    currPage = totalPage;\n    jump(currPage); // 跳转\n  } else {\n    jump(currPage); // 跳转\n  }\n};\n```\n\n可以看到上面的 `jump(currPage)` 重复了, 完全可以把它独立出来:\n\n```js\nconst paging = (currPage) => {\n  if (currPage <= 0) {\n    currPage = 0;\n  } else if (currPage >= totalPage) {\n    currPage = totalPage;\n  }\n  jump(currPage);\n}\n```\n\n[⤴️Go Top](#概述)\n\n### 把条件分支语句提炼成函数\n\n复杂的条件分支语句是导致程序难以阅读和理解的重要原因, 而且很容易导致一个庞大的函数. 这种情况下就需要把条件分支语句提炼出来.\n\n**例子:**\n\n```js\n// 需求: 如果当季是处于夏季, 那么所有的商品 8 折出售\n\nconst getPrice = (price) => {\n  const date = new Date();\n  if (date.getMonth() >= 6 && date.getMonth() <= 9) { // 夏季\n    return price * 0.8;\n  }\n  return price;\n};\n```\n\n观察这段代码:\n\n```js\nif (date.getMonth() >= 6 && date.getMonth() <= 9) { // 夏季\n  // ...\n}\n```\n\n我们需要让它更符合语义, 这样读代码的人能很轻松理解意图, 这里就可以提炼成一个单独函数.\n\n```js\nconst isSummer = () => {\n  const date = new Date();\n  return date.getMonth() >= 6 && date.getMonth() <= 9;\n};\n\nconst getPrice = (price) => {\n  const date = new Date();\n  if (isSummer()) {\n    return price * 0.8;\n  }\n  return price;\n};\n```\n\n[⤴️Go Top](#概述)\n\n### 合理的使用循环\n\n在函数体内, 如果一些代码只是完成一些重复的工作, 那么可以合理利用循环完成同样的功能, 这样可以保持代码量更少.\n\n**例子:**\n\n```js\n// 需求: IE9 以下创建一个 XHR 对象\n\nvar createXHR = function() {\n  var xhr;\n  try {\n    xhr = new ActiveXObject('MSXML2.XMLHttp.6.0');\n  } catch(e) {\n    try {\n      xhr = new ActiveXObject('MSXML2.XMLHttp.3.0')\n    } catch(e) {\n      xhr = new ActiveXObject('MSXML2.XMLHttp');\n    }\n  }\n  return xhr;\n};\n\nvar xhr = createXHR();\n```\n\n这个时候, 使用循环来优化上面的代码:\n\n<div class=\"tip\">复习一下 **for** 循环: `for(初始值; 循环条件; 步长;) {}` </div>\n\n```js\n// 这段代码就看着符合语义了, 而且好理解 🤡\n\nvar createXHR = function() {\n  var versions = ['MSXML2.XMLHttp.6.0', 'MSXML2.XMLHttp.3.0', 'MSXML2.XMLHttp'];\n  for (var i = 0, version; version = versions[i++];) {\n    try {\n      return new ActiveXObject(version);\n    } catch(e) {};\n  }\n};\n\nvar xhr = createXHR();\n```\n\n[⤴️Go Top](#概述)\n\n### 提前让函数退出代替嵌套条件分支\n\n很多程序员👨‍💻‍都有这种观念 \"每个函数只能有一个入口和一个出口\", 但是关于 \"函数只有一个出口\" 往往有一些不同的看法, 下面用代码来说明一下, 光讲概念有点晦涩.\n\n**例子:**\n\n```js\n// 下面是 \"函数只有一个出口\" 的典型代码\n\nconst del = (obj) => {\n  let ret;\n  if (!obj.isReadOnly) {\n    if (obj.isFolder) {\n      ret = delFolder(obj);\n    } else if (obj.isFile) {\n      ret = delFile(obj);\n    }\n  }\n  return ret;\n};\n```\n\n嵌套的条件分支绝对是代码维护者的噩梦, 多层嵌套的条件更加不容易理解, 有时候如果代码过长, 上一个 `if ()` 语句可能相隔很远. 严重影响了阅读体验啊. 重构的 `del` 函数如下:\n\n```js\nconst del = (obj) => {\n  if (obj.isReadOnly) { // 反转 if\n    return;\n  }\n  if (obj.isFolder) {\n    return delFolder(obj);\n  }\n  if (obj.isFile) {\n    return delFile(obj);\n  }\n};\n\n// 瞬间清爽 👌\n```\n\n[⤴️Go Top](#概述)\n\n### 传递对象参数代替过长的参数列表\n\n有时候一个函数可能接收多个参数, 而且参数阅读, 就越难理解和使用. 最重要的一点需要注意参数的顺序, 如果不传的情况要使用占位符代替. 如果参数超过 3 个, 请使用对象吧.\n\n**例子:**\n\n```js\nconst setUserInfo = (id, name, address, sex, mobile, qq) => {\n  // ...\n}\n\n// 调用 ☹️:\nsetUserInfo(1, 'ifyour', undefined, 'male', undefined, '123456');\n\n\n// 重构 😁:\nsetUserInfo({\n  id: 1,\n  name: 'ifyour',\n  sex: 'male',\n  qq: '123456',\n})\n```\n\n[⤴️Go Top](#概述)\n\n### 尽量减少参数数量\n\n如果调用一个函数, 需要传递很多参数, 这样的函数用起来就要小心了, 必须搞清楚每个参数的含义, 所以, 如果能尽量少传参数就少传参数. 把复杂的逻辑封装到函数内部.\n\n**例子:**\n\n```js\n// 需求: 有一个画图函数 draw\n\nconst draw = (width, height, square) => {\n  // ...\n};\n\n// 优化如下:\nconst draw = (width, height) => {\n  const square = width * height;\n  // ...\n}\n```\n\n这里的 `square` 参数没必要, 可以通过 `width` 和 `height` 计算获得, 还有一种情况, 这个画图函数, 如果可以画多种图形呢? 所以需要在内部去处理, 什么时候需要 `square` 什么时候需要 `radius`, 然后可以使用 **策略模式** 让它支持画多种图形.\n\n[⤴️Go Top](#概述)\n\n### 少用三目运算\n\n三目运算能减少代码量, 但是不能滥用, 如果以牺牲代码可读性为代价, 那就得不偿失了.\n\n```js\nconst global = typeof window !== 'undefined' ? window : this;\n\n// 但是这种情况就完全没必要了, 老实写 if..else...\n\nif (!aup || !bup) {\n  return a === doc ? -1 :\n    b === doc ? 1 :\n    aup ? -1 :\n    bup ? 1 :\n    sortInput ?\n    (indexOf.call(sortInput, a) - indexOf.call(sortInput, b)) :\n    0;\n}\n\n// 😡 这是人看的吗\n```\n\n[⤴️Go Top](#概述)\n\n### 合理使用链式调用\n\njQuery 中的链式调用用起来还是很爽的, 它的实现也非常简单, 我们可以很容易的实现一个链式调用. 使用的前提就是链条的结构相对来说稳定, 不容易发生修改, 如果是经常发生修改的话, 还是建议使用普通的调用. 因为它调试的时候需要把这个链子拆开, 才知道是哪个环节有 Bug.\n\n**例子:**\n\n```js\n// ES5\n\nvar User = function() {\n  this.id = null;\n  this.name = null;\n};\n\nUser.prototype.setId = function (id) {\n  this.id = id;\n  return this; // 返回实例本身\n}\n\nUser.prototype.setName = function (name) {\n  this.name = name;\n  return this;\n}\n\n// 链式调用\nnew User()\n  .setId(1)\n  .setNmae('ifyour');\n```\n\n或者这样:\n\n```js\nvar User = {\n  id: null,\n  name: null,\n  setId: function(id) {\n    this.id = id;\n    return this;\n  },\n  setName: function(name) {\n    this.name = name;\n    return this;\n  }\n};\n\nUser.setId(1).setName('ifyour');\n```\n\n[⤴️Go Top](#概述)\n\n### 分解大型类\n\n从字面意思我们就能理解, 如果一个类里面有太多的方法, 我们要考虑把其中同一类型相关的方法抽离出来. 模块化的好处不言而喻, 把逻辑复杂的分离成小的单元, 这样更便于维护, 出现 bug 了也好定位问题. 来看一段代码.\n\n**例子:**\n\n```js\n// 英雄类\nvar Spirit = function() {\n  this.name = name;\n};\n\n// 原型上的攻击方法\nSpirit.prototype.attack = function (type) {\n  if (type === 'waveBoxing') {\n    console.log(this.name + ': 使用波动拳');\n  } else if (type === 'whirlKick') {\n    console.log(this.name + ': 使用旋风腿');\n  }\n  // ... 还有很多攻击方法\n}\n\nvar spirit = new Spirit('RYU');\nspirit.attack('waveBoxing'); // RYU: 使用波动拳\nspirit.attack('whirlKick'); // RYU: 使用旋风腿\n```\n\n面向对象的设计鼓励将 **行为** 分解到合理数量的更小的对象中:\n\n```js\nvar Attack = function (spirit) {\n  this.spirit = spirit;\n};\n\nAttack.prototype.start = function (type) {\n  return this.list[type].call(this);\n}\n\nAttack.prototype.list = function () {\n  waveBoxing: function () {\n    console.log(this.sprite.name + ': 使用波动拳')\n  },\n  whirlKick: function () {\n    console.log(this.sprite.name + ': 使用旋风腿')\n  },\n}\n```\n\n现在 Sprite 类精简了很多, 不再直接包含攻击相关的方法, 而是把方法委托给 Attack 类来执行. 这段代码也是 **策略模式** 的运用之一, 看代码:\n\n```js\nvar Spirit = function() {\n  this.name = name;\n  this.attackObj = new Attack(this);\n};\n\nSpirit.prototype.attack = function (type) {\n  this.attackObj.start(type);\n}\n\nvar spirit = new Spirit('RYU');\nspirit.attack('waveBoxing'); // RYU: 使用波动拳\nspirit.attack('whirlKick'); // RYU: 使用旋风腿\n```\n\n[⤴️Go Top](#概述)\n\n### 退出多重循环\n\n使用 `return` 退出多重循环. 一定程度上能简化代码, 使代码更容易理解.\n\n**例子:**\n\n```js\n// 需求: 假设在一个函数体内的多重循环内, 达到某个临界条件时退出循环\n\nvar func = function () {\n  var flag = false;\n  for (var i = 0; i < 10; i++) {\n    for (var j = 0; j < 10; j++) {\n      if (i * j > 30) {\n        flag = true;\n        break;\n      }\n    }\n  }\n};\n\n// 这种代码看着就头晕目眩, 重构如下:\n\nvar func = function () {\n  for (var i = 0; i < 10; i++) {\n    for (var j = 0; j < 10; j++) {\n      if (i * j > 30) {\n        return;\n      }\n    }\n  }\n};\n```\n\n直接使用 `return` 后, 后面的代码无法执行, 还是有点小问题的:\n\n```js\nvar func = function () {\n  for (var i = 0; i < 10; i++) {\n    for (var j = 0; j < 10; j++) {\n      if (i * j > 30) {\n        return;\n      }\n    }\n  }\n  console.log(i) // 无法执行\n};\n```\n\n为了解决这个问题, 我们可以把相关的代码放到 `return` 后面. 如果需要执行的代码较多, 可以提取成一个函数:\n\n```js\nvar print = function (i) {\n  console.log(i)\n};\n\nvar func = function () {\n  for (var i = 0; i < 10; i++) {\n    for (var j = 0; j < 10; j++) {\n      if (i * j > 30) {\n        return print(i); // 执行\n      }\n    }\n  }\n};\n```\n\n[⤴️Go Top](#概述)\n","source":"_posts/代码重构.md","raw":"---\ntitle: 代码重构\ncomments: true\ndate: 2018-06-16 22:46:36\ntags:\nfrom:\n---\n\n今天读了曾探的[《设计模式》](https://book.douban.com/subject/26382780/)中的代码重构这一章节, 知识点不多却非常使用, 在实际项目中除了使用设计模式重构代码外, 还有一些容易忽略的细节. 这些细节也是重构的重要手段. 写这篇文章总结一下.\n\n<!-- more -->\n\n> 代码是写给人看的, 顺便给机器运行. 优雅的代码应该是简单、易维护、可扩展的.\n\n### 概述\n\n1. [提炼函数](#提炼函数)\n2. [合并重复的条件片段](#合并重复的条件片段)\n3. [把条件分支语句提炼成函数](#把条件分支语句提炼成函数)\n4. [合理的使用循环](#合理的使用循环)\n5. [提前让函数退出代替嵌套条件分支](#提前让函数退出代替嵌套条件分支)\n6. [传递对象参数代替过长的参数列表](#传递对象参数代替过长的参数列表)\n7. [尽量减少参数数量](#尽量减少参数数量)\n8. [少用三目运算](#少用三目运算)\n9. [合理使用链式调用](#合理使用链式调用)\n10. [分解大型类](#分解大型类)\n11. [退出多重循环](#退出多重循环)\n\n### 提炼函数\n\n如果一个函数过长, 而且需要注释才清楚它是如何工作的, 那么需要考虑把它独立出来. 这样做的好处是:\n\n* 避免超大函数, 作用域过大变量不好维护\n* 抽离公共逻辑, 易于复用和覆写\n* 良好的命名起到了注释作用\n\n**例子:**\n\n```js\nconst getUserInfo = () => {\n  fetch('https://xxx.com/userInfo', (data) => {\n    console.log(`\n      userId: ${data.userId}\\n\n      userName: ${data.userName}\\n\n      nickName: ${data.NickName}\n    `);\n  });\n};\n```\n\n重构如下:\n\n```js\nconst printDetail = (data) => {\n    console.log(`\n    userId: ${data.userId}\\n\n    userName: ${data.userName}\\n\n    nickName: ${data.NickName}\n  `);\n}\n\nconst getUserInfo = () => {\n  fetch('https://xxx.com/userInfo', (data) => {\n    printDetail(data);\n  });\n};\n```\n\n[⤴️Go Top](#概述)\n\n### 合并重复的条件片段\n\n如果一个函数体内有一些条件分支, 而且这些条件分支内散布了一些重复的代码, 这个时候就有必要进行合并去重操作.\n\n**例子:**\n\n```js\nconst paging = (currPage) => {\n  if (currPage <= 0) {\n    currPage = 0;\n    jump(currPage); // 跳转\n  } else if (currPage >= totalPage) {\n    currPage = totalPage;\n    jump(currPage); // 跳转\n  } else {\n    jump(currPage); // 跳转\n  }\n};\n```\n\n可以看到上面的 `jump(currPage)` 重复了, 完全可以把它独立出来:\n\n```js\nconst paging = (currPage) => {\n  if (currPage <= 0) {\n    currPage = 0;\n  } else if (currPage >= totalPage) {\n    currPage = totalPage;\n  }\n  jump(currPage);\n}\n```\n\n[⤴️Go Top](#概述)\n\n### 把条件分支语句提炼成函数\n\n复杂的条件分支语句是导致程序难以阅读和理解的重要原因, 而且很容易导致一个庞大的函数. 这种情况下就需要把条件分支语句提炼出来.\n\n**例子:**\n\n```js\n// 需求: 如果当季是处于夏季, 那么所有的商品 8 折出售\n\nconst getPrice = (price) => {\n  const date = new Date();\n  if (date.getMonth() >= 6 && date.getMonth() <= 9) { // 夏季\n    return price * 0.8;\n  }\n  return price;\n};\n```\n\n观察这段代码:\n\n```js\nif (date.getMonth() >= 6 && date.getMonth() <= 9) { // 夏季\n  // ...\n}\n```\n\n我们需要让它更符合语义, 这样读代码的人能很轻松理解意图, 这里就可以提炼成一个单独函数.\n\n```js\nconst isSummer = () => {\n  const date = new Date();\n  return date.getMonth() >= 6 && date.getMonth() <= 9;\n};\n\nconst getPrice = (price) => {\n  const date = new Date();\n  if (isSummer()) {\n    return price * 0.8;\n  }\n  return price;\n};\n```\n\n[⤴️Go Top](#概述)\n\n### 合理的使用循环\n\n在函数体内, 如果一些代码只是完成一些重复的工作, 那么可以合理利用循环完成同样的功能, 这样可以保持代码量更少.\n\n**例子:**\n\n```js\n// 需求: IE9 以下创建一个 XHR 对象\n\nvar createXHR = function() {\n  var xhr;\n  try {\n    xhr = new ActiveXObject('MSXML2.XMLHttp.6.0');\n  } catch(e) {\n    try {\n      xhr = new ActiveXObject('MSXML2.XMLHttp.3.0')\n    } catch(e) {\n      xhr = new ActiveXObject('MSXML2.XMLHttp');\n    }\n  }\n  return xhr;\n};\n\nvar xhr = createXHR();\n```\n\n这个时候, 使用循环来优化上面的代码:\n\n<div class=\"tip\">复习一下 **for** 循环: `for(初始值; 循环条件; 步长;) {}` </div>\n\n```js\n// 这段代码就看着符合语义了, 而且好理解 🤡\n\nvar createXHR = function() {\n  var versions = ['MSXML2.XMLHttp.6.0', 'MSXML2.XMLHttp.3.0', 'MSXML2.XMLHttp'];\n  for (var i = 0, version; version = versions[i++];) {\n    try {\n      return new ActiveXObject(version);\n    } catch(e) {};\n  }\n};\n\nvar xhr = createXHR();\n```\n\n[⤴️Go Top](#概述)\n\n### 提前让函数退出代替嵌套条件分支\n\n很多程序员👨‍💻‍都有这种观念 \"每个函数只能有一个入口和一个出口\", 但是关于 \"函数只有一个出口\" 往往有一些不同的看法, 下面用代码来说明一下, 光讲概念有点晦涩.\n\n**例子:**\n\n```js\n// 下面是 \"函数只有一个出口\" 的典型代码\n\nconst del = (obj) => {\n  let ret;\n  if (!obj.isReadOnly) {\n    if (obj.isFolder) {\n      ret = delFolder(obj);\n    } else if (obj.isFile) {\n      ret = delFile(obj);\n    }\n  }\n  return ret;\n};\n```\n\n嵌套的条件分支绝对是代码维护者的噩梦, 多层嵌套的条件更加不容易理解, 有时候如果代码过长, 上一个 `if ()` 语句可能相隔很远. 严重影响了阅读体验啊. 重构的 `del` 函数如下:\n\n```js\nconst del = (obj) => {\n  if (obj.isReadOnly) { // 反转 if\n    return;\n  }\n  if (obj.isFolder) {\n    return delFolder(obj);\n  }\n  if (obj.isFile) {\n    return delFile(obj);\n  }\n};\n\n// 瞬间清爽 👌\n```\n\n[⤴️Go Top](#概述)\n\n### 传递对象参数代替过长的参数列表\n\n有时候一个函数可能接收多个参数, 而且参数阅读, 就越难理解和使用. 最重要的一点需要注意参数的顺序, 如果不传的情况要使用占位符代替. 如果参数超过 3 个, 请使用对象吧.\n\n**例子:**\n\n```js\nconst setUserInfo = (id, name, address, sex, mobile, qq) => {\n  // ...\n}\n\n// 调用 ☹️:\nsetUserInfo(1, 'ifyour', undefined, 'male', undefined, '123456');\n\n\n// 重构 😁:\nsetUserInfo({\n  id: 1,\n  name: 'ifyour',\n  sex: 'male',\n  qq: '123456',\n})\n```\n\n[⤴️Go Top](#概述)\n\n### 尽量减少参数数量\n\n如果调用一个函数, 需要传递很多参数, 这样的函数用起来就要小心了, 必须搞清楚每个参数的含义, 所以, 如果能尽量少传参数就少传参数. 把复杂的逻辑封装到函数内部.\n\n**例子:**\n\n```js\n// 需求: 有一个画图函数 draw\n\nconst draw = (width, height, square) => {\n  // ...\n};\n\n// 优化如下:\nconst draw = (width, height) => {\n  const square = width * height;\n  // ...\n}\n```\n\n这里的 `square` 参数没必要, 可以通过 `width` 和 `height` 计算获得, 还有一种情况, 这个画图函数, 如果可以画多种图形呢? 所以需要在内部去处理, 什么时候需要 `square` 什么时候需要 `radius`, 然后可以使用 **策略模式** 让它支持画多种图形.\n\n[⤴️Go Top](#概述)\n\n### 少用三目运算\n\n三目运算能减少代码量, 但是不能滥用, 如果以牺牲代码可读性为代价, 那就得不偿失了.\n\n```js\nconst global = typeof window !== 'undefined' ? window : this;\n\n// 但是这种情况就完全没必要了, 老实写 if..else...\n\nif (!aup || !bup) {\n  return a === doc ? -1 :\n    b === doc ? 1 :\n    aup ? -1 :\n    bup ? 1 :\n    sortInput ?\n    (indexOf.call(sortInput, a) - indexOf.call(sortInput, b)) :\n    0;\n}\n\n// 😡 这是人看的吗\n```\n\n[⤴️Go Top](#概述)\n\n### 合理使用链式调用\n\njQuery 中的链式调用用起来还是很爽的, 它的实现也非常简单, 我们可以很容易的实现一个链式调用. 使用的前提就是链条的结构相对来说稳定, 不容易发生修改, 如果是经常发生修改的话, 还是建议使用普通的调用. 因为它调试的时候需要把这个链子拆开, 才知道是哪个环节有 Bug.\n\n**例子:**\n\n```js\n// ES5\n\nvar User = function() {\n  this.id = null;\n  this.name = null;\n};\n\nUser.prototype.setId = function (id) {\n  this.id = id;\n  return this; // 返回实例本身\n}\n\nUser.prototype.setName = function (name) {\n  this.name = name;\n  return this;\n}\n\n// 链式调用\nnew User()\n  .setId(1)\n  .setNmae('ifyour');\n```\n\n或者这样:\n\n```js\nvar User = {\n  id: null,\n  name: null,\n  setId: function(id) {\n    this.id = id;\n    return this;\n  },\n  setName: function(name) {\n    this.name = name;\n    return this;\n  }\n};\n\nUser.setId(1).setName('ifyour');\n```\n\n[⤴️Go Top](#概述)\n\n### 分解大型类\n\n从字面意思我们就能理解, 如果一个类里面有太多的方法, 我们要考虑把其中同一类型相关的方法抽离出来. 模块化的好处不言而喻, 把逻辑复杂的分离成小的单元, 这样更便于维护, 出现 bug 了也好定位问题. 来看一段代码.\n\n**例子:**\n\n```js\n// 英雄类\nvar Spirit = function() {\n  this.name = name;\n};\n\n// 原型上的攻击方法\nSpirit.prototype.attack = function (type) {\n  if (type === 'waveBoxing') {\n    console.log(this.name + ': 使用波动拳');\n  } else if (type === 'whirlKick') {\n    console.log(this.name + ': 使用旋风腿');\n  }\n  // ... 还有很多攻击方法\n}\n\nvar spirit = new Spirit('RYU');\nspirit.attack('waveBoxing'); // RYU: 使用波动拳\nspirit.attack('whirlKick'); // RYU: 使用旋风腿\n```\n\n面向对象的设计鼓励将 **行为** 分解到合理数量的更小的对象中:\n\n```js\nvar Attack = function (spirit) {\n  this.spirit = spirit;\n};\n\nAttack.prototype.start = function (type) {\n  return this.list[type].call(this);\n}\n\nAttack.prototype.list = function () {\n  waveBoxing: function () {\n    console.log(this.sprite.name + ': 使用波动拳')\n  },\n  whirlKick: function () {\n    console.log(this.sprite.name + ': 使用旋风腿')\n  },\n}\n```\n\n现在 Sprite 类精简了很多, 不再直接包含攻击相关的方法, 而是把方法委托给 Attack 类来执行. 这段代码也是 **策略模式** 的运用之一, 看代码:\n\n```js\nvar Spirit = function() {\n  this.name = name;\n  this.attackObj = new Attack(this);\n};\n\nSpirit.prototype.attack = function (type) {\n  this.attackObj.start(type);\n}\n\nvar spirit = new Spirit('RYU');\nspirit.attack('waveBoxing'); // RYU: 使用波动拳\nspirit.attack('whirlKick'); // RYU: 使用旋风腿\n```\n\n[⤴️Go Top](#概述)\n\n### 退出多重循环\n\n使用 `return` 退出多重循环. 一定程度上能简化代码, 使代码更容易理解.\n\n**例子:**\n\n```js\n// 需求: 假设在一个函数体内的多重循环内, 达到某个临界条件时退出循环\n\nvar func = function () {\n  var flag = false;\n  for (var i = 0; i < 10; i++) {\n    for (var j = 0; j < 10; j++) {\n      if (i * j > 30) {\n        flag = true;\n        break;\n      }\n    }\n  }\n};\n\n// 这种代码看着就头晕目眩, 重构如下:\n\nvar func = function () {\n  for (var i = 0; i < 10; i++) {\n    for (var j = 0; j < 10; j++) {\n      if (i * j > 30) {\n        return;\n      }\n    }\n  }\n};\n```\n\n直接使用 `return` 后, 后面的代码无法执行, 还是有点小问题的:\n\n```js\nvar func = function () {\n  for (var i = 0; i < 10; i++) {\n    for (var j = 0; j < 10; j++) {\n      if (i * j > 30) {\n        return;\n      }\n    }\n  }\n  console.log(i) // 无法执行\n};\n```\n\n为了解决这个问题, 我们可以把相关的代码放到 `return` 后面. 如果需要执行的代码较多, 可以提取成一个函数:\n\n```js\nvar print = function (i) {\n  console.log(i)\n};\n\nvar func = function () {\n  for (var i = 0; i < 10; i++) {\n    for (var j = 0; j < 10; j++) {\n      if (i * j > 30) {\n        return print(i); // 执行\n      }\n    }\n  }\n};\n```\n\n[⤴️Go Top](#概述)\n","slug":"代码重构","published":1,"updated":"2018-06-17T12:50:41.000Z","_id":"cjiitidj7000iu4q9dqo99rfo","layout":"post","photos":[],"link":"","content":"<p>今天读了曾探的<a href=\"https://book.douban.com/subject/26382780/\" target=\"_blank\" rel=\"noopener\">《设计模式》</a>中的代码重构这一章节, 知识点不多却非常使用, 在实际项目中除了使用设计模式重构代码外, 还有一些容易忽略的细节. 这些细节也是重构的重要手段. 写这篇文章总结一下.</p>\n<a id=\"more\"></a>\n<blockquote>\n<p>代码是写给人看的, 顺便给机器运行. 优雅的代码应该是简单、易维护、可扩展的.</p>\n</blockquote>\n<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li><a href=\"#提炼函数\">提炼函数</a></li>\n<li><a href=\"#合并重复的条件片段\">合并重复的条件片段</a></li>\n<li><a href=\"#把条件分支语句提炼成函数\">把条件分支语句提炼成函数</a></li>\n<li><a href=\"#合理的使用循环\">合理的使用循环</a></li>\n<li><a href=\"#提前让函数退出代替嵌套条件分支\">提前让函数退出代替嵌套条件分支</a></li>\n<li><a href=\"#传递对象参数代替过长的参数列表\">传递对象参数代替过长的参数列表</a></li>\n<li><a href=\"#尽量减少参数数量\">尽量减少参数数量</a></li>\n<li><a href=\"#少用三目运算\">少用三目运算</a></li>\n<li><a href=\"#合理使用链式调用\">合理使用链式调用</a></li>\n<li><a href=\"#分解大型类\">分解大型类</a></li>\n<li><a href=\"#退出多重循环\">退出多重循环</a></li>\n</ol>\n<h3 id=\"提炼函数\"><a href=\"#提炼函数\" class=\"headerlink\" title=\"提炼函数\"></a>提炼函数</h3><p>如果一个函数过长, 而且需要注释才清楚它是如何工作的, 那么需要考虑把它独立出来. 这样做的好处是:</p>\n<ul>\n<li>避免超大函数, 作用域过大变量不好维护</li>\n<li>抽离公共逻辑, 易于复用和覆写</li>\n<li>良好的命名起到了注释作用</li>\n</ul>\n<p><strong>例子:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> getUserInfo = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  fetch(<span class=\"string\">'https://xxx.com/userInfo'</span>, (data) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">      userId: <span class=\"subst\">$&#123;data.userId&#125;</span>\\n</span></span><br><span class=\"line\"><span class=\"string\">      userName: <span class=\"subst\">$&#123;data.userName&#125;</span>\\n</span></span><br><span class=\"line\"><span class=\"string\">      nickName: <span class=\"subst\">$&#123;data.NickName&#125;</span></span></span><br><span class=\"line\"><span class=\"string\">    `</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>重构如下:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> printDetail = <span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">    userId: <span class=\"subst\">$&#123;data.userId&#125;</span>\\n</span></span><br><span class=\"line\"><span class=\"string\">    userName: <span class=\"subst\">$&#123;data.userName&#125;</span>\\n</span></span><br><span class=\"line\"><span class=\"string\">    nickName: <span class=\"subst\">$&#123;data.NickName&#125;</span></span></span><br><span class=\"line\"><span class=\"string\">  `</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> getUserInfo = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  fetch(<span class=\"string\">'https://xxx.com/userInfo'</span>, (data) =&gt; &#123;</span><br><span class=\"line\">    printDetail(data);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><a href=\"#概述\">⤴️Go Top</a></p>\n<h3 id=\"合并重复的条件片段\"><a href=\"#合并重复的条件片段\" class=\"headerlink\" title=\"合并重复的条件片段\"></a>合并重复的条件片段</h3><p>如果一个函数体内有一些条件分支, 而且这些条件分支内散布了一些重复的代码, 这个时候就有必要进行合并去重操作.</p>\n<p><strong>例子:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> paging = <span class=\"function\">(<span class=\"params\">currPage</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (currPage &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    currPage = <span class=\"number\">0</span>;</span><br><span class=\"line\">    jump(currPage); <span class=\"comment\">// 跳转</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (currPage &gt;= totalPage) &#123;</span><br><span class=\"line\">    currPage = totalPage;</span><br><span class=\"line\">    jump(currPage); <span class=\"comment\">// 跳转</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    jump(currPage); <span class=\"comment\">// 跳转</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>可以看到上面的 <code>jump(currPage)</code> 重复了, 完全可以把它独立出来:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> paging = <span class=\"function\">(<span class=\"params\">currPage</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (currPage &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    currPage = <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (currPage &gt;= totalPage) &#123;</span><br><span class=\"line\">    currPage = totalPage;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  jump(currPage);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"#概述\">⤴️Go Top</a></p>\n<h3 id=\"把条件分支语句提炼成函数\"><a href=\"#把条件分支语句提炼成函数\" class=\"headerlink\" title=\"把条件分支语句提炼成函数\"></a>把条件分支语句提炼成函数</h3><p>复杂的条件分支语句是导致程序难以阅读和理解的重要原因, 而且很容易导致一个庞大的函数. 这种情况下就需要把条件分支语句提炼出来.</p>\n<p><strong>例子:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 需求: 如果当季是处于夏季, 那么所有的商品 8 折出售</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> getPrice = <span class=\"function\">(<span class=\"params\">price</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> date = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (date.getMonth() &gt;= <span class=\"number\">6</span> &amp;&amp; date.getMonth() &lt;= <span class=\"number\">9</span>) &#123; <span class=\"comment\">// 夏季</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> price * <span class=\"number\">0.8</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> price;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>观察这段代码:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (date.getMonth() &gt;= <span class=\"number\">6</span> &amp;&amp; date.getMonth() &lt;= <span class=\"number\">9</span>) &#123; <span class=\"comment\">// 夏季</span></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们需要让它更符合语义, 这样读代码的人能很轻松理解意图, 这里就可以提炼成一个单独函数.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> isSummer = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> date = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> date.getMonth() &gt;= <span class=\"number\">6</span> &amp;&amp; date.getMonth() &lt;= <span class=\"number\">9</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> getPrice = <span class=\"function\">(<span class=\"params\">price</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> date = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isSummer()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> price * <span class=\"number\">0.8</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> price;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><a href=\"#概述\">⤴️Go Top</a></p>\n<h3 id=\"合理的使用循环\"><a href=\"#合理的使用循环\" class=\"headerlink\" title=\"合理的使用循环\"></a>合理的使用循环</h3><p>在函数体内, 如果一些代码只是完成一些重复的工作, 那么可以合理利用循环完成同样的功能, 这样可以保持代码量更少.</p>\n<p><strong>例子:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 需求: IE9 以下创建一个 XHR 对象</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> createXHR = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> xhr;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    xhr = <span class=\"keyword\">new</span> ActiveXObject(<span class=\"string\">'MSXML2.XMLHttp.6.0'</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      xhr = <span class=\"keyword\">new</span> ActiveXObject(<span class=\"string\">'MSXML2.XMLHttp.3.0'</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">      xhr = <span class=\"keyword\">new</span> ActiveXObject(<span class=\"string\">'MSXML2.XMLHttp'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> xhr;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> xhr = createXHR();</span><br></pre></td></tr></table></figure>\n<p>这个时候, 使用循环来优化上面的代码:</p>\n<div class=\"tip\">复习一下 <strong>for</strong> 循环: <code>for(初始值; 循环条件; 步长;) {}</code> </div>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这段代码就看着符合语义了, 而且好理解 🤡</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> createXHR = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> versions = [<span class=\"string\">'MSXML2.XMLHttp.6.0'</span>, <span class=\"string\">'MSXML2.XMLHttp.3.0'</span>, <span class=\"string\">'MSXML2.XMLHttp'</span>];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, version; version = versions[i++];) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ActiveXObject(version);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(e) &#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> xhr = createXHR();</span><br></pre></td></tr></table></figure>\n<p><a href=\"#概述\">⤴️Go Top</a></p>\n<h3 id=\"提前让函数退出代替嵌套条件分支\"><a href=\"#提前让函数退出代替嵌套条件分支\" class=\"headerlink\" title=\"提前让函数退出代替嵌套条件分支\"></a>提前让函数退出代替嵌套条件分支</h3><p>很多程序员👨‍💻‍都有这种观念 “每个函数只能有一个入口和一个出口”, 但是关于 “函数只有一个出口” 往往有一些不同的看法, 下面用代码来说明一下, 光讲概念有点晦涩.</p>\n<p><strong>例子:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 下面是 \"函数只有一个出口\" 的典型代码</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> del = <span class=\"function\">(<span class=\"params\">obj</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> ret;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!obj.isReadOnly) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj.isFolder) &#123;</span><br><span class=\"line\">      ret = delFolder(obj);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (obj.isFile) &#123;</span><br><span class=\"line\">      ret = delFile(obj);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>嵌套的条件分支绝对是代码维护者的噩梦, 多层嵌套的条件更加不容易理解, 有时候如果代码过长, 上一个 <code>if ()</code> 语句可能相隔很远. 严重影响了阅读体验啊. 重构的 <code>del</code> 函数如下:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> del = <span class=\"function\">(<span class=\"params\">obj</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (obj.isReadOnly) &#123; <span class=\"comment\">// 反转 if</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (obj.isFolder) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> delFolder(obj);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (obj.isFile) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> delFile(obj);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 瞬间清爽 👌</span></span><br></pre></td></tr></table></figure>\n<p><a href=\"#概述\">⤴️Go Top</a></p>\n<h3 id=\"传递对象参数代替过长的参数列表\"><a href=\"#传递对象参数代替过长的参数列表\" class=\"headerlink\" title=\"传递对象参数代替过长的参数列表\"></a>传递对象参数代替过长的参数列表</h3><p>有时候一个函数可能接收多个参数, 而且参数阅读, 就越难理解和使用. 最重要的一点需要注意参数的顺序, 如果不传的情况要使用占位符代替. 如果参数超过 3 个, 请使用对象吧.</p>\n<p><strong>例子:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> setUserInfo = <span class=\"function\">(<span class=\"params\">id, name, address, sex, mobile, qq</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用 ☹️:</span></span><br><span class=\"line\">setUserInfo(<span class=\"number\">1</span>, <span class=\"string\">'ifyour'</span>, <span class=\"literal\">undefined</span>, <span class=\"string\">'male'</span>, <span class=\"literal\">undefined</span>, <span class=\"string\">'123456'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 重构 😁:</span></span><br><span class=\"line\">setUserInfo(&#123;</span><br><span class=\"line\">  id: <span class=\"number\">1</span>,</span><br><span class=\"line\">  name: <span class=\"string\">'ifyour'</span>,</span><br><span class=\"line\">  sex: <span class=\"string\">'male'</span>,</span><br><span class=\"line\">  qq: <span class=\"string\">'123456'</span>,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p><a href=\"#概述\">⤴️Go Top</a></p>\n<h3 id=\"尽量减少参数数量\"><a href=\"#尽量减少参数数量\" class=\"headerlink\" title=\"尽量减少参数数量\"></a>尽量减少参数数量</h3><p>如果调用一个函数, 需要传递很多参数, 这样的函数用起来就要小心了, 必须搞清楚每个参数的含义, 所以, 如果能尽量少传参数就少传参数. 把复杂的逻辑封装到函数内部.</p>\n<p><strong>例子:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 需求: 有一个画图函数 draw</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> draw = <span class=\"function\">(<span class=\"params\">width, height, square</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 优化如下:</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> draw = <span class=\"function\">(<span class=\"params\">width, height</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> square = width * height;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的 <code>square</code> 参数没必要, 可以通过 <code>width</code> 和 <code>height</code> 计算获得, 还有一种情况, 这个画图函数, 如果可以画多种图形呢? 所以需要在内部去处理, 什么时候需要 <code>square</code> 什么时候需要 <code>radius</code>, 然后可以使用 <strong>策略模式</strong> 让它支持画多种图形.</p>\n<p><a href=\"#概述\">⤴️Go Top</a></p>\n<h3 id=\"少用三目运算\"><a href=\"#少用三目运算\" class=\"headerlink\" title=\"少用三目运算\"></a>少用三目运算</h3><p>三目运算能减少代码量, 但是不能滥用, 如果以牺牲代码可读性为代价, 那就得不偿失了.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> global = <span class=\"keyword\">typeof</span> <span class=\"built_in\">window</span> !== <span class=\"string\">'undefined'</span> ? <span class=\"built_in\">window</span> : <span class=\"keyword\">this</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 但是这种情况就完全没必要了, 老实写 if..else...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!aup || !bup) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a === doc ? <span class=\"number\">-1</span> :</span><br><span class=\"line\">    b === doc ? <span class=\"number\">1</span> :</span><br><span class=\"line\">    aup ? <span class=\"number\">-1</span> :</span><br><span class=\"line\">    bup ? <span class=\"number\">1</span> :</span><br><span class=\"line\">    sortInput ?</span><br><span class=\"line\">    (indexOf.call(sortInput, a) - indexOf.call(sortInput, b)) :</span><br><span class=\"line\">    <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 😡 这是人看的吗</span></span><br></pre></td></tr></table></figure>\n<p><a href=\"#概述\">⤴️Go Top</a></p>\n<h3 id=\"合理使用链式调用\"><a href=\"#合理使用链式调用\" class=\"headerlink\" title=\"合理使用链式调用\"></a>合理使用链式调用</h3><p>jQuery 中的链式调用用起来还是很爽的, 它的实现也非常简单, 我们可以很容易的实现一个链式调用. 使用的前提就是链条的结构相对来说稳定, 不容易发生修改, 如果是经常发生修改的话, 还是建议使用普通的调用. 因为它调试的时候需要把这个链子拆开, 才知道是哪个环节有 Bug.</p>\n<p><strong>例子:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> User = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.id = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">User.prototype.setId = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>; <span class=\"comment\">// 返回实例本身</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">User.prototype.setName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 链式调用</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> User()</span><br><span class=\"line\">  .setId(<span class=\"number\">1</span>)</span><br><span class=\"line\">  .setNmae(<span class=\"string\">'ifyour'</span>);</span><br></pre></td></tr></table></figure>\n<p>或者这样:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> User = &#123;</span><br><span class=\"line\">  id: <span class=\"literal\">null</span>,</span><br><span class=\"line\">  name: <span class=\"literal\">null</span>,</span><br><span class=\"line\">  setId: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  setName: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">User.setId(<span class=\"number\">1</span>).setName(<span class=\"string\">'ifyour'</span>);</span><br></pre></td></tr></table></figure>\n<p><a href=\"#概述\">⤴️Go Top</a></p>\n<h3 id=\"分解大型类\"><a href=\"#分解大型类\" class=\"headerlink\" title=\"分解大型类\"></a>分解大型类</h3><p>从字面意思我们就能理解, 如果一个类里面有太多的方法, 我们要考虑把其中同一类型相关的方法抽离出来. 模块化的好处不言而喻, 把逻辑复杂的分离成小的单元, 这样更便于维护, 出现 bug 了也好定位问题. 来看一段代码.</p>\n<p><strong>例子:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 英雄类</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Spirit = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 原型上的攻击方法</span></span><br><span class=\"line\">Spirit.prototype.attack = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">type</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (type === <span class=\"string\">'waveBoxing'</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">': 使用波动拳'</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (type === <span class=\"string\">'whirlKick'</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">': 使用旋风腿'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// ... 还有很多攻击方法</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> spirit = <span class=\"keyword\">new</span> Spirit(<span class=\"string\">'RYU'</span>);</span><br><span class=\"line\">spirit.attack(<span class=\"string\">'waveBoxing'</span>); <span class=\"comment\">// RYU: 使用波动拳</span></span><br><span class=\"line\">spirit.attack(<span class=\"string\">'whirlKick'</span>); <span class=\"comment\">// RYU: 使用旋风腿</span></span><br></pre></td></tr></table></figure>\n<p>面向对象的设计鼓励将 <strong>行为</strong> 分解到合理数量的更小的对象中:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Attack = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">spirit</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.spirit = spirit;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Attack.prototype.start = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">type</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.list[type].call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Attack.prototype.list = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  waveBoxing: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.sprite.name + <span class=\"string\">': 使用波动拳'</span>)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  whirlKick: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.sprite.name + <span class=\"string\">': 使用旋风腿'</span>)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在 Sprite 类精简了很多, 不再直接包含攻击相关的方法, 而是把方法委托给 Attack 类来执行. 这段代码也是 <strong>策略模式</strong> 的运用之一, 看代码:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Spirit = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.attackObj = <span class=\"keyword\">new</span> Attack(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Spirit.prototype.attack = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">type</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.attackObj.start(type);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> spirit = <span class=\"keyword\">new</span> Spirit(<span class=\"string\">'RYU'</span>);</span><br><span class=\"line\">spirit.attack(<span class=\"string\">'waveBoxing'</span>); <span class=\"comment\">// RYU: 使用波动拳</span></span><br><span class=\"line\">spirit.attack(<span class=\"string\">'whirlKick'</span>); <span class=\"comment\">// RYU: 使用旋风腿</span></span><br></pre></td></tr></table></figure>\n<p><a href=\"#概述\">⤴️Go Top</a></p>\n<h3 id=\"退出多重循环\"><a href=\"#退出多重循环\" class=\"headerlink\" title=\"退出多重循环\"></a>退出多重循环</h3><p>使用 <code>return</code> 退出多重循环. 一定程度上能简化代码, 使代码更容易理解.</p>\n<p><strong>例子:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 需求: 假设在一个函数体内的多重循环内, 达到某个临界条件时退出循环</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> flag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">10</span>; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i * j &gt; <span class=\"number\">30</span>) &#123;</span><br><span class=\"line\">        flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这种代码看着就头晕目眩, 重构如下:</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">10</span>; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i * j &gt; <span class=\"number\">30</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>直接使用 <code>return</code> 后, 后面的代码无法执行, 还是有点小问题的:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">10</span>; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i * j &gt; <span class=\"number\">30</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i) <span class=\"comment\">// 无法执行</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>为了解决这个问题, 我们可以把相关的代码放到 <code>return</code> 后面. 如果需要执行的代码较多, 可以提取成一个函数:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> print = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">i</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">10</span>; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i * j &gt; <span class=\"number\">30</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> print(i); <span class=\"comment\">// 执行</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><a href=\"#概述\">⤴️Go Top</a></p>\n","site":{"data":{}},"excerpt":"<p>今天读了曾探的<a href=\"https://book.douban.com/subject/26382780/\" target=\"_blank\" rel=\"noopener\">《设计模式》</a>中的代码重构这一章节, 知识点不多却非常使用, 在实际项目中除了使用设计模式重构代码外, 还有一些容易忽略的细节. 这些细节也是重构的重要手段. 写这篇文章总结一下.</p>","more":"<blockquote>\n<p>代码是写给人看的, 顺便给机器运行. 优雅的代码应该是简单、易维护、可扩展的.</p>\n</blockquote>\n<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li><a href=\"#提炼函数\">提炼函数</a></li>\n<li><a href=\"#合并重复的条件片段\">合并重复的条件片段</a></li>\n<li><a href=\"#把条件分支语句提炼成函数\">把条件分支语句提炼成函数</a></li>\n<li><a href=\"#合理的使用循环\">合理的使用循环</a></li>\n<li><a href=\"#提前让函数退出代替嵌套条件分支\">提前让函数退出代替嵌套条件分支</a></li>\n<li><a href=\"#传递对象参数代替过长的参数列表\">传递对象参数代替过长的参数列表</a></li>\n<li><a href=\"#尽量减少参数数量\">尽量减少参数数量</a></li>\n<li><a href=\"#少用三目运算\">少用三目运算</a></li>\n<li><a href=\"#合理使用链式调用\">合理使用链式调用</a></li>\n<li><a href=\"#分解大型类\">分解大型类</a></li>\n<li><a href=\"#退出多重循环\">退出多重循环</a></li>\n</ol>\n<h3 id=\"提炼函数\"><a href=\"#提炼函数\" class=\"headerlink\" title=\"提炼函数\"></a>提炼函数</h3><p>如果一个函数过长, 而且需要注释才清楚它是如何工作的, 那么需要考虑把它独立出来. 这样做的好处是:</p>\n<ul>\n<li>避免超大函数, 作用域过大变量不好维护</li>\n<li>抽离公共逻辑, 易于复用和覆写</li>\n<li>良好的命名起到了注释作用</li>\n</ul>\n<p><strong>例子:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> getUserInfo = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  fetch(<span class=\"string\">'https://xxx.com/userInfo'</span>, (data) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">      userId: <span class=\"subst\">$&#123;data.userId&#125;</span>\\n</span></span><br><span class=\"line\"><span class=\"string\">      userName: <span class=\"subst\">$&#123;data.userName&#125;</span>\\n</span></span><br><span class=\"line\"><span class=\"string\">      nickName: <span class=\"subst\">$&#123;data.NickName&#125;</span></span></span><br><span class=\"line\"><span class=\"string\">    `</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>重构如下:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> printDetail = <span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">    userId: <span class=\"subst\">$&#123;data.userId&#125;</span>\\n</span></span><br><span class=\"line\"><span class=\"string\">    userName: <span class=\"subst\">$&#123;data.userName&#125;</span>\\n</span></span><br><span class=\"line\"><span class=\"string\">    nickName: <span class=\"subst\">$&#123;data.NickName&#125;</span></span></span><br><span class=\"line\"><span class=\"string\">  `</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> getUserInfo = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  fetch(<span class=\"string\">'https://xxx.com/userInfo'</span>, (data) =&gt; &#123;</span><br><span class=\"line\">    printDetail(data);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><a href=\"#概述\">⤴️Go Top</a></p>\n<h3 id=\"合并重复的条件片段\"><a href=\"#合并重复的条件片段\" class=\"headerlink\" title=\"合并重复的条件片段\"></a>合并重复的条件片段</h3><p>如果一个函数体内有一些条件分支, 而且这些条件分支内散布了一些重复的代码, 这个时候就有必要进行合并去重操作.</p>\n<p><strong>例子:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> paging = <span class=\"function\">(<span class=\"params\">currPage</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (currPage &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    currPage = <span class=\"number\">0</span>;</span><br><span class=\"line\">    jump(currPage); <span class=\"comment\">// 跳转</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (currPage &gt;= totalPage) &#123;</span><br><span class=\"line\">    currPage = totalPage;</span><br><span class=\"line\">    jump(currPage); <span class=\"comment\">// 跳转</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    jump(currPage); <span class=\"comment\">// 跳转</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>可以看到上面的 <code>jump(currPage)</code> 重复了, 完全可以把它独立出来:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> paging = <span class=\"function\">(<span class=\"params\">currPage</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (currPage &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    currPage = <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (currPage &gt;= totalPage) &#123;</span><br><span class=\"line\">    currPage = totalPage;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  jump(currPage);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"#概述\">⤴️Go Top</a></p>\n<h3 id=\"把条件分支语句提炼成函数\"><a href=\"#把条件分支语句提炼成函数\" class=\"headerlink\" title=\"把条件分支语句提炼成函数\"></a>把条件分支语句提炼成函数</h3><p>复杂的条件分支语句是导致程序难以阅读和理解的重要原因, 而且很容易导致一个庞大的函数. 这种情况下就需要把条件分支语句提炼出来.</p>\n<p><strong>例子:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 需求: 如果当季是处于夏季, 那么所有的商品 8 折出售</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> getPrice = <span class=\"function\">(<span class=\"params\">price</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> date = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (date.getMonth() &gt;= <span class=\"number\">6</span> &amp;&amp; date.getMonth() &lt;= <span class=\"number\">9</span>) &#123; <span class=\"comment\">// 夏季</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> price * <span class=\"number\">0.8</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> price;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>观察这段代码:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (date.getMonth() &gt;= <span class=\"number\">6</span> &amp;&amp; date.getMonth() &lt;= <span class=\"number\">9</span>) &#123; <span class=\"comment\">// 夏季</span></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们需要让它更符合语义, 这样读代码的人能很轻松理解意图, 这里就可以提炼成一个单独函数.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> isSummer = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> date = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> date.getMonth() &gt;= <span class=\"number\">6</span> &amp;&amp; date.getMonth() &lt;= <span class=\"number\">9</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> getPrice = <span class=\"function\">(<span class=\"params\">price</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> date = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isSummer()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> price * <span class=\"number\">0.8</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> price;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><a href=\"#概述\">⤴️Go Top</a></p>\n<h3 id=\"合理的使用循环\"><a href=\"#合理的使用循环\" class=\"headerlink\" title=\"合理的使用循环\"></a>合理的使用循环</h3><p>在函数体内, 如果一些代码只是完成一些重复的工作, 那么可以合理利用循环完成同样的功能, 这样可以保持代码量更少.</p>\n<p><strong>例子:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 需求: IE9 以下创建一个 XHR 对象</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> createXHR = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> xhr;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    xhr = <span class=\"keyword\">new</span> ActiveXObject(<span class=\"string\">'MSXML2.XMLHttp.6.0'</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      xhr = <span class=\"keyword\">new</span> ActiveXObject(<span class=\"string\">'MSXML2.XMLHttp.3.0'</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">      xhr = <span class=\"keyword\">new</span> ActiveXObject(<span class=\"string\">'MSXML2.XMLHttp'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> xhr;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> xhr = createXHR();</span><br></pre></td></tr></table></figure>\n<p>这个时候, 使用循环来优化上面的代码:</p>\n<div class=\"tip\">复习一下 <strong>for</strong> 循环: <code>for(初始值; 循环条件; 步长;) {}</code> </div>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这段代码就看着符合语义了, 而且好理解 🤡</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> createXHR = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> versions = [<span class=\"string\">'MSXML2.XMLHttp.6.0'</span>, <span class=\"string\">'MSXML2.XMLHttp.3.0'</span>, <span class=\"string\">'MSXML2.XMLHttp'</span>];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, version; version = versions[i++];) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ActiveXObject(version);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(e) &#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> xhr = createXHR();</span><br></pre></td></tr></table></figure>\n<p><a href=\"#概述\">⤴️Go Top</a></p>\n<h3 id=\"提前让函数退出代替嵌套条件分支\"><a href=\"#提前让函数退出代替嵌套条件分支\" class=\"headerlink\" title=\"提前让函数退出代替嵌套条件分支\"></a>提前让函数退出代替嵌套条件分支</h3><p>很多程序员👨‍💻‍都有这种观念 “每个函数只能有一个入口和一个出口”, 但是关于 “函数只有一个出口” 往往有一些不同的看法, 下面用代码来说明一下, 光讲概念有点晦涩.</p>\n<p><strong>例子:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 下面是 \"函数只有一个出口\" 的典型代码</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> del = <span class=\"function\">(<span class=\"params\">obj</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> ret;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!obj.isReadOnly) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj.isFolder) &#123;</span><br><span class=\"line\">      ret = delFolder(obj);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (obj.isFile) &#123;</span><br><span class=\"line\">      ret = delFile(obj);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>嵌套的条件分支绝对是代码维护者的噩梦, 多层嵌套的条件更加不容易理解, 有时候如果代码过长, 上一个 <code>if ()</code> 语句可能相隔很远. 严重影响了阅读体验啊. 重构的 <code>del</code> 函数如下:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> del = <span class=\"function\">(<span class=\"params\">obj</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (obj.isReadOnly) &#123; <span class=\"comment\">// 反转 if</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (obj.isFolder) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> delFolder(obj);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (obj.isFile) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> delFile(obj);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 瞬间清爽 👌</span></span><br></pre></td></tr></table></figure>\n<p><a href=\"#概述\">⤴️Go Top</a></p>\n<h3 id=\"传递对象参数代替过长的参数列表\"><a href=\"#传递对象参数代替过长的参数列表\" class=\"headerlink\" title=\"传递对象参数代替过长的参数列表\"></a>传递对象参数代替过长的参数列表</h3><p>有时候一个函数可能接收多个参数, 而且参数阅读, 就越难理解和使用. 最重要的一点需要注意参数的顺序, 如果不传的情况要使用占位符代替. 如果参数超过 3 个, 请使用对象吧.</p>\n<p><strong>例子:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> setUserInfo = <span class=\"function\">(<span class=\"params\">id, name, address, sex, mobile, qq</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用 ☹️:</span></span><br><span class=\"line\">setUserInfo(<span class=\"number\">1</span>, <span class=\"string\">'ifyour'</span>, <span class=\"literal\">undefined</span>, <span class=\"string\">'male'</span>, <span class=\"literal\">undefined</span>, <span class=\"string\">'123456'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 重构 😁:</span></span><br><span class=\"line\">setUserInfo(&#123;</span><br><span class=\"line\">  id: <span class=\"number\">1</span>,</span><br><span class=\"line\">  name: <span class=\"string\">'ifyour'</span>,</span><br><span class=\"line\">  sex: <span class=\"string\">'male'</span>,</span><br><span class=\"line\">  qq: <span class=\"string\">'123456'</span>,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p><a href=\"#概述\">⤴️Go Top</a></p>\n<h3 id=\"尽量减少参数数量\"><a href=\"#尽量减少参数数量\" class=\"headerlink\" title=\"尽量减少参数数量\"></a>尽量减少参数数量</h3><p>如果调用一个函数, 需要传递很多参数, 这样的函数用起来就要小心了, 必须搞清楚每个参数的含义, 所以, 如果能尽量少传参数就少传参数. 把复杂的逻辑封装到函数内部.</p>\n<p><strong>例子:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 需求: 有一个画图函数 draw</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> draw = <span class=\"function\">(<span class=\"params\">width, height, square</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 优化如下:</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> draw = <span class=\"function\">(<span class=\"params\">width, height</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> square = width * height;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的 <code>square</code> 参数没必要, 可以通过 <code>width</code> 和 <code>height</code> 计算获得, 还有一种情况, 这个画图函数, 如果可以画多种图形呢? 所以需要在内部去处理, 什么时候需要 <code>square</code> 什么时候需要 <code>radius</code>, 然后可以使用 <strong>策略模式</strong> 让它支持画多种图形.</p>\n<p><a href=\"#概述\">⤴️Go Top</a></p>\n<h3 id=\"少用三目运算\"><a href=\"#少用三目运算\" class=\"headerlink\" title=\"少用三目运算\"></a>少用三目运算</h3><p>三目运算能减少代码量, 但是不能滥用, 如果以牺牲代码可读性为代价, 那就得不偿失了.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> global = <span class=\"keyword\">typeof</span> <span class=\"built_in\">window</span> !== <span class=\"string\">'undefined'</span> ? <span class=\"built_in\">window</span> : <span class=\"keyword\">this</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 但是这种情况就完全没必要了, 老实写 if..else...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!aup || !bup) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a === doc ? <span class=\"number\">-1</span> :</span><br><span class=\"line\">    b === doc ? <span class=\"number\">1</span> :</span><br><span class=\"line\">    aup ? <span class=\"number\">-1</span> :</span><br><span class=\"line\">    bup ? <span class=\"number\">1</span> :</span><br><span class=\"line\">    sortInput ?</span><br><span class=\"line\">    (indexOf.call(sortInput, a) - indexOf.call(sortInput, b)) :</span><br><span class=\"line\">    <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 😡 这是人看的吗</span></span><br></pre></td></tr></table></figure>\n<p><a href=\"#概述\">⤴️Go Top</a></p>\n<h3 id=\"合理使用链式调用\"><a href=\"#合理使用链式调用\" class=\"headerlink\" title=\"合理使用链式调用\"></a>合理使用链式调用</h3><p>jQuery 中的链式调用用起来还是很爽的, 它的实现也非常简单, 我们可以很容易的实现一个链式调用. 使用的前提就是链条的结构相对来说稳定, 不容易发生修改, 如果是经常发生修改的话, 还是建议使用普通的调用. 因为它调试的时候需要把这个链子拆开, 才知道是哪个环节有 Bug.</p>\n<p><strong>例子:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> User = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.id = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">User.prototype.setId = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>; <span class=\"comment\">// 返回实例本身</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">User.prototype.setName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 链式调用</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> User()</span><br><span class=\"line\">  .setId(<span class=\"number\">1</span>)</span><br><span class=\"line\">  .setNmae(<span class=\"string\">'ifyour'</span>);</span><br></pre></td></tr></table></figure>\n<p>或者这样:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> User = &#123;</span><br><span class=\"line\">  id: <span class=\"literal\">null</span>,</span><br><span class=\"line\">  name: <span class=\"literal\">null</span>,</span><br><span class=\"line\">  setId: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  setName: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">User.setId(<span class=\"number\">1</span>).setName(<span class=\"string\">'ifyour'</span>);</span><br></pre></td></tr></table></figure>\n<p><a href=\"#概述\">⤴️Go Top</a></p>\n<h3 id=\"分解大型类\"><a href=\"#分解大型类\" class=\"headerlink\" title=\"分解大型类\"></a>分解大型类</h3><p>从字面意思我们就能理解, 如果一个类里面有太多的方法, 我们要考虑把其中同一类型相关的方法抽离出来. 模块化的好处不言而喻, 把逻辑复杂的分离成小的单元, 这样更便于维护, 出现 bug 了也好定位问题. 来看一段代码.</p>\n<p><strong>例子:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 英雄类</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Spirit = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 原型上的攻击方法</span></span><br><span class=\"line\">Spirit.prototype.attack = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">type</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (type === <span class=\"string\">'waveBoxing'</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">': 使用波动拳'</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (type === <span class=\"string\">'whirlKick'</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">': 使用旋风腿'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// ... 还有很多攻击方法</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> spirit = <span class=\"keyword\">new</span> Spirit(<span class=\"string\">'RYU'</span>);</span><br><span class=\"line\">spirit.attack(<span class=\"string\">'waveBoxing'</span>); <span class=\"comment\">// RYU: 使用波动拳</span></span><br><span class=\"line\">spirit.attack(<span class=\"string\">'whirlKick'</span>); <span class=\"comment\">// RYU: 使用旋风腿</span></span><br></pre></td></tr></table></figure>\n<p>面向对象的设计鼓励将 <strong>行为</strong> 分解到合理数量的更小的对象中:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Attack = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">spirit</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.spirit = spirit;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Attack.prototype.start = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">type</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.list[type].call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Attack.prototype.list = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  waveBoxing: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.sprite.name + <span class=\"string\">': 使用波动拳'</span>)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  whirlKick: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.sprite.name + <span class=\"string\">': 使用旋风腿'</span>)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在 Sprite 类精简了很多, 不再直接包含攻击相关的方法, 而是把方法委托给 Attack 类来执行. 这段代码也是 <strong>策略模式</strong> 的运用之一, 看代码:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Spirit = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.attackObj = <span class=\"keyword\">new</span> Attack(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Spirit.prototype.attack = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">type</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.attackObj.start(type);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> spirit = <span class=\"keyword\">new</span> Spirit(<span class=\"string\">'RYU'</span>);</span><br><span class=\"line\">spirit.attack(<span class=\"string\">'waveBoxing'</span>); <span class=\"comment\">// RYU: 使用波动拳</span></span><br><span class=\"line\">spirit.attack(<span class=\"string\">'whirlKick'</span>); <span class=\"comment\">// RYU: 使用旋风腿</span></span><br></pre></td></tr></table></figure>\n<p><a href=\"#概述\">⤴️Go Top</a></p>\n<h3 id=\"退出多重循环\"><a href=\"#退出多重循环\" class=\"headerlink\" title=\"退出多重循环\"></a>退出多重循环</h3><p>使用 <code>return</code> 退出多重循环. 一定程度上能简化代码, 使代码更容易理解.</p>\n<p><strong>例子:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 需求: 假设在一个函数体内的多重循环内, 达到某个临界条件时退出循环</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> flag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">10</span>; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i * j &gt; <span class=\"number\">30</span>) &#123;</span><br><span class=\"line\">        flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这种代码看着就头晕目眩, 重构如下:</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">10</span>; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i * j &gt; <span class=\"number\">30</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>直接使用 <code>return</code> 后, 后面的代码无法执行, 还是有点小问题的:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">10</span>; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i * j &gt; <span class=\"number\">30</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i) <span class=\"comment\">// 无法执行</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>为了解决这个问题, 我们可以把相关的代码放到 <code>return</code> 后面. 如果需要执行的代码较多, 可以提取成一个函数:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> print = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">i</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">10</span>; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i * j &gt; <span class=\"number\">30</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> print(i); <span class=\"comment\">// 执行</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><a href=\"#概述\">⤴️Go Top</a></p>"},{"title":"一段神奇的 CSS 调试代码","date":"2016-03-22T08:32:52.000Z","comments":0,"_content":"\n现在到处都是 JavaScript，倘若花点时间去深入分析，每次都能学到点新的东西。当我发现些有意思的东西，习惯先收藏起来。等时技（时间＋技术）成熟，再去 Review 他们的代码，看一看它们是如何做到的，览一览大牛们的 “奇技淫巧”。\n<!-- more -->\n### 代码片段\n\n```js\n[].forEach.call($$(\"*\"),function(a){\n    a.style.outline=\"1px solid #\"+(~~(Math.random()*(1<<24))).toString(16);\n})\n```\n在浏览器控制台运行此段代码，会给页面里所有的 DOM 元素添加一个 1px 的描边（outline），方便我们在调试 CSS 过程中分析、排查问题。\n![](http://ww1.sinaimg.cn/large/6057861cgy1fbzi0vggl6j21kw0vyq8s.jpg)\n\n\n### 代码分析\n这段代码是 Github 上的 140 Bytes 活动中的代码，简单分析下这段 JS 代码，作者使用了不少技巧：\n\n首先是需要选择页面上的所有元素，这里使用了只能在 Console 调试工具中使用的 `$$` 函数，你可以在 Console 中输入 `$$('a')` 自己试一下。它会返回当前页面的所有 anchor（链接）元素。`$$` 与 `document.querySelectorAll` 是等价的，有兴趣可[查看](http://ourjs.com/detail/54ab768a5695544119000007) $$ 和 $ 选择器的历史。\n\n其次遍历所有元素，这里用的是 `[].forEach.call(...)`，使用 forEach 替代 for 之类循环能减少不少代码量，而 forEach 是 Array 对象的方法，所以用了个 `[]` 空数组来代替 `Array.prototype` 更显简洁，得到所有元素的节点列表（NodeList），但是它并没有实现 Array 的所有接口，因此使用 `$$(\"*\").forEach` 会返回错误，这里使用 `call` 方法来更改 forEach 内部 `this` 指向，当然也可以使用 `apply`。\n\n之后就是让元素有一个漂亮的边框，并拥有不同的颜色了。在 CSS 渲染的盒子模型（Box Model）中，`outline` ***并不会改变元素及其布局的位置***。这里较有意思的是定义不同的颜色的色值：\n```js\n~~(Math.random()*(1<<24))).toString(16)\n```\n这里想构造的其实是一个16进制的颜色值，即 `000000～ffffff`，也就是 `parseInt('0',16)` 到 `parseInt('ffffff',16)` 之间的一个值。\n\n```js\nparseInt('ffffff',16) == 16777215 == (2^24-1) == (1<<24 - 1)\n```\n\n而 `Math.random()`，得到的是一个 0~1 之间的浮点数，`(Math.random()*(1<<24)`，即得到 0~16777215 之间的浮点数，而色值是需要整数的，所以就需要将浮点数进行 int 转换。这里用到了 `~~`，可[参见](http://www.jeffjade.com/2015/05/31/2015-05-31-javascript-operational%EF%BC%8Dsymbol/)理解 JavaScript 非运算符(~/~~ )。当然可以将 `~~` 视为 `parseInt` 的简写。并且使用按位或 `|` 操作符也可以得到相同的结果：\n\n```js\nvar a = 1.234567890;\nvar b = 0.000000001;\n~~a == 0|a == parseInt(a, 10) == 1\n~~b == 0|b == parseInt(b, 10) == 0\n```\n`toString(16)` 使用数字类型的 `toString` 方法进行十进制到16进制的转换。至此我们得到了一个 0 到 16777215之间的随机数，然后使用 `toString(16)` 转换成16进制，将此值赋予到页面上所有元素节点的 `outline` 附加属性上。它就是这样工作的。精致巧妙而且非常实用，顶一个！\n","source":"_posts/一段神奇的-CSS-调试代码.md","raw":"---\ntitle: 一段神奇的 CSS 调试代码\ndate: 2016-03-22 16:32:52\ntags:\ncomments: false\n---\n\n现在到处都是 JavaScript，倘若花点时间去深入分析，每次都能学到点新的东西。当我发现些有意思的东西，习惯先收藏起来。等时技（时间＋技术）成熟，再去 Review 他们的代码，看一看它们是如何做到的，览一览大牛们的 “奇技淫巧”。\n<!-- more -->\n### 代码片段\n\n```js\n[].forEach.call($$(\"*\"),function(a){\n    a.style.outline=\"1px solid #\"+(~~(Math.random()*(1<<24))).toString(16);\n})\n```\n在浏览器控制台运行此段代码，会给页面里所有的 DOM 元素添加一个 1px 的描边（outline），方便我们在调试 CSS 过程中分析、排查问题。\n![](http://ww1.sinaimg.cn/large/6057861cgy1fbzi0vggl6j21kw0vyq8s.jpg)\n\n\n### 代码分析\n这段代码是 Github 上的 140 Bytes 活动中的代码，简单分析下这段 JS 代码，作者使用了不少技巧：\n\n首先是需要选择页面上的所有元素，这里使用了只能在 Console 调试工具中使用的 `$$` 函数，你可以在 Console 中输入 `$$('a')` 自己试一下。它会返回当前页面的所有 anchor（链接）元素。`$$` 与 `document.querySelectorAll` 是等价的，有兴趣可[查看](http://ourjs.com/detail/54ab768a5695544119000007) $$ 和 $ 选择器的历史。\n\n其次遍历所有元素，这里用的是 `[].forEach.call(...)`，使用 forEach 替代 for 之类循环能减少不少代码量，而 forEach 是 Array 对象的方法，所以用了个 `[]` 空数组来代替 `Array.prototype` 更显简洁，得到所有元素的节点列表（NodeList），但是它并没有实现 Array 的所有接口，因此使用 `$$(\"*\").forEach` 会返回错误，这里使用 `call` 方法来更改 forEach 内部 `this` 指向，当然也可以使用 `apply`。\n\n之后就是让元素有一个漂亮的边框，并拥有不同的颜色了。在 CSS 渲染的盒子模型（Box Model）中，`outline` ***并不会改变元素及其布局的位置***。这里较有意思的是定义不同的颜色的色值：\n```js\n~~(Math.random()*(1<<24))).toString(16)\n```\n这里想构造的其实是一个16进制的颜色值，即 `000000～ffffff`，也就是 `parseInt('0',16)` 到 `parseInt('ffffff',16)` 之间的一个值。\n\n```js\nparseInt('ffffff',16) == 16777215 == (2^24-1) == (1<<24 - 1)\n```\n\n而 `Math.random()`，得到的是一个 0~1 之间的浮点数，`(Math.random()*(1<<24)`，即得到 0~16777215 之间的浮点数，而色值是需要整数的，所以就需要将浮点数进行 int 转换。这里用到了 `~~`，可[参见](http://www.jeffjade.com/2015/05/31/2015-05-31-javascript-operational%EF%BC%8Dsymbol/)理解 JavaScript 非运算符(~/~~ )。当然可以将 `~~` 视为 `parseInt` 的简写。并且使用按位或 `|` 操作符也可以得到相同的结果：\n\n```js\nvar a = 1.234567890;\nvar b = 0.000000001;\n~~a == 0|a == parseInt(a, 10) == 1\n~~b == 0|b == parseInt(b, 10) == 0\n```\n`toString(16)` 使用数字类型的 `toString` 方法进行十进制到16进制的转换。至此我们得到了一个 0 到 16777215之间的随机数，然后使用 `toString(16)` 转换成16进制，将此值赋予到页面上所有元素节点的 `outline` 附加属性上。它就是这样工作的。精致巧妙而且非常实用，顶一个！\n","slug":"一段神奇的-CSS-调试代码","published":1,"updated":"2018-06-17T09:49:30.000Z","layout":"post","photos":[],"link":"","_id":"cjiitidj8000ju4q97rhmeeib","content":"<p>现在到处都是 JavaScript，倘若花点时间去深入分析，每次都能学到点新的东西。当我发现些有意思的东西，习惯先收藏起来。等时技（时间＋技术）成熟，再去 Review 他们的代码，看一看它们是如何做到的，览一览大牛们的 “奇技淫巧”。<br><a id=\"more\"></a></p>\n<h3 id=\"代码片段\"><a href=\"#代码片段\" class=\"headerlink\" title=\"代码片段\"></a>代码片段</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[].forEach.call($$(<span class=\"string\">\"*\"</span>),<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">    a.style.outline=<span class=\"string\">\"1px solid #\"</span>+(~~(<span class=\"built_in\">Math</span>.random()*(<span class=\"number\">1</span>&lt;&lt;<span class=\"number\">24</span>))).toString(<span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>在浏览器控制台运行此段代码，会给页面里所有的 DOM 元素添加一个 1px 的描边（outline），方便我们在调试 CSS 过程中分析、排查问题。<br><img src=\"http://ww1.sinaimg.cn/large/6057861cgy1fbzi0vggl6j21kw0vyq8s.jpg\" alt=\"\"></p>\n<h3 id=\"代码分析\"><a href=\"#代码分析\" class=\"headerlink\" title=\"代码分析\"></a>代码分析</h3><p>这段代码是 Github 上的 140 Bytes 活动中的代码，简单分析下这段 JS 代码，作者使用了不少技巧：</p>\n<p>首先是需要选择页面上的所有元素，这里使用了只能在 Console 调试工具中使用的 <code>$$</code> 函数，你可以在 Console 中输入 <code>$$(&#39;a&#39;)</code> 自己试一下。它会返回当前页面的所有 anchor（链接）元素。<code>$$</code> 与 <code>document.querySelectorAll</code> 是等价的，有兴趣可<a href=\"http://ourjs.com/detail/54ab768a5695544119000007\" target=\"_blank\" rel=\"noopener\">查看</a> $$ 和 $ 选择器的历史。</p>\n<p>其次遍历所有元素，这里用的是 <code>[].forEach.call(...)</code>，使用 forEach 替代 for 之类循环能减少不少代码量，而 forEach 是 Array 对象的方法，所以用了个 <code>[]</code> 空数组来代替 <code>Array.prototype</code> 更显简洁，得到所有元素的节点列表（NodeList），但是它并没有实现 Array 的所有接口，因此使用 <code>$$(&quot;*&quot;).forEach</code> 会返回错误，这里使用 <code>call</code> 方法来更改 forEach 内部 <code>this</code> 指向，当然也可以使用 <code>apply</code>。</p>\n<p>之后就是让元素有一个漂亮的边框，并拥有不同的颜色了。在 CSS 渲染的盒子模型（Box Model）中，<code>outline</code> <strong><em>并不会改变元素及其布局的位置</em></strong>。这里较有意思的是定义不同的颜色的色值：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~~(<span class=\"built_in\">Math</span>.random()*(<span class=\"number\">1</span>&lt;&lt;<span class=\"number\">24</span>))).toString(<span class=\"number\">16</span>)</span><br></pre></td></tr></table></figure></p>\n<p>这里想构造的其实是一个16进制的颜色值，即 <code>000000～ffffff</code>，也就是 <code>parseInt(&#39;0&#39;,16)</code> 到 <code>parseInt(&#39;ffffff&#39;,16)</code> 之间的一个值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"string\">'ffffff'</span>,<span class=\"number\">16</span>) == <span class=\"number\">16777215</span> == (<span class=\"number\">2</span>^<span class=\"number\">24</span><span class=\"number\">-1</span>) == (<span class=\"number\">1</span>&lt;&lt;<span class=\"number\">24</span> - <span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n<p>而 <code>Math.random()</code>，得到的是一个 0~1 之间的浮点数，<code>(Math.random()*(1&lt;&lt;24)</code>，即得到 0~16777215 之间的浮点数，而色值是需要整数的，所以就需要将浮点数进行 int 转换。这里用到了 <code>~~</code>，可<a href=\"http://www.jeffjade.com/2015/05/31/2015-05-31-javascript-operational%EF%BC%8Dsymbol/\" target=\"_blank\" rel=\"noopener\">参见</a>理解 JavaScript 非运算符(~/~~ )。当然可以将 <code>~~</code> 视为 <code>parseInt</code> 的简写。并且使用按位或 <code>|</code> 操作符也可以得到相同的结果：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1.234567890</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">0.000000001</span>;</span><br><span class=\"line\">~~a == <span class=\"number\">0</span>|a == <span class=\"built_in\">parseInt</span>(a, <span class=\"number\">10</span>) == <span class=\"number\">1</span></span><br><span class=\"line\">~~b == <span class=\"number\">0</span>|b == <span class=\"built_in\">parseInt</span>(b, <span class=\"number\">10</span>) == <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<p><code>toString(16)</code> 使用数字类型的 <code>toString</code> 方法进行十进制到16进制的转换。至此我们得到了一个 0 到 16777215之间的随机数，然后使用 <code>toString(16)</code> 转换成16进制，将此值赋予到页面上所有元素节点的 <code>outline</code> 附加属性上。它就是这样工作的。精致巧妙而且非常实用，顶一个！</p>\n","site":{"data":{}},"excerpt":"<p>现在到处都是 JavaScript，倘若花点时间去深入分析，每次都能学到点新的东西。当我发现些有意思的东西，习惯先收藏起来。等时技（时间＋技术）成熟，再去 Review 他们的代码，看一看它们是如何做到的，览一览大牛们的 “奇技淫巧”。<br>","more":"</p>\n<h3 id=\"代码片段\"><a href=\"#代码片段\" class=\"headerlink\" title=\"代码片段\"></a>代码片段</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[].forEach.call($$(<span class=\"string\">\"*\"</span>),<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">    a.style.outline=<span class=\"string\">\"1px solid #\"</span>+(~~(<span class=\"built_in\">Math</span>.random()*(<span class=\"number\">1</span>&lt;&lt;<span class=\"number\">24</span>))).toString(<span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>在浏览器控制台运行此段代码，会给页面里所有的 DOM 元素添加一个 1px 的描边（outline），方便我们在调试 CSS 过程中分析、排查问题。<br><img src=\"http://ww1.sinaimg.cn/large/6057861cgy1fbzi0vggl6j21kw0vyq8s.jpg\" alt=\"\"></p>\n<h3 id=\"代码分析\"><a href=\"#代码分析\" class=\"headerlink\" title=\"代码分析\"></a>代码分析</h3><p>这段代码是 Github 上的 140 Bytes 活动中的代码，简单分析下这段 JS 代码，作者使用了不少技巧：</p>\n<p>首先是需要选择页面上的所有元素，这里使用了只能在 Console 调试工具中使用的 <code>$$</code> 函数，你可以在 Console 中输入 <code>$$(&#39;a&#39;)</code> 自己试一下。它会返回当前页面的所有 anchor（链接）元素。<code>$$</code> 与 <code>document.querySelectorAll</code> 是等价的，有兴趣可<a href=\"http://ourjs.com/detail/54ab768a5695544119000007\" target=\"_blank\" rel=\"noopener\">查看</a> $$ 和 $ 选择器的历史。</p>\n<p>其次遍历所有元素，这里用的是 <code>[].forEach.call(...)</code>，使用 forEach 替代 for 之类循环能减少不少代码量，而 forEach 是 Array 对象的方法，所以用了个 <code>[]</code> 空数组来代替 <code>Array.prototype</code> 更显简洁，得到所有元素的节点列表（NodeList），但是它并没有实现 Array 的所有接口，因此使用 <code>$$(&quot;*&quot;).forEach</code> 会返回错误，这里使用 <code>call</code> 方法来更改 forEach 内部 <code>this</code> 指向，当然也可以使用 <code>apply</code>。</p>\n<p>之后就是让元素有一个漂亮的边框，并拥有不同的颜色了。在 CSS 渲染的盒子模型（Box Model）中，<code>outline</code> <strong><em>并不会改变元素及其布局的位置</em></strong>。这里较有意思的是定义不同的颜色的色值：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~~(<span class=\"built_in\">Math</span>.random()*(<span class=\"number\">1</span>&lt;&lt;<span class=\"number\">24</span>))).toString(<span class=\"number\">16</span>)</span><br></pre></td></tr></table></figure></p>\n<p>这里想构造的其实是一个16进制的颜色值，即 <code>000000～ffffff</code>，也就是 <code>parseInt(&#39;0&#39;,16)</code> 到 <code>parseInt(&#39;ffffff&#39;,16)</code> 之间的一个值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"string\">'ffffff'</span>,<span class=\"number\">16</span>) == <span class=\"number\">16777215</span> == (<span class=\"number\">2</span>^<span class=\"number\">24</span><span class=\"number\">-1</span>) == (<span class=\"number\">1</span>&lt;&lt;<span class=\"number\">24</span> - <span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n<p>而 <code>Math.random()</code>，得到的是一个 0~1 之间的浮点数，<code>(Math.random()*(1&lt;&lt;24)</code>，即得到 0~16777215 之间的浮点数，而色值是需要整数的，所以就需要将浮点数进行 int 转换。这里用到了 <code>~~</code>，可<a href=\"http://www.jeffjade.com/2015/05/31/2015-05-31-javascript-operational%EF%BC%8Dsymbol/\" target=\"_blank\" rel=\"noopener\">参见</a>理解 JavaScript 非运算符(~/~~ )。当然可以将 <code>~~</code> 视为 <code>parseInt</code> 的简写。并且使用按位或 <code>|</code> 操作符也可以得到相同的结果：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1.234567890</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">0.000000001</span>;</span><br><span class=\"line\">~~a == <span class=\"number\">0</span>|a == <span class=\"built_in\">parseInt</span>(a, <span class=\"number\">10</span>) == <span class=\"number\">1</span></span><br><span class=\"line\">~~b == <span class=\"number\">0</span>|b == <span class=\"built_in\">parseInt</span>(b, <span class=\"number\">10</span>) == <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<p><code>toString(16)</code> 使用数字类型的 <code>toString</code> 方法进行十进制到16进制的转换。至此我们得到了一个 0 到 16777215之间的随机数，然后使用 <code>toString(16)</code> 转换成16进制，将此值赋予到页面上所有元素节点的 <code>outline</code> 附加属性上。它就是这样工作的。精致巧妙而且非常实用，顶一个！</p>"},{"title":"call、apply、bind 的区别及应用","date":"2016-03-26T10:14:16.000Z","comments":0,"_content":"\n在面向对象的编程中，经常会处理 `this` 的指向问题，改变 this 的指向就不得不谈谈今天的主角—— `call`、`apply`、`bind`。个人感觉 `this` 的问题初学者不同容易一下理解透彻，今天再来好好捋一捋加深理解。\n<!-- more -->\n### 作用\n`call`、`apply`、`bind` 的作用就是改变函数执行时的上下文，即改变 `this` 指向。\n\n`this` 的指向其实也就[不外乎这四种情况](https://ifyour.github.io/2016/02/19/JavaScript-%E4%B8%AD%E7%9A%84-this-%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/)，其实理解起来还是很容易的，理解不了也没关系，先记住，后面在工作中大量编码应用，写多了就知道为啥要这样用了。先来一个简单的例子。\n```js\n// 定义人类构造函数，属性是姓名，方法是输出自己的姓名\nfunction Person(name) {\n    this.name = name;\n}\n\nPerson.prototype = {\n    constructor: Person,\n    showName: function() {\n        console.log(this.name);\n    }\n};\n\nvar p1 = new Person('ifyour');\np1.showName(); // => ifyour\n\n// 定义一个动物对象，它有个一姓名属性\nvar animal = {\n    name: 'cat'\n};\n\n```\n人类实例 `p1` 想要打印自己的姓名，只要调用自身的 `showName` 方法即可，但是动物呢？我也想要动物实例 `animal` 打印自己的名字，如何做呢？当然改变 this 咯，把人类的 `showName` 方法借给动物用。\n\n```js\n// 可以直接去原型上借用\nPerson.prototype.showName.call(animal);//=>cat\n\n// 也可以从人类上生成的实例 p1 去借用\np1.showName.call(animal);//  => cat\np1.showName.apply(animal);// => cat\np1.showName.bind(animal)();//=> cat\n```\n\n### 区别\n#### call、apply 与 bind\n- `call`、`apply` 改变 `this` 指向后会 ***立即执行***\n- `bind` 并不会执行\n\n在上面的例子我们也看到了，`bind` 方法改变 this 时，还需要加一个 `()` 才能执行输出 `cat`。\n\n#### call 与 apply\n\n- `call` 把参数按顺序传入，即：`fn.call(obj, arg1, arg2, arg3...);`\n- `apply` 把参数打包成 `Array` 后传入，即： `fn.apply(obj, [arg1, arg2, arg3...]);`\n\n\n它们俩之间的差别在于 ***参数***，`call` 和 `aplly` 的第一个参数都是要改变上下文的对象，而 `call` 从第二个参数开始以参数列表的形式展现，`apply` 则是把除了改变上下文对象的参数放在一个数组里面作为它的第二个参数。\n\n### 应用\n知道了怎么使用和它们之间的区别，接下来我们来了解一下使用 `call`、`apply`、`bind` 的常见应用场景。\n\n#### 求数组中的最大、最小值\n```js\nvar arr = [34,5,3,6,54,6,-67,5,7,6,-8,687];\n\nMath.max.call(Math, 34,5,3,6,54,6,-67,5,7,6,-8,687);\nMath.max.apply(Math, arr);\n\nMath.min.call(Math, 34,5,3,6,54,6,-67,5,7,6,-8,687);\nMath.min.apply(Math, arr);\n```\n#### 将伪数组转化为数组\nJavaScript 中的伪数组(例如通过 `document.getElementsByTagName` 获取的元素)具有 `length` 属性，并且可以通过 0、1、2…下标来访问其中的元素，但是没有 `Array` 中的 `push`、`pop` 等方法。我们可以利用 `call`、`apply` 来将其转化为真正的数组这样便可以方便地使用数组方法了。\n\n```js\n// 这是一个伪数组\nvar arrayLike = {\n    0: 'aaaa',\n    1: 'bbbb',\n    2: 'cccc',\n    length: 3\n}\n// 通过这个方法转换\nvar arr = Array.prototype.slice.call(arrayLike);\n```\n<div class='tip'>上面 `arr` 便是一个包含 `arrayLike` 元素的真正的数组啦( 注意数据结构必须是以数字为下标而且一定要有 `length` 属性 )\n</div>\n\n#### 数组追加\n```js\nvar arr1 = [1,2,3];\nvar arr2 = [4,5,6];\n[].push.apply(arr1, arr2);\n\nconsole.log(arr1);// => [1, 2, 3, 4, 5, 6]\nconsole.log(arr2);// => [1, 2, 3]\n```\n\n#### 变量类型判断\n```js\nfunction isArray(obj){\n    return Object.prototype.toString.call(obj) == '[object Array]'\n}\nvar arr1 = [1,2,3];\nvar arr2 = '[1,2,3]';\n\nisArray(arr1);//   => true\nisArray(arr2);//   => false\n```\n\n#### 继承\n```js\n// 基础类\nvar Person = function (name, age) {\n  this.name = name;\n  this.age = age;\n};\n\n// 女孩类继承基础人类\nvar Girl = function (name) {\n  Person.call(this, name);\n};\n// 男孩类继承基础人类\nvar Boy = function (name, age) {\n  Person.apply(this, arguments);\n};\n\nvar g1 = new Girl ('Jilly');\nvar b1 = new Boy('ifyour', 18);\n```\n","source":"_posts/call、apply、bind-的区别及应用.md","raw":"---\ntitle: call、apply、bind 的区别及应用\ndate: 2016-03-26 18:14:16\ntags:\ncomments: false\n---\n\n在面向对象的编程中，经常会处理 `this` 的指向问题，改变 this 的指向就不得不谈谈今天的主角—— `call`、`apply`、`bind`。个人感觉 `this` 的问题初学者不同容易一下理解透彻，今天再来好好捋一捋加深理解。\n<!-- more -->\n### 作用\n`call`、`apply`、`bind` 的作用就是改变函数执行时的上下文，即改变 `this` 指向。\n\n`this` 的指向其实也就[不外乎这四种情况](https://ifyour.github.io/2016/02/19/JavaScript-%E4%B8%AD%E7%9A%84-this-%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/)，其实理解起来还是很容易的，理解不了也没关系，先记住，后面在工作中大量编码应用，写多了就知道为啥要这样用了。先来一个简单的例子。\n```js\n// 定义人类构造函数，属性是姓名，方法是输出自己的姓名\nfunction Person(name) {\n    this.name = name;\n}\n\nPerson.prototype = {\n    constructor: Person,\n    showName: function() {\n        console.log(this.name);\n    }\n};\n\nvar p1 = new Person('ifyour');\np1.showName(); // => ifyour\n\n// 定义一个动物对象，它有个一姓名属性\nvar animal = {\n    name: 'cat'\n};\n\n```\n人类实例 `p1` 想要打印自己的姓名，只要调用自身的 `showName` 方法即可，但是动物呢？我也想要动物实例 `animal` 打印自己的名字，如何做呢？当然改变 this 咯，把人类的 `showName` 方法借给动物用。\n\n```js\n// 可以直接去原型上借用\nPerson.prototype.showName.call(animal);//=>cat\n\n// 也可以从人类上生成的实例 p1 去借用\np1.showName.call(animal);//  => cat\np1.showName.apply(animal);// => cat\np1.showName.bind(animal)();//=> cat\n```\n\n### 区别\n#### call、apply 与 bind\n- `call`、`apply` 改变 `this` 指向后会 ***立即执行***\n- `bind` 并不会执行\n\n在上面的例子我们也看到了，`bind` 方法改变 this 时，还需要加一个 `()` 才能执行输出 `cat`。\n\n#### call 与 apply\n\n- `call` 把参数按顺序传入，即：`fn.call(obj, arg1, arg2, arg3...);`\n- `apply` 把参数打包成 `Array` 后传入，即： `fn.apply(obj, [arg1, arg2, arg3...]);`\n\n\n它们俩之间的差别在于 ***参数***，`call` 和 `aplly` 的第一个参数都是要改变上下文的对象，而 `call` 从第二个参数开始以参数列表的形式展现，`apply` 则是把除了改变上下文对象的参数放在一个数组里面作为它的第二个参数。\n\n### 应用\n知道了怎么使用和它们之间的区别，接下来我们来了解一下使用 `call`、`apply`、`bind` 的常见应用场景。\n\n#### 求数组中的最大、最小值\n```js\nvar arr = [34,5,3,6,54,6,-67,5,7,6,-8,687];\n\nMath.max.call(Math, 34,5,3,6,54,6,-67,5,7,6,-8,687);\nMath.max.apply(Math, arr);\n\nMath.min.call(Math, 34,5,3,6,54,6,-67,5,7,6,-8,687);\nMath.min.apply(Math, arr);\n```\n#### 将伪数组转化为数组\nJavaScript 中的伪数组(例如通过 `document.getElementsByTagName` 获取的元素)具有 `length` 属性，并且可以通过 0、1、2…下标来访问其中的元素，但是没有 `Array` 中的 `push`、`pop` 等方法。我们可以利用 `call`、`apply` 来将其转化为真正的数组这样便可以方便地使用数组方法了。\n\n```js\n// 这是一个伪数组\nvar arrayLike = {\n    0: 'aaaa',\n    1: 'bbbb',\n    2: 'cccc',\n    length: 3\n}\n// 通过这个方法转换\nvar arr = Array.prototype.slice.call(arrayLike);\n```\n<div class='tip'>上面 `arr` 便是一个包含 `arrayLike` 元素的真正的数组啦( 注意数据结构必须是以数字为下标而且一定要有 `length` 属性 )\n</div>\n\n#### 数组追加\n```js\nvar arr1 = [1,2,3];\nvar arr2 = [4,5,6];\n[].push.apply(arr1, arr2);\n\nconsole.log(arr1);// => [1, 2, 3, 4, 5, 6]\nconsole.log(arr2);// => [1, 2, 3]\n```\n\n#### 变量类型判断\n```js\nfunction isArray(obj){\n    return Object.prototype.toString.call(obj) == '[object Array]'\n}\nvar arr1 = [1,2,3];\nvar arr2 = '[1,2,3]';\n\nisArray(arr1);//   => true\nisArray(arr2);//   => false\n```\n\n#### 继承\n```js\n// 基础类\nvar Person = function (name, age) {\n  this.name = name;\n  this.age = age;\n};\n\n// 女孩类继承基础人类\nvar Girl = function (name) {\n  Person.call(this, name);\n};\n// 男孩类继承基础人类\nvar Boy = function (name, age) {\n  Person.apply(this, arguments);\n};\n\nvar g1 = new Girl ('Jilly');\nvar b1 = new Boy('ifyour', 18);\n```\n","slug":"call、apply、bind-的区别及应用","published":1,"updated":"2018-06-17T09:49:30.000Z","layout":"post","photos":[],"link":"","_id":"cjiitidj9000ku4q9pmz93dxl","content":"<p>在面向对象的编程中，经常会处理 <code>this</code> 的指向问题，改变 this 的指向就不得不谈谈今天的主角—— <code>call</code>、<code>apply</code>、<code>bind</code>。个人感觉 <code>this</code> 的问题初学者不同容易一下理解透彻，今天再来好好捋一捋加深理解。<br><a id=\"more\"></a></p>\n<h3 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h3><p><code>call</code>、<code>apply</code>、<code>bind</code> 的作用就是改变函数执行时的上下文，即改变 <code>this</code> 指向。</p>\n<p><code>this</code> 的指向其实也就<a href=\"https://ifyour.github.io/2016/02/19/JavaScript-%E4%B8%AD%E7%9A%84-this-%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/\">不外乎这四种情况</a>，其实理解起来还是很容易的，理解不了也没关系，先记住，后面在工作中大量编码应用，写多了就知道为啥要这样用了。先来一个简单的例子。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义人类构造函数，属性是姓名，方法是输出自己的姓名</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>: Person,</span><br><span class=\"line\">    showName: function() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p1 = <span class=\"keyword\">new</span> Person(<span class=\"string\">'ifyour'</span>);</span><br><span class=\"line\">p1.showName(); <span class=\"comment\">// =&gt; ifyour</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义一个动物对象，它有个一姓名属性</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> animal = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'cat'</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>人类实例 <code>p1</code> 想要打印自己的姓名，只要调用自身的 <code>showName</code> 方法即可，但是动物呢？我也想要动物实例 <code>animal</code> 打印自己的名字，如何做呢？当然改变 this 咯，把人类的 <code>showName</code> 方法借给动物用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 可以直接去原型上借用</span></span><br><span class=\"line\">Person.prototype.showName.call(animal);<span class=\"comment\">//=&gt;cat</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 也可以从人类上生成的实例 p1 去借用</span></span><br><span class=\"line\">p1.showName.call(animal);<span class=\"comment\">//  =&gt; cat</span></span><br><span class=\"line\">p1.showName.apply(animal);<span class=\"comment\">// =&gt; cat</span></span><br><span class=\"line\">p1.showName.bind(animal)();<span class=\"comment\">//=&gt; cat</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h3><h4 id=\"call、apply-与-bind\"><a href=\"#call、apply-与-bind\" class=\"headerlink\" title=\"call、apply 与 bind\"></a>call、apply 与 bind</h4><ul>\n<li><code>call</code>、<code>apply</code> 改变 <code>this</code> 指向后会 <strong><em>立即执行</em></strong></li>\n<li><code>bind</code> 并不会执行</li>\n</ul>\n<p>在上面的例子我们也看到了，<code>bind</code> 方法改变 this 时，还需要加一个 <code>()</code> 才能执行输出 <code>cat</code>。</p>\n<h4 id=\"call-与-apply\"><a href=\"#call-与-apply\" class=\"headerlink\" title=\"call 与 apply\"></a>call 与 apply</h4><ul>\n<li><code>call</code> 把参数按顺序传入，即：<code>fn.call(obj, arg1, arg2, arg3...);</code></li>\n<li><code>apply</code> 把参数打包成 <code>Array</code> 后传入，即： <code>fn.apply(obj, [arg1, arg2, arg3...]);</code></li>\n</ul>\n<p>它们俩之间的差别在于 <strong><em>参数</em></strong>，<code>call</code> 和 <code>aplly</code> 的第一个参数都是要改变上下文的对象，而 <code>call</code> 从第二个参数开始以参数列表的形式展现，<code>apply</code> 则是把除了改变上下文对象的参数放在一个数组里面作为它的第二个参数。</p>\n<h3 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h3><p>知道了怎么使用和它们之间的区别，接下来我们来了解一下使用 <code>call</code>、<code>apply</code>、<code>bind</code> 的常见应用场景。</p>\n<h4 id=\"求数组中的最大、最小值\"><a href=\"#求数组中的最大、最小值\" class=\"headerlink\" title=\"求数组中的最大、最小值\"></a>求数组中的最大、最小值</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">34</span>,<span class=\"number\">5</span>,<span class=\"number\">3</span>,<span class=\"number\">6</span>,<span class=\"number\">54</span>,<span class=\"number\">6</span>,<span class=\"number\">-67</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">6</span>,<span class=\"number\">-8</span>,<span class=\"number\">687</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.max.call(<span class=\"built_in\">Math</span>, <span class=\"number\">34</span>,<span class=\"number\">5</span>,<span class=\"number\">3</span>,<span class=\"number\">6</span>,<span class=\"number\">54</span>,<span class=\"number\">6</span>,<span class=\"number\">-67</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">6</span>,<span class=\"number\">-8</span>,<span class=\"number\">687</span>);</span><br><span class=\"line\"><span class=\"built_in\">Math</span>.max.apply(<span class=\"built_in\">Math</span>, arr);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.min.call(<span class=\"built_in\">Math</span>, <span class=\"number\">34</span>,<span class=\"number\">5</span>,<span class=\"number\">3</span>,<span class=\"number\">6</span>,<span class=\"number\">54</span>,<span class=\"number\">6</span>,<span class=\"number\">-67</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">6</span>,<span class=\"number\">-8</span>,<span class=\"number\">687</span>);</span><br><span class=\"line\"><span class=\"built_in\">Math</span>.min.apply(<span class=\"built_in\">Math</span>, arr);</span><br></pre></td></tr></table></figure>\n<h4 id=\"将伪数组转化为数组\"><a href=\"#将伪数组转化为数组\" class=\"headerlink\" title=\"将伪数组转化为数组\"></a>将伪数组转化为数组</h4><p>JavaScript 中的伪数组(例如通过 <code>document.getElementsByTagName</code> 获取的元素)具有 <code>length</code> 属性，并且可以通过 0、1、2…下标来访问其中的元素，但是没有 <code>Array</code> 中的 <code>push</code>、<code>pop</code> 等方法。我们可以利用 <code>call</code>、<code>apply</code> 来将其转化为真正的数组这样便可以方便地使用数组方法了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这是一个伪数组</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arrayLike = &#123;</span><br><span class=\"line\">    <span class=\"number\">0</span>: <span class=\"string\">'aaaa'</span>,</span><br><span class=\"line\">    <span class=\"number\">1</span>: <span class=\"string\">'bbbb'</span>,</span><br><span class=\"line\">    <span class=\"number\">2</span>: <span class=\"string\">'cccc'</span>,</span><br><span class=\"line\">    length: <span class=\"number\">3</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 通过这个方法转换</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = <span class=\"built_in\">Array</span>.prototype.slice.call(arrayLike);</span><br></pre></td></tr></table></figure>\n<div class=\"tip\">上面 <code>arr</code> 便是一个包含 <code>arrayLike</code> 元素的真正的数组啦( 注意数据结构必须是以数字为下标而且一定要有 <code>length</code> 属性 )<br></div>\n\n<h4 id=\"数组追加\"><a href=\"#数组追加\" class=\"headerlink\" title=\"数组追加\"></a>数组追加</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr1 = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = [<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>];</span><br><span class=\"line\">[].push.apply(arr1, arr2);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr1);<span class=\"comment\">// =&gt; [1, 2, 3, 4, 5, 6]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2);<span class=\"comment\">// =&gt; [1, 2, 3]</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"变量类型判断\"><a href=\"#变量类型判断\" class=\"headerlink\" title=\"变量类型判断\"></a>变量类型判断</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isArray</span>(<span class=\"params\">obj</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(obj) == <span class=\"string\">'[object Array]'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr1 = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = <span class=\"string\">'[1,2,3]'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">isArray(arr1);<span class=\"comment\">//   =&gt; true</span></span><br><span class=\"line\">isArray(arr2);<span class=\"comment\">//   =&gt; false</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 基础类</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Person = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 女孩类继承基础人类</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Girl = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  Person.call(<span class=\"keyword\">this</span>, name);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 男孩类继承基础人类</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Boy = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">  Person.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> g1 = <span class=\"keyword\">new</span> Girl (<span class=\"string\">'Jilly'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> b1 = <span class=\"keyword\">new</span> Boy(<span class=\"string\">'ifyour'</span>, <span class=\"number\">18</span>);</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>在面向对象的编程中，经常会处理 <code>this</code> 的指向问题，改变 this 的指向就不得不谈谈今天的主角—— <code>call</code>、<code>apply</code>、<code>bind</code>。个人感觉 <code>this</code> 的问题初学者不同容易一下理解透彻，今天再来好好捋一捋加深理解。<br>","more":"</p>\n<h3 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h3><p><code>call</code>、<code>apply</code>、<code>bind</code> 的作用就是改变函数执行时的上下文，即改变 <code>this</code> 指向。</p>\n<p><code>this</code> 的指向其实也就<a href=\"https://ifyour.github.io/2016/02/19/JavaScript-%E4%B8%AD%E7%9A%84-this-%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/\">不外乎这四种情况</a>，其实理解起来还是很容易的，理解不了也没关系，先记住，后面在工作中大量编码应用，写多了就知道为啥要这样用了。先来一个简单的例子。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义人类构造函数，属性是姓名，方法是输出自己的姓名</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>: Person,</span><br><span class=\"line\">    showName: function() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p1 = <span class=\"keyword\">new</span> Person(<span class=\"string\">'ifyour'</span>);</span><br><span class=\"line\">p1.showName(); <span class=\"comment\">// =&gt; ifyour</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义一个动物对象，它有个一姓名属性</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> animal = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'cat'</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>人类实例 <code>p1</code> 想要打印自己的姓名，只要调用自身的 <code>showName</code> 方法即可，但是动物呢？我也想要动物实例 <code>animal</code> 打印自己的名字，如何做呢？当然改变 this 咯，把人类的 <code>showName</code> 方法借给动物用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 可以直接去原型上借用</span></span><br><span class=\"line\">Person.prototype.showName.call(animal);<span class=\"comment\">//=&gt;cat</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 也可以从人类上生成的实例 p1 去借用</span></span><br><span class=\"line\">p1.showName.call(animal);<span class=\"comment\">//  =&gt; cat</span></span><br><span class=\"line\">p1.showName.apply(animal);<span class=\"comment\">// =&gt; cat</span></span><br><span class=\"line\">p1.showName.bind(animal)();<span class=\"comment\">//=&gt; cat</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h3><h4 id=\"call、apply-与-bind\"><a href=\"#call、apply-与-bind\" class=\"headerlink\" title=\"call、apply 与 bind\"></a>call、apply 与 bind</h4><ul>\n<li><code>call</code>、<code>apply</code> 改变 <code>this</code> 指向后会 <strong><em>立即执行</em></strong></li>\n<li><code>bind</code> 并不会执行</li>\n</ul>\n<p>在上面的例子我们也看到了，<code>bind</code> 方法改变 this 时，还需要加一个 <code>()</code> 才能执行输出 <code>cat</code>。</p>\n<h4 id=\"call-与-apply\"><a href=\"#call-与-apply\" class=\"headerlink\" title=\"call 与 apply\"></a>call 与 apply</h4><ul>\n<li><code>call</code> 把参数按顺序传入，即：<code>fn.call(obj, arg1, arg2, arg3...);</code></li>\n<li><code>apply</code> 把参数打包成 <code>Array</code> 后传入，即： <code>fn.apply(obj, [arg1, arg2, arg3...]);</code></li>\n</ul>\n<p>它们俩之间的差别在于 <strong><em>参数</em></strong>，<code>call</code> 和 <code>aplly</code> 的第一个参数都是要改变上下文的对象，而 <code>call</code> 从第二个参数开始以参数列表的形式展现，<code>apply</code> 则是把除了改变上下文对象的参数放在一个数组里面作为它的第二个参数。</p>\n<h3 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h3><p>知道了怎么使用和它们之间的区别，接下来我们来了解一下使用 <code>call</code>、<code>apply</code>、<code>bind</code> 的常见应用场景。</p>\n<h4 id=\"求数组中的最大、最小值\"><a href=\"#求数组中的最大、最小值\" class=\"headerlink\" title=\"求数组中的最大、最小值\"></a>求数组中的最大、最小值</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">34</span>,<span class=\"number\">5</span>,<span class=\"number\">3</span>,<span class=\"number\">6</span>,<span class=\"number\">54</span>,<span class=\"number\">6</span>,<span class=\"number\">-67</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">6</span>,<span class=\"number\">-8</span>,<span class=\"number\">687</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.max.call(<span class=\"built_in\">Math</span>, <span class=\"number\">34</span>,<span class=\"number\">5</span>,<span class=\"number\">3</span>,<span class=\"number\">6</span>,<span class=\"number\">54</span>,<span class=\"number\">6</span>,<span class=\"number\">-67</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">6</span>,<span class=\"number\">-8</span>,<span class=\"number\">687</span>);</span><br><span class=\"line\"><span class=\"built_in\">Math</span>.max.apply(<span class=\"built_in\">Math</span>, arr);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.min.call(<span class=\"built_in\">Math</span>, <span class=\"number\">34</span>,<span class=\"number\">5</span>,<span class=\"number\">3</span>,<span class=\"number\">6</span>,<span class=\"number\">54</span>,<span class=\"number\">6</span>,<span class=\"number\">-67</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">6</span>,<span class=\"number\">-8</span>,<span class=\"number\">687</span>);</span><br><span class=\"line\"><span class=\"built_in\">Math</span>.min.apply(<span class=\"built_in\">Math</span>, arr);</span><br></pre></td></tr></table></figure>\n<h4 id=\"将伪数组转化为数组\"><a href=\"#将伪数组转化为数组\" class=\"headerlink\" title=\"将伪数组转化为数组\"></a>将伪数组转化为数组</h4><p>JavaScript 中的伪数组(例如通过 <code>document.getElementsByTagName</code> 获取的元素)具有 <code>length</code> 属性，并且可以通过 0、1、2…下标来访问其中的元素，但是没有 <code>Array</code> 中的 <code>push</code>、<code>pop</code> 等方法。我们可以利用 <code>call</code>、<code>apply</code> 来将其转化为真正的数组这样便可以方便地使用数组方法了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这是一个伪数组</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arrayLike = &#123;</span><br><span class=\"line\">    <span class=\"number\">0</span>: <span class=\"string\">'aaaa'</span>,</span><br><span class=\"line\">    <span class=\"number\">1</span>: <span class=\"string\">'bbbb'</span>,</span><br><span class=\"line\">    <span class=\"number\">2</span>: <span class=\"string\">'cccc'</span>,</span><br><span class=\"line\">    length: <span class=\"number\">3</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 通过这个方法转换</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = <span class=\"built_in\">Array</span>.prototype.slice.call(arrayLike);</span><br></pre></td></tr></table></figure>\n<div class=\"tip\">上面 <code>arr</code> 便是一个包含 <code>arrayLike</code> 元素的真正的数组啦( 注意数据结构必须是以数字为下标而且一定要有 <code>length</code> 属性 )<br></div>\n\n<h4 id=\"数组追加\"><a href=\"#数组追加\" class=\"headerlink\" title=\"数组追加\"></a>数组追加</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr1 = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = [<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>];</span><br><span class=\"line\">[].push.apply(arr1, arr2);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr1);<span class=\"comment\">// =&gt; [1, 2, 3, 4, 5, 6]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2);<span class=\"comment\">// =&gt; [1, 2, 3]</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"变量类型判断\"><a href=\"#变量类型判断\" class=\"headerlink\" title=\"变量类型判断\"></a>变量类型判断</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isArray</span>(<span class=\"params\">obj</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(obj) == <span class=\"string\">'[object Array]'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr1 = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = <span class=\"string\">'[1,2,3]'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">isArray(arr1);<span class=\"comment\">//   =&gt; true</span></span><br><span class=\"line\">isArray(arr2);<span class=\"comment\">//   =&gt; false</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 基础类</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Person = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 女孩类继承基础人类</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Girl = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  Person.call(<span class=\"keyword\">this</span>, name);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 男孩类继承基础人类</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Boy = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">  Person.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> g1 = <span class=\"keyword\">new</span> Girl (<span class=\"string\">'Jilly'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> b1 = <span class=\"keyword\">new</span> Boy(<span class=\"string\">'ifyour'</span>, <span class=\"number\">18</span>);</span><br></pre></td></tr></table></figure>"},{"title":"持续集成 (CI) 及简单实践","date":"2018-04-30T01:00:00.000Z","comments":1,"_content":"\n在软件开发领域, 一直有很多比较专业的术语, 本着科普的精神, 来填一下自己的 ~~知识盲区~~ 😂, 什么是持续集成? 如何做持续集成? 为什么要做持续集成? 带着这些问题, 本篇文章会给你答案.\n\n<!-- more -->\n\n## What\n\n> 持续集成（英语：Continuous integration，缩写 CI）是一种软件工程流程，是将所有软件工程师对于软件的工作副本持续提交到共用主线（mainline）的一种措施。\n\n## Why\n\n持续集成的目的，就是让产品可以快速迭代，同时还能保持高质量。\n\n![image](https://user-images.githubusercontent.com/15377484/39465580-acb719cc-4d56-11e8-9915-2964d5e523c5.png)\n\n## How\n\n它的核心措施是，代码集成到主干之前，必须通过自动化测试。只要有一个测试用例失败，就不能集成。以本次给博客做持续集成为例，它的流程是这样子的：\n\n1. 写完博客后，直接 push 到 GitHub 的 `src` 分支(我的 `master` 分支是 pages)\n2. CI 服务通过配置文件 `.travis.yml` 监听当前 `src` 分支发生变化，触发 webhook\n3. CI 服务将当前项目 clone 过去，根据 `.travis.yml` 的配置执行测试和构建\n4. 将最终可以作为生产环境的代码推送到线上环境，并且 push 回  `src` 分支\n\n这样做的好处就是：\n\n- 发布新文章，只需 push 一次到仓库，剩下的测试、构建、部署生产环境等，CI 帮我自动完成。\n- 快速发现错误。每完成一点更新，就集成到主干，定位错误也比较容易。\n- 防止分支大幅偏离主干。如果不是经常集成，主干又在不断更新，会导致以后集成的难度变大。\n\n## More\n\n- [持续集成是什么](http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html)\n- [使用 Travis 自动部署 Hexo](https://segmentfault.com/a/1190000009054888)\n","source":"_posts/持续集成-CI-及简单实践.md","raw":"---\ntitle: '持续集成 (CI) 及简单实践'\ndate: 2018-04-30 9:00:00\ntags:\ncomments: true\n---\n\n在软件开发领域, 一直有很多比较专业的术语, 本着科普的精神, 来填一下自己的 ~~知识盲区~~ 😂, 什么是持续集成? 如何做持续集成? 为什么要做持续集成? 带着这些问题, 本篇文章会给你答案.\n\n<!-- more -->\n\n## What\n\n> 持续集成（英语：Continuous integration，缩写 CI）是一种软件工程流程，是将所有软件工程师对于软件的工作副本持续提交到共用主线（mainline）的一种措施。\n\n## Why\n\n持续集成的目的，就是让产品可以快速迭代，同时还能保持高质量。\n\n![image](https://user-images.githubusercontent.com/15377484/39465580-acb719cc-4d56-11e8-9915-2964d5e523c5.png)\n\n## How\n\n它的核心措施是，代码集成到主干之前，必须通过自动化测试。只要有一个测试用例失败，就不能集成。以本次给博客做持续集成为例，它的流程是这样子的：\n\n1. 写完博客后，直接 push 到 GitHub 的 `src` 分支(我的 `master` 分支是 pages)\n2. CI 服务通过配置文件 `.travis.yml` 监听当前 `src` 分支发生变化，触发 webhook\n3. CI 服务将当前项目 clone 过去，根据 `.travis.yml` 的配置执行测试和构建\n4. 将最终可以作为生产环境的代码推送到线上环境，并且 push 回  `src` 分支\n\n这样做的好处就是：\n\n- 发布新文章，只需 push 一次到仓库，剩下的测试、构建、部署生产环境等，CI 帮我自动完成。\n- 快速发现错误。每完成一点更新，就集成到主干，定位错误也比较容易。\n- 防止分支大幅偏离主干。如果不是经常集成，主干又在不断更新，会导致以后集成的难度变大。\n\n## More\n\n- [持续集成是什么](http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html)\n- [使用 Travis 自动部署 Hexo](https://segmentfault.com/a/1190000009054888)\n","slug":"持续集成-CI-及简单实践","published":1,"updated":"2018-06-17T09:49:30.000Z","layout":"post","photos":[],"link":"","_id":"cjiitidja000lu4q9nerikxz8","content":"<p>在软件开发领域, 一直有很多比较专业的术语, 本着科普的精神, 来填一下自己的 <del>知识盲区</del> 😂, 什么是持续集成? 如何做持续集成? 为什么要做持续集成? 带着这些问题, 本篇文章会给你答案.</p>\n<a id=\"more\"></a>\n<h2 id=\"What\"><a href=\"#What\" class=\"headerlink\" title=\"What\"></a>What</h2><blockquote>\n<p>持续集成（英语：Continuous integration，缩写 CI）是一种软件工程流程，是将所有软件工程师对于软件的工作副本持续提交到共用主线（mainline）的一种措施。</p>\n</blockquote>\n<h2 id=\"Why\"><a href=\"#Why\" class=\"headerlink\" title=\"Why\"></a>Why</h2><p>持续集成的目的，就是让产品可以快速迭代，同时还能保持高质量。</p>\n<p><img src=\"https://user-images.githubusercontent.com/15377484/39465580-acb719cc-4d56-11e8-9915-2964d5e523c5.png\" alt=\"image\"></p>\n<h2 id=\"How\"><a href=\"#How\" class=\"headerlink\" title=\"How\"></a>How</h2><p>它的核心措施是，代码集成到主干之前，必须通过自动化测试。只要有一个测试用例失败，就不能集成。以本次给博客做持续集成为例，它的流程是这样子的：</p>\n<ol>\n<li>写完博客后，直接 push 到 GitHub 的 <code>src</code> 分支(我的 <code>master</code> 分支是 pages)</li>\n<li>CI 服务通过配置文件 <code>.travis.yml</code> 监听当前 <code>src</code> 分支发生变化，触发 webhook</li>\n<li>CI 服务将当前项目 clone 过去，根据 <code>.travis.yml</code> 的配置执行测试和构建</li>\n<li>将最终可以作为生产环境的代码推送到线上环境，并且 push 回  <code>src</code> 分支</li>\n</ol>\n<p>这样做的好处就是：</p>\n<ul>\n<li>发布新文章，只需 push 一次到仓库，剩下的测试、构建、部署生产环境等，CI 帮我自动完成。</li>\n<li>快速发现错误。每完成一点更新，就集成到主干，定位错误也比较容易。</li>\n<li>防止分支大幅偏离主干。如果不是经常集成，主干又在不断更新，会导致以后集成的难度变大。</li>\n</ul>\n<h2 id=\"More\"><a href=\"#More\" class=\"headerlink\" title=\"More\"></a>More</h2><ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html\" target=\"_blank\" rel=\"noopener\">持续集成是什么</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000009054888\" target=\"_blank\" rel=\"noopener\">使用 Travis 自动部署 Hexo</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>在软件开发领域, 一直有很多比较专业的术语, 本着科普的精神, 来填一下自己的 <del>知识盲区</del> 😂, 什么是持续集成? 如何做持续集成? 为什么要做持续集成? 带着这些问题, 本篇文章会给你答案.</p>","more":"<h2 id=\"What\"><a href=\"#What\" class=\"headerlink\" title=\"What\"></a>What</h2><blockquote>\n<p>持续集成（英语：Continuous integration，缩写 CI）是一种软件工程流程，是将所有软件工程师对于软件的工作副本持续提交到共用主线（mainline）的一种措施。</p>\n</blockquote>\n<h2 id=\"Why\"><a href=\"#Why\" class=\"headerlink\" title=\"Why\"></a>Why</h2><p>持续集成的目的，就是让产品可以快速迭代，同时还能保持高质量。</p>\n<p><img src=\"https://user-images.githubusercontent.com/15377484/39465580-acb719cc-4d56-11e8-9915-2964d5e523c5.png\" alt=\"image\"></p>\n<h2 id=\"How\"><a href=\"#How\" class=\"headerlink\" title=\"How\"></a>How</h2><p>它的核心措施是，代码集成到主干之前，必须通过自动化测试。只要有一个测试用例失败，就不能集成。以本次给博客做持续集成为例，它的流程是这样子的：</p>\n<ol>\n<li>写完博客后，直接 push 到 GitHub 的 <code>src</code> 分支(我的 <code>master</code> 分支是 pages)</li>\n<li>CI 服务通过配置文件 <code>.travis.yml</code> 监听当前 <code>src</code> 分支发生变化，触发 webhook</li>\n<li>CI 服务将当前项目 clone 过去，根据 <code>.travis.yml</code> 的配置执行测试和构建</li>\n<li>将最终可以作为生产环境的代码推送到线上环境，并且 push 回  <code>src</code> 分支</li>\n</ol>\n<p>这样做的好处就是：</p>\n<ul>\n<li>发布新文章，只需 push 一次到仓库，剩下的测试、构建、部署生产环境等，CI 帮我自动完成。</li>\n<li>快速发现错误。每完成一点更新，就集成到主干，定位错误也比较容易。</li>\n<li>防止分支大幅偏离主干。如果不是经常集成，主干又在不断更新，会导致以后集成的难度变大。</li>\n</ul>\n<h2 id=\"More\"><a href=\"#More\" class=\"headerlink\" title=\"More\"></a>More</h2><ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html\" target=\"_blank\" rel=\"noopener\">持续集成是什么</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000009054888\" target=\"_blank\" rel=\"noopener\">使用 Travis 自动部署 Hexo</a></li>\n</ul>"},{"title":"如何避免 async/await 地狱","comments":1,"date":"2018-05-20T14:11:35.000Z","from":"https://medium.freecodecamp.org/avoiding-the-async-await-hell-c77a0fb71c4c","_content":"\n最近阅读了 Aditya Agarwal 的一篇文章：How to escape async/await hell。这篇文章主要讨论了过度使用 async/await 导致的新的「地狱」问题，其已经在 Medium 上获得了 19k+ 的 Applause。\n\n<!-- more -->\n\n<div class=\"tip\">\n  async/await 是 ES7 的新语法。在 async/await 标准出来之前，JavaScript 的异步编程经历了 callback --> promise --> generator 的演变过程。\n</div>\n\n在 callback 的时代，最让人头疼的问题就是回调地狱 (callback hell)。所以，在 async/await 一经推出，社区就有人认为「这是 JavaScript 异步编程的终极解决方案」。但 async/await 也可能带来新的问题。\n\n> 好不容易逃离了一个「地狱」，又马上陷入另一个「地狱」了。\n\n### 何为 async/await 地狱\n\n在编写异步代码时，人们总是喜欢一次写多个语句，并且在一个函数调用之前使用 await 关键字。这可能会导致性能问题，因为很多时候一个语句并不依赖于前一个语句——但使用 await 关键字后，你就需要等待前一个语句完成。\n\n#### 示例\n\n假设你要写一个订购 pizza 和 drink 的脚本，代码可能是如下这样的：\n\n```js\n(async () => {\n  const pizzaData = await getPizzaData(); // async call\n  const drinkData = await getDrinkData(); // async call\n  const chosenPizza = choosePizza(); // sync call\n  const chosenDrink = chooseDrink(); // sync call\n  await addPizzaToCart(chosenPizza); // async call\n  await addDrinkToCart(chosenDrink); // async call\n  orderItems(); // async call\n})();\n```\n\n这段代码开起来没什么问题，也能正常的运行。但是，这并不是一个好的实现，因为这把本身可以并行执行的任务变成了串行执行。\n\n选择一个 drink 添加到购物车和选择一个 pizza 添加到购物车可以看作是两个任务，而这两个任务之间并没有相互依赖的关系，也没有特定的顺序执行关系。所以这两个任务是可以并行执行的，这样能提高性能。而上述代码将二者变成了串行执行，显然是降低了程序性能的。\n\n### 更糟糕的例子\n\n假设要写一个程序，根据 followers 数用来显示 GitHub 中国区用户的排名情况。\n\n如果只是获取排名，我们可以调用 Github 官方的 [Search users](https://developer.github.com/v3/search/#search-users) 接口，伪代码如下：\n\n```js\nasync function getUserRank() {\n  const data = await fetch(search_url);\n  return data;\n}\n\ngetUserRank();\n```\n\n调用 getUserRank 函数就能获取到想要的结果。但是，你可能还要想要获取每个用户的 follower 数、email、地区和仓库等数据，而 Search users 接口并没有返回这些数据，你可能需要再去调用 [Single user](https://developer.github.com/v3/users/#get-a-single-user) 接口。\n\n然后上述代码可能被改写为：\n\n```js\nasync function getUserRank() {\n  const data = await fetch(search_url);\n  const res = [];\n\n  for (let i = 0; i < data.length; i++) {\n    const item = data[i];\n    const user = await fetch(user_url);\n    res.push({...item, ...user});\n  }\n\n  return res;\n}\n\ngetUserRank();\n```\n\n运行查看结果，自己想要的数据都拿到了。但是，你发现一个问题，程序运行时间有点长，该怎么优化下呢？\n\n其实，铺垫了这么长，就是想说明一个问题：你陷入了 async/await 的地狱。\n\n上述代码的问题在于，获取每个用户资料的请求并不存在依赖性，就类似上文中的选择 pizza 和 drink 一样，这是可以并行执行的请求。而根据上述代码，请求都变成了串行执行，这当然会损耗程序的性能。\n\n按照上述代码，可以看一下其异步请求的动态图：\n\n![image](https://user-images.githubusercontent.com/7871813/40270076-c08ec820-5bb9-11e8-8470-5e716e87dc76.gif)\n\n可以看到，获取用户资料的每个请求都需要等到上一个请求完成之后才能执行，Waterfall 处于一个串行的状态。那要怎么改进这个问题呢？\n\n既然获取每个用户资料的请求并不存在依赖性，那么我们可以先触发异步请求，然后延迟处理异步请求的结果，而不是一直等该请求完成。根据这个思路，那可能改进的代码如下：\n\n```js\nasync function getUserDetails (username) {\n  const user = await fetch(user_url);\n  return user;\n}\n\nasync function getUserRank () {\n  const data = await fetch(search_url);\n  const promises = data.map((item) => getUserDetails(item.username));\n  await Promise.all(promises).then(handleYourData);\n}\n\ngetUserRank();\n```\n\n可以看一下异步请求的动态图：\n\n![image](https://user-images.githubusercontent.com/7871813/40270077-c2536602-5bb9-11e8-9438-a15ac05b41e0.gif)\n\n可以看到，获取用户资料的异步请求处理不再是串行执行，而是并行执行了，这将大大提高程序的运行效率和性能。\n\n### 总结\n\nAditya Agarwal 在其文章中也给出了怎么避免陷入 async/await 地狱的建议：\n\n1. 首先找出依赖于其他语句的执行的语句\n2. 然后将有依赖关系的一系列语句进行组合，合并成一个异步函数\n3. 最后用正确的方式执行这些函数\n\n### 参考\n\n* [精读《async/await 是把双刃剑》](https://github.com/dt-fe/weekly/blob/master/55.%E7%B2%BE%E8%AF%BB%E3%80%8Aasync%20await%20%E6%98%AF%E6%8A%8A%E5%8F%8C%E5%88%83%E5%89%91%E3%80%8B.md)\n* [async 函数的含义和用法](http://www.ruanyifeng.com/blog/2015/05/async.html)\n* [体验异步的终极解决方案 - ES7 的 Async/Await](https://cnodejs.org/topic/5640b80d3a6aa72c5e0030b6)\n* [How to escape async/await hell](https://github.com/dwqs/blog/issues/65)\n","source":"_posts/如何避免-async-await-地狱.md","raw":"---\ntitle: 如何避免 async/await 地狱\ncomments: true\ndate: 2018-05-20 22:11:35\ntags:\nfrom: https://medium.freecodecamp.org/avoiding-the-async-await-hell-c77a0fb71c4c\n---\n\n最近阅读了 Aditya Agarwal 的一篇文章：How to escape async/await hell。这篇文章主要讨论了过度使用 async/await 导致的新的「地狱」问题，其已经在 Medium 上获得了 19k+ 的 Applause。\n\n<!-- more -->\n\n<div class=\"tip\">\n  async/await 是 ES7 的新语法。在 async/await 标准出来之前，JavaScript 的异步编程经历了 callback --> promise --> generator 的演变过程。\n</div>\n\n在 callback 的时代，最让人头疼的问题就是回调地狱 (callback hell)。所以，在 async/await 一经推出，社区就有人认为「这是 JavaScript 异步编程的终极解决方案」。但 async/await 也可能带来新的问题。\n\n> 好不容易逃离了一个「地狱」，又马上陷入另一个「地狱」了。\n\n### 何为 async/await 地狱\n\n在编写异步代码时，人们总是喜欢一次写多个语句，并且在一个函数调用之前使用 await 关键字。这可能会导致性能问题，因为很多时候一个语句并不依赖于前一个语句——但使用 await 关键字后，你就需要等待前一个语句完成。\n\n#### 示例\n\n假设你要写一个订购 pizza 和 drink 的脚本，代码可能是如下这样的：\n\n```js\n(async () => {\n  const pizzaData = await getPizzaData(); // async call\n  const drinkData = await getDrinkData(); // async call\n  const chosenPizza = choosePizza(); // sync call\n  const chosenDrink = chooseDrink(); // sync call\n  await addPizzaToCart(chosenPizza); // async call\n  await addDrinkToCart(chosenDrink); // async call\n  orderItems(); // async call\n})();\n```\n\n这段代码开起来没什么问题，也能正常的运行。但是，这并不是一个好的实现，因为这把本身可以并行执行的任务变成了串行执行。\n\n选择一个 drink 添加到购物车和选择一个 pizza 添加到购物车可以看作是两个任务，而这两个任务之间并没有相互依赖的关系，也没有特定的顺序执行关系。所以这两个任务是可以并行执行的，这样能提高性能。而上述代码将二者变成了串行执行，显然是降低了程序性能的。\n\n### 更糟糕的例子\n\n假设要写一个程序，根据 followers 数用来显示 GitHub 中国区用户的排名情况。\n\n如果只是获取排名，我们可以调用 Github 官方的 [Search users](https://developer.github.com/v3/search/#search-users) 接口，伪代码如下：\n\n```js\nasync function getUserRank() {\n  const data = await fetch(search_url);\n  return data;\n}\n\ngetUserRank();\n```\n\n调用 getUserRank 函数就能获取到想要的结果。但是，你可能还要想要获取每个用户的 follower 数、email、地区和仓库等数据，而 Search users 接口并没有返回这些数据，你可能需要再去调用 [Single user](https://developer.github.com/v3/users/#get-a-single-user) 接口。\n\n然后上述代码可能被改写为：\n\n```js\nasync function getUserRank() {\n  const data = await fetch(search_url);\n  const res = [];\n\n  for (let i = 0; i < data.length; i++) {\n    const item = data[i];\n    const user = await fetch(user_url);\n    res.push({...item, ...user});\n  }\n\n  return res;\n}\n\ngetUserRank();\n```\n\n运行查看结果，自己想要的数据都拿到了。但是，你发现一个问题，程序运行时间有点长，该怎么优化下呢？\n\n其实，铺垫了这么长，就是想说明一个问题：你陷入了 async/await 的地狱。\n\n上述代码的问题在于，获取每个用户资料的请求并不存在依赖性，就类似上文中的选择 pizza 和 drink 一样，这是可以并行执行的请求。而根据上述代码，请求都变成了串行执行，这当然会损耗程序的性能。\n\n按照上述代码，可以看一下其异步请求的动态图：\n\n![image](https://user-images.githubusercontent.com/7871813/40270076-c08ec820-5bb9-11e8-8470-5e716e87dc76.gif)\n\n可以看到，获取用户资料的每个请求都需要等到上一个请求完成之后才能执行，Waterfall 处于一个串行的状态。那要怎么改进这个问题呢？\n\n既然获取每个用户资料的请求并不存在依赖性，那么我们可以先触发异步请求，然后延迟处理异步请求的结果，而不是一直等该请求完成。根据这个思路，那可能改进的代码如下：\n\n```js\nasync function getUserDetails (username) {\n  const user = await fetch(user_url);\n  return user;\n}\n\nasync function getUserRank () {\n  const data = await fetch(search_url);\n  const promises = data.map((item) => getUserDetails(item.username));\n  await Promise.all(promises).then(handleYourData);\n}\n\ngetUserRank();\n```\n\n可以看一下异步请求的动态图：\n\n![image](https://user-images.githubusercontent.com/7871813/40270077-c2536602-5bb9-11e8-9438-a15ac05b41e0.gif)\n\n可以看到，获取用户资料的异步请求处理不再是串行执行，而是并行执行了，这将大大提高程序的运行效率和性能。\n\n### 总结\n\nAditya Agarwal 在其文章中也给出了怎么避免陷入 async/await 地狱的建议：\n\n1. 首先找出依赖于其他语句的执行的语句\n2. 然后将有依赖关系的一系列语句进行组合，合并成一个异步函数\n3. 最后用正确的方式执行这些函数\n\n### 参考\n\n* [精读《async/await 是把双刃剑》](https://github.com/dt-fe/weekly/blob/master/55.%E7%B2%BE%E8%AF%BB%E3%80%8Aasync%20await%20%E6%98%AF%E6%8A%8A%E5%8F%8C%E5%88%83%E5%89%91%E3%80%8B.md)\n* [async 函数的含义和用法](http://www.ruanyifeng.com/blog/2015/05/async.html)\n* [体验异步的终极解决方案 - ES7 的 Async/Await](https://cnodejs.org/topic/5640b80d3a6aa72c5e0030b6)\n* [How to escape async/await hell](https://github.com/dwqs/blog/issues/65)\n","slug":"如何避免-async-await-地狱","published":1,"updated":"2018-06-17T09:49:30.000Z","layout":"post","photos":[],"link":"","_id":"cjiitidjb000mu4q9khczc8t9","content":"<p>最近阅读了 Aditya Agarwal 的一篇文章：How to escape async/await hell。这篇文章主要讨论了过度使用 async/await 导致的新的「地狱」问题，其已经在 Medium 上获得了 19k+ 的 Applause。</p>\n<a id=\"more\"></a>\n<div class=\"tip\"><br>  async/await 是 ES7 的新语法。在 async/await 标准出来之前，JavaScript 的异步编程经历了 callback –&gt; promise –&gt; generator 的演变过程。<br></div>\n\n<p>在 callback 的时代，最让人头疼的问题就是回调地狱 (callback hell)。所以，在 async/await 一经推出，社区就有人认为「这是 JavaScript 异步编程的终极解决方案」。但 async/await 也可能带来新的问题。</p>\n<blockquote>\n<p>好不容易逃离了一个「地狱」，又马上陷入另一个「地狱」了。</p>\n</blockquote>\n<h3 id=\"何为-async-await-地狱\"><a href=\"#何为-async-await-地狱\" class=\"headerlink\" title=\"何为 async/await 地狱\"></a>何为 async/await 地狱</h3><p>在编写异步代码时，人们总是喜欢一次写多个语句，并且在一个函数调用之前使用 await 关键字。这可能会导致性能问题，因为很多时候一个语句并不依赖于前一个语句——但使用 await 关键字后，你就需要等待前一个语句完成。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><p>假设你要写一个订购 pizza 和 drink 的脚本，代码可能是如下这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> pizzaData = <span class=\"keyword\">await</span> getPizzaData(); <span class=\"comment\">// async call</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> drinkData = <span class=\"keyword\">await</span> getDrinkData(); <span class=\"comment\">// async call</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> chosenPizza = choosePizza(); <span class=\"comment\">// sync call</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> chosenDrink = chooseDrink(); <span class=\"comment\">// sync call</span></span><br><span class=\"line\">  <span class=\"keyword\">await</span> addPizzaToCart(chosenPizza); <span class=\"comment\">// async call</span></span><br><span class=\"line\">  <span class=\"keyword\">await</span> addDrinkToCart(chosenDrink); <span class=\"comment\">// async call</span></span><br><span class=\"line\">  orderItems(); <span class=\"comment\">// async call</span></span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>这段代码开起来没什么问题，也能正常的运行。但是，这并不是一个好的实现，因为这把本身可以并行执行的任务变成了串行执行。</p>\n<p>选择一个 drink 添加到购物车和选择一个 pizza 添加到购物车可以看作是两个任务，而这两个任务之间并没有相互依赖的关系，也没有特定的顺序执行关系。所以这两个任务是可以并行执行的，这样能提高性能。而上述代码将二者变成了串行执行，显然是降低了程序性能的。</p>\n<h3 id=\"更糟糕的例子\"><a href=\"#更糟糕的例子\" class=\"headerlink\" title=\"更糟糕的例子\"></a>更糟糕的例子</h3><p>假设要写一个程序，根据 followers 数用来显示 GitHub 中国区用户的排名情况。</p>\n<p>如果只是获取排名，我们可以调用 Github 官方的 <a href=\"https://developer.github.com/v3/search/#search-users\" target=\"_blank\" rel=\"noopener\">Search users</a> 接口，伪代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getUserRank</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> fetch(search_url);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> data;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">getUserRank();</span><br></pre></td></tr></table></figure>\n<p>调用 getUserRank 函数就能获取到想要的结果。但是，你可能还要想要获取每个用户的 follower 数、email、地区和仓库等数据，而 Search users 接口并没有返回这些数据，你可能需要再去调用 <a href=\"https://developer.github.com/v3/users/#get-a-single-user\" target=\"_blank\" rel=\"noopener\">Single user</a> 接口。</p>\n<p>然后上述代码可能被改写为：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getUserRank</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> fetch(search_url);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = [];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; data.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> item = data[i];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> user = <span class=\"keyword\">await</span> fetch(user_url);</span><br><span class=\"line\">    res.push(&#123;...item, ...user&#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">getUserRank();</span><br></pre></td></tr></table></figure>\n<p>运行查看结果，自己想要的数据都拿到了。但是，你发现一个问题，程序运行时间有点长，该怎么优化下呢？</p>\n<p>其实，铺垫了这么长，就是想说明一个问题：你陷入了 async/await 的地狱。</p>\n<p>上述代码的问题在于，获取每个用户资料的请求并不存在依赖性，就类似上文中的选择 pizza 和 drink 一样，这是可以并行执行的请求。而根据上述代码，请求都变成了串行执行，这当然会损耗程序的性能。</p>\n<p>按照上述代码，可以看一下其异步请求的动态图：</p>\n<p><img src=\"https://user-images.githubusercontent.com/7871813/40270076-c08ec820-5bb9-11e8-8470-5e716e87dc76.gif\" alt=\"image\"></p>\n<p>可以看到，获取用户资料的每个请求都需要等到上一个请求完成之后才能执行，Waterfall 处于一个串行的状态。那要怎么改进这个问题呢？</p>\n<p>既然获取每个用户资料的请求并不存在依赖性，那么我们可以先触发异步请求，然后延迟处理异步请求的结果，而不是一直等该请求完成。根据这个思路，那可能改进的代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getUserDetails</span> (<span class=\"params\">username</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> user = <span class=\"keyword\">await</span> fetch(user_url);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> user;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getUserRank</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> fetch(search_url);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> promises = data.map(<span class=\"function\">(<span class=\"params\">item</span>) =&gt;</span> getUserDetails(item.username));</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.all(promises).then(handleYourData);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">getUserRank();</span><br></pre></td></tr></table></figure>\n<p>可以看一下异步请求的动态图：</p>\n<p><img src=\"https://user-images.githubusercontent.com/7871813/40270077-c2536602-5bb9-11e8-9438-a15ac05b41e0.gif\" alt=\"image\"></p>\n<p>可以看到，获取用户资料的异步请求处理不再是串行执行，而是并行执行了，这将大大提高程序的运行效率和性能。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>Aditya Agarwal 在其文章中也给出了怎么避免陷入 async/await 地狱的建议：</p>\n<ol>\n<li>首先找出依赖于其他语句的执行的语句</li>\n<li>然后将有依赖关系的一系列语句进行组合，合并成一个异步函数</li>\n<li>最后用正确的方式执行这些函数</li>\n</ol>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><a href=\"https://github.com/dt-fe/weekly/blob/master/55.%E7%B2%BE%E8%AF%BB%E3%80%8Aasync%20await%20%E6%98%AF%E6%8A%8A%E5%8F%8C%E5%88%83%E5%89%91%E3%80%8B.md\" target=\"_blank\" rel=\"noopener\">精读《async/await 是把双刃剑》</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/05/async.html\" target=\"_blank\" rel=\"noopener\">async 函数的含义和用法</a></li>\n<li><a href=\"https://cnodejs.org/topic/5640b80d3a6aa72c5e0030b6\" target=\"_blank\" rel=\"noopener\">体验异步的终极解决方案 - ES7 的 Async/Await</a></li>\n<li><a href=\"https://github.com/dwqs/blog/issues/65\" target=\"_blank\" rel=\"noopener\">How to escape async/await hell</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>最近阅读了 Aditya Agarwal 的一篇文章：How to escape async/await hell。这篇文章主要讨论了过度使用 async/await 导致的新的「地狱」问题，其已经在 Medium 上获得了 19k+ 的 Applause。</p>","more":"<div class=\"tip\"><br>  async/await 是 ES7 的新语法。在 async/await 标准出来之前，JavaScript 的异步编程经历了 callback –&gt; promise –&gt; generator 的演变过程。<br></div>\n\n<p>在 callback 的时代，最让人头疼的问题就是回调地狱 (callback hell)。所以，在 async/await 一经推出，社区就有人认为「这是 JavaScript 异步编程的终极解决方案」。但 async/await 也可能带来新的问题。</p>\n<blockquote>\n<p>好不容易逃离了一个「地狱」，又马上陷入另一个「地狱」了。</p>\n</blockquote>\n<h3 id=\"何为-async-await-地狱\"><a href=\"#何为-async-await-地狱\" class=\"headerlink\" title=\"何为 async/await 地狱\"></a>何为 async/await 地狱</h3><p>在编写异步代码时，人们总是喜欢一次写多个语句，并且在一个函数调用之前使用 await 关键字。这可能会导致性能问题，因为很多时候一个语句并不依赖于前一个语句——但使用 await 关键字后，你就需要等待前一个语句完成。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><p>假设你要写一个订购 pizza 和 drink 的脚本，代码可能是如下这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> pizzaData = <span class=\"keyword\">await</span> getPizzaData(); <span class=\"comment\">// async call</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> drinkData = <span class=\"keyword\">await</span> getDrinkData(); <span class=\"comment\">// async call</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> chosenPizza = choosePizza(); <span class=\"comment\">// sync call</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> chosenDrink = chooseDrink(); <span class=\"comment\">// sync call</span></span><br><span class=\"line\">  <span class=\"keyword\">await</span> addPizzaToCart(chosenPizza); <span class=\"comment\">// async call</span></span><br><span class=\"line\">  <span class=\"keyword\">await</span> addDrinkToCart(chosenDrink); <span class=\"comment\">// async call</span></span><br><span class=\"line\">  orderItems(); <span class=\"comment\">// async call</span></span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>这段代码开起来没什么问题，也能正常的运行。但是，这并不是一个好的实现，因为这把本身可以并行执行的任务变成了串行执行。</p>\n<p>选择一个 drink 添加到购物车和选择一个 pizza 添加到购物车可以看作是两个任务，而这两个任务之间并没有相互依赖的关系，也没有特定的顺序执行关系。所以这两个任务是可以并行执行的，这样能提高性能。而上述代码将二者变成了串行执行，显然是降低了程序性能的。</p>\n<h3 id=\"更糟糕的例子\"><a href=\"#更糟糕的例子\" class=\"headerlink\" title=\"更糟糕的例子\"></a>更糟糕的例子</h3><p>假设要写一个程序，根据 followers 数用来显示 GitHub 中国区用户的排名情况。</p>\n<p>如果只是获取排名，我们可以调用 Github 官方的 <a href=\"https://developer.github.com/v3/search/#search-users\" target=\"_blank\" rel=\"noopener\">Search users</a> 接口，伪代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getUserRank</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> fetch(search_url);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> data;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">getUserRank();</span><br></pre></td></tr></table></figure>\n<p>调用 getUserRank 函数就能获取到想要的结果。但是，你可能还要想要获取每个用户的 follower 数、email、地区和仓库等数据，而 Search users 接口并没有返回这些数据，你可能需要再去调用 <a href=\"https://developer.github.com/v3/users/#get-a-single-user\" target=\"_blank\" rel=\"noopener\">Single user</a> 接口。</p>\n<p>然后上述代码可能被改写为：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getUserRank</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> fetch(search_url);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = [];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; data.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> item = data[i];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> user = <span class=\"keyword\">await</span> fetch(user_url);</span><br><span class=\"line\">    res.push(&#123;...item, ...user&#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">getUserRank();</span><br></pre></td></tr></table></figure>\n<p>运行查看结果，自己想要的数据都拿到了。但是，你发现一个问题，程序运行时间有点长，该怎么优化下呢？</p>\n<p>其实，铺垫了这么长，就是想说明一个问题：你陷入了 async/await 的地狱。</p>\n<p>上述代码的问题在于，获取每个用户资料的请求并不存在依赖性，就类似上文中的选择 pizza 和 drink 一样，这是可以并行执行的请求。而根据上述代码，请求都变成了串行执行，这当然会损耗程序的性能。</p>\n<p>按照上述代码，可以看一下其异步请求的动态图：</p>\n<p><img src=\"https://user-images.githubusercontent.com/7871813/40270076-c08ec820-5bb9-11e8-8470-5e716e87dc76.gif\" alt=\"image\"></p>\n<p>可以看到，获取用户资料的每个请求都需要等到上一个请求完成之后才能执行，Waterfall 处于一个串行的状态。那要怎么改进这个问题呢？</p>\n<p>既然获取每个用户资料的请求并不存在依赖性，那么我们可以先触发异步请求，然后延迟处理异步请求的结果，而不是一直等该请求完成。根据这个思路，那可能改进的代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getUserDetails</span> (<span class=\"params\">username</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> user = <span class=\"keyword\">await</span> fetch(user_url);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> user;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getUserRank</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> fetch(search_url);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> promises = data.map(<span class=\"function\">(<span class=\"params\">item</span>) =&gt;</span> getUserDetails(item.username));</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.all(promises).then(handleYourData);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">getUserRank();</span><br></pre></td></tr></table></figure>\n<p>可以看一下异步请求的动态图：</p>\n<p><img src=\"https://user-images.githubusercontent.com/7871813/40270077-c2536602-5bb9-11e8-9438-a15ac05b41e0.gif\" alt=\"image\"></p>\n<p>可以看到，获取用户资料的异步请求处理不再是串行执行，而是并行执行了，这将大大提高程序的运行效率和性能。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>Aditya Agarwal 在其文章中也给出了怎么避免陷入 async/await 地狱的建议：</p>\n<ol>\n<li>首先找出依赖于其他语句的执行的语句</li>\n<li>然后将有依赖关系的一系列语句进行组合，合并成一个异步函数</li>\n<li>最后用正确的方式执行这些函数</li>\n</ol>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><a href=\"https://github.com/dt-fe/weekly/blob/master/55.%E7%B2%BE%E8%AF%BB%E3%80%8Aasync%20await%20%E6%98%AF%E6%8A%8A%E5%8F%8C%E5%88%83%E5%89%91%E3%80%8B.md\" target=\"_blank\" rel=\"noopener\">精读《async/await 是把双刃剑》</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/05/async.html\" target=\"_blank\" rel=\"noopener\">async 函数的含义和用法</a></li>\n<li><a href=\"https://cnodejs.org/topic/5640b80d3a6aa72c5e0030b6\" target=\"_blank\" rel=\"noopener\">体验异步的终极解决方案 - ES7 的 Async/Await</a></li>\n<li><a href=\"https://github.com/dwqs/blog/issues/65\" target=\"_blank\" rel=\"noopener\">How to escape async/await hell</a></li>\n</ul>"},{"title":"浏览器跨域请求数据总结","date":"2016-01-19T13:06:08.000Z","comments":0,"_content":"\n首先说下同源，同源策略是浏览器的一种安全策略，所谓同源是指：域名、协议、端口完全相同。而跨域就是不同源！一般 `a`, `img`, `link`, `video`, `audio`, 等等能够发出请求的标签都可以实现跨域访问。但是这些标签不能得到返回的东西，所以一般不会用他们来请求资源。\n<!-- more -->\n\n### 跨域方法\n#### 原生 JavaScript 跨域\n```html\n<script type=\"text/javascript\">\nfunction showuser(data) {\n    var data = JSON.parse(data);\n    console.log(data);// 处理得到的 data\n};\n</script>\n\n<script src=\"http://x.cn/showalluser.html?callback=showuser\" charset=\"utf-8\"></script>\n```\n#### jQuery 跨域\n```js\n$.ajax({\n    type: \"post\",\n    url: \"http://127.0.0.1:8080/showalluser.html\",\n    dataType: \"jsonp\",\n    jsonp: \"callback\",\n    success: function(data) {\n        console.log(data);// 处理得到的 data\n    }\n});\n```\n#### iframe 跨域\n```js\nfunction(URL, callBack) {\n    $iframe = $(\"<iframe style='display: none;'></iframe>\");\n    $iframe.prop(\"src\", URL);\n    $(\"body\").append($iframe);\n\n    $iframe.on('load', function() {\n        // 转换成 jsonStr\n        // contentDocument是 iframe 节点的方法获取contentDocument\n        var ifrDocument = this.contentDocument;\n\n        var jsonStr = $(ifrDocument).find(\"body\").text();\n\n        // 转换成 json 对象\n        var jsonObj = JSON.parse(jsonStr);\n\n        // 把 json 对象传给回调函数\n        callBack(jsonObj);\n        // 删除当前的 iframe\n        $(this).remove();\n    });\n}\n```\n#### 原生 JavaScript 跨域封装\n```html\n<script>\n// 封装数据  跨域url  params fn\nfunction crossDomain(url,params,fn){\n    var head = document.getElementsByTagName('head')[0];\n    // 1. 处理回调函数\n    var cbName = 'jsonp'+\n    (Math.random() * Math.random()).toString().substr(2) +\n    new Date().getTime();\n    // 将回调函数挂载到 window 对象上\n    window[cbName] = function(data){\n        // 拿到并处理数据，交给回调函数\n        fn(data);\n        // 拿到数据后remove掉\n        //head.removeChild(scriptObj);\n    }\n    // 2. 解析url，处理查询字符串 解决这样的需求 ?count=5\n    var qstring = '';\n    for(var key in params){\n        qstring += key + '=' + params[key] + '&';\n    }\n    qstring += 'callback=' + cbName;\n    url += '?' + qstring;\n    // 3. 插入script\n    var scriptObj = document.createElement('script');\n    scriptObj.src = url;\n    head.appendChild(scriptObj);\n}\n</script>\n\n<script>\n// 使用\ncrossDomain('http://api.douban.com/v2/movie/in_theaters',{},function(data){\n    console.log(data);\n})\n</script>\n```\n```html\n<!-- 解读：注意上面封装的函数会在 head 标签生成下面的内容，并随机产生函数名防止冲突 -->\n<script src=\"jsonp412964552676679031484646377133(data)”>// 挂载在 window 上可以直接执行\n      /*远程获取的 data 传入 jsonp* 函数内容，交给回调函数fn(data) */\n</script>\n```\n","source":"_posts/浏览器跨域请求数据总结.md","raw":"---\ntitle: 浏览器跨域请求数据总结\ndate: 2016-01-19 21:06:08\ntags:\ncomments: false\n---\n\n首先说下同源，同源策略是浏览器的一种安全策略，所谓同源是指：域名、协议、端口完全相同。而跨域就是不同源！一般 `a`, `img`, `link`, `video`, `audio`, 等等能够发出请求的标签都可以实现跨域访问。但是这些标签不能得到返回的东西，所以一般不会用他们来请求资源。\n<!-- more -->\n\n### 跨域方法\n#### 原生 JavaScript 跨域\n```html\n<script type=\"text/javascript\">\nfunction showuser(data) {\n    var data = JSON.parse(data);\n    console.log(data);// 处理得到的 data\n};\n</script>\n\n<script src=\"http://x.cn/showalluser.html?callback=showuser\" charset=\"utf-8\"></script>\n```\n#### jQuery 跨域\n```js\n$.ajax({\n    type: \"post\",\n    url: \"http://127.0.0.1:8080/showalluser.html\",\n    dataType: \"jsonp\",\n    jsonp: \"callback\",\n    success: function(data) {\n        console.log(data);// 处理得到的 data\n    }\n});\n```\n#### iframe 跨域\n```js\nfunction(URL, callBack) {\n    $iframe = $(\"<iframe style='display: none;'></iframe>\");\n    $iframe.prop(\"src\", URL);\n    $(\"body\").append($iframe);\n\n    $iframe.on('load', function() {\n        // 转换成 jsonStr\n        // contentDocument是 iframe 节点的方法获取contentDocument\n        var ifrDocument = this.contentDocument;\n\n        var jsonStr = $(ifrDocument).find(\"body\").text();\n\n        // 转换成 json 对象\n        var jsonObj = JSON.parse(jsonStr);\n\n        // 把 json 对象传给回调函数\n        callBack(jsonObj);\n        // 删除当前的 iframe\n        $(this).remove();\n    });\n}\n```\n#### 原生 JavaScript 跨域封装\n```html\n<script>\n// 封装数据  跨域url  params fn\nfunction crossDomain(url,params,fn){\n    var head = document.getElementsByTagName('head')[0];\n    // 1. 处理回调函数\n    var cbName = 'jsonp'+\n    (Math.random() * Math.random()).toString().substr(2) +\n    new Date().getTime();\n    // 将回调函数挂载到 window 对象上\n    window[cbName] = function(data){\n        // 拿到并处理数据，交给回调函数\n        fn(data);\n        // 拿到数据后remove掉\n        //head.removeChild(scriptObj);\n    }\n    // 2. 解析url，处理查询字符串 解决这样的需求 ?count=5\n    var qstring = '';\n    for(var key in params){\n        qstring += key + '=' + params[key] + '&';\n    }\n    qstring += 'callback=' + cbName;\n    url += '?' + qstring;\n    // 3. 插入script\n    var scriptObj = document.createElement('script');\n    scriptObj.src = url;\n    head.appendChild(scriptObj);\n}\n</script>\n\n<script>\n// 使用\ncrossDomain('http://api.douban.com/v2/movie/in_theaters',{},function(data){\n    console.log(data);\n})\n</script>\n```\n```html\n<!-- 解读：注意上面封装的函数会在 head 标签生成下面的内容，并随机产生函数名防止冲突 -->\n<script src=\"jsonp412964552676679031484646377133(data)”>// 挂载在 window 上可以直接执行\n      /*远程获取的 data 传入 jsonp* 函数内容，交给回调函数fn(data) */\n</script>\n```\n","slug":"浏览器跨域请求数据总结","published":1,"updated":"2018-06-17T09:49:30.000Z","layout":"post","photos":[],"link":"","_id":"cjiitidjc000nu4q9tltqnd7s","content":"<p>首先说下同源，同源策略是浏览器的一种安全策略，所谓同源是指：域名、协议、端口完全相同。而跨域就是不同源！一般 <code>a</code>, <code>img</code>, <code>link</code>, <code>video</code>, <code>audio</code>, 等等能够发出请求的标签都可以实现跨域访问。但是这些标签不能得到返回的东西，所以一般不会用他们来请求资源。<br><a id=\"more\"></a></p>\n<h3 id=\"跨域方法\"><a href=\"#跨域方法\" class=\"headerlink\" title=\"跨域方法\"></a>跨域方法</h3><h4 id=\"原生-JavaScript-跨域\"><a href=\"#原生-JavaScript-跨域\" class=\"headerlink\" title=\"原生 JavaScript 跨域\"></a>原生 JavaScript 跨域</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">showuser</span>(<span class=\"params\">data</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> data = <span class=\"built_in\">JSON</span>.parse(data);</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(data);<span class=\"comment\">// 处理得到的 data</span></span></span><br><span class=\"line\"><span class=\"undefined\">&#125;;</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"http://x.cn/showalluser.html?callback=showuser\"</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"utf-8\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"jQuery-跨域\"><a href=\"#jQuery-跨域\" class=\"headerlink\" title=\"jQuery 跨域\"></a>jQuery 跨域</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">    type: <span class=\"string\">\"post\"</span>,</span><br><span class=\"line\">    url: <span class=\"string\">\"http://127.0.0.1:8080/showalluser.html\"</span>,</span><br><span class=\"line\">    dataType: <span class=\"string\">\"jsonp\"</span>,</span><br><span class=\"line\">    jsonp: <span class=\"string\">\"callback\"</span>,</span><br><span class=\"line\">    success: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(data);<span class=\"comment\">// 处理得到的 data</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"iframe-跨域\"><a href=\"#iframe-跨域\" class=\"headerlink\" title=\"iframe 跨域\"></a>iframe 跨域</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">URL, callBack</span>) </span>&#123;</span><br><span class=\"line\">    $iframe = $(<span class=\"string\">\"&lt;iframe style='display: none;'&gt;&lt;/iframe&gt;\"</span>);</span><br><span class=\"line\">    $iframe.prop(<span class=\"string\">\"src\"</span>, URL);</span><br><span class=\"line\">    $(<span class=\"string\">\"body\"</span>).append($iframe);</span><br><span class=\"line\"></span><br><span class=\"line\">    $iframe.on(<span class=\"string\">'load'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 转换成 jsonStr</span></span><br><span class=\"line\">        <span class=\"comment\">// contentDocument是 iframe 节点的方法获取contentDocument</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> ifrDocument = <span class=\"keyword\">this</span>.contentDocument;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> jsonStr = $(ifrDocument).find(<span class=\"string\">\"body\"</span>).text();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 转换成 json 对象</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> jsonObj = <span class=\"built_in\">JSON</span>.parse(jsonStr);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 把 json 对象传给回调函数</span></span><br><span class=\"line\">        callBack(jsonObj);</span><br><span class=\"line\">        <span class=\"comment\">// 删除当前的 iframe</span></span><br><span class=\"line\">        $(<span class=\"keyword\">this</span>).remove();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"原生-JavaScript-跨域封装\"><a href=\"#原生-JavaScript-跨域封装\" class=\"headerlink\" title=\"原生 JavaScript 跨域封装\"></a>原生 JavaScript 跨域封装</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"comment\">// 封装数据  跨域url  params fn</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">crossDomain</span>(<span class=\"params\">url,params,fn</span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> head = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'head'</span>)[<span class=\"number\">0</span>];</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 1. 处理回调函数</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> cbName = <span class=\"string\">'jsonp'</span>+</span></span><br><span class=\"line\"><span class=\"javascript\">    (<span class=\"built_in\">Math</span>.random() * <span class=\"built_in\">Math</span>.random()).toString().substr(<span class=\"number\">2</span>) +</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime();</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 将回调函数挂载到 window 对象上</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">window</span>[cbName] = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// 拿到并处理数据，交给回调函数</span></span></span><br><span class=\"line\"><span class=\"undefined\">        fn(data);</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// 拿到数据后remove掉</span></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">//head.removeChild(scriptObj);</span></span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 2. 解析url，处理查询字符串 解决这样的需求 ?count=5</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> qstring = <span class=\"string\">''</span>;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> params)&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        qstring += key + <span class=\"string\">'='</span> + params[key] + <span class=\"string\">'&amp;'</span>;</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;</span></span><br><span class=\"line\"><span class=\"javascript\">    qstring += <span class=\"string\">'callback='</span> + cbName;</span></span><br><span class=\"line\"><span class=\"javascript\">    url += <span class=\"string\">'?'</span> + qstring;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 3. 插入script</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> scriptObj = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'script'</span>);</span></span><br><span class=\"line\"><span class=\"undefined\">    scriptObj.src = url;</span></span><br><span class=\"line\"><span class=\"undefined\">    head.appendChild(scriptObj);</span></span><br><span class=\"line\"><span class=\"undefined\">&#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"comment\">// 使用</span></span></span><br><span class=\"line\"><span class=\"javascript\">crossDomain(<span class=\"string\">'http://api.douban.com/v2/movie/in_theaters'</span>,&#123;&#125;,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(data);</span></span><br><span class=\"line\"><span class=\"undefined\">&#125;)</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 解读：注意上面封装的函数会在 head 标签生成下面的内容，并随机产生函数名防止冲突 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"jsonp412964552676679031484646377133(data)”&gt;// 挂载在 window 上可以直接执行</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">      /*远程获取的 data 传入 jsonp* 函数内容，交给回调函数fn(data) */</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">&lt;/script&gt;</span></span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>首先说下同源，同源策略是浏览器的一种安全策略，所谓同源是指：域名、协议、端口完全相同。而跨域就是不同源！一般 <code>a</code>, <code>img</code>, <code>link</code>, <code>video</code>, <code>audio</code>, 等等能够发出请求的标签都可以实现跨域访问。但是这些标签不能得到返回的东西，所以一般不会用他们来请求资源。<br>","more":"</p>\n<h3 id=\"跨域方法\"><a href=\"#跨域方法\" class=\"headerlink\" title=\"跨域方法\"></a>跨域方法</h3><h4 id=\"原生-JavaScript-跨域\"><a href=\"#原生-JavaScript-跨域\" class=\"headerlink\" title=\"原生 JavaScript 跨域\"></a>原生 JavaScript 跨域</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">showuser</span>(<span class=\"params\">data</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> data = <span class=\"built_in\">JSON</span>.parse(data);</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(data);<span class=\"comment\">// 处理得到的 data</span></span></span><br><span class=\"line\"><span class=\"undefined\">&#125;;</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"http://x.cn/showalluser.html?callback=showuser\"</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"utf-8\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"jQuery-跨域\"><a href=\"#jQuery-跨域\" class=\"headerlink\" title=\"jQuery 跨域\"></a>jQuery 跨域</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">    type: <span class=\"string\">\"post\"</span>,</span><br><span class=\"line\">    url: <span class=\"string\">\"http://127.0.0.1:8080/showalluser.html\"</span>,</span><br><span class=\"line\">    dataType: <span class=\"string\">\"jsonp\"</span>,</span><br><span class=\"line\">    jsonp: <span class=\"string\">\"callback\"</span>,</span><br><span class=\"line\">    success: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(data);<span class=\"comment\">// 处理得到的 data</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"iframe-跨域\"><a href=\"#iframe-跨域\" class=\"headerlink\" title=\"iframe 跨域\"></a>iframe 跨域</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">URL, callBack</span>) </span>&#123;</span><br><span class=\"line\">    $iframe = $(<span class=\"string\">\"&lt;iframe style='display: none;'&gt;&lt;/iframe&gt;\"</span>);</span><br><span class=\"line\">    $iframe.prop(<span class=\"string\">\"src\"</span>, URL);</span><br><span class=\"line\">    $(<span class=\"string\">\"body\"</span>).append($iframe);</span><br><span class=\"line\"></span><br><span class=\"line\">    $iframe.on(<span class=\"string\">'load'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 转换成 jsonStr</span></span><br><span class=\"line\">        <span class=\"comment\">// contentDocument是 iframe 节点的方法获取contentDocument</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> ifrDocument = <span class=\"keyword\">this</span>.contentDocument;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> jsonStr = $(ifrDocument).find(<span class=\"string\">\"body\"</span>).text();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 转换成 json 对象</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> jsonObj = <span class=\"built_in\">JSON</span>.parse(jsonStr);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 把 json 对象传给回调函数</span></span><br><span class=\"line\">        callBack(jsonObj);</span><br><span class=\"line\">        <span class=\"comment\">// 删除当前的 iframe</span></span><br><span class=\"line\">        $(<span class=\"keyword\">this</span>).remove();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"原生-JavaScript-跨域封装\"><a href=\"#原生-JavaScript-跨域封装\" class=\"headerlink\" title=\"原生 JavaScript 跨域封装\"></a>原生 JavaScript 跨域封装</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"comment\">// 封装数据  跨域url  params fn</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">crossDomain</span>(<span class=\"params\">url,params,fn</span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> head = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'head'</span>)[<span class=\"number\">0</span>];</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 1. 处理回调函数</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> cbName = <span class=\"string\">'jsonp'</span>+</span></span><br><span class=\"line\"><span class=\"javascript\">    (<span class=\"built_in\">Math</span>.random() * <span class=\"built_in\">Math</span>.random()).toString().substr(<span class=\"number\">2</span>) +</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime();</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 将回调函数挂载到 window 对象上</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">window</span>[cbName] = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// 拿到并处理数据，交给回调函数</span></span></span><br><span class=\"line\"><span class=\"undefined\">        fn(data);</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// 拿到数据后remove掉</span></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">//head.removeChild(scriptObj);</span></span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 2. 解析url，处理查询字符串 解决这样的需求 ?count=5</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> qstring = <span class=\"string\">''</span>;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> params)&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        qstring += key + <span class=\"string\">'='</span> + params[key] + <span class=\"string\">'&amp;'</span>;</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;</span></span><br><span class=\"line\"><span class=\"javascript\">    qstring += <span class=\"string\">'callback='</span> + cbName;</span></span><br><span class=\"line\"><span class=\"javascript\">    url += <span class=\"string\">'?'</span> + qstring;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 3. 插入script</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> scriptObj = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'script'</span>);</span></span><br><span class=\"line\"><span class=\"undefined\">    scriptObj.src = url;</span></span><br><span class=\"line\"><span class=\"undefined\">    head.appendChild(scriptObj);</span></span><br><span class=\"line\"><span class=\"undefined\">&#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"comment\">// 使用</span></span></span><br><span class=\"line\"><span class=\"javascript\">crossDomain(<span class=\"string\">'http://api.douban.com/v2/movie/in_theaters'</span>,&#123;&#125;,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(data);</span></span><br><span class=\"line\"><span class=\"undefined\">&#125;)</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 解读：注意上面封装的函数会在 head 标签生成下面的内容，并随机产生函数名防止冲突 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"jsonp412964552676679031484646377133(data)”&gt;// 挂载在 window 上可以直接执行</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">      /*远程获取的 data 传入 jsonp* 函数内容，交给回调函数fn(data) */</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">&lt;/script&gt;</span></span></span><br></pre></td></tr></table></figure>"},{"title":"给小白读的 WEB 托管服务进化史","comments":1,"date":"2018-06-09T10:29:12.000Z","from":null,"_content":"这篇文章是来拓展自己知识面的, 在我读高中那会 (08 年), 我身边就有沉迷电脑技术的同学, 那个时候我想着做一个自己的网站, 肯定是非常牛逼的事了. 从最开始接触的服务, 依次来排个序. 永硕 E 盘 -> 免费空间建站 (国外居多) -> 虚拟空间 -> 虚拟服务器 (VPS) -> 独立服务器. 看完这篇文章后, 我总算对这方面知识有了一个比较系统性的认识了. 一起来学习一下.\n\n<!-- more -->\n### 引子\n\n文章开始之前, 我觉得还是有必要把这些专有名词先科普一下, 不要觉得很高大上, 简称而已.\n\n* IaaS - 基础设施即服务\n* PaaS - 平台即服务\n* CaaS - 容器即服务\n\n本文介绍了 Web 托管服务进化的历史, 从专用服务器到虚拟化到 IaaS、PaaS 和最新的 CaaS; 说明了每种方式的优点和缺点. 着重阐述了构建 PaaS 应用的各个组件, 以及在选择 CaaS 提供商时应该考虑的问题. 最后从成本和功能性的角度论述了 PaaS 用户应该迁移到 CaaS 平台.\n\n读完这篇博文, 你应该可以清楚的理解:\n\n* 这些名词到底指什么\n* 这为什么对你很重要\n* 对于你的使用场景，哪种方式最适合\n\n当然没有一种方式能够适合所有的 Web 基础设施的场景, 你的特殊场景或许需要特殊的考虑.\n\n### 从头开始——专用服务器\n\nWeb 托管的本质还是在一个数据中心里布满了服务器、交换机、路由器、存储阵列和其它网络组件. 我们所讨论的每一个选项不管它是 PaaS、IaaS 还是 CaaS, 它底层使用的基础设施都是相同的, 即在一个大屋子里的很多独立服务器. 他们只是上面增加了很多抽象层使得管理变得更简单, 和使用自动化的方式处理以前很慢或者需要手动步骤的任务.\n\n专用服务器, 或者叫做 “裸机” 有它的优点和缺点.\n\n#### 优点\n\n* 性能——你在直接使用一个服务器, 没有任何抽象层例如虚拟化带来的性能开销.\n* 可靠性——没有抽象层和虚拟化, 出错的可能性会降低.\n* 资源利用率——使用专用服务器, 你的进程不需要跟其它的虚拟机或者进程竞争资源例如 CPU、内存和带宽.\n\n#### 缺点\n\n* 管理复杂性——你无法容易地克隆专用服务器来产生更多的实例, 专用服务器没有 AMI（译者注: Amazon Machine Image）或者镜像的概念. 想扩展你的基础设施到多个服务器上？我希望你用配置管理, 或者使用可信赖的老朋友 rsync.\n* 成本——使用专用服务器, 在大多数情况下你需要预先支付服务器的硬件价格, 然后再付租用场地的成本, 或者你从一个服务提供商那里租赁它们. 无论哪种方式, 你都没法在不使用时终止服务器的租赁来节省成本, 因此你需要更加谨慎的对待你的财务计划.\n* 你所有的进程和应用都运行在专用服务器上, 因此运行在相同的操作系统上. 为了可扩展性的目的, 你往往希望服务器只运行单一的进程, 例如 Web 服务或者数据库服务. 在一个服务器上运行所有的应用使得操作系统的调优变得更困难.\n\n### 使事情变得更容易——虚拟化\n\n尽管专用服务器有很多优点, 但是它的缺点在大多数情况下会远远超过其优点. 公司为了能够迅速进入市场赢得竞争, 对于部署的速度提出了更高的要求, 虚拟化就很自然的成为了数据中心进化中的下一个步骤.\n\n#### 什么是虚拟化\n\n简而言之, 虚拟化就是将物理服务器分成更小的虚拟机, 这些虚拟机只能访问物理机的部分资源. 例如你有一个 8CPU 核以及 16GB 内存的物理服务器, 则可以将它分成 8 个虚拟机, 每个虚拟机有 1 个 CPU 和 2GB 内存. 你或许已经听说过一些虚拟化技术如 Xen, KVM, VMware 和 Hyper-V, 其实很有更多.\n\n#### 优点\n\n* 你可以在需要更多虚拟机实例或者想要虚拟机共享时进行虚拟机的克隆.\n* 你可以备份虚拟机镜像作为安全保护或者灾备.\n\n#### 缺点\n\n* 使用虚拟化意味着额外的性能开销, 可能造成性能下降.\n* 虚拟机镜像在不同的服务提供商和虚拟化技术之间基本上是不可移植的.\n* 管理虚拟机依然是手工步骤, 需要管理的时间和专业知识.\n\n### 进化——虚拟化变成 (IaaS)\n\n你知道 [51% 的人认为 “云” 会被天气影响吗](http://www.businessinsider.com/people-think-stormy-weather-affects-cloud-computing-2012-8)？你知道当人们谈论 “云” 时他们实际上是在讨论基础设施即服务 (IaaS) 吗？\n\n#### 什么是基础设施即服务 (IaaS)\n\n* 通过 API 来管理硬件的虚拟化.\n* 通过编程接口访问计算、存储和网络资源和配置.\n* 当你需要是申请一个新的虚拟机, 当你完成后终止虚拟机, 你只需要为你使用的资源付费.\n* 将数据中心资源视为公共设施.\n\n亚马逊在 2006 年发布了其 Amazon Web Services（AWS）和 EC2 产品，成为了这个领域的先驱。\n\n#### 为什么这个进化如此重要\n\n在过去当你需要上线一个在线业务时, 你不得不进行复杂的计划来保证你在数据中心内有足够的机架空间、足够的服务器和存储来处理业务的增长, 足够的网络带宽来处理所有的用户流量. 这种计划并不容易, 尤其是对早期的业务来讲, 你无法预测业务的未来和增长轨迹.\n\n1. 它给了开发者超能量:\n    * 构思一个想法立即上线.\n    * 如果成功了, 可以容易的扩展规模.\n    * 如果失败了, 关闭虚拟机以节约成本.\n2. 它使得数据中心自动化变得更强大:\n    * 全自动基础设施管理成为可能, 出现了 “基础设施即代码” 的概念.\n    * 弹性伸缩在过去是不可能实现的, 但是现在 web 基础设施可以当业务变化时自动的扩展或者收缩.\n    * 在服务器的自动化管理之后, 数据中心的自动化也扩展到了存储、网络以及其它大量的需要专业知识的系统, 在代码和 API 能够处理这些自动化之后, 这给全球的开发者社区带来了新的机遇.\n\n### 进一步演化——平台即服务 (PaaS)\n\n平台即服务 (PaaS) 使得开发人员可以很容易的部署和管理应用而隐藏掉所有的实现细节例如服务器、负载均衡器、DNS 等等. 他们或多或少的去除了对运维团队的需求, 而是让开发人员去关注应用部署. 有很多 PaaS 提供商, 其中一个最流行的是 Heroku. 关于 Heroku 的一个有趣的事情是 Heroku 完全是运行在 AWS 之上并依赖 AWS 的. 如果你不愿意你的应用运行在美国东部或者欧洲西部的 AWS 上的话, 这或许是一个问题. 没有 IaaS, 像 Heroku 这样的平台可能就不会存在了. PaaS 提供商利用 IaaS 作为一个非常重要的组成部分来交付它们的服务. 在减少从想法到部署的时间、自动化流程以及减少特殊的系统知识需求的趋势中, PaaS 是合理的下一步, 就像是从专用服务器到 IaaS 一样.\n\n#### 构建 PaaS 是困难的\n\n能够通过抽象而避免处理服务器相关的问题是不容易的, 需要引入很多东西才能做到.\n\n在 PaaS 的概念之下有几个主要的模块：\n\n* 编译系统——把你的代码编译成可以运行的应用, 并且把它存储到某个地方作为后续使用.\n* 应用管理数据库——管理 Git 版本、build 版本和应用元数据.\n* 集群调度器——将一组服务器作为一台大的服务器来管理, 在服务器资源池的某个服务器上运行你的程序, 并检查和替换失效的作业.\n* 负载均衡——允许从 Internet 和内部程序来的业务负载被正确的路由到合适的位置.\n* DNS——在你产生和修改应用时自动配置 DNS 条目.\n* 或许是最重要的——某个形式的容器化例如  freebsd jails、solaris zones、或者 linux containers, 容器化使得某个的应用不会进入和影响到其它的应用.\n\n第一个和最后一个点是 Docker 迅速发展的非常重要的原因. Linux 容器技术已经存在了一段时间了, 但是只有某些大的公司或者 PaaS 提供商自动化了容器的使用, Docker 使 Linux 容器的使用变得非常简单, 也提供了标准化的镜像格式, 它成为了 PaaS 中重要的组成部分.\n\n这非常强大, 因为很多公司在处理爆发式的用户增长, 来自于移动、社交和 IoT 的新的业务模式, 以及期望从传统的长的版本发布周期转变到持续交付. 他们利用基于软件的架构或者微服务. 他们需要能够自动部署和测试新的代码, 并根据业务的变化弹性伸缩. 但问题是他们没有足够的资源和经验来交付到他们的开发团队, 所以他们不得不将其外包给 PaaS 提供商. 不幸的是, 当你这么做的时候, 你就放弃了对于这个黑盒子的很多控制, 而是花很多钱并使得自己完全依赖于它. 另外一个选项是, 很多公司反复的重新发明轮子或者使用那些难于维护的、运行缓慢的和易于出错的工具.\n\n最好的情形是在自己的数据中心或者 Cloud 帐号中运行一个 PaaS 平台, 你可以全权控制, 你的团队可以直接参与应用的部署, 因此可以形成一种真正的 DevOps 文化. Docker 及其标准化的生态系统是这种愿景成为现实的重要一步.\n\n### 最后——容器托管平台 (CaaS)\n\n什么是容器托管平台, 或者叫容器即服务呢？这就是我在上面的章节中提到的另外一种构建在 Docker 基础上的 Web 托管方式. 它是你用容器来部署复杂的多层次的应用所需要的自动化的编译系统, 集群调度器, 负载均衡, DNS 自动化以及服务发现. 这是 PaaS 的另外一部分内容, 但是你不是用一个复杂的编译系统来编译你的应用, 而是用 Docker 镜像. 镜像可以非常容易的进行编译和本地测试, 因此你在部署应用之前就确认应用可以正常工作. 现在 PaaS 用户也可以得到相同的体验, 但是不需要拥有自己的硬件或者云帐号的前提下节约大量的成本. 他们不再受限于其服务提供商所支持的环境, 可以通过将应用打包成 Docker 镜像的方式在任何地方运行.\n\n在这个过程中, 利用诸如 ContainerShip Cloud, 你可以在任何地方, 在任何云平台上甚至是裸机上用相同的方式运行你的应用. 你不再被卡在构建复杂的应用来解决非常困难的问题, 或者卡在使用某个提供商的特殊的自动化部署工具上.\n\n* 但是选择一个正确的 Docker 容器托管平台并不是一件容易的事情, 有很多的问题需要你去思考和注意.\n* 有大量的选项, 因此选择其中一个进行研究就变得困难. 好消息是如果你的应用已经容器化, 你就可以轻松的测试其中的每一个.\n* 你正在使用的服务提供商例如 Triton 或者 ECS 的某个解决方案或许使得你无法脱离这个提供商, 这也使得 Docker 的最令人兴奋的可移植性变得不那么重要了.\n* 许多 CaaS 方案在他们自己的硬件上运行所有的管理系统, 你自己的服务器上只是运行某个代理程序来连接他们的 API, 因此如果他们的系统宕机后你的集群将无法工作.\n* 允许你在防火墙后运行整个系统的方案是非常复杂的, 需要一个团队去管理和升级.\n* 能够容易的在防火墙后运行整个系统的方案会使得高可用成为低优先级的事情.\n* 当你选择了一个 CaaS 提供商时, 你就可以摆脱了你的服务托管提供商的锁定, 但是你将陷入到 CaaS 提供商的锁定. 你无法不使用他们的 SaaS 管理接口而在你自己的硬件上运行整个系统包括管理系统, API 和 UI. 你一旦决定付钱, 你最好可以一直付钱.\n\n### 总结\n\n终于看完了, 真的是又臭又长啊. 回顾一下这篇文章, 总体来说是经历了这样一个过程:\n\n1. 专有服务器\n2. 虚拟化技术\n3. 基础设施即服务 (IaaS)\n4. 平台即服务 (PaaS)\n5. 容器即服务 (CaaS)\n\n总结一下, 我觉得开发人员还是有必要了解一下关于产品部署相关的技术发展. 然后根据自己的业务来选择合适的服务提供商.\n","source":"_posts/给小白读的-WEB-托管服务进化史.md","raw":"---\ntitle: 给小白读的 WEB 托管服务进化史\ncomments: true\ndate: 2018-06-09 18:29:12\ntags:\nfrom:\n---\n这篇文章是来拓展自己知识面的, 在我读高中那会 (08 年), 我身边就有沉迷电脑技术的同学, 那个时候我想着做一个自己的网站, 肯定是非常牛逼的事了. 从最开始接触的服务, 依次来排个序. 永硕 E 盘 -> 免费空间建站 (国外居多) -> 虚拟空间 -> 虚拟服务器 (VPS) -> 独立服务器. 看完这篇文章后, 我总算对这方面知识有了一个比较系统性的认识了. 一起来学习一下.\n\n<!-- more -->\n### 引子\n\n文章开始之前, 我觉得还是有必要把这些专有名词先科普一下, 不要觉得很高大上, 简称而已.\n\n* IaaS - 基础设施即服务\n* PaaS - 平台即服务\n* CaaS - 容器即服务\n\n本文介绍了 Web 托管服务进化的历史, 从专用服务器到虚拟化到 IaaS、PaaS 和最新的 CaaS; 说明了每种方式的优点和缺点. 着重阐述了构建 PaaS 应用的各个组件, 以及在选择 CaaS 提供商时应该考虑的问题. 最后从成本和功能性的角度论述了 PaaS 用户应该迁移到 CaaS 平台.\n\n读完这篇博文, 你应该可以清楚的理解:\n\n* 这些名词到底指什么\n* 这为什么对你很重要\n* 对于你的使用场景，哪种方式最适合\n\n当然没有一种方式能够适合所有的 Web 基础设施的场景, 你的特殊场景或许需要特殊的考虑.\n\n### 从头开始——专用服务器\n\nWeb 托管的本质还是在一个数据中心里布满了服务器、交换机、路由器、存储阵列和其它网络组件. 我们所讨论的每一个选项不管它是 PaaS、IaaS 还是 CaaS, 它底层使用的基础设施都是相同的, 即在一个大屋子里的很多独立服务器. 他们只是上面增加了很多抽象层使得管理变得更简单, 和使用自动化的方式处理以前很慢或者需要手动步骤的任务.\n\n专用服务器, 或者叫做 “裸机” 有它的优点和缺点.\n\n#### 优点\n\n* 性能——你在直接使用一个服务器, 没有任何抽象层例如虚拟化带来的性能开销.\n* 可靠性——没有抽象层和虚拟化, 出错的可能性会降低.\n* 资源利用率——使用专用服务器, 你的进程不需要跟其它的虚拟机或者进程竞争资源例如 CPU、内存和带宽.\n\n#### 缺点\n\n* 管理复杂性——你无法容易地克隆专用服务器来产生更多的实例, 专用服务器没有 AMI（译者注: Amazon Machine Image）或者镜像的概念. 想扩展你的基础设施到多个服务器上？我希望你用配置管理, 或者使用可信赖的老朋友 rsync.\n* 成本——使用专用服务器, 在大多数情况下你需要预先支付服务器的硬件价格, 然后再付租用场地的成本, 或者你从一个服务提供商那里租赁它们. 无论哪种方式, 你都没法在不使用时终止服务器的租赁来节省成本, 因此你需要更加谨慎的对待你的财务计划.\n* 你所有的进程和应用都运行在专用服务器上, 因此运行在相同的操作系统上. 为了可扩展性的目的, 你往往希望服务器只运行单一的进程, 例如 Web 服务或者数据库服务. 在一个服务器上运行所有的应用使得操作系统的调优变得更困难.\n\n### 使事情变得更容易——虚拟化\n\n尽管专用服务器有很多优点, 但是它的缺点在大多数情况下会远远超过其优点. 公司为了能够迅速进入市场赢得竞争, 对于部署的速度提出了更高的要求, 虚拟化就很自然的成为了数据中心进化中的下一个步骤.\n\n#### 什么是虚拟化\n\n简而言之, 虚拟化就是将物理服务器分成更小的虚拟机, 这些虚拟机只能访问物理机的部分资源. 例如你有一个 8CPU 核以及 16GB 内存的物理服务器, 则可以将它分成 8 个虚拟机, 每个虚拟机有 1 个 CPU 和 2GB 内存. 你或许已经听说过一些虚拟化技术如 Xen, KVM, VMware 和 Hyper-V, 其实很有更多.\n\n#### 优点\n\n* 你可以在需要更多虚拟机实例或者想要虚拟机共享时进行虚拟机的克隆.\n* 你可以备份虚拟机镜像作为安全保护或者灾备.\n\n#### 缺点\n\n* 使用虚拟化意味着额外的性能开销, 可能造成性能下降.\n* 虚拟机镜像在不同的服务提供商和虚拟化技术之间基本上是不可移植的.\n* 管理虚拟机依然是手工步骤, 需要管理的时间和专业知识.\n\n### 进化——虚拟化变成 (IaaS)\n\n你知道 [51% 的人认为 “云” 会被天气影响吗](http://www.businessinsider.com/people-think-stormy-weather-affects-cloud-computing-2012-8)？你知道当人们谈论 “云” 时他们实际上是在讨论基础设施即服务 (IaaS) 吗？\n\n#### 什么是基础设施即服务 (IaaS)\n\n* 通过 API 来管理硬件的虚拟化.\n* 通过编程接口访问计算、存储和网络资源和配置.\n* 当你需要是申请一个新的虚拟机, 当你完成后终止虚拟机, 你只需要为你使用的资源付费.\n* 将数据中心资源视为公共设施.\n\n亚马逊在 2006 年发布了其 Amazon Web Services（AWS）和 EC2 产品，成为了这个领域的先驱。\n\n#### 为什么这个进化如此重要\n\n在过去当你需要上线一个在线业务时, 你不得不进行复杂的计划来保证你在数据中心内有足够的机架空间、足够的服务器和存储来处理业务的增长, 足够的网络带宽来处理所有的用户流量. 这种计划并不容易, 尤其是对早期的业务来讲, 你无法预测业务的未来和增长轨迹.\n\n1. 它给了开发者超能量:\n    * 构思一个想法立即上线.\n    * 如果成功了, 可以容易的扩展规模.\n    * 如果失败了, 关闭虚拟机以节约成本.\n2. 它使得数据中心自动化变得更强大:\n    * 全自动基础设施管理成为可能, 出现了 “基础设施即代码” 的概念.\n    * 弹性伸缩在过去是不可能实现的, 但是现在 web 基础设施可以当业务变化时自动的扩展或者收缩.\n    * 在服务器的自动化管理之后, 数据中心的自动化也扩展到了存储、网络以及其它大量的需要专业知识的系统, 在代码和 API 能够处理这些自动化之后, 这给全球的开发者社区带来了新的机遇.\n\n### 进一步演化——平台即服务 (PaaS)\n\n平台即服务 (PaaS) 使得开发人员可以很容易的部署和管理应用而隐藏掉所有的实现细节例如服务器、负载均衡器、DNS 等等. 他们或多或少的去除了对运维团队的需求, 而是让开发人员去关注应用部署. 有很多 PaaS 提供商, 其中一个最流行的是 Heroku. 关于 Heroku 的一个有趣的事情是 Heroku 完全是运行在 AWS 之上并依赖 AWS 的. 如果你不愿意你的应用运行在美国东部或者欧洲西部的 AWS 上的话, 这或许是一个问题. 没有 IaaS, 像 Heroku 这样的平台可能就不会存在了. PaaS 提供商利用 IaaS 作为一个非常重要的组成部分来交付它们的服务. 在减少从想法到部署的时间、自动化流程以及减少特殊的系统知识需求的趋势中, PaaS 是合理的下一步, 就像是从专用服务器到 IaaS 一样.\n\n#### 构建 PaaS 是困难的\n\n能够通过抽象而避免处理服务器相关的问题是不容易的, 需要引入很多东西才能做到.\n\n在 PaaS 的概念之下有几个主要的模块：\n\n* 编译系统——把你的代码编译成可以运行的应用, 并且把它存储到某个地方作为后续使用.\n* 应用管理数据库——管理 Git 版本、build 版本和应用元数据.\n* 集群调度器——将一组服务器作为一台大的服务器来管理, 在服务器资源池的某个服务器上运行你的程序, 并检查和替换失效的作业.\n* 负载均衡——允许从 Internet 和内部程序来的业务负载被正确的路由到合适的位置.\n* DNS——在你产生和修改应用时自动配置 DNS 条目.\n* 或许是最重要的——某个形式的容器化例如  freebsd jails、solaris zones、或者 linux containers, 容器化使得某个的应用不会进入和影响到其它的应用.\n\n第一个和最后一个点是 Docker 迅速发展的非常重要的原因. Linux 容器技术已经存在了一段时间了, 但是只有某些大的公司或者 PaaS 提供商自动化了容器的使用, Docker 使 Linux 容器的使用变得非常简单, 也提供了标准化的镜像格式, 它成为了 PaaS 中重要的组成部分.\n\n这非常强大, 因为很多公司在处理爆发式的用户增长, 来自于移动、社交和 IoT 的新的业务模式, 以及期望从传统的长的版本发布周期转变到持续交付. 他们利用基于软件的架构或者微服务. 他们需要能够自动部署和测试新的代码, 并根据业务的变化弹性伸缩. 但问题是他们没有足够的资源和经验来交付到他们的开发团队, 所以他们不得不将其外包给 PaaS 提供商. 不幸的是, 当你这么做的时候, 你就放弃了对于这个黑盒子的很多控制, 而是花很多钱并使得自己完全依赖于它. 另外一个选项是, 很多公司反复的重新发明轮子或者使用那些难于维护的、运行缓慢的和易于出错的工具.\n\n最好的情形是在自己的数据中心或者 Cloud 帐号中运行一个 PaaS 平台, 你可以全权控制, 你的团队可以直接参与应用的部署, 因此可以形成一种真正的 DevOps 文化. Docker 及其标准化的生态系统是这种愿景成为现实的重要一步.\n\n### 最后——容器托管平台 (CaaS)\n\n什么是容器托管平台, 或者叫容器即服务呢？这就是我在上面的章节中提到的另外一种构建在 Docker 基础上的 Web 托管方式. 它是你用容器来部署复杂的多层次的应用所需要的自动化的编译系统, 集群调度器, 负载均衡, DNS 自动化以及服务发现. 这是 PaaS 的另外一部分内容, 但是你不是用一个复杂的编译系统来编译你的应用, 而是用 Docker 镜像. 镜像可以非常容易的进行编译和本地测试, 因此你在部署应用之前就确认应用可以正常工作. 现在 PaaS 用户也可以得到相同的体验, 但是不需要拥有自己的硬件或者云帐号的前提下节约大量的成本. 他们不再受限于其服务提供商所支持的环境, 可以通过将应用打包成 Docker 镜像的方式在任何地方运行.\n\n在这个过程中, 利用诸如 ContainerShip Cloud, 你可以在任何地方, 在任何云平台上甚至是裸机上用相同的方式运行你的应用. 你不再被卡在构建复杂的应用来解决非常困难的问题, 或者卡在使用某个提供商的特殊的自动化部署工具上.\n\n* 但是选择一个正确的 Docker 容器托管平台并不是一件容易的事情, 有很多的问题需要你去思考和注意.\n* 有大量的选项, 因此选择其中一个进行研究就变得困难. 好消息是如果你的应用已经容器化, 你就可以轻松的测试其中的每一个.\n* 你正在使用的服务提供商例如 Triton 或者 ECS 的某个解决方案或许使得你无法脱离这个提供商, 这也使得 Docker 的最令人兴奋的可移植性变得不那么重要了.\n* 许多 CaaS 方案在他们自己的硬件上运行所有的管理系统, 你自己的服务器上只是运行某个代理程序来连接他们的 API, 因此如果他们的系统宕机后你的集群将无法工作.\n* 允许你在防火墙后运行整个系统的方案是非常复杂的, 需要一个团队去管理和升级.\n* 能够容易的在防火墙后运行整个系统的方案会使得高可用成为低优先级的事情.\n* 当你选择了一个 CaaS 提供商时, 你就可以摆脱了你的服务托管提供商的锁定, 但是你将陷入到 CaaS 提供商的锁定. 你无法不使用他们的 SaaS 管理接口而在你自己的硬件上运行整个系统包括管理系统, API 和 UI. 你一旦决定付钱, 你最好可以一直付钱.\n\n### 总结\n\n终于看完了, 真的是又臭又长啊. 回顾一下这篇文章, 总体来说是经历了这样一个过程:\n\n1. 专有服务器\n2. 虚拟化技术\n3. 基础设施即服务 (IaaS)\n4. 平台即服务 (PaaS)\n5. 容器即服务 (CaaS)\n\n总结一下, 我觉得开发人员还是有必要了解一下关于产品部署相关的技术发展. 然后根据自己的业务来选择合适的服务提供商.\n","slug":"给小白读的-WEB-托管服务进化史","published":1,"updated":"2018-06-17T09:49:30.000Z","layout":"post","photos":[],"link":"","_id":"cjiitidjd000ou4q9ymolvx3x","content":"<p>这篇文章是来拓展自己知识面的, 在我读高中那会 (08 年), 我身边就有沉迷电脑技术的同学, 那个时候我想着做一个自己的网站, 肯定是非常牛逼的事了. 从最开始接触的服务, 依次来排个序. 永硕 E 盘 -&gt; 免费空间建站 (国外居多) -&gt; 虚拟空间 -&gt; 虚拟服务器 (VPS) -&gt; 独立服务器. 看完这篇文章后, 我总算对这方面知识有了一个比较系统性的认识了. 一起来学习一下.</p>\n<a id=\"more\"></a>\n<h3 id=\"引子\"><a href=\"#引子\" class=\"headerlink\" title=\"引子\"></a>引子</h3><p>文章开始之前, 我觉得还是有必要把这些专有名词先科普一下, 不要觉得很高大上, 简称而已.</p>\n<ul>\n<li>IaaS - 基础设施即服务</li>\n<li>PaaS - 平台即服务</li>\n<li>CaaS - 容器即服务</li>\n</ul>\n<p>本文介绍了 Web 托管服务进化的历史, 从专用服务器到虚拟化到 IaaS、PaaS 和最新的 CaaS; 说明了每种方式的优点和缺点. 着重阐述了构建 PaaS 应用的各个组件, 以及在选择 CaaS 提供商时应该考虑的问题. 最后从成本和功能性的角度论述了 PaaS 用户应该迁移到 CaaS 平台.</p>\n<p>读完这篇博文, 你应该可以清楚的理解:</p>\n<ul>\n<li>这些名词到底指什么</li>\n<li>这为什么对你很重要</li>\n<li>对于你的使用场景，哪种方式最适合</li>\n</ul>\n<p>当然没有一种方式能够适合所有的 Web 基础设施的场景, 你的特殊场景或许需要特殊的考虑.</p>\n<h3 id=\"从头开始——专用服务器\"><a href=\"#从头开始——专用服务器\" class=\"headerlink\" title=\"从头开始——专用服务器\"></a>从头开始——专用服务器</h3><p>Web 托管的本质还是在一个数据中心里布满了服务器、交换机、路由器、存储阵列和其它网络组件. 我们所讨论的每一个选项不管它是 PaaS、IaaS 还是 CaaS, 它底层使用的基础设施都是相同的, 即在一个大屋子里的很多独立服务器. 他们只是上面增加了很多抽象层使得管理变得更简单, 和使用自动化的方式处理以前很慢或者需要手动步骤的任务.</p>\n<p>专用服务器, 或者叫做 “裸机” 有它的优点和缺点.</p>\n<h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><ul>\n<li>性能——你在直接使用一个服务器, 没有任何抽象层例如虚拟化带来的性能开销.</li>\n<li>可靠性——没有抽象层和虚拟化, 出错的可能性会降低.</li>\n<li>资源利用率——使用专用服务器, 你的进程不需要跟其它的虚拟机或者进程竞争资源例如 CPU、内存和带宽.</li>\n</ul>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><ul>\n<li>管理复杂性——你无法容易地克隆专用服务器来产生更多的实例, 专用服务器没有 AMI（译者注: Amazon Machine Image）或者镜像的概念. 想扩展你的基础设施到多个服务器上？我希望你用配置管理, 或者使用可信赖的老朋友 rsync.</li>\n<li>成本——使用专用服务器, 在大多数情况下你需要预先支付服务器的硬件价格, 然后再付租用场地的成本, 或者你从一个服务提供商那里租赁它们. 无论哪种方式, 你都没法在不使用时终止服务器的租赁来节省成本, 因此你需要更加谨慎的对待你的财务计划.</li>\n<li>你所有的进程和应用都运行在专用服务器上, 因此运行在相同的操作系统上. 为了可扩展性的目的, 你往往希望服务器只运行单一的进程, 例如 Web 服务或者数据库服务. 在一个服务器上运行所有的应用使得操作系统的调优变得更困难.</li>\n</ul>\n<h3 id=\"使事情变得更容易——虚拟化\"><a href=\"#使事情变得更容易——虚拟化\" class=\"headerlink\" title=\"使事情变得更容易——虚拟化\"></a>使事情变得更容易——虚拟化</h3><p>尽管专用服务器有很多优点, 但是它的缺点在大多数情况下会远远超过其优点. 公司为了能够迅速进入市场赢得竞争, 对于部署的速度提出了更高的要求, 虚拟化就很自然的成为了数据中心进化中的下一个步骤.</p>\n<h4 id=\"什么是虚拟化\"><a href=\"#什么是虚拟化\" class=\"headerlink\" title=\"什么是虚拟化\"></a>什么是虚拟化</h4><p>简而言之, 虚拟化就是将物理服务器分成更小的虚拟机, 这些虚拟机只能访问物理机的部分资源. 例如你有一个 8CPU 核以及 16GB 内存的物理服务器, 则可以将它分成 8 个虚拟机, 每个虚拟机有 1 个 CPU 和 2GB 内存. 你或许已经听说过一些虚拟化技术如 Xen, KVM, VMware 和 Hyper-V, 其实很有更多.</p>\n<h4 id=\"优点-1\"><a href=\"#优点-1\" class=\"headerlink\" title=\"优点\"></a>优点</h4><ul>\n<li>你可以在需要更多虚拟机实例或者想要虚拟机共享时进行虚拟机的克隆.</li>\n<li>你可以备份虚拟机镜像作为安全保护或者灾备.</li>\n</ul>\n<h4 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><ul>\n<li>使用虚拟化意味着额外的性能开销, 可能造成性能下降.</li>\n<li>虚拟机镜像在不同的服务提供商和虚拟化技术之间基本上是不可移植的.</li>\n<li>管理虚拟机依然是手工步骤, 需要管理的时间和专业知识.</li>\n</ul>\n<h3 id=\"进化——虚拟化变成-IaaS\"><a href=\"#进化——虚拟化变成-IaaS\" class=\"headerlink\" title=\"进化——虚拟化变成 (IaaS)\"></a>进化——虚拟化变成 (IaaS)</h3><p>你知道 <a href=\"http://www.businessinsider.com/people-think-stormy-weather-affects-cloud-computing-2012-8\" target=\"_blank\" rel=\"noopener\">51% 的人认为 “云” 会被天气影响吗</a>？你知道当人们谈论 “云” 时他们实际上是在讨论基础设施即服务 (IaaS) 吗？</p>\n<h4 id=\"什么是基础设施即服务-IaaS\"><a href=\"#什么是基础设施即服务-IaaS\" class=\"headerlink\" title=\"什么是基础设施即服务 (IaaS)\"></a>什么是基础设施即服务 (IaaS)</h4><ul>\n<li>通过 API 来管理硬件的虚拟化.</li>\n<li>通过编程接口访问计算、存储和网络资源和配置.</li>\n<li>当你需要是申请一个新的虚拟机, 当你完成后终止虚拟机, 你只需要为你使用的资源付费.</li>\n<li>将数据中心资源视为公共设施.</li>\n</ul>\n<p>亚马逊在 2006 年发布了其 Amazon Web Services（AWS）和 EC2 产品，成为了这个领域的先驱。</p>\n<h4 id=\"为什么这个进化如此重要\"><a href=\"#为什么这个进化如此重要\" class=\"headerlink\" title=\"为什么这个进化如此重要\"></a>为什么这个进化如此重要</h4><p>在过去当你需要上线一个在线业务时, 你不得不进行复杂的计划来保证你在数据中心内有足够的机架空间、足够的服务器和存储来处理业务的增长, 足够的网络带宽来处理所有的用户流量. 这种计划并不容易, 尤其是对早期的业务来讲, 你无法预测业务的未来和增长轨迹.</p>\n<ol>\n<li>它给了开发者超能量:<ul>\n<li>构思一个想法立即上线.</li>\n<li>如果成功了, 可以容易的扩展规模.</li>\n<li>如果失败了, 关闭虚拟机以节约成本.</li>\n</ul>\n</li>\n<li>它使得数据中心自动化变得更强大:<ul>\n<li>全自动基础设施管理成为可能, 出现了 “基础设施即代码” 的概念.</li>\n<li>弹性伸缩在过去是不可能实现的, 但是现在 web 基础设施可以当业务变化时自动的扩展或者收缩.</li>\n<li>在服务器的自动化管理之后, 数据中心的自动化也扩展到了存储、网络以及其它大量的需要专业知识的系统, 在代码和 API 能够处理这些自动化之后, 这给全球的开发者社区带来了新的机遇.</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"进一步演化——平台即服务-PaaS\"><a href=\"#进一步演化——平台即服务-PaaS\" class=\"headerlink\" title=\"进一步演化——平台即服务 (PaaS)\"></a>进一步演化——平台即服务 (PaaS)</h3><p>平台即服务 (PaaS) 使得开发人员可以很容易的部署和管理应用而隐藏掉所有的实现细节例如服务器、负载均衡器、DNS 等等. 他们或多或少的去除了对运维团队的需求, 而是让开发人员去关注应用部署. 有很多 PaaS 提供商, 其中一个最流行的是 Heroku. 关于 Heroku 的一个有趣的事情是 Heroku 完全是运行在 AWS 之上并依赖 AWS 的. 如果你不愿意你的应用运行在美国东部或者欧洲西部的 AWS 上的话, 这或许是一个问题. 没有 IaaS, 像 Heroku 这样的平台可能就不会存在了. PaaS 提供商利用 IaaS 作为一个非常重要的组成部分来交付它们的服务. 在减少从想法到部署的时间、自动化流程以及减少特殊的系统知识需求的趋势中, PaaS 是合理的下一步, 就像是从专用服务器到 IaaS 一样.</p>\n<h4 id=\"构建-PaaS-是困难的\"><a href=\"#构建-PaaS-是困难的\" class=\"headerlink\" title=\"构建 PaaS 是困难的\"></a>构建 PaaS 是困难的</h4><p>能够通过抽象而避免处理服务器相关的问题是不容易的, 需要引入很多东西才能做到.</p>\n<p>在 PaaS 的概念之下有几个主要的模块：</p>\n<ul>\n<li>编译系统——把你的代码编译成可以运行的应用, 并且把它存储到某个地方作为后续使用.</li>\n<li>应用管理数据库——管理 Git 版本、build 版本和应用元数据.</li>\n<li>集群调度器——将一组服务器作为一台大的服务器来管理, 在服务器资源池的某个服务器上运行你的程序, 并检查和替换失效的作业.</li>\n<li>负载均衡——允许从 Internet 和内部程序来的业务负载被正确的路由到合适的位置.</li>\n<li>DNS——在你产生和修改应用时自动配置 DNS 条目.</li>\n<li>或许是最重要的——某个形式的容器化例如  freebsd jails、solaris zones、或者 linux containers, 容器化使得某个的应用不会进入和影响到其它的应用.</li>\n</ul>\n<p>第一个和最后一个点是 Docker 迅速发展的非常重要的原因. Linux 容器技术已经存在了一段时间了, 但是只有某些大的公司或者 PaaS 提供商自动化了容器的使用, Docker 使 Linux 容器的使用变得非常简单, 也提供了标准化的镜像格式, 它成为了 PaaS 中重要的组成部分.</p>\n<p>这非常强大, 因为很多公司在处理爆发式的用户增长, 来自于移动、社交和 IoT 的新的业务模式, 以及期望从传统的长的版本发布周期转变到持续交付. 他们利用基于软件的架构或者微服务. 他们需要能够自动部署和测试新的代码, 并根据业务的变化弹性伸缩. 但问题是他们没有足够的资源和经验来交付到他们的开发团队, 所以他们不得不将其外包给 PaaS 提供商. 不幸的是, 当你这么做的时候, 你就放弃了对于这个黑盒子的很多控制, 而是花很多钱并使得自己完全依赖于它. 另外一个选项是, 很多公司反复的重新发明轮子或者使用那些难于维护的、运行缓慢的和易于出错的工具.</p>\n<p>最好的情形是在自己的数据中心或者 Cloud 帐号中运行一个 PaaS 平台, 你可以全权控制, 你的团队可以直接参与应用的部署, 因此可以形成一种真正的 DevOps 文化. Docker 及其标准化的生态系统是这种愿景成为现实的重要一步.</p>\n<h3 id=\"最后——容器托管平台-CaaS\"><a href=\"#最后——容器托管平台-CaaS\" class=\"headerlink\" title=\"最后——容器托管平台 (CaaS)\"></a>最后——容器托管平台 (CaaS)</h3><p>什么是容器托管平台, 或者叫容器即服务呢？这就是我在上面的章节中提到的另外一种构建在 Docker 基础上的 Web 托管方式. 它是你用容器来部署复杂的多层次的应用所需要的自动化的编译系统, 集群调度器, 负载均衡, DNS 自动化以及服务发现. 这是 PaaS 的另外一部分内容, 但是你不是用一个复杂的编译系统来编译你的应用, 而是用 Docker 镜像. 镜像可以非常容易的进行编译和本地测试, 因此你在部署应用之前就确认应用可以正常工作. 现在 PaaS 用户也可以得到相同的体验, 但是不需要拥有自己的硬件或者云帐号的前提下节约大量的成本. 他们不再受限于其服务提供商所支持的环境, 可以通过将应用打包成 Docker 镜像的方式在任何地方运行.</p>\n<p>在这个过程中, 利用诸如 ContainerShip Cloud, 你可以在任何地方, 在任何云平台上甚至是裸机上用相同的方式运行你的应用. 你不再被卡在构建复杂的应用来解决非常困难的问题, 或者卡在使用某个提供商的特殊的自动化部署工具上.</p>\n<ul>\n<li>但是选择一个正确的 Docker 容器托管平台并不是一件容易的事情, 有很多的问题需要你去思考和注意.</li>\n<li>有大量的选项, 因此选择其中一个进行研究就变得困难. 好消息是如果你的应用已经容器化, 你就可以轻松的测试其中的每一个.</li>\n<li>你正在使用的服务提供商例如 Triton 或者 ECS 的某个解决方案或许使得你无法脱离这个提供商, 这也使得 Docker 的最令人兴奋的可移植性变得不那么重要了.</li>\n<li>许多 CaaS 方案在他们自己的硬件上运行所有的管理系统, 你自己的服务器上只是运行某个代理程序来连接他们的 API, 因此如果他们的系统宕机后你的集群将无法工作.</li>\n<li>允许你在防火墙后运行整个系统的方案是非常复杂的, 需要一个团队去管理和升级.</li>\n<li>能够容易的在防火墙后运行整个系统的方案会使得高可用成为低优先级的事情.</li>\n<li>当你选择了一个 CaaS 提供商时, 你就可以摆脱了你的服务托管提供商的锁定, 但是你将陷入到 CaaS 提供商的锁定. 你无法不使用他们的 SaaS 管理接口而在你自己的硬件上运行整个系统包括管理系统, API 和 UI. 你一旦决定付钱, 你最好可以一直付钱.</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>终于看完了, 真的是又臭又长啊. 回顾一下这篇文章, 总体来说是经历了这样一个过程:</p>\n<ol>\n<li>专有服务器</li>\n<li>虚拟化技术</li>\n<li>基础设施即服务 (IaaS)</li>\n<li>平台即服务 (PaaS)</li>\n<li>容器即服务 (CaaS)</li>\n</ol>\n<p>总结一下, 我觉得开发人员还是有必要了解一下关于产品部署相关的技术发展. 然后根据自己的业务来选择合适的服务提供商.</p>\n","site":{"data":{}},"excerpt":"<p>这篇文章是来拓展自己知识面的, 在我读高中那会 (08 年), 我身边就有沉迷电脑技术的同学, 那个时候我想着做一个自己的网站, 肯定是非常牛逼的事了. 从最开始接触的服务, 依次来排个序. 永硕 E 盘 -&gt; 免费空间建站 (国外居多) -&gt; 虚拟空间 -&gt; 虚拟服务器 (VPS) -&gt; 独立服务器. 看完这篇文章后, 我总算对这方面知识有了一个比较系统性的认识了. 一起来学习一下.</p>","more":"<h3 id=\"引子\"><a href=\"#引子\" class=\"headerlink\" title=\"引子\"></a>引子</h3><p>文章开始之前, 我觉得还是有必要把这些专有名词先科普一下, 不要觉得很高大上, 简称而已.</p>\n<ul>\n<li>IaaS - 基础设施即服务</li>\n<li>PaaS - 平台即服务</li>\n<li>CaaS - 容器即服务</li>\n</ul>\n<p>本文介绍了 Web 托管服务进化的历史, 从专用服务器到虚拟化到 IaaS、PaaS 和最新的 CaaS; 说明了每种方式的优点和缺点. 着重阐述了构建 PaaS 应用的各个组件, 以及在选择 CaaS 提供商时应该考虑的问题. 最后从成本和功能性的角度论述了 PaaS 用户应该迁移到 CaaS 平台.</p>\n<p>读完这篇博文, 你应该可以清楚的理解:</p>\n<ul>\n<li>这些名词到底指什么</li>\n<li>这为什么对你很重要</li>\n<li>对于你的使用场景，哪种方式最适合</li>\n</ul>\n<p>当然没有一种方式能够适合所有的 Web 基础设施的场景, 你的特殊场景或许需要特殊的考虑.</p>\n<h3 id=\"从头开始——专用服务器\"><a href=\"#从头开始——专用服务器\" class=\"headerlink\" title=\"从头开始——专用服务器\"></a>从头开始——专用服务器</h3><p>Web 托管的本质还是在一个数据中心里布满了服务器、交换机、路由器、存储阵列和其它网络组件. 我们所讨论的每一个选项不管它是 PaaS、IaaS 还是 CaaS, 它底层使用的基础设施都是相同的, 即在一个大屋子里的很多独立服务器. 他们只是上面增加了很多抽象层使得管理变得更简单, 和使用自动化的方式处理以前很慢或者需要手动步骤的任务.</p>\n<p>专用服务器, 或者叫做 “裸机” 有它的优点和缺点.</p>\n<h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><ul>\n<li>性能——你在直接使用一个服务器, 没有任何抽象层例如虚拟化带来的性能开销.</li>\n<li>可靠性——没有抽象层和虚拟化, 出错的可能性会降低.</li>\n<li>资源利用率——使用专用服务器, 你的进程不需要跟其它的虚拟机或者进程竞争资源例如 CPU、内存和带宽.</li>\n</ul>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><ul>\n<li>管理复杂性——你无法容易地克隆专用服务器来产生更多的实例, 专用服务器没有 AMI（译者注: Amazon Machine Image）或者镜像的概念. 想扩展你的基础设施到多个服务器上？我希望你用配置管理, 或者使用可信赖的老朋友 rsync.</li>\n<li>成本——使用专用服务器, 在大多数情况下你需要预先支付服务器的硬件价格, 然后再付租用场地的成本, 或者你从一个服务提供商那里租赁它们. 无论哪种方式, 你都没法在不使用时终止服务器的租赁来节省成本, 因此你需要更加谨慎的对待你的财务计划.</li>\n<li>你所有的进程和应用都运行在专用服务器上, 因此运行在相同的操作系统上. 为了可扩展性的目的, 你往往希望服务器只运行单一的进程, 例如 Web 服务或者数据库服务. 在一个服务器上运行所有的应用使得操作系统的调优变得更困难.</li>\n</ul>\n<h3 id=\"使事情变得更容易——虚拟化\"><a href=\"#使事情变得更容易——虚拟化\" class=\"headerlink\" title=\"使事情变得更容易——虚拟化\"></a>使事情变得更容易——虚拟化</h3><p>尽管专用服务器有很多优点, 但是它的缺点在大多数情况下会远远超过其优点. 公司为了能够迅速进入市场赢得竞争, 对于部署的速度提出了更高的要求, 虚拟化就很自然的成为了数据中心进化中的下一个步骤.</p>\n<h4 id=\"什么是虚拟化\"><a href=\"#什么是虚拟化\" class=\"headerlink\" title=\"什么是虚拟化\"></a>什么是虚拟化</h4><p>简而言之, 虚拟化就是将物理服务器分成更小的虚拟机, 这些虚拟机只能访问物理机的部分资源. 例如你有一个 8CPU 核以及 16GB 内存的物理服务器, 则可以将它分成 8 个虚拟机, 每个虚拟机有 1 个 CPU 和 2GB 内存. 你或许已经听说过一些虚拟化技术如 Xen, KVM, VMware 和 Hyper-V, 其实很有更多.</p>\n<h4 id=\"优点-1\"><a href=\"#优点-1\" class=\"headerlink\" title=\"优点\"></a>优点</h4><ul>\n<li>你可以在需要更多虚拟机实例或者想要虚拟机共享时进行虚拟机的克隆.</li>\n<li>你可以备份虚拟机镜像作为安全保护或者灾备.</li>\n</ul>\n<h4 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><ul>\n<li>使用虚拟化意味着额外的性能开销, 可能造成性能下降.</li>\n<li>虚拟机镜像在不同的服务提供商和虚拟化技术之间基本上是不可移植的.</li>\n<li>管理虚拟机依然是手工步骤, 需要管理的时间和专业知识.</li>\n</ul>\n<h3 id=\"进化——虚拟化变成-IaaS\"><a href=\"#进化——虚拟化变成-IaaS\" class=\"headerlink\" title=\"进化——虚拟化变成 (IaaS)\"></a>进化——虚拟化变成 (IaaS)</h3><p>你知道 <a href=\"http://www.businessinsider.com/people-think-stormy-weather-affects-cloud-computing-2012-8\" target=\"_blank\" rel=\"noopener\">51% 的人认为 “云” 会被天气影响吗</a>？你知道当人们谈论 “云” 时他们实际上是在讨论基础设施即服务 (IaaS) 吗？</p>\n<h4 id=\"什么是基础设施即服务-IaaS\"><a href=\"#什么是基础设施即服务-IaaS\" class=\"headerlink\" title=\"什么是基础设施即服务 (IaaS)\"></a>什么是基础设施即服务 (IaaS)</h4><ul>\n<li>通过 API 来管理硬件的虚拟化.</li>\n<li>通过编程接口访问计算、存储和网络资源和配置.</li>\n<li>当你需要是申请一个新的虚拟机, 当你完成后终止虚拟机, 你只需要为你使用的资源付费.</li>\n<li>将数据中心资源视为公共设施.</li>\n</ul>\n<p>亚马逊在 2006 年发布了其 Amazon Web Services（AWS）和 EC2 产品，成为了这个领域的先驱。</p>\n<h4 id=\"为什么这个进化如此重要\"><a href=\"#为什么这个进化如此重要\" class=\"headerlink\" title=\"为什么这个进化如此重要\"></a>为什么这个进化如此重要</h4><p>在过去当你需要上线一个在线业务时, 你不得不进行复杂的计划来保证你在数据中心内有足够的机架空间、足够的服务器和存储来处理业务的增长, 足够的网络带宽来处理所有的用户流量. 这种计划并不容易, 尤其是对早期的业务来讲, 你无法预测业务的未来和增长轨迹.</p>\n<ol>\n<li>它给了开发者超能量:<ul>\n<li>构思一个想法立即上线.</li>\n<li>如果成功了, 可以容易的扩展规模.</li>\n<li>如果失败了, 关闭虚拟机以节约成本.</li>\n</ul>\n</li>\n<li>它使得数据中心自动化变得更强大:<ul>\n<li>全自动基础设施管理成为可能, 出现了 “基础设施即代码” 的概念.</li>\n<li>弹性伸缩在过去是不可能实现的, 但是现在 web 基础设施可以当业务变化时自动的扩展或者收缩.</li>\n<li>在服务器的自动化管理之后, 数据中心的自动化也扩展到了存储、网络以及其它大量的需要专业知识的系统, 在代码和 API 能够处理这些自动化之后, 这给全球的开发者社区带来了新的机遇.</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"进一步演化——平台即服务-PaaS\"><a href=\"#进一步演化——平台即服务-PaaS\" class=\"headerlink\" title=\"进一步演化——平台即服务 (PaaS)\"></a>进一步演化——平台即服务 (PaaS)</h3><p>平台即服务 (PaaS) 使得开发人员可以很容易的部署和管理应用而隐藏掉所有的实现细节例如服务器、负载均衡器、DNS 等等. 他们或多或少的去除了对运维团队的需求, 而是让开发人员去关注应用部署. 有很多 PaaS 提供商, 其中一个最流行的是 Heroku. 关于 Heroku 的一个有趣的事情是 Heroku 完全是运行在 AWS 之上并依赖 AWS 的. 如果你不愿意你的应用运行在美国东部或者欧洲西部的 AWS 上的话, 这或许是一个问题. 没有 IaaS, 像 Heroku 这样的平台可能就不会存在了. PaaS 提供商利用 IaaS 作为一个非常重要的组成部分来交付它们的服务. 在减少从想法到部署的时间、自动化流程以及减少特殊的系统知识需求的趋势中, PaaS 是合理的下一步, 就像是从专用服务器到 IaaS 一样.</p>\n<h4 id=\"构建-PaaS-是困难的\"><a href=\"#构建-PaaS-是困难的\" class=\"headerlink\" title=\"构建 PaaS 是困难的\"></a>构建 PaaS 是困难的</h4><p>能够通过抽象而避免处理服务器相关的问题是不容易的, 需要引入很多东西才能做到.</p>\n<p>在 PaaS 的概念之下有几个主要的模块：</p>\n<ul>\n<li>编译系统——把你的代码编译成可以运行的应用, 并且把它存储到某个地方作为后续使用.</li>\n<li>应用管理数据库——管理 Git 版本、build 版本和应用元数据.</li>\n<li>集群调度器——将一组服务器作为一台大的服务器来管理, 在服务器资源池的某个服务器上运行你的程序, 并检查和替换失效的作业.</li>\n<li>负载均衡——允许从 Internet 和内部程序来的业务负载被正确的路由到合适的位置.</li>\n<li>DNS——在你产生和修改应用时自动配置 DNS 条目.</li>\n<li>或许是最重要的——某个形式的容器化例如  freebsd jails、solaris zones、或者 linux containers, 容器化使得某个的应用不会进入和影响到其它的应用.</li>\n</ul>\n<p>第一个和最后一个点是 Docker 迅速发展的非常重要的原因. Linux 容器技术已经存在了一段时间了, 但是只有某些大的公司或者 PaaS 提供商自动化了容器的使用, Docker 使 Linux 容器的使用变得非常简单, 也提供了标准化的镜像格式, 它成为了 PaaS 中重要的组成部分.</p>\n<p>这非常强大, 因为很多公司在处理爆发式的用户增长, 来自于移动、社交和 IoT 的新的业务模式, 以及期望从传统的长的版本发布周期转变到持续交付. 他们利用基于软件的架构或者微服务. 他们需要能够自动部署和测试新的代码, 并根据业务的变化弹性伸缩. 但问题是他们没有足够的资源和经验来交付到他们的开发团队, 所以他们不得不将其外包给 PaaS 提供商. 不幸的是, 当你这么做的时候, 你就放弃了对于这个黑盒子的很多控制, 而是花很多钱并使得自己完全依赖于它. 另外一个选项是, 很多公司反复的重新发明轮子或者使用那些难于维护的、运行缓慢的和易于出错的工具.</p>\n<p>最好的情形是在自己的数据中心或者 Cloud 帐号中运行一个 PaaS 平台, 你可以全权控制, 你的团队可以直接参与应用的部署, 因此可以形成一种真正的 DevOps 文化. Docker 及其标准化的生态系统是这种愿景成为现实的重要一步.</p>\n<h3 id=\"最后——容器托管平台-CaaS\"><a href=\"#最后——容器托管平台-CaaS\" class=\"headerlink\" title=\"最后——容器托管平台 (CaaS)\"></a>最后——容器托管平台 (CaaS)</h3><p>什么是容器托管平台, 或者叫容器即服务呢？这就是我在上面的章节中提到的另外一种构建在 Docker 基础上的 Web 托管方式. 它是你用容器来部署复杂的多层次的应用所需要的自动化的编译系统, 集群调度器, 负载均衡, DNS 自动化以及服务发现. 这是 PaaS 的另外一部分内容, 但是你不是用一个复杂的编译系统来编译你的应用, 而是用 Docker 镜像. 镜像可以非常容易的进行编译和本地测试, 因此你在部署应用之前就确认应用可以正常工作. 现在 PaaS 用户也可以得到相同的体验, 但是不需要拥有自己的硬件或者云帐号的前提下节约大量的成本. 他们不再受限于其服务提供商所支持的环境, 可以通过将应用打包成 Docker 镜像的方式在任何地方运行.</p>\n<p>在这个过程中, 利用诸如 ContainerShip Cloud, 你可以在任何地方, 在任何云平台上甚至是裸机上用相同的方式运行你的应用. 你不再被卡在构建复杂的应用来解决非常困难的问题, 或者卡在使用某个提供商的特殊的自动化部署工具上.</p>\n<ul>\n<li>但是选择一个正确的 Docker 容器托管平台并不是一件容易的事情, 有很多的问题需要你去思考和注意.</li>\n<li>有大量的选项, 因此选择其中一个进行研究就变得困难. 好消息是如果你的应用已经容器化, 你就可以轻松的测试其中的每一个.</li>\n<li>你正在使用的服务提供商例如 Triton 或者 ECS 的某个解决方案或许使得你无法脱离这个提供商, 这也使得 Docker 的最令人兴奋的可移植性变得不那么重要了.</li>\n<li>许多 CaaS 方案在他们自己的硬件上运行所有的管理系统, 你自己的服务器上只是运行某个代理程序来连接他们的 API, 因此如果他们的系统宕机后你的集群将无法工作.</li>\n<li>允许你在防火墙后运行整个系统的方案是非常复杂的, 需要一个团队去管理和升级.</li>\n<li>能够容易的在防火墙后运行整个系统的方案会使得高可用成为低优先级的事情.</li>\n<li>当你选择了一个 CaaS 提供商时, 你就可以摆脱了你的服务托管提供商的锁定, 但是你将陷入到 CaaS 提供商的锁定. 你无法不使用他们的 SaaS 管理接口而在你自己的硬件上运行整个系统包括管理系统, API 和 UI. 你一旦决定付钱, 你最好可以一直付钱.</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>终于看完了, 真的是又臭又长啊. 回顾一下这篇文章, 总体来说是经历了这样一个过程:</p>\n<ol>\n<li>专有服务器</li>\n<li>虚拟化技术</li>\n<li>基础设施即服务 (IaaS)</li>\n<li>平台即服务 (PaaS)</li>\n<li>容器即服务 (CaaS)</li>\n</ol>\n<p>总结一下, 我觉得开发人员还是有必要了解一下关于产品部署相关的技术发展. 然后根据自己的业务来选择合适的服务提供商.</p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}