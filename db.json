{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/favicon.ico","path":"favicon.ico","modified":1,"renderable":0},{"_id":"themes/hexo-theme-apollo/source/favicon.png","path":"favicon.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-apollo/source/manifest.json","path":"manifest.json","modified":1,"renderable":1},{"_id":"themes/hexo-theme-apollo/source/css/apollo.css","path":"css/apollo.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-apollo/source/font/sourcesanspro.woff","path":"font/sourcesanspro.woff","modified":1,"renderable":1},{"_id":"themes/hexo-theme-apollo/source/font/sourcesanspro.woff2","path":"font/sourcesanspro.woff2","modified":1,"renderable":1},{"_id":"themes/hexo-theme-apollo/source/img/apple-launch-750x1334.png","path":"img/apple-launch-750x1334.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-apollo/source/img/webAppIcon-256x256.png","path":"img/webAppIcon-256x256.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-apollo/source/img/webAppIcon-256x256.png.bak","path":"img/webAppIcon-256x256.png.bak","modified":1,"renderable":1},{"_id":"themes/hexo-theme-apollo/source/img/webAppIcon-512x512.png","path":"img/webAppIcon-512x512.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-apollo/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-apollo/source/scss/apollo.scss","path":"scss/apollo.scss","modified":1,"renderable":1},{"_id":"themes/hexo-theme-apollo/source/js/template-web.min.js","path":"js/template-web.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-apollo/source/js/algoliasearch.min.js","path":"js/algoliasearch.min.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"d3e227ef309161835752c475a54126640d1149ab","modified":1575695527032},{"_id":"themes/hexo-theme-apollo/.gitignore","hash":"2851ba7682bb8e132da4511e7d3d769c6f247858","modified":1545840064000},{"_id":"source/favicon.ico","hash":"10df6f583311f8533e055ab21ad1be9eb3a7d80d","modified":1545840064000},{"_id":"themes/hexo-theme-apollo/LICENSE","hash":"0cbd1cc64463ddff5c569cada287e69011ef385c","modified":1545840064000},{"_id":"themes/hexo-theme-apollo/README.md","hash":"9c3cdfd232ed49a3d32b43696e02b980c93260ba","modified":1545840064000},{"_id":"themes/hexo-theme-apollo/_config.yml","hash":"20facb13773bc7960e5dac9e9ae96ad1fa9a4849","modified":1575127310414},{"_id":"themes/hexo-theme-apollo/gulpfile.js","hash":"5f1e4d173e6ad54a4014c7b73b4b6202f54e0772","modified":1545840064000},{"_id":"themes/hexo-theme-apollo/package.json","hash":"c61b194aac46b29e437b0ee2729d0c47d2478f6e","modified":1575127310421},{"_id":"source/about/index.md","hash":"b01a2955428cc6c1bc3e981586b84e4481520185","modified":1561825886649},{"_id":"source/categories/index.md","hash":"fe4bebea66d0ac9f7f2b961a0a55b5dbee2eae88","modified":1545840064000},{"_id":"source/_posts/7招轻松搞定-JavaScript-多行字符串拼接.md","hash":"c3627c09c7753685a67ee90d26cd1eb256a2ee42","modified":1575694773501},{"_id":"source/_posts/Async-await-查漏补缺.md","hash":"35b6958c59e46528e7a641e2f5a417efcf314249","modified":1575694398084},{"_id":"source/_posts/CentOS-6-x86-Node-js-MongoDB-Express-环境配置笔记.md","hash":"0dd99e65f66f722d645a823f910551a567239c72","modified":1545840064000},{"_id":"source/_posts/Axios-使用姿势指南.md","hash":"8097446b759763d79c8a15af0a71102957e017f6","modified":1575694398084},{"_id":"source/_posts/ES6-Promise-简明指南.md","hash":"1a5b115ff8db5054ba8170c4ac26bf0218ecd1c6","modified":1545840064000},{"_id":"source/_posts/Git-操作详细总结.md","hash":"67100f507fb33044881e49890bc80694e3c31bd1","modified":1545840064000},{"_id":"source/_posts/JavaScript-中的-this-用法总结.md","hash":"9aac09ce6e26627426898d9b3039447495777be6","modified":1545840064000},{"_id":"source/_posts/Mongodb-学习笔记----增删改查.md","hash":"d24c15a319c41f0ad48cfcc9cd30c16d3c82c1c5","modified":1575694773834},{"_id":"source/_posts/Node.JS-学习笔记-[01]----入门.md","hash":"d582583c33d60bc88b5593bd46a7e52c88f430ea","modified":1575694773895},{"_id":"themes/hexo-theme-apollo/yarn.lock","hash":"22b28a0b73b68a2a49e9b9148bdc190fff0097e5","modified":1575127310426},{"_id":"source/_posts/Node.JS-学习笔记-[02]----同步异步.md","hash":"8c31f273a415cd4684d5cca07ae0a9d8fb62b466","modified":1575694774071},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1575695527025},{"_id":"source/_posts/Promise-查漏补缺.md","hash":"01f2ac9210e3cf1858ed2b2ff5c19daf0b31a387","modified":1575694774322},{"_id":"source/_posts/Node.JS-学习笔记-[04]----HTTP.md","hash":"7030203aed05fe83e4e6d52ded4e450283e55138","modified":1575694774172},{"_id":"source/_posts/Node.JS-学习笔记-[03]----Buffer-fs-path.md","hash":"e82c5de197792c6ee5d9eca5acd34b6f5af4d618","modified":1545840064000},{"_id":"source/_posts/Node.JS-学习笔记-[05]----Express.md","hash":"fb242cedc1e274832f244a5b5c04a364f64b8242","modified":1575694774226},{"_id":"source/_posts/ProxyChains-NG-ShadowSocks-实现终端代理.md","hash":"605995615e4e36dc1d62569dcfc6ff07eb0e4f3f","modified":1575696157267},{"_id":"source/_posts/React-组件模式.md","hash":"9b06a23532bd2b8d9e6d24aeafe12f4a7b04f11b","modified":1575694774371},{"_id":"source/_posts/Why-Immutable-Data.md","hash":"30335a9111ae9db150de8c1c7e13c864cac86371","modified":1575697526498},{"_id":"source/_posts/call、apply、bind-的区别及应用.md","hash":"e043c224d23c7b99ad5a0561a408932693896ad1","modified":1575694773620},{"_id":"source/_posts/webpack4-定制前端开发环境.md","hash":"7b8c8ce24cb97b20a718e4d4724fd99820c91bdc","modified":1575694775928},{"_id":"source/_posts/一段神奇的-CSS-调试代码.md","hash":"aa8b751446268285200d374a147173802e1910df","modified":1575694775962},{"_id":"source/_posts/代码洁癖养成指南.md","hash":"aa3eaf98d8320d2d07eaeba66f53dafa765ef8be","modified":1575694398094},{"_id":"source/_posts/代码重构.md","hash":"9dddb23435df44b9f28a1c65b0af5054567e4770","modified":1575694398094},{"_id":"source/_posts/前后端鉴权方式总结.md","hash":"9f88e5835b69350ecb35a82a2f8c0cb1fe43fcfc","modified":1575694398095},{"_id":"source/_posts/如何在-Git-中使用撤消操作.md","hash":"49d28bf80507cc51b3e352fb7da5b67c2f3b3701","modified":1545840064000},{"_id":"source/_posts/如何避免-async-await-地狱.md","hash":"23f232f0345ceec631edd80a681a690c6a7e3bbb","modified":1545840064000},{"_id":"source/_posts/我的主管给我的一些建议.md","hash":"7667fd4542a55a0f50557fe098e69bc43fe73e0f","modified":1575694776112},{"_id":"source/_posts/持续集成-CI-及简单实践.md","hash":"bd5c47acf28494bcb96241dfbddb70ef9f79a7e1","modified":1545840064000},{"_id":"source/_posts/浏览器跨域请求数据总结.md","hash":"d7cc336bcbbb988423500c2e429622492e69b826","modified":1545840064000},{"_id":"source/_posts/给小白读的-WEB-托管服务进化史.md","hash":"284a23ba626210ebc1e4ae843db2718dbc2da764","modified":1575694398096},{"_id":"source/docs/index.md","hash":"0c785bf663a4f65c66bb1c01e1103b0ab3fe071d","modified":1548170120357},{"_id":"themes/hexo-theme-apollo/doc/doc-zh.md","hash":"e6151b25d3abba657e0c57aab98b95275cfd9355","modified":1545840064000},{"_id":"themes/hexo-theme-apollo/doc/doc-en.md","hash":"fc0a961b1fe5bf40c0347df28eab4205a0fae316","modified":1545840064000},{"_id":"themes/hexo-theme-apollo/languages/en.yml","hash":"ec237cfc9ae0cc26a382a237ae1ed7516b83926a","modified":1545840064000},{"_id":"themes/hexo-theme-apollo/layout/archive.jade","hash":"09ddf1c05d13a8b98e6d704afaa2291d79ea7ec3","modified":1546018063000},{"_id":"themes/hexo-theme-apollo/languages/zh-cn.yml","hash":"70605654c5effd2d85848b2e89d0be4c8f307f49","modified":1545840064000},{"_id":"themes/hexo-theme-apollo/layout/index.jade","hash":"2eb55941756a818ac892b278c417513e9f2a3c2f","modified":1546018066000},{"_id":"themes/hexo-theme-apollo/layout/post.jade","hash":"3e723074d0fbe3d12b30da0453edf11dda5a55b2","modified":1545840064000},{"_id":"themes/hexo-theme-apollo/source/favicon.png","hash":"5384fc67ce416c0748de077e00cc72f1f51428ea","modified":1561825886649},{"_id":"themes/hexo-theme-apollo/source/manifest.json","hash":"48662c18b7af76f2eb75d55bc47a466be6689354","modified":1545840064000},{"_id":"themes/hexo-theme-apollo/layout/mixins/post.jade","hash":"f9d1cb8830bd7100ee3db730e30fc5d355b8c638","modified":1545840064000},{"_id":"themes/hexo-theme-apollo/layout/mixins/paginator.jade","hash":"1b8863711e214fed8f716977833a1932e94798c3","modified":1545840064000},{"_id":"themes/hexo-theme-apollo/layout/partial/copyright.jade","hash":"df74de116edf92d00f3a33914dc8f82b45bcc9ab","modified":1545840064000},{"_id":"themes/hexo-theme-apollo/layout/partial/comment.jade","hash":"a04077365171c4cef60cf518e0c8d0ab2635c576","modified":1575127310415},{"_id":"themes/hexo-theme-apollo/layout/partial/head.jade","hash":"ec415e0ea6c8cda2d26101dc86758c8a72d705e7","modified":1545840064000},{"_id":"themes/hexo-theme-apollo/layout/partial/layout.jade","hash":"5e388a024616e92305e31ce086e6f2b8adbcf773","modified":1545840064000},{"_id":"themes/hexo-theme-apollo/layout/partial/nav.jade","hash":"cbe1af51107d330240859ce26ce54e57a47f906c","modified":1575127310416},{"_id":"themes/hexo-theme-apollo/layout/partial/scripts.jade","hash":"8fa6432eb4c174f15b631d61d7d634eccbca2d94","modified":1575127310416},{"_id":"themes/hexo-theme-apollo/layout/partial/search.jade","hash":"2c5733fa0d27f5546a64732c925aa71af8be84e6","modified":1575127310418},{"_id":"themes/hexo-theme-apollo/source/css/apollo.css","hash":"d1c1e8300650c1d830bec0543bc2170a43868b3e","modified":1575127310424},{"_id":"themes/hexo-theme-apollo/source/font/sourcesanspro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1545840064000},{"_id":"themes/hexo-theme-apollo/source/font/sourcesanspro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1545840064000},{"_id":"themes/hexo-theme-apollo/source/img/apple-launch-750x1334.png","hash":"6f75a0339a57e48cd8202ef3cabcd76477a1c7d0","modified":1561825886650},{"_id":"themes/hexo-theme-apollo/source/img/webAppIcon-256x256.png","hash":"5250aaf69dab950d86361a4ee83127f8bdc643cc","modified":1561825886651},{"_id":"themes/hexo-theme-apollo/source/img/webAppIcon-256x256.png.bak","hash":"d665a7de84f94a8f59e4ab0a7a01d2038f200601","modified":1545840064000},{"_id":"themes/hexo-theme-apollo/source/img/webAppIcon-512x512.png","hash":"cad088796287d7fe2b6d7dd4c96700789adad1e9","modified":1561825886651},{"_id":"themes/hexo-theme-apollo/source/js/main.js","hash":"b00ccadd912a2ab3bc89f6371da66740376a682f","modified":1548173391291},{"_id":"themes/hexo-theme-apollo/source/scss/apollo.scss","hash":"a5950e209c2aaefab05f1f57ee96ec44ff49d126","modified":1575127310425},{"_id":"themes/hexo-theme-apollo/source/js/template-web.min.js","hash":"315aedb8fac14e2bcc9464c609fe3ad8a03cbe20","modified":1545840064000},{"_id":"themes/hexo-theme-apollo/source/js/algoliasearch.min.js","hash":"5244731131a647d230c1d80731171191adc7e2a8","modified":1545840064000},{"_id":"themes/hexo-theme-apollo/source/scss/_partial/archive-post-list.scss","hash":"8c982e6ffcdc0200c622136c56edcb5fe5118e64","modified":1545840064000},{"_id":"themes/hexo-theme-apollo/source/scss/_partial/base.scss","hash":"a0f16e6b8c66c34686eef29d2b784f6f7cb94a93","modified":1545840064000},{"_id":"themes/hexo-theme-apollo/source/scss/_partial/copyright.scss","hash":"a010baa6867800674cd53e20e608b2a256727ae5","modified":1545840064000},{"_id":"themes/hexo-theme-apollo/source/scss/_partial/dakmod-override.scss","hash":"9ebb68221d525cb18445e66819be9c6e27e0b0a7","modified":1575127310424},{"_id":"themes/hexo-theme-apollo/source/scss/_partial/footer.scss","hash":"72ca7067009770a07909efe76d02c6d438f4f211","modified":1545840064000},{"_id":"themes/hexo-theme-apollo/source/scss/_partial/header.scss","hash":"e66e1056134c9c314300cf91ef0ec20791714a98","modified":1545840064000},{"_id":"themes/hexo-theme-apollo/source/scss/_partial/home-post-list.scss","hash":"d85ff34b9c1faf0d0e5baa7eae19724911a1631e","modified":1545840064000},{"_id":"themes/hexo-theme-apollo/source/scss/_partial/git-comment.scss","hash":"3d0ef57d45d2f09a04524db7d1dd950ee754fd34","modified":1575697548282},{"_id":"themes/hexo-theme-apollo/source/scss/_partial/mq.scss","hash":"4bb6b91e821d75f751271facc53cf22b13640d1c","modified":1545840064000},{"_id":"themes/hexo-theme-apollo/source/scss/_partial/normalize.scss","hash":"623e8d1e7aa525fe207378cbe3206314ed0c1598","modified":1575698105815},{"_id":"themes/hexo-theme-apollo/source/scss/_partial/search.scss","hash":"0ee6c1065eac784e68edd0af9a5d2ebb177ca46b","modified":1545840064000},{"_id":"themes/hexo-theme-apollo/source/scss/_partial/toc.scss","hash":"eb84cc2b740e629492da245e226f9e584522e981","modified":1546312549099},{"_id":"themes/hexo-theme-apollo/source/scss/_partial/post.scss","hash":"af3a412f9fac801fbcc830e19fafc0afca8ecd92","modified":1545840064000}],"Category":[],"Data":[],"Page":[{"title":"About Me","date":"2018-04-30T03:14:00.000Z","comments":0,"_content":"\n```js\nlet Me = {\n  Name: 'Willard Wong',\n  Gender: 'male',\n  Job: 'Front-end Developer',\n  Hobbies: ['movie', 'reading', 'photography', 'code'],\n  Email: 'ifyour@outlook.com',\n  GitHub: 'github.com/ifyour',\n  Twitter: '@johnwmm',\n  Instagram: '@wmmjohn',\n};\n```\n\n> _念念不忘, 必有回响!_\n","source":"about/index.md","raw":"---\ntitle: About Me\ndate: 2018-04-30 11:14:00\ncomments: false\n---\n\n```js\nlet Me = {\n  Name: 'Willard Wong',\n  Gender: 'male',\n  Job: 'Front-end Developer',\n  Hobbies: ['movie', 'reading', 'photography', 'code'],\n  Email: 'ifyour@outlook.com',\n  GitHub: 'github.com/ifyour',\n  Twitter: '@johnwmm',\n  Instagram: '@wmmjohn',\n};\n```\n\n> _念念不忘, 必有回响!_\n","updated":"2019-06-29T16:31:26.649Z","path":"about/index.html","layout":"page","_id":"ck3v60jt00000r9q9ucjfcm4w","content":"<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> Me = &#123;</span><br><span class=\"line\">  Name: <span class=\"string\">'Willard Wong'</span>,</span><br><span class=\"line\">  Gender: <span class=\"string\">'male'</span>,</span><br><span class=\"line\">  Job: <span class=\"string\">'Front-end Developer'</span>,</span><br><span class=\"line\">  Hobbies: [<span class=\"string\">'movie'</span>, <span class=\"string\">'reading'</span>, <span class=\"string\">'photography'</span>, <span class=\"string\">'code'</span>],</span><br><span class=\"line\">  Email: <span class=\"string\">'ifyour@outlook.com'</span>,</span><br><span class=\"line\">  GitHub: <span class=\"string\">'github.com/ifyour'</span>,</span><br><span class=\"line\">  Twitter: <span class=\"string\">'@johnwmm'</span>,</span><br><span class=\"line\">  Instagram: <span class=\"string\">'@wmmjohn'</span>,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><em>念念不忘, 必有回响!</em></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> Me = &#123;</span><br><span class=\"line\">  Name: <span class=\"string\">'Willard Wong'</span>,</span><br><span class=\"line\">  Gender: <span class=\"string\">'male'</span>,</span><br><span class=\"line\">  Job: <span class=\"string\">'Front-end Developer'</span>,</span><br><span class=\"line\">  Hobbies: [<span class=\"string\">'movie'</span>, <span class=\"string\">'reading'</span>, <span class=\"string\">'photography'</span>, <span class=\"string\">'code'</span>],</span><br><span class=\"line\">  Email: <span class=\"string\">'ifyour@outlook.com'</span>,</span><br><span class=\"line\">  GitHub: <span class=\"string\">'github.com/ifyour'</span>,</span><br><span class=\"line\">  Twitter: <span class=\"string\">'@johnwmm'</span>,</span><br><span class=\"line\">  Instagram: <span class=\"string\">'@wmmjohn'</span>,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><em>念念不忘, 必有回响!</em></p>\n</blockquote>\n"},{"title":"工具及文档","date":"2018-05-06T03:56:00.000Z","comments":1,"_content":"\n### Interesting tools\n\n- [Rico's cheatsheets](https://devhints.io/) - 记忆小抄, 长话短说各种开发文档\n- [Carbon](https://carbon.now.sh/) - 带样式分享代码\n- [CodePen](https://codepen.io/pen/) - 在线测试前端代码\n- [CodeSandbox](https://codesandbox.io/s/) - 代码沙盒，可以分享带有依赖的前端项目\n- [Prettier](https://prettier.io/playground/) - 在线格式化 JavaScript 代码\n- [Text-formatter](https://text-formatter.herokuapp.com/) - 格式化文本, 中英文之间留空格以及英文标点\n- [DevDocs](https://devdocs.io/) - 一站式开发文档集合\n- [Grammarly](https://app.grammarly.com/) - 英文语法错误检查\n- [JSONPlaceholder](http://jsonplaceholder.typicode.com/) - RESTful API 假数据模拟\n- [JSON2YAML](https://www.json2yaml.com/) - JSON 和 YAML 互转\n- [JSON Parser](http://json.parser.online.fr/beta/) - JSON 格式化\n- [RegExr](https://regexr.com/) - 在线正则测试及调试\n- [Regulex](https://jex.im/regulex/) - 正则表达可视化, 快速理解正则表达式\n- [CSSMatic](https://www.cssmatic.com/) - 生成镜像渐变, 盒子阴影等\n- [CSS Gradient](https://cssgradient.io/) - 专业生成镜像渐变、线性渐变\n- [SassMeister](https://www.sassmeister.com/) - Sass 演练场, 可以输出 AutoPrefixer 的结果\n- [KeyframesApp](https://keyframes.app/) - CSS3 动画关键帧生成工具\n- [CSS Sprites Generator](https://www.toptal.com/developers/css/sprite-generator) - CSS 精灵生成工具\n- [JSNice](http://www.jsnice.org/) - 反编译已压缩的 JS 代码, 理解变量含义\n- [Love2.io](https://love2.io/) - 开源技术文档分享平台\n- [WakaTime](https://wakatime.com/) - 记录每天的编码情况, 使用什么语言及统计时长\n- [Best of JavaScript](https://bestofjs.org/) - 最流行的前端开源项目清单\n- [蓝湖](https://lanhuapp.com/) - 高效的产品设计协作平台, 标注切图很好用\n\n### Docs\n\n- **React**\n\n  - [React 中文文档](https://doc.react-china.org/docs/hello-world.html)\n  - [Redux 中文文档](https://www.kancloud.cn/allanyu/redux-in-chinese/82399)\n  - [React-saga 中文文档](http://leonshi.com/redux-saga-in-chinese/docs/api/index.html)\n  - [React-router 中文文档](https://react-guide.github.io/react-router-cn)\n  - [Mobx 中文文档](https://suprise.gitbooks.io/mobx-cn/content/fp.html)\n  - [Ant-design 文档](https://ant.design/docs/react/introduce-cn)\n  - [React-Native 文档](http://reactnative.cn/docs/0.50/getting-started.html)\n\n- **Vue.js**\n\n  - [Vue.js 官网](https://cn.vuejs.org/v2/guide/)\n  - [Vue-Router](https://router.vuejs.org/zh-cn/)\n  - [Vuex](https://vuex.vuejs.org/zh-cn/)\n  - [Vue-SSR 服务器端渲染](https://ssr.vuejs.org/zh/)\n  - [Vue-NUXT](https://zh.nuxtjs.org/guide/installation)\n\n- **Node.js**\n\n  - [Node.js API](http://nodejs.cn/api/)\n  - [Express 官网](http://www.expressjs.com.cn/guide/routing.html)\n\n- **Electron**\n\n  - [Electron 官方文档](https://electronjs.org/docs/)\n\n- **WeChat**\n\n  - [小程序官方文档](https://mp.weixin.qq.com/debug/wxadoc/dev/index.html?t=201832)\n\n- **TypeScript**\n\n  - [TypeScript 中文网](https://www.tslang.cn/index.html)\n\n- **Vanilla JS**\n\n  - [JavaScript 基础进阶系列](https://segmentfault.com/a/1190000012646488)\n  - [深入理解 JS 异步](https://github.com/wangfupeng1988/js-async-tutorial)\n  - [深入理解 JS (Tom)](https://www.cnblogs.com/tomxu/archive/2011/12/15/2288411.html)\n\n- **Webpack**\n\n  - [Webpack 3.x](http://www.css88.com/doc/webpack/)\n  - [Webpack 2.x](http://www.css88.com/doc/webpack2/api/loaders/#version)\n\n- **Python**\n\n  - [Python 3 教程 (廖雪峰)](https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000)\n  - [Django 中文文档](https://docs.djangoproject.com/zh-hans/2.0/)\n\n- **More...**\n  - [印记中文](https://docschina.org/)\n\n### One more thing\n\n欢迎在下面留言板分享你觉得有趣的所有东西, 本文[源代码地址](https://raw.githubusercontent.com/ifyour/ifyour.github.io/src/source/docs/index.md). 😎\n","source":"docs/index.md","raw":"---\ntitle: 工具及文档\ndate: 2018-05-06 11:56:00\ncomments: true\n---\n\n### Interesting tools\n\n- [Rico's cheatsheets](https://devhints.io/) - 记忆小抄, 长话短说各种开发文档\n- [Carbon](https://carbon.now.sh/) - 带样式分享代码\n- [CodePen](https://codepen.io/pen/) - 在线测试前端代码\n- [CodeSandbox](https://codesandbox.io/s/) - 代码沙盒，可以分享带有依赖的前端项目\n- [Prettier](https://prettier.io/playground/) - 在线格式化 JavaScript 代码\n- [Text-formatter](https://text-formatter.herokuapp.com/) - 格式化文本, 中英文之间留空格以及英文标点\n- [DevDocs](https://devdocs.io/) - 一站式开发文档集合\n- [Grammarly](https://app.grammarly.com/) - 英文语法错误检查\n- [JSONPlaceholder](http://jsonplaceholder.typicode.com/) - RESTful API 假数据模拟\n- [JSON2YAML](https://www.json2yaml.com/) - JSON 和 YAML 互转\n- [JSON Parser](http://json.parser.online.fr/beta/) - JSON 格式化\n- [RegExr](https://regexr.com/) - 在线正则测试及调试\n- [Regulex](https://jex.im/regulex/) - 正则表达可视化, 快速理解正则表达式\n- [CSSMatic](https://www.cssmatic.com/) - 生成镜像渐变, 盒子阴影等\n- [CSS Gradient](https://cssgradient.io/) - 专业生成镜像渐变、线性渐变\n- [SassMeister](https://www.sassmeister.com/) - Sass 演练场, 可以输出 AutoPrefixer 的结果\n- [KeyframesApp](https://keyframes.app/) - CSS3 动画关键帧生成工具\n- [CSS Sprites Generator](https://www.toptal.com/developers/css/sprite-generator) - CSS 精灵生成工具\n- [JSNice](http://www.jsnice.org/) - 反编译已压缩的 JS 代码, 理解变量含义\n- [Love2.io](https://love2.io/) - 开源技术文档分享平台\n- [WakaTime](https://wakatime.com/) - 记录每天的编码情况, 使用什么语言及统计时长\n- [Best of JavaScript](https://bestofjs.org/) - 最流行的前端开源项目清单\n- [蓝湖](https://lanhuapp.com/) - 高效的产品设计协作平台, 标注切图很好用\n\n### Docs\n\n- **React**\n\n  - [React 中文文档](https://doc.react-china.org/docs/hello-world.html)\n  - [Redux 中文文档](https://www.kancloud.cn/allanyu/redux-in-chinese/82399)\n  - [React-saga 中文文档](http://leonshi.com/redux-saga-in-chinese/docs/api/index.html)\n  - [React-router 中文文档](https://react-guide.github.io/react-router-cn)\n  - [Mobx 中文文档](https://suprise.gitbooks.io/mobx-cn/content/fp.html)\n  - [Ant-design 文档](https://ant.design/docs/react/introduce-cn)\n  - [React-Native 文档](http://reactnative.cn/docs/0.50/getting-started.html)\n\n- **Vue.js**\n\n  - [Vue.js 官网](https://cn.vuejs.org/v2/guide/)\n  - [Vue-Router](https://router.vuejs.org/zh-cn/)\n  - [Vuex](https://vuex.vuejs.org/zh-cn/)\n  - [Vue-SSR 服务器端渲染](https://ssr.vuejs.org/zh/)\n  - [Vue-NUXT](https://zh.nuxtjs.org/guide/installation)\n\n- **Node.js**\n\n  - [Node.js API](http://nodejs.cn/api/)\n  - [Express 官网](http://www.expressjs.com.cn/guide/routing.html)\n\n- **Electron**\n\n  - [Electron 官方文档](https://electronjs.org/docs/)\n\n- **WeChat**\n\n  - [小程序官方文档](https://mp.weixin.qq.com/debug/wxadoc/dev/index.html?t=201832)\n\n- **TypeScript**\n\n  - [TypeScript 中文网](https://www.tslang.cn/index.html)\n\n- **Vanilla JS**\n\n  - [JavaScript 基础进阶系列](https://segmentfault.com/a/1190000012646488)\n  - [深入理解 JS 异步](https://github.com/wangfupeng1988/js-async-tutorial)\n  - [深入理解 JS (Tom)](https://www.cnblogs.com/tomxu/archive/2011/12/15/2288411.html)\n\n- **Webpack**\n\n  - [Webpack 3.x](http://www.css88.com/doc/webpack/)\n  - [Webpack 2.x](http://www.css88.com/doc/webpack2/api/loaders/#version)\n\n- **Python**\n\n  - [Python 3 教程 (廖雪峰)](https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000)\n  - [Django 中文文档](https://docs.djangoproject.com/zh-hans/2.0/)\n\n- **More...**\n  - [印记中文](https://docschina.org/)\n\n### One more thing\n\n欢迎在下面留言板分享你觉得有趣的所有东西, 本文[源代码地址](https://raw.githubusercontent.com/ifyour/ifyour.github.io/src/source/docs/index.md). 😎\n","updated":"2019-01-22T15:15:20.357Z","path":"docs/index.html","layout":"page","_id":"ck3v60jt50002r9q9qr3v4ly1","content":"<h3 id=\"Interesting-tools\"><a href=\"#Interesting-tools\" class=\"headerlink\" title=\"Interesting tools\"></a>Interesting tools</h3><ul>\n<li><a href=\"https://devhints.io/\" target=\"_blank\" rel=\"noopener\">Rico’s cheatsheets</a> - 记忆小抄, 长话短说各种开发文档</li>\n<li><a href=\"https://carbon.now.sh/\" target=\"_blank\" rel=\"noopener\">Carbon</a> - 带样式分享代码</li>\n<li><a href=\"https://codepen.io/pen/\" target=\"_blank\" rel=\"noopener\">CodePen</a> - 在线测试前端代码</li>\n<li><a href=\"https://codesandbox.io/s/\" target=\"_blank\" rel=\"noopener\">CodeSandbox</a> - 代码沙盒，可以分享带有依赖的前端项目</li>\n<li><a href=\"https://prettier.io/playground/\" target=\"_blank\" rel=\"noopener\">Prettier</a> - 在线格式化 JavaScript 代码</li>\n<li><a href=\"https://text-formatter.herokuapp.com/\" target=\"_blank\" rel=\"noopener\">Text-formatter</a> - 格式化文本, 中英文之间留空格以及英文标点</li>\n<li><a href=\"https://devdocs.io/\" target=\"_blank\" rel=\"noopener\">DevDocs</a> - 一站式开发文档集合</li>\n<li><a href=\"https://app.grammarly.com/\" target=\"_blank\" rel=\"noopener\">Grammarly</a> - 英文语法错误检查</li>\n<li><a href=\"http://jsonplaceholder.typicode.com/\" target=\"_blank\" rel=\"noopener\">JSONPlaceholder</a> - RESTful API 假数据模拟</li>\n<li><a href=\"https://www.json2yaml.com/\" target=\"_blank\" rel=\"noopener\">JSON2YAML</a> - JSON 和 YAML 互转</li>\n<li><a href=\"http://json.parser.online.fr/beta/\" target=\"_blank\" rel=\"noopener\">JSON Parser</a> - JSON 格式化</li>\n<li><a href=\"https://regexr.com/\" target=\"_blank\" rel=\"noopener\">RegExr</a> - 在线正则测试及调试</li>\n<li><a href=\"https://jex.im/regulex/\" target=\"_blank\" rel=\"noopener\">Regulex</a> - 正则表达可视化, 快速理解正则表达式</li>\n<li><a href=\"https://www.cssmatic.com/\" target=\"_blank\" rel=\"noopener\">CSSMatic</a> - 生成镜像渐变, 盒子阴影等</li>\n<li><a href=\"https://cssgradient.io/\" target=\"_blank\" rel=\"noopener\">CSS Gradient</a> - 专业生成镜像渐变、线性渐变</li>\n<li><a href=\"https://www.sassmeister.com/\" target=\"_blank\" rel=\"noopener\">SassMeister</a> - Sass 演练场, 可以输出 AutoPrefixer 的结果</li>\n<li><a href=\"https://keyframes.app/\" target=\"_blank\" rel=\"noopener\">KeyframesApp</a> - CSS3 动画关键帧生成工具</li>\n<li><a href=\"https://www.toptal.com/developers/css/sprite-generator\" target=\"_blank\" rel=\"noopener\">CSS Sprites Generator</a> - CSS 精灵生成工具</li>\n<li><a href=\"http://www.jsnice.org/\" target=\"_blank\" rel=\"noopener\">JSNice</a> - 反编译已压缩的 JS 代码, 理解变量含义</li>\n<li><a href=\"https://love2.io/\" target=\"_blank\" rel=\"noopener\">Love2.io</a> - 开源技术文档分享平台</li>\n<li><a href=\"https://wakatime.com/\" target=\"_blank\" rel=\"noopener\">WakaTime</a> - 记录每天的编码情况, 使用什么语言及统计时长</li>\n<li><a href=\"https://bestofjs.org/\" target=\"_blank\" rel=\"noopener\">Best of JavaScript</a> - 最流行的前端开源项目清单</li>\n<li><a href=\"https://lanhuapp.com/\" target=\"_blank\" rel=\"noopener\">蓝湖</a> - 高效的产品设计协作平台, 标注切图很好用</li>\n</ul>\n<h3 id=\"Docs\"><a href=\"#Docs\" class=\"headerlink\" title=\"Docs\"></a>Docs</h3><ul>\n<li><p><strong>React</strong></p>\n<ul>\n<li><a href=\"https://doc.react-china.org/docs/hello-world.html\" target=\"_blank\" rel=\"noopener\">React 中文文档</a></li>\n<li><a href=\"https://www.kancloud.cn/allanyu/redux-in-chinese/82399\" target=\"_blank\" rel=\"noopener\">Redux 中文文档</a></li>\n<li><a href=\"http://leonshi.com/redux-saga-in-chinese/docs/api/index.html\" target=\"_blank\" rel=\"noopener\">React-saga 中文文档</a></li>\n<li><a href=\"https://react-guide.github.io/react-router-cn\" target=\"_blank\" rel=\"noopener\">React-router 中文文档</a></li>\n<li><a href=\"https://suprise.gitbooks.io/mobx-cn/content/fp.html\" target=\"_blank\" rel=\"noopener\">Mobx 中文文档</a></li>\n<li><a href=\"https://ant.design/docs/react/introduce-cn\" target=\"_blank\" rel=\"noopener\">Ant-design 文档</a></li>\n<li><a href=\"http://reactnative.cn/docs/0.50/getting-started.html\" target=\"_blank\" rel=\"noopener\">React-Native 文档</a></li>\n</ul>\n</li>\n<li><p><strong>Vue.js</strong></p>\n<ul>\n<li><a href=\"https://cn.vuejs.org/v2/guide/\" target=\"_blank\" rel=\"noopener\">Vue.js 官网</a></li>\n<li><a href=\"https://router.vuejs.org/zh-cn/\" target=\"_blank\" rel=\"noopener\">Vue-Router</a></li>\n<li><a href=\"https://vuex.vuejs.org/zh-cn/\" target=\"_blank\" rel=\"noopener\">Vuex</a></li>\n<li><a href=\"https://ssr.vuejs.org/zh/\" target=\"_blank\" rel=\"noopener\">Vue-SSR 服务器端渲染</a></li>\n<li><a href=\"https://zh.nuxtjs.org/guide/installation\" target=\"_blank\" rel=\"noopener\">Vue-NUXT</a></li>\n</ul>\n</li>\n<li><p><strong>Node.js</strong></p>\n<ul>\n<li><a href=\"http://nodejs.cn/api/\" target=\"_blank\" rel=\"noopener\">Node.js API</a></li>\n<li><a href=\"http://www.expressjs.com.cn/guide/routing.html\" target=\"_blank\" rel=\"noopener\">Express 官网</a></li>\n</ul>\n</li>\n<li><p><strong>Electron</strong></p>\n<ul>\n<li><a href=\"https://electronjs.org/docs/\" target=\"_blank\" rel=\"noopener\">Electron 官方文档</a></li>\n</ul>\n</li>\n<li><p><strong>WeChat</strong></p>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/debug/wxadoc/dev/index.html?t=201832\" target=\"_blank\" rel=\"noopener\">小程序官方文档</a></li>\n</ul>\n</li>\n<li><p><strong>TypeScript</strong></p>\n<ul>\n<li><a href=\"https://www.tslang.cn/index.html\" target=\"_blank\" rel=\"noopener\">TypeScript 中文网</a></li>\n</ul>\n</li>\n<li><p><strong>Vanilla JS</strong></p>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000012646488\" target=\"_blank\" rel=\"noopener\">JavaScript 基础进阶系列</a></li>\n<li><a href=\"https://github.com/wangfupeng1988/js-async-tutorial\" target=\"_blank\" rel=\"noopener\">深入理解 JS 异步</a></li>\n<li><a href=\"https://www.cnblogs.com/tomxu/archive/2011/12/15/2288411.html\" target=\"_blank\" rel=\"noopener\">深入理解 JS (Tom)</a></li>\n</ul>\n</li>\n<li><p><strong>Webpack</strong></p>\n<ul>\n<li><a href=\"http://www.css88.com/doc/webpack/\" target=\"_blank\" rel=\"noopener\">Webpack 3.x</a></li>\n<li><a href=\"http://www.css88.com/doc/webpack2/api/loaders/#version\" target=\"_blank\" rel=\"noopener\">Webpack 2.x</a></li>\n</ul>\n</li>\n<li><p><strong>Python</strong></p>\n<ul>\n<li><a href=\"https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000\" target=\"_blank\" rel=\"noopener\">Python 3 教程 (廖雪峰)</a></li>\n<li><a href=\"https://docs.djangoproject.com/zh-hans/2.0/\" target=\"_blank\" rel=\"noopener\">Django 中文文档</a></li>\n</ul>\n</li>\n<li><p><strong>More…</strong></p>\n<ul>\n<li><a href=\"https://docschina.org/\" target=\"_blank\" rel=\"noopener\">印记中文</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"One-more-thing\"><a href=\"#One-more-thing\" class=\"headerlink\" title=\"One more thing\"></a>One more thing</h3><p>欢迎在下面留言板分享你觉得有趣的所有东西, 本文<a href=\"https://raw.githubusercontent.com/ifyour/ifyour.github.io/src/source/docs/index.md\" target=\"_blank\" rel=\"noopener\">源代码地址</a>. 😎</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Interesting-tools\"><a href=\"#Interesting-tools\" class=\"headerlink\" title=\"Interesting tools\"></a>Interesting tools</h3><ul>\n<li><a href=\"https://devhints.io/\" target=\"_blank\" rel=\"noopener\">Rico’s cheatsheets</a> - 记忆小抄, 长话短说各种开发文档</li>\n<li><a href=\"https://carbon.now.sh/\" target=\"_blank\" rel=\"noopener\">Carbon</a> - 带样式分享代码</li>\n<li><a href=\"https://codepen.io/pen/\" target=\"_blank\" rel=\"noopener\">CodePen</a> - 在线测试前端代码</li>\n<li><a href=\"https://codesandbox.io/s/\" target=\"_blank\" rel=\"noopener\">CodeSandbox</a> - 代码沙盒，可以分享带有依赖的前端项目</li>\n<li><a href=\"https://prettier.io/playground/\" target=\"_blank\" rel=\"noopener\">Prettier</a> - 在线格式化 JavaScript 代码</li>\n<li><a href=\"https://text-formatter.herokuapp.com/\" target=\"_blank\" rel=\"noopener\">Text-formatter</a> - 格式化文本, 中英文之间留空格以及英文标点</li>\n<li><a href=\"https://devdocs.io/\" target=\"_blank\" rel=\"noopener\">DevDocs</a> - 一站式开发文档集合</li>\n<li><a href=\"https://app.grammarly.com/\" target=\"_blank\" rel=\"noopener\">Grammarly</a> - 英文语法错误检查</li>\n<li><a href=\"http://jsonplaceholder.typicode.com/\" target=\"_blank\" rel=\"noopener\">JSONPlaceholder</a> - RESTful API 假数据模拟</li>\n<li><a href=\"https://www.json2yaml.com/\" target=\"_blank\" rel=\"noopener\">JSON2YAML</a> - JSON 和 YAML 互转</li>\n<li><a href=\"http://json.parser.online.fr/beta/\" target=\"_blank\" rel=\"noopener\">JSON Parser</a> - JSON 格式化</li>\n<li><a href=\"https://regexr.com/\" target=\"_blank\" rel=\"noopener\">RegExr</a> - 在线正则测试及调试</li>\n<li><a href=\"https://jex.im/regulex/\" target=\"_blank\" rel=\"noopener\">Regulex</a> - 正则表达可视化, 快速理解正则表达式</li>\n<li><a href=\"https://www.cssmatic.com/\" target=\"_blank\" rel=\"noopener\">CSSMatic</a> - 生成镜像渐变, 盒子阴影等</li>\n<li><a href=\"https://cssgradient.io/\" target=\"_blank\" rel=\"noopener\">CSS Gradient</a> - 专业生成镜像渐变、线性渐变</li>\n<li><a href=\"https://www.sassmeister.com/\" target=\"_blank\" rel=\"noopener\">SassMeister</a> - Sass 演练场, 可以输出 AutoPrefixer 的结果</li>\n<li><a href=\"https://keyframes.app/\" target=\"_blank\" rel=\"noopener\">KeyframesApp</a> - CSS3 动画关键帧生成工具</li>\n<li><a href=\"https://www.toptal.com/developers/css/sprite-generator\" target=\"_blank\" rel=\"noopener\">CSS Sprites Generator</a> - CSS 精灵生成工具</li>\n<li><a href=\"http://www.jsnice.org/\" target=\"_blank\" rel=\"noopener\">JSNice</a> - 反编译已压缩的 JS 代码, 理解变量含义</li>\n<li><a href=\"https://love2.io/\" target=\"_blank\" rel=\"noopener\">Love2.io</a> - 开源技术文档分享平台</li>\n<li><a href=\"https://wakatime.com/\" target=\"_blank\" rel=\"noopener\">WakaTime</a> - 记录每天的编码情况, 使用什么语言及统计时长</li>\n<li><a href=\"https://bestofjs.org/\" target=\"_blank\" rel=\"noopener\">Best of JavaScript</a> - 最流行的前端开源项目清单</li>\n<li><a href=\"https://lanhuapp.com/\" target=\"_blank\" rel=\"noopener\">蓝湖</a> - 高效的产品设计协作平台, 标注切图很好用</li>\n</ul>\n<h3 id=\"Docs\"><a href=\"#Docs\" class=\"headerlink\" title=\"Docs\"></a>Docs</h3><ul>\n<li><p><strong>React</strong></p>\n<ul>\n<li><a href=\"https://doc.react-china.org/docs/hello-world.html\" target=\"_blank\" rel=\"noopener\">React 中文文档</a></li>\n<li><a href=\"https://www.kancloud.cn/allanyu/redux-in-chinese/82399\" target=\"_blank\" rel=\"noopener\">Redux 中文文档</a></li>\n<li><a href=\"http://leonshi.com/redux-saga-in-chinese/docs/api/index.html\" target=\"_blank\" rel=\"noopener\">React-saga 中文文档</a></li>\n<li><a href=\"https://react-guide.github.io/react-router-cn\" target=\"_blank\" rel=\"noopener\">React-router 中文文档</a></li>\n<li><a href=\"https://suprise.gitbooks.io/mobx-cn/content/fp.html\" target=\"_blank\" rel=\"noopener\">Mobx 中文文档</a></li>\n<li><a href=\"https://ant.design/docs/react/introduce-cn\" target=\"_blank\" rel=\"noopener\">Ant-design 文档</a></li>\n<li><a href=\"http://reactnative.cn/docs/0.50/getting-started.html\" target=\"_blank\" rel=\"noopener\">React-Native 文档</a></li>\n</ul>\n</li>\n<li><p><strong>Vue.js</strong></p>\n<ul>\n<li><a href=\"https://cn.vuejs.org/v2/guide/\" target=\"_blank\" rel=\"noopener\">Vue.js 官网</a></li>\n<li><a href=\"https://router.vuejs.org/zh-cn/\" target=\"_blank\" rel=\"noopener\">Vue-Router</a></li>\n<li><a href=\"https://vuex.vuejs.org/zh-cn/\" target=\"_blank\" rel=\"noopener\">Vuex</a></li>\n<li><a href=\"https://ssr.vuejs.org/zh/\" target=\"_blank\" rel=\"noopener\">Vue-SSR 服务器端渲染</a></li>\n<li><a href=\"https://zh.nuxtjs.org/guide/installation\" target=\"_blank\" rel=\"noopener\">Vue-NUXT</a></li>\n</ul>\n</li>\n<li><p><strong>Node.js</strong></p>\n<ul>\n<li><a href=\"http://nodejs.cn/api/\" target=\"_blank\" rel=\"noopener\">Node.js API</a></li>\n<li><a href=\"http://www.expressjs.com.cn/guide/routing.html\" target=\"_blank\" rel=\"noopener\">Express 官网</a></li>\n</ul>\n</li>\n<li><p><strong>Electron</strong></p>\n<ul>\n<li><a href=\"https://electronjs.org/docs/\" target=\"_blank\" rel=\"noopener\">Electron 官方文档</a></li>\n</ul>\n</li>\n<li><p><strong>WeChat</strong></p>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/debug/wxadoc/dev/index.html?t=201832\" target=\"_blank\" rel=\"noopener\">小程序官方文档</a></li>\n</ul>\n</li>\n<li><p><strong>TypeScript</strong></p>\n<ul>\n<li><a href=\"https://www.tslang.cn/index.html\" target=\"_blank\" rel=\"noopener\">TypeScript 中文网</a></li>\n</ul>\n</li>\n<li><p><strong>Vanilla JS</strong></p>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000012646488\" target=\"_blank\" rel=\"noopener\">JavaScript 基础进阶系列</a></li>\n<li><a href=\"https://github.com/wangfupeng1988/js-async-tutorial\" target=\"_blank\" rel=\"noopener\">深入理解 JS 异步</a></li>\n<li><a href=\"https://www.cnblogs.com/tomxu/archive/2011/12/15/2288411.html\" target=\"_blank\" rel=\"noopener\">深入理解 JS (Tom)</a></li>\n</ul>\n</li>\n<li><p><strong>Webpack</strong></p>\n<ul>\n<li><a href=\"http://www.css88.com/doc/webpack/\" target=\"_blank\" rel=\"noopener\">Webpack 3.x</a></li>\n<li><a href=\"http://www.css88.com/doc/webpack2/api/loaders/#version\" target=\"_blank\" rel=\"noopener\">Webpack 2.x</a></li>\n</ul>\n</li>\n<li><p><strong>Python</strong></p>\n<ul>\n<li><a href=\"https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000\" target=\"_blank\" rel=\"noopener\">Python 3 教程 (廖雪峰)</a></li>\n<li><a href=\"https://docs.djangoproject.com/zh-hans/2.0/\" target=\"_blank\" rel=\"noopener\">Django 中文文档</a></li>\n</ul>\n</li>\n<li><p><strong>More…</strong></p>\n<ul>\n<li><a href=\"https://docschina.org/\" target=\"_blank\" rel=\"noopener\">印记中文</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"One-more-thing\"><a href=\"#One-more-thing\" class=\"headerlink\" title=\"One more thing\"></a>One more thing</h3><p>欢迎在下面留言板分享你觉得有趣的所有东西, 本文<a href=\"https://raw.githubusercontent.com/ifyour/ifyour.github.io/src/source/docs/index.md\" target=\"_blank\" rel=\"noopener\">源代码地址</a>. 😎</p>\n"},{"title":"categories","date":"2015-12-27T14:33:51.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2015-12-27 22:33:51\ntype: \"categories\"\ncomments: false\n---\n","updated":"2018-12-26T16:01:04.000Z","path":"categories/index.html","layout":"page","_id":"ck3v60jt70004r9q9oi8glts8","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"7 招轻松搞定 JavaScript 多行字符串拼接","date":"2016-01-06T13:24:40.000Z","comments":0,"_content":"\n平常在做项目的时候，会经常遇到多行字符串拼接的需求，例如，我需要处理一个 `li` 标签动态拼接显示到 `ul` 中，等等，像这样的需求场景还是非常多的，这就需要根据在项目中实际遇到的需求来处理，选择合适的拼接方式会大大提高开发效率并减少出错的可能，在这里我总结了 7 招字符串拼接方法。\n\n<!-- more -->\n#### 需求场景\n在项目中，动态处理分页，根据系统设定的显示条目确定有多少分页，这时，需要将分页的内容经过处理动态生成再放回到原来的 `ul` 中，这时就需要进行多行字符串的拼接。\n\n```html\n<li><a href=\"#\">上页</a></li>\n<li><a href=\"#\"> 1 </a></li>\n<li><a href=\"#\">下页</a></li>\n```\n对于这样的 DOM 结构需要在 JavaScript 中拼接，你会怎样处理？\n#### 常规方法\n```js\nvar s=`<li><a href=\"\">上页</a></li><li><a href=\"\">1</a></li><li><a href=\"\">下页</a></li>`;\n```\n#### 字符串相加\n```js\nvar str = `<li><a href=\"#\">上页</a></li>` +\n          `<li><a href=\"#\"> 1 </a></li>` +\n          `<li><a href=\"#\">下页</a></li>`;\n```\n\n#### 反斜杠\n```js\nvar str = `<li><a href=\"#\">上页</a></li>\\\n          <li><a href=\"#\"> 1 </a></li>\\\n          <li><a href=\"#\">下页</a></li>`;\n```\n\n#### 数组切割\n```js\nvar str = [\n    `<li><a href=\"#\">上页</a></li>`,\n    `<li><a href=\"#\"> 1 </a></li>`,\n    `<li><a href=\"#\">下页</a></li>`\n].join('\\n');\n```\n\n#### ES6 语法\n```js\nvar str = `<li><a href=\"#\">上页</a></li>\n          <li><a href=\"#\"> 1 </a></li>\n          <li><a href=\"#\">下页</a></li>`\n```\n\n#### 正则表达式\n```text\n查找：\\n\n替换：\\\\\\n\n通过正则表达式把原有的换行 \\n 替换成了 \\\\\\n 带有反斜杠的换行，本质是和反斜杠方法一样\n```\n![](http://ww3.sinaimg.cn/large/6057861cgw1fbn70seheej218s0v8n0x.jpg)\n\n#### 黑魔法\n```js\nfunction aHereDoc() {/*\n    <li><a href=\"#\">上页</a></li>\n    <li><a href=\"#\"> 1 </a></li>\n    <li><a href=\"#\">下页</a></li>\n    */}\n\nfunction hereDoc(func) {\n    return func.toString().split(/\\n/).slice(1, -1).join('\\n');\n}\nconsole.log(hereDoc(aHereDoc));\n```\n利用 `func.toString()` 获取需要批量处理的字符串，利用 `split(/\\n/).slice(1, -1)` 去掉首尾两行函数定义的代码，控制台输出：\n![](http://ww3.sinaimg.cn/large/6057861cgw1fbn6ta8s3yj21460b5jt0.jpg)\n","source":"_posts/7招轻松搞定-JavaScript-多行字符串拼接.md","raw":"---\ntitle: '7 招轻松搞定 JavaScript 多行字符串拼接'\ndate: 2016-01-06 21:24:40\ntags:\ncomments: false\n---\n\n平常在做项目的时候，会经常遇到多行字符串拼接的需求，例如，我需要处理一个 `li` 标签动态拼接显示到 `ul` 中，等等，像这样的需求场景还是非常多的，这就需要根据在项目中实际遇到的需求来处理，选择合适的拼接方式会大大提高开发效率并减少出错的可能，在这里我总结了 7 招字符串拼接方法。\n\n<!-- more -->\n#### 需求场景\n在项目中，动态处理分页，根据系统设定的显示条目确定有多少分页，这时，需要将分页的内容经过处理动态生成再放回到原来的 `ul` 中，这时就需要进行多行字符串的拼接。\n\n```html\n<li><a href=\"#\">上页</a></li>\n<li><a href=\"#\"> 1 </a></li>\n<li><a href=\"#\">下页</a></li>\n```\n对于这样的 DOM 结构需要在 JavaScript 中拼接，你会怎样处理？\n#### 常规方法\n```js\nvar s=`<li><a href=\"\">上页</a></li><li><a href=\"\">1</a></li><li><a href=\"\">下页</a></li>`;\n```\n#### 字符串相加\n```js\nvar str = `<li><a href=\"#\">上页</a></li>` +\n          `<li><a href=\"#\"> 1 </a></li>` +\n          `<li><a href=\"#\">下页</a></li>`;\n```\n\n#### 反斜杠\n```js\nvar str = `<li><a href=\"#\">上页</a></li>\\\n          <li><a href=\"#\"> 1 </a></li>\\\n          <li><a href=\"#\">下页</a></li>`;\n```\n\n#### 数组切割\n```js\nvar str = [\n    `<li><a href=\"#\">上页</a></li>`,\n    `<li><a href=\"#\"> 1 </a></li>`,\n    `<li><a href=\"#\">下页</a></li>`\n].join('\\n');\n```\n\n#### ES6 语法\n```js\nvar str = `<li><a href=\"#\">上页</a></li>\n          <li><a href=\"#\"> 1 </a></li>\n          <li><a href=\"#\">下页</a></li>`\n```\n\n#### 正则表达式\n```text\n查找：\\n\n替换：\\\\\\n\n通过正则表达式把原有的换行 \\n 替换成了 \\\\\\n 带有反斜杠的换行，本质是和反斜杠方法一样\n```\n![](http://ww3.sinaimg.cn/large/6057861cgw1fbn70seheej218s0v8n0x.jpg)\n\n#### 黑魔法\n```js\nfunction aHereDoc() {/*\n    <li><a href=\"#\">上页</a></li>\n    <li><a href=\"#\"> 1 </a></li>\n    <li><a href=\"#\">下页</a></li>\n    */}\n\nfunction hereDoc(func) {\n    return func.toString().split(/\\n/).slice(1, -1).join('\\n');\n}\nconsole.log(hereDoc(aHereDoc));\n```\n利用 `func.toString()` 获取需要批量处理的字符串，利用 `split(/\\n/).slice(1, -1)` 去掉首尾两行函数定义的代码，控制台输出：\n![](http://ww3.sinaimg.cn/large/6057861cgw1fbn6ta8s3yj21460b5jt0.jpg)\n","slug":"7招轻松搞定-JavaScript-多行字符串拼接","published":1,"updated":"2019-12-07T04:59:33.501Z","layout":"post","photos":[],"link":"","_id":"ck3v60jt20001r9q9n4y5t2y3","content":"<p>平常在做项目的时候，会经常遇到多行字符串拼接的需求，例如，我需要处理一个 <code>li</code> 标签动态拼接显示到 <code>ul</code> 中，等等，像这样的需求场景还是非常多的，这就需要根据在项目中实际遇到的需求来处理，选择合适的拼接方式会大大提高开发效率并减少出错的可能，在这里我总结了 7 招字符串拼接方法。</p>\n<a id=\"more\"></a>\n<h4 id=\"需求场景\"><a href=\"#需求场景\" class=\"headerlink\" title=\"需求场景\"></a>需求场景</h4><p>在项目中，动态处理分页，根据系统设定的显示条目确定有多少分页，这时，需要将分页的内容经过处理动态生成再放回到原来的 <code>ul</code> 中，这时就需要进行多行字符串的拼接。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#\"</span>&gt;</span>上页<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#\"</span>&gt;</span> 1 <span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#\"</span>&gt;</span>下页<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>对于这样的 DOM 结构需要在 JavaScript 中拼接，你会怎样处理？</p>\n<h4 id=\"常规方法\"><a href=\"#常规方法\" class=\"headerlink\" title=\"常规方法\"></a>常规方法</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s=<span class=\"string\">`&lt;li&gt;&lt;a href=\"\"&gt;上页&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=\"\"&gt;1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=\"\"&gt;下页&lt;/a&gt;&lt;/li&gt;`</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"字符串相加\"><a href=\"#字符串相加\" class=\"headerlink\" title=\"字符串相加\"></a>字符串相加</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">`&lt;li&gt;&lt;a href=\"#\"&gt;上页&lt;/a&gt;&lt;/li&gt;`</span> +</span><br><span class=\"line\">          <span class=\"string\">`&lt;li&gt;&lt;a href=\"#\"&gt; 1 &lt;/a&gt;&lt;/li&gt;`</span> +</span><br><span class=\"line\">          <span class=\"string\">`&lt;li&gt;&lt;a href=\"#\"&gt;下页&lt;/a&gt;&lt;/li&gt;`</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"反斜杠\"><a href=\"#反斜杠\" class=\"headerlink\" title=\"反斜杠\"></a>反斜杠</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">`&lt;li&gt;&lt;a href=\"#\"&gt;上页&lt;/a&gt;&lt;/li&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">          &lt;li&gt;&lt;a href=\"#\"&gt; 1 &lt;/a&gt;&lt;/li&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">          &lt;li&gt;&lt;a href=\"#\"&gt;下页&lt;/a&gt;&lt;/li&gt;`</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"数组切割\"><a href=\"#数组切割\" class=\"headerlink\" title=\"数组切割\"></a>数组切割</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = [</span><br><span class=\"line\">    <span class=\"string\">`&lt;li&gt;&lt;a href=\"#\"&gt;上页&lt;/a&gt;&lt;/li&gt;`</span>,</span><br><span class=\"line\">    <span class=\"string\">`&lt;li&gt;&lt;a href=\"#\"&gt; 1 &lt;/a&gt;&lt;/li&gt;`</span>,</span><br><span class=\"line\">    <span class=\"string\">`&lt;li&gt;&lt;a href=\"#\"&gt;下页&lt;/a&gt;&lt;/li&gt;`</span></span><br><span class=\"line\">].join(<span class=\"string\">'\\n'</span>);</span><br></pre></td></tr></table></figure>\n<h4 id=\"ES6-语法\"><a href=\"#ES6-语法\" class=\"headerlink\" title=\"ES6 语法\"></a>ES6 语法</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">`&lt;li&gt;&lt;a href=\"#\"&gt;上页&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">          &lt;li&gt;&lt;a href=\"#\"&gt; 1 &lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">          &lt;li&gt;&lt;a href=\"#\"&gt;下页&lt;/a&gt;&lt;/li&gt;`</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">查找：\\n</span><br><span class=\"line\">替换：\\\\\\n</span><br><span class=\"line\">通过正则表达式把原有的换行 \\n 替换成了 \\\\\\n 带有反斜杠的换行，本质是和反斜杠方法一样</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://ww3.sinaimg.cn/large/6057861cgw1fbn70seheej218s0v8n0x.jpg\" alt=\"\"></p>\n<h4 id=\"黑魔法\"><a href=\"#黑魔法\" class=\"headerlink\" title=\"黑魔法\"></a>黑魔法</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">aHereDoc</span>(<span class=\"params\"></span>) </span>&#123;<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    &lt;li&gt;&lt;a href=\"#\"&gt;上页&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"comment\">    &lt;li&gt;&lt;a href=\"#\"&gt; 1 &lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"comment\">    &lt;li&gt;&lt;a href=\"#\"&gt;下页&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"comment\">    */</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">hereDoc</span>(<span class=\"params\">func</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> func.toString().split(<span class=\"regexp\">/\\n/</span>).slice(<span class=\"number\">1</span>, <span class=\"number\">-1</span>).join(<span class=\"string\">'\\n'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(hereDoc(aHereDoc));</span><br></pre></td></tr></table></figure>\n<p>利用 <code>func.toString()</code> 获取需要批量处理的字符串，利用 <code>split(/\\n/).slice(1, -1)</code> 去掉首尾两行函数定义的代码，控制台输出：<br><img src=\"http://ww3.sinaimg.cn/large/6057861cgw1fbn6ta8s3yj21460b5jt0.jpg\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<p>平常在做项目的时候，会经常遇到多行字符串拼接的需求，例如，我需要处理一个 <code>li</code> 标签动态拼接显示到 <code>ul</code> 中，等等，像这样的需求场景还是非常多的，这就需要根据在项目中实际遇到的需求来处理，选择合适的拼接方式会大大提高开发效率并减少出错的可能，在这里我总结了 7 招字符串拼接方法。</p>","more":"<h4 id=\"需求场景\"><a href=\"#需求场景\" class=\"headerlink\" title=\"需求场景\"></a>需求场景</h4><p>在项目中，动态处理分页，根据系统设定的显示条目确定有多少分页，这时，需要将分页的内容经过处理动态生成再放回到原来的 <code>ul</code> 中，这时就需要进行多行字符串的拼接。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#\"</span>&gt;</span>上页<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#\"</span>&gt;</span> 1 <span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#\"</span>&gt;</span>下页<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>对于这样的 DOM 结构需要在 JavaScript 中拼接，你会怎样处理？</p>\n<h4 id=\"常规方法\"><a href=\"#常规方法\" class=\"headerlink\" title=\"常规方法\"></a>常规方法</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s=<span class=\"string\">`&lt;li&gt;&lt;a href=\"\"&gt;上页&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=\"\"&gt;1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=\"\"&gt;下页&lt;/a&gt;&lt;/li&gt;`</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"字符串相加\"><a href=\"#字符串相加\" class=\"headerlink\" title=\"字符串相加\"></a>字符串相加</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">`&lt;li&gt;&lt;a href=\"#\"&gt;上页&lt;/a&gt;&lt;/li&gt;`</span> +</span><br><span class=\"line\">          <span class=\"string\">`&lt;li&gt;&lt;a href=\"#\"&gt; 1 &lt;/a&gt;&lt;/li&gt;`</span> +</span><br><span class=\"line\">          <span class=\"string\">`&lt;li&gt;&lt;a href=\"#\"&gt;下页&lt;/a&gt;&lt;/li&gt;`</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"反斜杠\"><a href=\"#反斜杠\" class=\"headerlink\" title=\"反斜杠\"></a>反斜杠</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">`&lt;li&gt;&lt;a href=\"#\"&gt;上页&lt;/a&gt;&lt;/li&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">          &lt;li&gt;&lt;a href=\"#\"&gt; 1 &lt;/a&gt;&lt;/li&gt;\\</span></span><br><span class=\"line\"><span class=\"string\">          &lt;li&gt;&lt;a href=\"#\"&gt;下页&lt;/a&gt;&lt;/li&gt;`</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"数组切割\"><a href=\"#数组切割\" class=\"headerlink\" title=\"数组切割\"></a>数组切割</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = [</span><br><span class=\"line\">    <span class=\"string\">`&lt;li&gt;&lt;a href=\"#\"&gt;上页&lt;/a&gt;&lt;/li&gt;`</span>,</span><br><span class=\"line\">    <span class=\"string\">`&lt;li&gt;&lt;a href=\"#\"&gt; 1 &lt;/a&gt;&lt;/li&gt;`</span>,</span><br><span class=\"line\">    <span class=\"string\">`&lt;li&gt;&lt;a href=\"#\"&gt;下页&lt;/a&gt;&lt;/li&gt;`</span></span><br><span class=\"line\">].join(<span class=\"string\">'\\n'</span>);</span><br></pre></td></tr></table></figure>\n<h4 id=\"ES6-语法\"><a href=\"#ES6-语法\" class=\"headerlink\" title=\"ES6 语法\"></a>ES6 语法</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">`&lt;li&gt;&lt;a href=\"#\"&gt;上页&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">          &lt;li&gt;&lt;a href=\"#\"&gt; 1 &lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">          &lt;li&gt;&lt;a href=\"#\"&gt;下页&lt;/a&gt;&lt;/li&gt;`</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">查找：\\n</span><br><span class=\"line\">替换：\\\\\\n</span><br><span class=\"line\">通过正则表达式把原有的换行 \\n 替换成了 \\\\\\n 带有反斜杠的换行，本质是和反斜杠方法一样</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://ww3.sinaimg.cn/large/6057861cgw1fbn70seheej218s0v8n0x.jpg\" alt=\"\"></p>\n<h4 id=\"黑魔法\"><a href=\"#黑魔法\" class=\"headerlink\" title=\"黑魔法\"></a>黑魔法</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">aHereDoc</span>(<span class=\"params\"></span>) </span>&#123;<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    &lt;li&gt;&lt;a href=\"#\"&gt;上页&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"comment\">    &lt;li&gt;&lt;a href=\"#\"&gt; 1 &lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"comment\">    &lt;li&gt;&lt;a href=\"#\"&gt;下页&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"comment\">    */</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">hereDoc</span>(<span class=\"params\">func</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> func.toString().split(<span class=\"regexp\">/\\n/</span>).slice(<span class=\"number\">1</span>, <span class=\"number\">-1</span>).join(<span class=\"string\">'\\n'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(hereDoc(aHereDoc));</span><br></pre></td></tr></table></figure>\n<p>利用 <code>func.toString()</code> 获取需要批量处理的字符串，利用 <code>split(/\\n/).slice(1, -1)</code> 去掉首尾两行函数定义的代码，控制台输出：<br><img src=\"http://ww3.sinaimg.cn/large/6057861cgw1fbn6ta8s3yj21460b5jt0.jpg\" alt=\"\"></p>"},{"title":"Async/await 查漏补缺","comments":1,"date":"2018-07-22T06:44:15.000Z","from":null,"_content":"\n上周末我复习了 Promise 的用法，通过一些实例加深了 Promise 的理解。今天来看下异步编程的终极解决方案 async/await。JavaScript 中的异步操作从最初的 callback 演进到 Promise，再到 Generator，都是逐步的改进，而 async 函数的出现仿佛看到了异步方案的终点，用同步的方式写异步代码。\n\n<!-- more -->\n\n### async 函数\n\n简单解释：async 函数就是 Generator 函数的语法糖。\n\n```js\n// Generator 函数写法\n\nlet promise = function(val) {\n  return new Promise(function(resolve, reject) {\n    setTimeout(() => {\n      console.log(val);\n      resolve(val);\n    }, 1000);\n  });\n};\n\nlet gen = function*() {\n  let p1 = yield promise('1');\n  let p2 = yield promise('2');\n};\n\nlet genF = gen(); // Iterator 对象\ngenF.next(); // => 1\ngenF.next(); // => 2\n```\n\n更多 `yield` 表达式可以看这篇文章：[Generator 函数语法解析](https://juejin.im/post/5a6db41351882573351a8d72)。\n\n使用 async 来改写上面的 `gen` 函数 👇：\n\n```js\nlet gen = async function() {\n  let p1 = await promise('1');\n  let p2 = await promise('2');\n};\n\ngen();\n\n// 输出结果 👇：\n1\n2\n```\n\nasync 函数是在 Generator 函数上进行的改进，语法上 Generator 函数的星号换成了 `async`，`yield` 换成了 `await`。\n\n而 async 也与 Generator 函数 **不同**：\n\n- `async` 自带内置执行器，Generator 函数需要依靠执行器，并且 `async` 可以和普通函数一样，只需要一行\n- 相对 Generator 函数，`async` 和 `await` 语义更清楚\n- 适用性强，`yield` 后只能是 Thunk 函数和 Promise 对象，而 `await` 后可以是 Promise 对象和原始类型的值 (数值、字符串、布尔型等)\n\n### async 作用\n\n寄予 async 函数的期望是希望可以帮助我们解决异步操作问题，所以需要搞清楚 async 函数的返回值是什么。\n\n```js\nasync function asyncAwait() {\n  return 'async await';\n}\n\nlet a = asyncAwait();\nconsole.log(a);\n\n// 输出结果 👇：\nPromise {<resolved>: \"async await\"}\n```\n\n可以看出 async 函数返回的是一个 Promise 对象，如果函数中 return 一个直接量，async 函数会封装成 Promise 对象返回，而如果没有返回值时，async 函数会返回 `undefined`:\n\n```js\n// 没有返回值时的输出结果 👇：\nPromise {<resolved>: undefined}\n```\n\n在没有结合 await 时，async 函数会立即执行，返回一个 Promise 对象。\n\n### await 等待\n\nawait 是个运算符，等待的结果是 Promise 对象或其它值，比如：\n\n```js\nfunction func1() {\n  return 'async';\n}\n\nasync function func2() {\n  return Promise.resolve('await');\n}\n\nasync function asyncAwait() {\n  let f1 = await func1();\n  let f2 = await func2();\n  console.log(f1, f2);\n}\n\nasyncAwait();\n\n// 输出结果 👇：\nasync await\n```\n\nawait 表达式的运算取决于等待的结果，如果它等到的不是一个 Promise 对象，那运算结果就是它等到的东西, 而如果它等到的是一个 Promise 对象，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为表达式的运算结果。\n\n<div class=\"tip\">**async 函数调用** 会封装在 Promise 中，这也是 await 需要在 async 函数中使用的原因。</div>\n\n### async/await 链式处理\n\n对于多个异步操作中，Promise 的 then 可以解决多层回调问题。\n\n```js\n// Promise 解决多层嵌套问题\n\nfunction ajax(t) {\n  return new Promise(resolve => {\n    setTimeout(() => resolve(t + 200), t);\n  });\n}\n\nfunction step1(t) {\n  console.log(`step1 in ${t}ms`);\n  return ajax(t);\n}\n\nfunction step2(t) {\n  console.log(`step2 in ${t}ms`);\n  return ajax(t);\n}\n\nfunction step3(t) {\n  console.log(`step3 in ${t}ms`);\n  return ajax(t);\n}\n\nfunction submit() {\n  console.time('submit');\n  step1(200)\n    .then(time2 => step2(time2))\n    .then(time3 => step3(time3))\n    .then(result => {\n      console.log(`result is ${result}ms`);\n      console.timeEnd('submit');\n    });\n}\n\nsubmit();\n```\n\n```js\n// async 函数实现，解决多层嵌套\n\nfunction ajax(t) {\n  return new Promise(resolve => {\n    setTimeout(() => resolve(t + 200), t);\n  });\n}\n\nfunction step1(t) {\n  console.log(`step1 in ${t}ms`);\n  return ajax(t);\n}\n\nfunction step2(t) {\n  console.log(`step2 in ${t}ms`);\n  return ajax(t);\n}\n\nfunction step3(t) {\n  console.log(`step3 in ${t}ms`);\n  return ajax(t);\n}\n\nasync function submit() {\n  console.time('submit');\n  const t1 = 200;\n  const t2 = await step1(t1);\n  const t3 = await step2(t2);\n  const result = await step3(t3);\n  console.log(`result is ${result}`);\n  console.timeEnd('submit');\n}\n\nsubmit();\n```\n\n输出结果 👇：\n\n```text\nstep1 in 200ms\nstep2 in 400ms\nstep3 in 600ms\nresult is 800\nsubmit: 1209.85107421875ms\n```\n\n而如果需求变更，每一步的参数都是之前步骤的结果后，async 函数可以写成：\n\n```js\nfunction ajax(t) {\n  return new Promise(resolve => {\n    setTimeout(() => resolve(t + 200), t);\n  });\n}\n\nfunction step1(t1) {\n  console.log(`step1 in ${t1}ms`);\n  return ajax(t1);\n}\n\nfunction step2(t1, t2) {\n  console.log(`step2 in ${t1}ms,${t2}ms`);\n  return ajax(t1 + t2);\n}\n\nfunction step3(t1, t2, t3) {\n  console.log(`step3 in ${t1}ms,${t2}ms,${t3}ms`);\n  return ajax(t1 + t2 + t3);\n}\n\nasync function submit() {\n  console.time('submit');\n  const t1 = 200;\n  const t2 = await step1(t1);\n  const t3 = await step2(t1, t2);\n  const result = await step3(t1, t2, t3);\n  console.log(`result is ${result}`);\n  console.timeEnd('submit');\n}\n\nsubmit();\n```\n\n输出结果 👇：\n\n```text\nstep1 in 200ms\nstep2 in 200ms,400ms\nstep3 in 200ms,400ms,800ms\nresult is 1600\nsubmit: 2210.47998046875ms\n```\n\n### async/await 注意点\n\n1.  `async` 用来声明里面包裹的内容 **能够以同步的方式执行**，`await` 则是进行执行顺序控制，每次执行一个 `await`，阻塞代码执行等待 `await` 返回值，然后再执行之后的 `await`\n2.  `await` 只能用在 `async` 函数之中，用在普通函数中会报错\n3.  `await` 命令后面的 Promise 对象，运行结果可能是 `rejected`，所以最好把 `await` 命令放在 `try...catch` 代码块中\n4.  `await` 后面的表达式如果不是 Promise 实例，`await` 会阻塞后面的代码，然后执行 `async` 外面的同步代码，等同步代码执行完毕后回到 `async` 执行这个表达式作为 `await` 内容，详见这个 [JSFiddle](https://jsfiddle.net/zd4cbfrv/)\n5.  `await` 后面的表达式是一个 Promise 对象，`await` 也会暂停 `async` 后面的代码，先执行 `async` 外面的同步代码，等着 Promise 对象 `fulfilled`，然后把 `resolve` 的参数作为 await 表达式的运算结果，详见[这道](https://github.com/ifyour/learn-javascript/issues/15)面试题\n\n#### async/await 结合 try/catch 写法\n\n```js\nasync function asyncAwait() {\n  try {\n    await promise();\n  } catch (err) {\n    console.log(err);\n  }\n}\n\n// 另一种写法\nasync function asyncAwait() {\n  await promise().catch(function(err) {\n    console.log(err);\n  });\n}\n```\n\n### 总结\n\nAsync/await 是 ES7 的重要特性之一，也是目前社区里公认的优秀异步解决方案，当你深入了解原理后会发现仿佛看到了异步回调隧道的尽头亮光。\n\n### 参考\n\n- [Generator 函数的语法 @阮一峰《ECMAScript 6 入门》](http://es6.ruanyifeng.com/#docs/generator)\n- [async 函数 @阮一峰《ECMAScript 6 入门》](http://es6.ruanyifeng.com/#docs/async)\n","source":"_posts/Async-await-查漏补缺.md","raw":"---\ntitle: Async/await 查漏补缺\ncomments: true\ndate: 2018-07-22 14:44:15\ntags:\nfrom:\n---\n\n上周末我复习了 Promise 的用法，通过一些实例加深了 Promise 的理解。今天来看下异步编程的终极解决方案 async/await。JavaScript 中的异步操作从最初的 callback 演进到 Promise，再到 Generator，都是逐步的改进，而 async 函数的出现仿佛看到了异步方案的终点，用同步的方式写异步代码。\n\n<!-- more -->\n\n### async 函数\n\n简单解释：async 函数就是 Generator 函数的语法糖。\n\n```js\n// Generator 函数写法\n\nlet promise = function(val) {\n  return new Promise(function(resolve, reject) {\n    setTimeout(() => {\n      console.log(val);\n      resolve(val);\n    }, 1000);\n  });\n};\n\nlet gen = function*() {\n  let p1 = yield promise('1');\n  let p2 = yield promise('2');\n};\n\nlet genF = gen(); // Iterator 对象\ngenF.next(); // => 1\ngenF.next(); // => 2\n```\n\n更多 `yield` 表达式可以看这篇文章：[Generator 函数语法解析](https://juejin.im/post/5a6db41351882573351a8d72)。\n\n使用 async 来改写上面的 `gen` 函数 👇：\n\n```js\nlet gen = async function() {\n  let p1 = await promise('1');\n  let p2 = await promise('2');\n};\n\ngen();\n\n// 输出结果 👇：\n1\n2\n```\n\nasync 函数是在 Generator 函数上进行的改进，语法上 Generator 函数的星号换成了 `async`，`yield` 换成了 `await`。\n\n而 async 也与 Generator 函数 **不同**：\n\n- `async` 自带内置执行器，Generator 函数需要依靠执行器，并且 `async` 可以和普通函数一样，只需要一行\n- 相对 Generator 函数，`async` 和 `await` 语义更清楚\n- 适用性强，`yield` 后只能是 Thunk 函数和 Promise 对象，而 `await` 后可以是 Promise 对象和原始类型的值 (数值、字符串、布尔型等)\n\n### async 作用\n\n寄予 async 函数的期望是希望可以帮助我们解决异步操作问题，所以需要搞清楚 async 函数的返回值是什么。\n\n```js\nasync function asyncAwait() {\n  return 'async await';\n}\n\nlet a = asyncAwait();\nconsole.log(a);\n\n// 输出结果 👇：\nPromise {<resolved>: \"async await\"}\n```\n\n可以看出 async 函数返回的是一个 Promise 对象，如果函数中 return 一个直接量，async 函数会封装成 Promise 对象返回，而如果没有返回值时，async 函数会返回 `undefined`:\n\n```js\n// 没有返回值时的输出结果 👇：\nPromise {<resolved>: undefined}\n```\n\n在没有结合 await 时，async 函数会立即执行，返回一个 Promise 对象。\n\n### await 等待\n\nawait 是个运算符，等待的结果是 Promise 对象或其它值，比如：\n\n```js\nfunction func1() {\n  return 'async';\n}\n\nasync function func2() {\n  return Promise.resolve('await');\n}\n\nasync function asyncAwait() {\n  let f1 = await func1();\n  let f2 = await func2();\n  console.log(f1, f2);\n}\n\nasyncAwait();\n\n// 输出结果 👇：\nasync await\n```\n\nawait 表达式的运算取决于等待的结果，如果它等到的不是一个 Promise 对象，那运算结果就是它等到的东西, 而如果它等到的是一个 Promise 对象，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为表达式的运算结果。\n\n<div class=\"tip\">**async 函数调用** 会封装在 Promise 中，这也是 await 需要在 async 函数中使用的原因。</div>\n\n### async/await 链式处理\n\n对于多个异步操作中，Promise 的 then 可以解决多层回调问题。\n\n```js\n// Promise 解决多层嵌套问题\n\nfunction ajax(t) {\n  return new Promise(resolve => {\n    setTimeout(() => resolve(t + 200), t);\n  });\n}\n\nfunction step1(t) {\n  console.log(`step1 in ${t}ms`);\n  return ajax(t);\n}\n\nfunction step2(t) {\n  console.log(`step2 in ${t}ms`);\n  return ajax(t);\n}\n\nfunction step3(t) {\n  console.log(`step3 in ${t}ms`);\n  return ajax(t);\n}\n\nfunction submit() {\n  console.time('submit');\n  step1(200)\n    .then(time2 => step2(time2))\n    .then(time3 => step3(time3))\n    .then(result => {\n      console.log(`result is ${result}ms`);\n      console.timeEnd('submit');\n    });\n}\n\nsubmit();\n```\n\n```js\n// async 函数实现，解决多层嵌套\n\nfunction ajax(t) {\n  return new Promise(resolve => {\n    setTimeout(() => resolve(t + 200), t);\n  });\n}\n\nfunction step1(t) {\n  console.log(`step1 in ${t}ms`);\n  return ajax(t);\n}\n\nfunction step2(t) {\n  console.log(`step2 in ${t}ms`);\n  return ajax(t);\n}\n\nfunction step3(t) {\n  console.log(`step3 in ${t}ms`);\n  return ajax(t);\n}\n\nasync function submit() {\n  console.time('submit');\n  const t1 = 200;\n  const t2 = await step1(t1);\n  const t3 = await step2(t2);\n  const result = await step3(t3);\n  console.log(`result is ${result}`);\n  console.timeEnd('submit');\n}\n\nsubmit();\n```\n\n输出结果 👇：\n\n```text\nstep1 in 200ms\nstep2 in 400ms\nstep3 in 600ms\nresult is 800\nsubmit: 1209.85107421875ms\n```\n\n而如果需求变更，每一步的参数都是之前步骤的结果后，async 函数可以写成：\n\n```js\nfunction ajax(t) {\n  return new Promise(resolve => {\n    setTimeout(() => resolve(t + 200), t);\n  });\n}\n\nfunction step1(t1) {\n  console.log(`step1 in ${t1}ms`);\n  return ajax(t1);\n}\n\nfunction step2(t1, t2) {\n  console.log(`step2 in ${t1}ms,${t2}ms`);\n  return ajax(t1 + t2);\n}\n\nfunction step3(t1, t2, t3) {\n  console.log(`step3 in ${t1}ms,${t2}ms,${t3}ms`);\n  return ajax(t1 + t2 + t3);\n}\n\nasync function submit() {\n  console.time('submit');\n  const t1 = 200;\n  const t2 = await step1(t1);\n  const t3 = await step2(t1, t2);\n  const result = await step3(t1, t2, t3);\n  console.log(`result is ${result}`);\n  console.timeEnd('submit');\n}\n\nsubmit();\n```\n\n输出结果 👇：\n\n```text\nstep1 in 200ms\nstep2 in 200ms,400ms\nstep3 in 200ms,400ms,800ms\nresult is 1600\nsubmit: 2210.47998046875ms\n```\n\n### async/await 注意点\n\n1.  `async` 用来声明里面包裹的内容 **能够以同步的方式执行**，`await` 则是进行执行顺序控制，每次执行一个 `await`，阻塞代码执行等待 `await` 返回值，然后再执行之后的 `await`\n2.  `await` 只能用在 `async` 函数之中，用在普通函数中会报错\n3.  `await` 命令后面的 Promise 对象，运行结果可能是 `rejected`，所以最好把 `await` 命令放在 `try...catch` 代码块中\n4.  `await` 后面的表达式如果不是 Promise 实例，`await` 会阻塞后面的代码，然后执行 `async` 外面的同步代码，等同步代码执行完毕后回到 `async` 执行这个表达式作为 `await` 内容，详见这个 [JSFiddle](https://jsfiddle.net/zd4cbfrv/)\n5.  `await` 后面的表达式是一个 Promise 对象，`await` 也会暂停 `async` 后面的代码，先执行 `async` 外面的同步代码，等着 Promise 对象 `fulfilled`，然后把 `resolve` 的参数作为 await 表达式的运算结果，详见[这道](https://github.com/ifyour/learn-javascript/issues/15)面试题\n\n#### async/await 结合 try/catch 写法\n\n```js\nasync function asyncAwait() {\n  try {\n    await promise();\n  } catch (err) {\n    console.log(err);\n  }\n}\n\n// 另一种写法\nasync function asyncAwait() {\n  await promise().catch(function(err) {\n    console.log(err);\n  });\n}\n```\n\n### 总结\n\nAsync/await 是 ES7 的重要特性之一，也是目前社区里公认的优秀异步解决方案，当你深入了解原理后会发现仿佛看到了异步回调隧道的尽头亮光。\n\n### 参考\n\n- [Generator 函数的语法 @阮一峰《ECMAScript 6 入门》](http://es6.ruanyifeng.com/#docs/generator)\n- [async 函数 @阮一峰《ECMAScript 6 入门》](http://es6.ruanyifeng.com/#docs/async)\n","slug":"Async-await-查漏补缺","published":1,"updated":"2019-12-07T04:53:18.084Z","layout":"post","photos":[],"link":"","_id":"ck3v60jt60003r9q915pa1whu","content":"<p>上周末我复习了 Promise 的用法，通过一些实例加深了 Promise 的理解。今天来看下异步编程的终极解决方案 async/await。JavaScript 中的异步操作从最初的 callback 演进到 Promise，再到 Generator，都是逐步的改进，而 async 函数的出现仿佛看到了异步方案的终点，用同步的方式写异步代码。</p>\n<a id=\"more\"></a>\n<h3 id=\"async-函数\"><a href=\"#async-函数\" class=\"headerlink\" title=\"async 函数\"></a>async 函数</h3><p>简单解释：async 函数就是 Generator 函数的语法糖。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Generator 函数写法</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> promise = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">val</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(val);</span><br><span class=\"line\">      resolve(val);</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> gen = <span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> p1 = <span class=\"keyword\">yield</span> promise(<span class=\"string\">'1'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> p2 = <span class=\"keyword\">yield</span> promise(<span class=\"string\">'2'</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> genF = gen(); <span class=\"comment\">// Iterator 对象</span></span><br><span class=\"line\">genF.next(); <span class=\"comment\">// =&gt; 1</span></span><br><span class=\"line\">genF.next(); <span class=\"comment\">// =&gt; 2</span></span><br></pre></td></tr></table></figure>\n<p>更多 <code>yield</code> 表达式可以看这篇文章：<a href=\"https://juejin.im/post/5a6db41351882573351a8d72\" target=\"_blank\" rel=\"noopener\">Generator 函数语法解析</a>。</p>\n<p>使用 async 来改写上面的 <code>gen</code> 函数 👇：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> gen = <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> p1 = <span class=\"keyword\">await</span> promise(<span class=\"string\">'1'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> p2 = <span class=\"keyword\">await</span> promise(<span class=\"string\">'2'</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">gen();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出结果 👇：</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<p>async 函数是在 Generator 函数上进行的改进，语法上 Generator 函数的星号换成了 <code>async</code>，<code>yield</code> 换成了 <code>await</code>。</p>\n<p>而 async 也与 Generator 函数 <strong>不同</strong>：</p>\n<ul>\n<li><code>async</code> 自带内置执行器，Generator 函数需要依靠执行器，并且 <code>async</code> 可以和普通函数一样，只需要一行</li>\n<li>相对 Generator 函数，<code>async</code> 和 <code>await</code> 语义更清楚</li>\n<li>适用性强，<code>yield</code> 后只能是 Thunk 函数和 Promise 对象，而 <code>await</code> 后可以是 Promise 对象和原始类型的值 (数值、字符串、布尔型等)</li>\n</ul>\n<h3 id=\"async-作用\"><a href=\"#async-作用\" class=\"headerlink\" title=\"async 作用\"></a>async 作用</h3><p>寄予 async 函数的期望是希望可以帮助我们解决异步操作问题，所以需要搞清楚 async 函数的返回值是什么。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">asyncAwait</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'async await'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> a = asyncAwait();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出结果 👇：</span></span><br><span class=\"line\"><span class=\"built_in\">Promise</span> &#123;&lt;resolved&gt;: <span class=\"string\">\"async await\"</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看出 async 函数返回的是一个 Promise 对象，如果函数中 return 一个直接量，async 函数会封装成 Promise 对象返回，而如果没有返回值时，async 函数会返回 <code>undefined</code>:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 没有返回值时的输出结果 👇：</span></span><br><span class=\"line\"><span class=\"built_in\">Promise</span> &#123;&lt;resolved&gt;: <span class=\"literal\">undefined</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>在没有结合 await 时，async 函数会立即执行，返回一个 Promise 对象。</p>\n<h3 id=\"await-等待\"><a href=\"#await-等待\" class=\"headerlink\" title=\"await 等待\"></a>await 等待</h3><p>await 是个运算符，等待的结果是 Promise 对象或其它值，比如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'async'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'await'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">asyncAwait</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> f1 = <span class=\"keyword\">await</span> func1();</span><br><span class=\"line\">  <span class=\"keyword\">let</span> f2 = <span class=\"keyword\">await</span> func2();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(f1, f2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">asyncAwait();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出结果 👇：</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">await</span></span><br></pre></td></tr></table></figure>\n<p>await 表达式的运算取决于等待的结果，如果它等到的不是一个 Promise 对象，那运算结果就是它等到的东西, 而如果它等到的是一个 Promise 对象，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为表达式的运算结果。</p>\n<div class=\"tip\"><strong>async 函数调用</strong> 会封装在 Promise 中，这也是 await 需要在 async 函数中使用的原因。</div>\n\n<h3 id=\"async-await-链式处理\"><a href=\"#async-await-链式处理\" class=\"headerlink\" title=\"async/await 链式处理\"></a>async/await 链式处理</h3><p>对于多个异步操作中，Promise 的 then 可以解决多层回调问题。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Promise 解决多层嵌套问题</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ajax</span>(<span class=\"params\">t</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> resolve(t + <span class=\"number\">200</span>), t);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">step1</span>(<span class=\"params\">t</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`step1 in <span class=\"subst\">$&#123;t&#125;</span>ms`</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ajax(t);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">step2</span>(<span class=\"params\">t</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`step2 in <span class=\"subst\">$&#123;t&#125;</span>ms`</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ajax(t);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">step3</span>(<span class=\"params\">t</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`step3 in <span class=\"subst\">$&#123;t&#125;</span>ms`</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ajax(t);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">submit</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.time(<span class=\"string\">'submit'</span>);</span><br><span class=\"line\">  step1(<span class=\"number\">200</span>)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"params\">time2</span> =&gt;</span> step2(time2))</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"params\">time3</span> =&gt;</span> step3(time3))</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"params\">result</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">`result is <span class=\"subst\">$&#123;result&#125;</span>ms`</span>);</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'submit'</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">submit();</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// async 函数实现，解决多层嵌套</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ajax</span>(<span class=\"params\">t</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> resolve(t + <span class=\"number\">200</span>), t);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">step1</span>(<span class=\"params\">t</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`step1 in <span class=\"subst\">$&#123;t&#125;</span>ms`</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ajax(t);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">step2</span>(<span class=\"params\">t</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`step2 in <span class=\"subst\">$&#123;t&#125;</span>ms`</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ajax(t);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">step3</span>(<span class=\"params\">t</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`step3 in <span class=\"subst\">$&#123;t&#125;</span>ms`</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ajax(t);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">submit</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.time(<span class=\"string\">'submit'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> t1 = <span class=\"number\">200</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> t2 = <span class=\"keyword\">await</span> step1(t1);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> t3 = <span class=\"keyword\">await</span> step2(t2);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> result = <span class=\"keyword\">await</span> step3(t3);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`result is <span class=\"subst\">$&#123;result&#125;</span>`</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'submit'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">submit();</span><br></pre></td></tr></table></figure>\n<p>输出结果 👇：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">step1 in 200ms</span><br><span class=\"line\">step2 in 400ms</span><br><span class=\"line\">step3 in 600ms</span><br><span class=\"line\">result is 800</span><br><span class=\"line\">submit: 1209.85107421875ms</span><br></pre></td></tr></table></figure>\n<p>而如果需求变更，每一步的参数都是之前步骤的结果后，async 函数可以写成：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ajax</span>(<span class=\"params\">t</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> resolve(t + <span class=\"number\">200</span>), t);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">step1</span>(<span class=\"params\">t1</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`step1 in <span class=\"subst\">$&#123;t1&#125;</span>ms`</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ajax(t1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">step2</span>(<span class=\"params\">t1, t2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`step2 in <span class=\"subst\">$&#123;t1&#125;</span>ms,<span class=\"subst\">$&#123;t2&#125;</span>ms`</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ajax(t1 + t2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">step3</span>(<span class=\"params\">t1, t2, t3</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`step3 in <span class=\"subst\">$&#123;t1&#125;</span>ms,<span class=\"subst\">$&#123;t2&#125;</span>ms,<span class=\"subst\">$&#123;t3&#125;</span>ms`</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ajax(t1 + t2 + t3);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">submit</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.time(<span class=\"string\">'submit'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> t1 = <span class=\"number\">200</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> t2 = <span class=\"keyword\">await</span> step1(t1);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> t3 = <span class=\"keyword\">await</span> step2(t1, t2);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> result = <span class=\"keyword\">await</span> step3(t1, t2, t3);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`result is <span class=\"subst\">$&#123;result&#125;</span>`</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'submit'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">submit();</span><br></pre></td></tr></table></figure>\n<p>输出结果 👇：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">step1 in 200ms</span><br><span class=\"line\">step2 in 200ms,400ms</span><br><span class=\"line\">step3 in 200ms,400ms,800ms</span><br><span class=\"line\">result is 1600</span><br><span class=\"line\">submit: 2210.47998046875ms</span><br></pre></td></tr></table></figure>\n<h3 id=\"async-await-注意点\"><a href=\"#async-await-注意点\" class=\"headerlink\" title=\"async/await 注意点\"></a>async/await 注意点</h3><ol>\n<li><code>async</code> 用来声明里面包裹的内容 <strong>能够以同步的方式执行</strong>，<code>await</code> 则是进行执行顺序控制，每次执行一个 <code>await</code>，阻塞代码执行等待 <code>await</code> 返回值，然后再执行之后的 <code>await</code></li>\n<li><code>await</code> 只能用在 <code>async</code> 函数之中，用在普通函数中会报错</li>\n<li><code>await</code> 命令后面的 Promise 对象，运行结果可能是 <code>rejected</code>，所以最好把 <code>await</code> 命令放在 <code>try...catch</code> 代码块中</li>\n<li><code>await</code> 后面的表达式如果不是 Promise 实例，<code>await</code> 会阻塞后面的代码，然后执行 <code>async</code> 外面的同步代码，等同步代码执行完毕后回到 <code>async</code> 执行这个表达式作为 <code>await</code> 内容，详见这个 <a href=\"https://jsfiddle.net/zd4cbfrv/\" target=\"_blank\" rel=\"noopener\">JSFiddle</a></li>\n<li><code>await</code> 后面的表达式是一个 Promise 对象，<code>await</code> 也会暂停 <code>async</code> 后面的代码，先执行 <code>async</code> 外面的同步代码，等着 Promise 对象 <code>fulfilled</code>，然后把 <code>resolve</code> 的参数作为 await 表达式的运算结果，详见<a href=\"https://github.com/ifyour/learn-javascript/issues/15\" target=\"_blank\" rel=\"noopener\">这道</a>面试题</li>\n</ol>\n<h4 id=\"async-await-结合-try-catch-写法\"><a href=\"#async-await-结合-try-catch-写法\" class=\"headerlink\" title=\"async/await 结合 try/catch 写法\"></a>async/await 结合 try/catch 写法</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">asyncAwait</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> promise();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 另一种写法</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">asyncAwait</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> promise().catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>Async/await 是 ES7 的重要特性之一，也是目前社区里公认的优秀异步解决方案，当你深入了解原理后会发现仿佛看到了异步回调隧道的尽头亮光。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><a href=\"http://es6.ruanyifeng.com/#docs/generator\" target=\"_blank\" rel=\"noopener\">Generator 函数的语法 @阮一峰《ECMAScript 6 入门》</a></li>\n<li><a href=\"http://es6.ruanyifeng.com/#docs/async\" target=\"_blank\" rel=\"noopener\">async 函数 @阮一峰《ECMAScript 6 入门》</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>上周末我复习了 Promise 的用法，通过一些实例加深了 Promise 的理解。今天来看下异步编程的终极解决方案 async/await。JavaScript 中的异步操作从最初的 callback 演进到 Promise，再到 Generator，都是逐步的改进，而 async 函数的出现仿佛看到了异步方案的终点，用同步的方式写异步代码。</p>","more":"<h3 id=\"async-函数\"><a href=\"#async-函数\" class=\"headerlink\" title=\"async 函数\"></a>async 函数</h3><p>简单解释：async 函数就是 Generator 函数的语法糖。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Generator 函数写法</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> promise = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">val</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(val);</span><br><span class=\"line\">      resolve(val);</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> gen = <span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> p1 = <span class=\"keyword\">yield</span> promise(<span class=\"string\">'1'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> p2 = <span class=\"keyword\">yield</span> promise(<span class=\"string\">'2'</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> genF = gen(); <span class=\"comment\">// Iterator 对象</span></span><br><span class=\"line\">genF.next(); <span class=\"comment\">// =&gt; 1</span></span><br><span class=\"line\">genF.next(); <span class=\"comment\">// =&gt; 2</span></span><br></pre></td></tr></table></figure>\n<p>更多 <code>yield</code> 表达式可以看这篇文章：<a href=\"https://juejin.im/post/5a6db41351882573351a8d72\" target=\"_blank\" rel=\"noopener\">Generator 函数语法解析</a>。</p>\n<p>使用 async 来改写上面的 <code>gen</code> 函数 👇：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> gen = <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> p1 = <span class=\"keyword\">await</span> promise(<span class=\"string\">'1'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> p2 = <span class=\"keyword\">await</span> promise(<span class=\"string\">'2'</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">gen();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出结果 👇：</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<p>async 函数是在 Generator 函数上进行的改进，语法上 Generator 函数的星号换成了 <code>async</code>，<code>yield</code> 换成了 <code>await</code>。</p>\n<p>而 async 也与 Generator 函数 <strong>不同</strong>：</p>\n<ul>\n<li><code>async</code> 自带内置执行器，Generator 函数需要依靠执行器，并且 <code>async</code> 可以和普通函数一样，只需要一行</li>\n<li>相对 Generator 函数，<code>async</code> 和 <code>await</code> 语义更清楚</li>\n<li>适用性强，<code>yield</code> 后只能是 Thunk 函数和 Promise 对象，而 <code>await</code> 后可以是 Promise 对象和原始类型的值 (数值、字符串、布尔型等)</li>\n</ul>\n<h3 id=\"async-作用\"><a href=\"#async-作用\" class=\"headerlink\" title=\"async 作用\"></a>async 作用</h3><p>寄予 async 函数的期望是希望可以帮助我们解决异步操作问题，所以需要搞清楚 async 函数的返回值是什么。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">asyncAwait</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'async await'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> a = asyncAwait();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出结果 👇：</span></span><br><span class=\"line\"><span class=\"built_in\">Promise</span> &#123;&lt;resolved&gt;: <span class=\"string\">\"async await\"</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看出 async 函数返回的是一个 Promise 对象，如果函数中 return 一个直接量，async 函数会封装成 Promise 对象返回，而如果没有返回值时，async 函数会返回 <code>undefined</code>:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 没有返回值时的输出结果 👇：</span></span><br><span class=\"line\"><span class=\"built_in\">Promise</span> &#123;&lt;resolved&gt;: <span class=\"literal\">undefined</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>在没有结合 await 时，async 函数会立即执行，返回一个 Promise 对象。</p>\n<h3 id=\"await-等待\"><a href=\"#await-等待\" class=\"headerlink\" title=\"await 等待\"></a>await 等待</h3><p>await 是个运算符，等待的结果是 Promise 对象或其它值，比如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'async'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'await'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">asyncAwait</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> f1 = <span class=\"keyword\">await</span> func1();</span><br><span class=\"line\">  <span class=\"keyword\">let</span> f2 = <span class=\"keyword\">await</span> func2();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(f1, f2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">asyncAwait();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出结果 👇：</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">await</span></span><br></pre></td></tr></table></figure>\n<p>await 表达式的运算取决于等待的结果，如果它等到的不是一个 Promise 对象，那运算结果就是它等到的东西, 而如果它等到的是一个 Promise 对象，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为表达式的运算结果。</p>\n<div class=\"tip\"><strong>async 函数调用</strong> 会封装在 Promise 中，这也是 await 需要在 async 函数中使用的原因。</div>\n\n<h3 id=\"async-await-链式处理\"><a href=\"#async-await-链式处理\" class=\"headerlink\" title=\"async/await 链式处理\"></a>async/await 链式处理</h3><p>对于多个异步操作中，Promise 的 then 可以解决多层回调问题。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Promise 解决多层嵌套问题</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ajax</span>(<span class=\"params\">t</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> resolve(t + <span class=\"number\">200</span>), t);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">step1</span>(<span class=\"params\">t</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`step1 in <span class=\"subst\">$&#123;t&#125;</span>ms`</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ajax(t);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">step2</span>(<span class=\"params\">t</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`step2 in <span class=\"subst\">$&#123;t&#125;</span>ms`</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ajax(t);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">step3</span>(<span class=\"params\">t</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`step3 in <span class=\"subst\">$&#123;t&#125;</span>ms`</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ajax(t);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">submit</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.time(<span class=\"string\">'submit'</span>);</span><br><span class=\"line\">  step1(<span class=\"number\">200</span>)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"params\">time2</span> =&gt;</span> step2(time2))</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"params\">time3</span> =&gt;</span> step3(time3))</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"params\">result</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">`result is <span class=\"subst\">$&#123;result&#125;</span>ms`</span>);</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'submit'</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">submit();</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// async 函数实现，解决多层嵌套</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ajax</span>(<span class=\"params\">t</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> resolve(t + <span class=\"number\">200</span>), t);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">step1</span>(<span class=\"params\">t</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`step1 in <span class=\"subst\">$&#123;t&#125;</span>ms`</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ajax(t);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">step2</span>(<span class=\"params\">t</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`step2 in <span class=\"subst\">$&#123;t&#125;</span>ms`</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ajax(t);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">step3</span>(<span class=\"params\">t</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`step3 in <span class=\"subst\">$&#123;t&#125;</span>ms`</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ajax(t);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">submit</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.time(<span class=\"string\">'submit'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> t1 = <span class=\"number\">200</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> t2 = <span class=\"keyword\">await</span> step1(t1);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> t3 = <span class=\"keyword\">await</span> step2(t2);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> result = <span class=\"keyword\">await</span> step3(t3);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`result is <span class=\"subst\">$&#123;result&#125;</span>`</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'submit'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">submit();</span><br></pre></td></tr></table></figure>\n<p>输出结果 👇：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">step1 in 200ms</span><br><span class=\"line\">step2 in 400ms</span><br><span class=\"line\">step3 in 600ms</span><br><span class=\"line\">result is 800</span><br><span class=\"line\">submit: 1209.85107421875ms</span><br></pre></td></tr></table></figure>\n<p>而如果需求变更，每一步的参数都是之前步骤的结果后，async 函数可以写成：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ajax</span>(<span class=\"params\">t</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> resolve(t + <span class=\"number\">200</span>), t);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">step1</span>(<span class=\"params\">t1</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`step1 in <span class=\"subst\">$&#123;t1&#125;</span>ms`</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ajax(t1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">step2</span>(<span class=\"params\">t1, t2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`step2 in <span class=\"subst\">$&#123;t1&#125;</span>ms,<span class=\"subst\">$&#123;t2&#125;</span>ms`</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ajax(t1 + t2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">step3</span>(<span class=\"params\">t1, t2, t3</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`step3 in <span class=\"subst\">$&#123;t1&#125;</span>ms,<span class=\"subst\">$&#123;t2&#125;</span>ms,<span class=\"subst\">$&#123;t3&#125;</span>ms`</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ajax(t1 + t2 + t3);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">submit</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.time(<span class=\"string\">'submit'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> t1 = <span class=\"number\">200</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> t2 = <span class=\"keyword\">await</span> step1(t1);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> t3 = <span class=\"keyword\">await</span> step2(t1, t2);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> result = <span class=\"keyword\">await</span> step3(t1, t2, t3);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`result is <span class=\"subst\">$&#123;result&#125;</span>`</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'submit'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">submit();</span><br></pre></td></tr></table></figure>\n<p>输出结果 👇：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">step1 in 200ms</span><br><span class=\"line\">step2 in 200ms,400ms</span><br><span class=\"line\">step3 in 200ms,400ms,800ms</span><br><span class=\"line\">result is 1600</span><br><span class=\"line\">submit: 2210.47998046875ms</span><br></pre></td></tr></table></figure>\n<h3 id=\"async-await-注意点\"><a href=\"#async-await-注意点\" class=\"headerlink\" title=\"async/await 注意点\"></a>async/await 注意点</h3><ol>\n<li><code>async</code> 用来声明里面包裹的内容 <strong>能够以同步的方式执行</strong>，<code>await</code> 则是进行执行顺序控制，每次执行一个 <code>await</code>，阻塞代码执行等待 <code>await</code> 返回值，然后再执行之后的 <code>await</code></li>\n<li><code>await</code> 只能用在 <code>async</code> 函数之中，用在普通函数中会报错</li>\n<li><code>await</code> 命令后面的 Promise 对象，运行结果可能是 <code>rejected</code>，所以最好把 <code>await</code> 命令放在 <code>try...catch</code> 代码块中</li>\n<li><code>await</code> 后面的表达式如果不是 Promise 实例，<code>await</code> 会阻塞后面的代码，然后执行 <code>async</code> 外面的同步代码，等同步代码执行完毕后回到 <code>async</code> 执行这个表达式作为 <code>await</code> 内容，详见这个 <a href=\"https://jsfiddle.net/zd4cbfrv/\" target=\"_blank\" rel=\"noopener\">JSFiddle</a></li>\n<li><code>await</code> 后面的表达式是一个 Promise 对象，<code>await</code> 也会暂停 <code>async</code> 后面的代码，先执行 <code>async</code> 外面的同步代码，等着 Promise 对象 <code>fulfilled</code>，然后把 <code>resolve</code> 的参数作为 await 表达式的运算结果，详见<a href=\"https://github.com/ifyour/learn-javascript/issues/15\" target=\"_blank\" rel=\"noopener\">这道</a>面试题</li>\n</ol>\n<h4 id=\"async-await-结合-try-catch-写法\"><a href=\"#async-await-结合-try-catch-写法\" class=\"headerlink\" title=\"async/await 结合 try/catch 写法\"></a>async/await 结合 try/catch 写法</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">asyncAwait</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> promise();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 另一种写法</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">asyncAwait</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> promise().catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>Async/await 是 ES7 的重要特性之一，也是目前社区里公认的优秀异步解决方案，当你深入了解原理后会发现仿佛看到了异步回调隧道的尽头亮光。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><a href=\"http://es6.ruanyifeng.com/#docs/generator\" target=\"_blank\" rel=\"noopener\">Generator 函数的语法 @阮一峰《ECMAScript 6 入门》</a></li>\n<li><a href=\"http://es6.ruanyifeng.com/#docs/async\" target=\"_blank\" rel=\"noopener\">async 函数 @阮一峰《ECMAScript 6 入门》</a></li>\n</ul>"},{"title":"CentOS 6 x86 Node.js + MongoDB + Express 环境配置笔记","date":"2015-01-01T12:18:33.000Z","comments":0,"_content":"\n总体来说配置比较顺利，也踩了不少坑 TAT，毕竟不是专业的运维人员，Linux 经验完全在平常项目中一点点积累的。\n<!-- more -->\n\n<div class=\"tip\">\n    重要提示：本文适用于有一定 Linux 基础的童鞋操作，比如懂得 `ls`、`cd`、`vim`等命令基本用法。\n    适用于操作系统：CentOS-6-x86_64，安装 node v6.9.4，mongodb v3.4.2。\n</div>\n\n### Node.js 安装\n0.进入到待安装位置\n```bash\ncd /usr/local/\n```\n\n1.下载安装文件\n```bash\nwget https://nodejs.org/dist/v6.9.4/node-v6.9.4-linux-x86.tar.xz\n```\n\n2.解压文件\n```bash\nxz -d node-v6.9.4-linux-x86.tar.xz\ntar xvf node-v6.9.4-linux-x86.tar\n```\n3.重命名文件\n```bash\nrm -rf node-v*.tar\nmv node-v* node\n```\n\n\n4.配置环境变量\n```bash\n#编辑系统文件\nvim ~/.bash_profile\n\n#在最顶端添加环境变量地址\nPATH=/usr/local/node/bin:$PATH\n\n#保存后重新启动以生效\nsource ~/.bash_profile\n```\n\n5.验证是否成功，显示版本号即安装成功！\n```bash\nnode -v\n```\n\n### Mongodb 安装\n\n0.进入到待安装位置\n```bash\ncd /usr/local/\n```\n\n1.下载安装文件\n```bash\nwget http://fastdl.mongodb.org/linux/mongodb-linux-x86_64-3.4.2.tgz\n```\n\n2.解压文件\n```bash\ntar zxf mongodb-linux-*.tgz\n```\n\n3.重命名\n```bash\nrm -rf mongodb-*.tgz\nmv mongodb-* mongodb\n```\n\n4.配置环境变量\n```bash\n#编辑系统文件\nvim ~/.bash_profile\n\n#在最顶端添加环境变量地址\nPATH=/usr/local/mongodb/bin:$PATH\n\n#保存后重新启动以生效\nsource ~/.bash_profile\n```\n\n5.验证是否安装成功\n```bash\nmongod --version\n```\n\n6.创建数据库目录和日志目录\n```bash\nmkdir -p /data/db\nmkdir -p /data/logs/mongodb.log\n```\n\n7.新增配置文件 `/data/mongodb.conf`\n```txet\n#数据库文件\ndbpath = /data/\n\n#日志文件\nlogpath = /data/logs/mongodb.log\n\n#默认端口\nport = 27017\n\n#后台运行\nfork = true\n\n#用户授权\nauth = true\n\n#不启用http访问\nnohttpinterface = true\n```\n<div class=\"tip\">\n添加授权后需要在 mongodb 数据库文件的 Users 集合新增用户，才可以正常使用。\n</div>\n\n\n8.在自启动文件 `/etc/rc.local` 中写入 mongod 进程带配置文件启动\n```bash\necho \"/usr/local/mongodb/bin/mongod -f /data/mongodb.conf\" >> /etc/rc.local\n```\n\n9.重启\n```bash\nreboot\n```\n\n\n### Express\n```bash\nnpm i express -g\n```\n","source":"_posts/CentOS-6-x86-Node-js-MongoDB-Express-环境配置笔记.md","raw":"---\ntitle: CentOS 6 x86 Node.js + MongoDB + Express 环境配置笔记\ndate: 2015-1-1 20:18:33\ntags:\ncomments: false\n---\n\n总体来说配置比较顺利，也踩了不少坑 TAT，毕竟不是专业的运维人员，Linux 经验完全在平常项目中一点点积累的。\n<!-- more -->\n\n<div class=\"tip\">\n    重要提示：本文适用于有一定 Linux 基础的童鞋操作，比如懂得 `ls`、`cd`、`vim`等命令基本用法。\n    适用于操作系统：CentOS-6-x86_64，安装 node v6.9.4，mongodb v3.4.2。\n</div>\n\n### Node.js 安装\n0.进入到待安装位置\n```bash\ncd /usr/local/\n```\n\n1.下载安装文件\n```bash\nwget https://nodejs.org/dist/v6.9.4/node-v6.9.4-linux-x86.tar.xz\n```\n\n2.解压文件\n```bash\nxz -d node-v6.9.4-linux-x86.tar.xz\ntar xvf node-v6.9.4-linux-x86.tar\n```\n3.重命名文件\n```bash\nrm -rf node-v*.tar\nmv node-v* node\n```\n\n\n4.配置环境变量\n```bash\n#编辑系统文件\nvim ~/.bash_profile\n\n#在最顶端添加环境变量地址\nPATH=/usr/local/node/bin:$PATH\n\n#保存后重新启动以生效\nsource ~/.bash_profile\n```\n\n5.验证是否成功，显示版本号即安装成功！\n```bash\nnode -v\n```\n\n### Mongodb 安装\n\n0.进入到待安装位置\n```bash\ncd /usr/local/\n```\n\n1.下载安装文件\n```bash\nwget http://fastdl.mongodb.org/linux/mongodb-linux-x86_64-3.4.2.tgz\n```\n\n2.解压文件\n```bash\ntar zxf mongodb-linux-*.tgz\n```\n\n3.重命名\n```bash\nrm -rf mongodb-*.tgz\nmv mongodb-* mongodb\n```\n\n4.配置环境变量\n```bash\n#编辑系统文件\nvim ~/.bash_profile\n\n#在最顶端添加环境变量地址\nPATH=/usr/local/mongodb/bin:$PATH\n\n#保存后重新启动以生效\nsource ~/.bash_profile\n```\n\n5.验证是否安装成功\n```bash\nmongod --version\n```\n\n6.创建数据库目录和日志目录\n```bash\nmkdir -p /data/db\nmkdir -p /data/logs/mongodb.log\n```\n\n7.新增配置文件 `/data/mongodb.conf`\n```txet\n#数据库文件\ndbpath = /data/\n\n#日志文件\nlogpath = /data/logs/mongodb.log\n\n#默认端口\nport = 27017\n\n#后台运行\nfork = true\n\n#用户授权\nauth = true\n\n#不启用http访问\nnohttpinterface = true\n```\n<div class=\"tip\">\n添加授权后需要在 mongodb 数据库文件的 Users 集合新增用户，才可以正常使用。\n</div>\n\n\n8.在自启动文件 `/etc/rc.local` 中写入 mongod 进程带配置文件启动\n```bash\necho \"/usr/local/mongodb/bin/mongod -f /data/mongodb.conf\" >> /etc/rc.local\n```\n\n9.重启\n```bash\nreboot\n```\n\n\n### Express\n```bash\nnpm i express -g\n```\n","slug":"CentOS-6-x86-Node-js-MongoDB-Express-环境配置笔记","published":1,"updated":"2018-12-26T16:01:04.000Z","layout":"post","photos":[],"link":"","_id":"ck3v60jt70005r9q9myt1u00p","content":"<p>总体来说配置比较顺利，也踩了不少坑 TAT，毕竟不是专业的运维人员，Linux 经验完全在平常项目中一点点积累的。<br><a id=\"more\"></a></p>\n<div class=\"tip\"><br>    重要提示：本文适用于有一定 Linux 基础的童鞋操作，比如懂得 <code>ls</code>、<code>cd</code>、<code>vim</code>等命令基本用法。<br>    适用于操作系统：CentOS-6-x86_64，安装 node v6.9.4，mongodb v3.4.2。<br></div>\n\n<h3 id=\"Node-js-安装\"><a href=\"#Node-js-安装\" class=\"headerlink\" title=\"Node.js 安装\"></a>Node.js 安装</h3><p>0.进入到待安装位置<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/</span><br></pre></td></tr></table></figure></p>\n<p>1.下载安装文件<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://nodejs.org/dist/v6.9.4/node-v6.9.4-linux-x86.tar.xz</span><br></pre></td></tr></table></figure></p>\n<p>2.解压文件<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xz -d node-v6.9.4-linux-x86.tar.xz</span><br><span class=\"line\">tar xvf node-v6.9.4-linux-x86.tar</span><br></pre></td></tr></table></figure></p>\n<p>3.重命名文件<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm -rf node-v*.tar</span><br><span class=\"line\">mv node-v* node</span><br></pre></td></tr></table></figure></p>\n<p>4.配置环境变量<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#编辑系统文件</span></span><br><span class=\"line\">vim ~/.bash_profile</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#在最顶端添加环境变量地址</span></span><br><span class=\"line\">PATH=/usr/<span class=\"built_in\">local</span>/node/bin:<span class=\"variable\">$PATH</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#保存后重新启动以生效</span></span><br><span class=\"line\"><span class=\"built_in\">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure></p>\n<p>5.验证是否成功，显示版本号即安装成功！<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node -v</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Mongodb-安装\"><a href=\"#Mongodb-安装\" class=\"headerlink\" title=\"Mongodb 安装\"></a>Mongodb 安装</h3><p>0.进入到待安装位置<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/</span><br></pre></td></tr></table></figure></p>\n<p>1.下载安装文件<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http://fastdl.mongodb.org/linux/mongodb-linux-x86_64-3.4.2.tgz</span><br></pre></td></tr></table></figure></p>\n<p>2.解压文件<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar zxf mongodb-linux-*.tgz</span><br></pre></td></tr></table></figure></p>\n<p>3.重命名<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm -rf mongodb-*.tgz</span><br><span class=\"line\">mv mongodb-* mongodb</span><br></pre></td></tr></table></figure></p>\n<p>4.配置环境变量<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#编辑系统文件</span></span><br><span class=\"line\">vim ~/.bash_profile</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#在最顶端添加环境变量地址</span></span><br><span class=\"line\">PATH=/usr/<span class=\"built_in\">local</span>/mongodb/bin:<span class=\"variable\">$PATH</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#保存后重新启动以生效</span></span><br><span class=\"line\"><span class=\"built_in\">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure></p>\n<p>5.验证是否安装成功<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mongod --version</span><br></pre></td></tr></table></figure></p>\n<p>6.创建数据库目录和日志目录<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir -p /data/db</span><br><span class=\"line\">mkdir -p /data/logs/mongodb.log</span><br></pre></td></tr></table></figure></p>\n<p>7.新增配置文件 <code>/data/mongodb.conf</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#数据库文件</span><br><span class=\"line\">dbpath = /data/</span><br><span class=\"line\"></span><br><span class=\"line\">#日志文件</span><br><span class=\"line\">logpath = /data/logs/mongodb.log</span><br><span class=\"line\"></span><br><span class=\"line\">#默认端口</span><br><span class=\"line\">port = 27017</span><br><span class=\"line\"></span><br><span class=\"line\">#后台运行</span><br><span class=\"line\">fork = true</span><br><span class=\"line\"></span><br><span class=\"line\">#用户授权</span><br><span class=\"line\">auth = true</span><br><span class=\"line\"></span><br><span class=\"line\">#不启用http访问</span><br><span class=\"line\">nohttpinterface = true</span><br></pre></td></tr></table></figure></p>\n<div class=\"tip\"><br>添加授权后需要在 mongodb 数据库文件的 Users 集合新增用户，才可以正常使用。<br></div>\n\n\n<p>8.在自启动文件 <code>/etc/rc.local</code> 中写入 mongod 进程带配置文件启动<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"/usr/local/mongodb/bin/mongod -f /data/mongodb.conf\"</span> &gt;&gt; /etc/rc.local</span><br></pre></td></tr></table></figure></p>\n<p>9.重启<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reboot</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Express\"><a href=\"#Express\" class=\"headerlink\" title=\"Express\"></a>Express</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i express -g</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>总体来说配置比较顺利，也踩了不少坑 TAT，毕竟不是专业的运维人员，Linux 经验完全在平常项目中一点点积累的。<br>","more":"</p>\n<div class=\"tip\"><br>    重要提示：本文适用于有一定 Linux 基础的童鞋操作，比如懂得 <code>ls</code>、<code>cd</code>、<code>vim</code>等命令基本用法。<br>    适用于操作系统：CentOS-6-x86_64，安装 node v6.9.4，mongodb v3.4.2。<br></div>\n\n<h3 id=\"Node-js-安装\"><a href=\"#Node-js-安装\" class=\"headerlink\" title=\"Node.js 安装\"></a>Node.js 安装</h3><p>0.进入到待安装位置<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/</span><br></pre></td></tr></table></figure></p>\n<p>1.下载安装文件<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://nodejs.org/dist/v6.9.4/node-v6.9.4-linux-x86.tar.xz</span><br></pre></td></tr></table></figure></p>\n<p>2.解压文件<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xz -d node-v6.9.4-linux-x86.tar.xz</span><br><span class=\"line\">tar xvf node-v6.9.4-linux-x86.tar</span><br></pre></td></tr></table></figure></p>\n<p>3.重命名文件<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm -rf node-v*.tar</span><br><span class=\"line\">mv node-v* node</span><br></pre></td></tr></table></figure></p>\n<p>4.配置环境变量<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#编辑系统文件</span></span><br><span class=\"line\">vim ~/.bash_profile</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#在最顶端添加环境变量地址</span></span><br><span class=\"line\">PATH=/usr/<span class=\"built_in\">local</span>/node/bin:<span class=\"variable\">$PATH</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#保存后重新启动以生效</span></span><br><span class=\"line\"><span class=\"built_in\">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure></p>\n<p>5.验证是否成功，显示版本号即安装成功！<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node -v</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Mongodb-安装\"><a href=\"#Mongodb-安装\" class=\"headerlink\" title=\"Mongodb 安装\"></a>Mongodb 安装</h3><p>0.进入到待安装位置<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/</span><br></pre></td></tr></table></figure></p>\n<p>1.下载安装文件<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http://fastdl.mongodb.org/linux/mongodb-linux-x86_64-3.4.2.tgz</span><br></pre></td></tr></table></figure></p>\n<p>2.解压文件<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar zxf mongodb-linux-*.tgz</span><br></pre></td></tr></table></figure></p>\n<p>3.重命名<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm -rf mongodb-*.tgz</span><br><span class=\"line\">mv mongodb-* mongodb</span><br></pre></td></tr></table></figure></p>\n<p>4.配置环境变量<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#编辑系统文件</span></span><br><span class=\"line\">vim ~/.bash_profile</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#在最顶端添加环境变量地址</span></span><br><span class=\"line\">PATH=/usr/<span class=\"built_in\">local</span>/mongodb/bin:<span class=\"variable\">$PATH</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#保存后重新启动以生效</span></span><br><span class=\"line\"><span class=\"built_in\">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure></p>\n<p>5.验证是否安装成功<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mongod --version</span><br></pre></td></tr></table></figure></p>\n<p>6.创建数据库目录和日志目录<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir -p /data/db</span><br><span class=\"line\">mkdir -p /data/logs/mongodb.log</span><br></pre></td></tr></table></figure></p>\n<p>7.新增配置文件 <code>/data/mongodb.conf</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#数据库文件</span><br><span class=\"line\">dbpath = /data/</span><br><span class=\"line\"></span><br><span class=\"line\">#日志文件</span><br><span class=\"line\">logpath = /data/logs/mongodb.log</span><br><span class=\"line\"></span><br><span class=\"line\">#默认端口</span><br><span class=\"line\">port = 27017</span><br><span class=\"line\"></span><br><span class=\"line\">#后台运行</span><br><span class=\"line\">fork = true</span><br><span class=\"line\"></span><br><span class=\"line\">#用户授权</span><br><span class=\"line\">auth = true</span><br><span class=\"line\"></span><br><span class=\"line\">#不启用http访问</span><br><span class=\"line\">nohttpinterface = true</span><br></pre></td></tr></table></figure></p>\n<div class=\"tip\"><br>添加授权后需要在 mongodb 数据库文件的 Users 集合新增用户，才可以正常使用。<br></div>\n\n\n<p>8.在自启动文件 <code>/etc/rc.local</code> 中写入 mongod 进程带配置文件启动<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"/usr/local/mongodb/bin/mongod -f /data/mongodb.conf\"</span> &gt;&gt; /etc/rc.local</span><br></pre></td></tr></table></figure></p>\n<p>9.重启<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reboot</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Express\"><a href=\"#Express\" class=\"headerlink\" title=\"Express\"></a>Express</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i express -g</span><br></pre></td></tr></table></figure>"},{"title":"Axios 使用姿势指南","comments":1,"date":"2018-09-19T14:09:48.000Z","from":null,"_content":"\n最近几个项目都用到了 Axios，它是一个更现代的 API 请求库，基于 Promise，能运行在浏览器和 Node.js 里。在项目里，一般都是需要进行一次封装再来使用，比如处理鉴权、还有全局的请求 Loading 动画等。今天来总结一下。\n\n<!-- more -->\n\n### Axios 简介\n\n[Axios](https://github.com/axios/axios) 是一个基于 Promise 用于浏览器和 nodejs 的 HTTP 客户端。它有以下功能：\n\n- 从浏览器中创建 XMLHttpRequest\n- 从 Node.js 发出 HTTP 请求\n- 支持 Promise API\n- 拦截请求和响应\n- 转换请求数据和响应数据\n- 自动转换 JSON 数据\n- 客户端防止 CSRF/XSRF\n\n### 基础 API\n\n- `axios.request(config)`\n- `axios.get(url [,config])`\n- `axios.delete(url [,config])`\n- `axios.head(url [,config])`\n- `axios.options(url [,config])`\n- `axios.post(url [,data [,config]])`\n- `axios.put(url [,data [,config]])`\n- `axios.patch(url [,data [,config]])`\n\n<div class=\"tip\">\n  HTTP 请求方法一般会按照它具体的含义来执行相关的动作，这里有一份 [HTTP 动词对应解释 @MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods)。\n</div>\n\n### 用法示例\n\n#### GET\n\n```js\n// 向具有指定 ID 的用户发出请求（参数在 URL 上）\naxios\n  .get('/user?ID=12345')\n  .then(function(res) {\n    console.log(res);\n  })\n  .catch(function(error) {\n    console.log(error);\n  });\n\n// 也可以通过 params 对象传递参数\naxios\n  .get('/user', {\n    params: {\n      ID: 12345\n    }\n  })\n  .then(function(response) {\n    console.log(response);\n  })\n  .catch(function(error) {\n    console.log(error);\n  });\n```\n\n#### POST\n\n```js\naxios\n  .post(\n    '/user',\n    {\n      userId: '123'\n    },\n    {\n      headers: {\n        token: 'abc'\n      }\n    }\n  )\n  .then(function(res) {\n    console.log(res);\n  })\n  .catch(function(error) {\n    console.log(error);\n  });\n```\n\n#### 直接使用 config\n\n```js\n// GET\naxios({\n  url: 'pakage.json',\n  method: 'get',\n  params: {\n    // get 在 params 中定义\n    userId: '123'\n  },\n  headers: {\n    token: 'http-test'\n  }\n}).then(res => {\n  console.log(res.data);\n});\n\n// POST\naxios({\n  url: 'pakage.json',\n  method: 'post',\n  data: {\n    // post 在 data 中定义\n    userId: '123'\n  },\n  headers: {\n    token: 'http-test'\n  }\n}).then(res => {\n  console.log(res.data);\n});\n```\n\n#### 并发请求\n\n```js\nfunction getUserAcount() {\n  // 返回一个 promise 对象\n  return axios.get('/user/1234');\n}\nfunction getUserPermissions() {\n  // 返回一个 promise 对象\n  return axios.get('/user/1234/getUserPermissions');\n}\n\n// 一次性返回两个接口\naxios.all([getUserAccount(), getUserPerssions()]).then(\n  axios.spread((acct, perms) => {\n    // spread 展开两个返回的结果\n    // 两个请求现已完成\n  })\n);\n```\n\n### 全局封装、异常处理\n\n在项目中，如果每次请求都写一堆 `config` 会存在大量重复代码，一般我们会封装成一个方法，把一些必要的参数配置好，同理，全局的异常还有鉴权等都统一配置。单次请求数据只做和数据相关的业务逻辑。下面来看一下 Axios 的全局封装例子。\n\n#### 封装\n\n```js\nimport axios from 'axios';\nimport qs from 'qs';\n\n// POST 方法封装  (原生 form 提交)\nexport const postRequest = (url, params) => {\n  return axios({\n    method: 'post',\n    url: url,\n    data: params,\n    transformRequest: [\n      function(data) {\n        return qs.stringify(data);\n      }\n    ],\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded'\n    }\n  });\n};\n\n// POST 方法封装  (文件上传)\nexport const uploadFileRequest = (url, params) => {\n  return axios({\n    method: 'post',\n    url: url,\n    data: params,\n    headers: {\n      'Content-Type': 'multipart/form-data'\n    }\n  });\n};\n\n// GET 方法封装\nexport const getRequest = url => {\n  return axios({\n    method: 'get',\n    url: url\n  });\n};\n\n// PUT 方法封装\nexport const putRequest = (url, params) => {\n  return axios({\n    method: 'put',\n    url: url,\n    data: params,\n    transformRequest: [\n      function(data) {\n        return qs.stringify(data);\n      }\n    ],\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded'\n    }\n  });\n};\n\n// DELETE 方法封装\nexport const deleteRequest = url => {\n  return axios({\n    method: 'delete',\n    url: url\n  });\n};\n```\n\n#### 异常处理\n\n```js\nimport axios from 'axios';\nimport { Message } from 'element-ui';\n\n//  请求拦截\naxios.interceptors.request.use(\n  config => {\n    // 请求前配置 config\n    return config;\n  },\n  err => {\n    // 错误处理\n    Message.error({ message: '请求超时!' });\n    return Promise.resolve(err);\n  }\n);\n\n// 响应拦截\naxios.interceptors.response.use(\n  data => {\n    // 请求后处理对应的数据\n\n    // 方式一：和后端约定响应码 `code`\n    switch (data.code) {\n      case '0':\n        // 正常直接返回\n        return data;\n      // 需要重新登录\n      case '-1':\n        // some code here..\n        break;\n      default:\n    }\n\n    // 方式二：仅判断 HTTP 状态码\n    if (data.status && data.status == 200 && data.data.status == 'error') {\n      Message.error({ message: data.data.msg });\n      return;\n    }\n    return data;\n  },\n  err => {\n    // 错误处理\n    if (err && err.response) {\n      switch (err.response.status) {\n        case 400:\n          err.message = '请求错误 (400)';\n          break;\n        case 401:\n          err.message = '未授权，请重新登录 (401)';\n          break;\n        case 403:\n          err.message = '拒绝访问 (403)';\n          break;\n        case 404:\n          err.message = '请求出错 (404)';\n          break;\n        case 408:\n          err.message = '请求超时 (408)';\n          break;\n        case 500:\n          err.message = '服务器错误 (500)';\n          break;\n        case 501:\n          err.message = '服务未实现 (501)';\n          break;\n        case 502:\n          err.message = '网络错误 (502)';\n          break;\n        case 503:\n          err.message = '服务不可用 (503)';\n          break;\n        case 504:\n          err.message = '网络超时 (504)';\n          break;\n        case 505:\n          err.message = 'HTTP 版本不受支持 (505)';\n          break;\n        default:\n          err.message = `连接出错 (${err.response.status})!`;\n      }\n    } else {\n      err.message = '连接服务器失败!';\n    }\n    Message.err({ message: err.message });\n    return Promise.resolve(err);\n  }\n);\n```\n\n<div class=\"tip\">\n请求出错的时候执行的是：`Promise.resolve(err)`，而不是 `Promise.reject(err)`，这样无论请求成功还是失败，在成功的回调中都能收到通知。\n</div>\n\n### 其它配置\n\n#### baseURL\n\n通过 `axios.defaults.baseURL` 来设置 API 的根域名。\n\n```js\nif (process.env.NODE_ENV == 'development') {\n  axios.defaults.baseURL = 'https://dev.server.com/';\n} else if (process.env.NODE_ENV == 'debug') {\n  axios.defaults.baseURL = 'https://debug.server.com/';\n} else if (process.env.NODE_ENV == 'production') {\n  axios.defaults.baseURL = 'https://pro.server.com/';\n}\n```\n\n<div class=\"tip\">\n`process.env` 是 Node.js 提供的全局变量，我们可以在 npm scripts 里通过 cross-env 这个工具统一配置不同的环境，cross-env 做了各种系统平台的兼容处理。一般用这个设置环境变量。\n</div>\n\n#### 请求超时\n\n通过 `axios.defaults.timeout` 设置默认的请求超时时间。例如超过了 10s，就会告知用户当前请求超时，请刷新等。\n\n```js\naxios.defaults.timeout = 10000;\n```\n\n#### 单独设置 POST 的请求头\n\n比如设置 POST 提交（原生 form）时单独配置。\n\n```js\naxios.defaults.headers.post['Content-Type'] =\n  'application/x-www-form-urlencoded;charset=UTF-8';\n```\n\n### 附: 完整代码\n\n```js\nimport axios from 'axios';\nimport QS from 'qs';\nimport { Toast } from 'vant';\n\n// 环境的切换\nif (process.env.NODE_ENV == 'development') {\n  axios.defaults.baseURL = 'https://dev.server.com/';\n} else if (process.env.NODE_ENV == 'debug') {\n  axios.defaults.baseURL = 'https://debug.server.com/';\n} else if (process.env.NODE_ENV == 'production') {\n  axios.defaults.baseURL = 'https://pro.server.com/';\n}\n\n// 请求超时时间\naxios.defaults.timeout = 10000;\n\n// POST 请求头\naxios.defaults.headers.post['Content-Type'] =\n  'application/x-www-form-urlencoded;charset=UTF-8';\n\n// 请求拦截器\naxios.interceptors.request.use(\n  config = > {\n    const token = store.state.token;\n    token && (config.headers.Authorization = token);\n    return config;\n  }, error = > {\n    return Promise.error(error);\n  }\n)\n\n// 响应拦截器\naxios.interceptors.response.use(\n  response = > {\n    if (response.status === 200) {\n      return Promise.resolve(response);\n    } else {\n      return Promise.reject(response);\n    }\n  },\n  // 服务器状态码不是 200 的情况\n  error = > {\n    if (error.response.status) {\n      switch (error.response.status) {\n        case 401:\n          router.replace({\n            path: '/login',\n            query: {\n              redirect: router.currentRoute.fullPath\n            }\n          });\n          break;\n        case 403:\n          Toast({\n            message: '登录过期，请重新登录',\n            duration: 1000,\n            forbidClick: true\n          });\n          break;\n          // 404 请求不存在\n        case 404:\n          Toast({\n            message: '网络请求不存在',\n            duration: 1500,\n            forbidClick: true\n          });\n          break;\n          // 其他错误，直接抛出错误提示\n        default:\n          Toast({\n            message: error.response.data.message,\n            duration: 1500,\n            forbidClick: true\n          });\n      }\n      return Promise.reject(error.response);\n    }\n  }\n);\n\n// GET 请求\nexport function get(url, params) {\n  return new Promise((resolve, reject) => {\n    axios\n      .get(url, { params: params })\n      .then(res => {\n        resolve(res.data);\n      })\n      .catch (err => {\n        reject(err.data)\n      })\n  });\n}\n\n// POST 请求\nexport function post(url, params) {\n  return new Promise((resolve, reject) => {\n    axios\n      .post(url, QS.stringify(params))\n      .then(res = > {\n        resolve(res.data);\n      })\n      .catch (err => {\n        reject(err.data)\n      })\n  });\n}\n```\n\n### 附: Content-Type\n\n说到和服务端数据交互，总是绕不开这个，必须要扫盲一下了！😂😂\n\n> Content-Type 用于指定内容类型，一般是指网页中存在的 Content-Type，Content-Type 属性指定请求和响应的 HTTP 内容类型。如果未指定 ContentType，默认为 `text/html`。\n\n常见类型有：\n\n- text/html\n- application/x-www-form-urlencoded\n- multipart/form-data\n- application/json\n- application/xml\n\n`application/x-www-form-urlencoded`、`multipart/form-data`、`application/json`、`application/xml` 这四个则是 ajax 请求需要指定的类型，表单提交或上传文件常用的资源类型。\n\n#### application/x-www-form-urlencoded\n\n这是表单默认提交方式，格式为 URL 编码 `key=value&key1=value1`。\n\n<div style=\"max-width: 500px\">![image](https://user-images.githubusercontent.com/9158841/32037816-ade83a36-b9ec-11e7-9f07-4f72a99c6aaa.png)</div>\n\n注：Chrome 浏览器会自动格式化成易读的格式\n\n#### multipart/form-data\n\n使用表单上传文件时，必须指定表单的 enctype 属性值为 `multipart/form-data`。\n请求体被分割成多部分，每部分使用 `--boundary` 分割，使用 `--boundary--\\r\\n` 结束。\n\n表单上传文件 Demo:\n\n```html\n<form action=\"/upload\" enctype=\"multipart/form-data\" method=\"post\">\n    用户名: <input type=\"text\" name=\"username\">\n    密码: <input type=\"password\" name=\"password\">\n    上传文件: <input type=\"file\" name=\"file\">\n    <input type=\"submit\" value=\"提交\">\n</form>\n```\n\n<div style=\"max-width: 500px\">![image](https://user-images.githubusercontent.com/9158841/32038354-1201f94c-b9ef-11e7-8817-fb9031b2b036.png)</div>\n\n#### application/json\n\nAxios 默认 `POST` 提交方式就是 `application/json`，所以，在使用 axios 提交表单时需要注意后端能不能解析，不能解析需要设置 `POST` 常用格式 `application/x-www-form-urlencoded`，且提交的数据需要使用 qs 模块序列化格式。\n\n```js\naxios.post(\n  'https://jsonplaceholder.typicode.com/posts',\n  {\n    userId: 1,\n    name: 'ifyour',\n    arr: [1, 2, 3, 4]\n  },\n  {\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded'\n    },\n    transformRequest: [\n      function(data) {\n        return qs.stringify(data);\n      }\n    ]\n  }\n);\n```\n\n<div style=\"max-width: 400px\">![image](https://user-images.githubusercontent.com/15377484/45913317-a939a580-be62-11e8-9d96-1a097337da44.png)</div>\n\n#### application/xml\n\n```text\nPOST http://www.example.com HTTP/1.1\nContent-Type: text/xml\n```\n\n```xml\n<?xml version=\"1.0\"?>\n<resource>\n    <id>123</id>\n    <params>\n        <name>\n            <value>example</value>\n        </name>\n        <age>\n            <value>21</value>\n        </age>\n    </params>\n</resource>\n```\n\n### 参考\n\n- [Axios 官方文档 @GitHub](https://github.com/axios/axios#installing)\n- [HTTP Content-Type 对照表 @OSChina](http://tool.oschina.net/commons)\n- [HTTP 请求方法 @MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods)\n","source":"_posts/Axios-使用姿势指南.md","raw":"---\ntitle: Axios 使用姿势指南\ncomments: true\ndate: 2018-09-19 22:09:48\ntags:\nfrom:\n---\n\n最近几个项目都用到了 Axios，它是一个更现代的 API 请求库，基于 Promise，能运行在浏览器和 Node.js 里。在项目里，一般都是需要进行一次封装再来使用，比如处理鉴权、还有全局的请求 Loading 动画等。今天来总结一下。\n\n<!-- more -->\n\n### Axios 简介\n\n[Axios](https://github.com/axios/axios) 是一个基于 Promise 用于浏览器和 nodejs 的 HTTP 客户端。它有以下功能：\n\n- 从浏览器中创建 XMLHttpRequest\n- 从 Node.js 发出 HTTP 请求\n- 支持 Promise API\n- 拦截请求和响应\n- 转换请求数据和响应数据\n- 自动转换 JSON 数据\n- 客户端防止 CSRF/XSRF\n\n### 基础 API\n\n- `axios.request(config)`\n- `axios.get(url [,config])`\n- `axios.delete(url [,config])`\n- `axios.head(url [,config])`\n- `axios.options(url [,config])`\n- `axios.post(url [,data [,config]])`\n- `axios.put(url [,data [,config]])`\n- `axios.patch(url [,data [,config]])`\n\n<div class=\"tip\">\n  HTTP 请求方法一般会按照它具体的含义来执行相关的动作，这里有一份 [HTTP 动词对应解释 @MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods)。\n</div>\n\n### 用法示例\n\n#### GET\n\n```js\n// 向具有指定 ID 的用户发出请求（参数在 URL 上）\naxios\n  .get('/user?ID=12345')\n  .then(function(res) {\n    console.log(res);\n  })\n  .catch(function(error) {\n    console.log(error);\n  });\n\n// 也可以通过 params 对象传递参数\naxios\n  .get('/user', {\n    params: {\n      ID: 12345\n    }\n  })\n  .then(function(response) {\n    console.log(response);\n  })\n  .catch(function(error) {\n    console.log(error);\n  });\n```\n\n#### POST\n\n```js\naxios\n  .post(\n    '/user',\n    {\n      userId: '123'\n    },\n    {\n      headers: {\n        token: 'abc'\n      }\n    }\n  )\n  .then(function(res) {\n    console.log(res);\n  })\n  .catch(function(error) {\n    console.log(error);\n  });\n```\n\n#### 直接使用 config\n\n```js\n// GET\naxios({\n  url: 'pakage.json',\n  method: 'get',\n  params: {\n    // get 在 params 中定义\n    userId: '123'\n  },\n  headers: {\n    token: 'http-test'\n  }\n}).then(res => {\n  console.log(res.data);\n});\n\n// POST\naxios({\n  url: 'pakage.json',\n  method: 'post',\n  data: {\n    // post 在 data 中定义\n    userId: '123'\n  },\n  headers: {\n    token: 'http-test'\n  }\n}).then(res => {\n  console.log(res.data);\n});\n```\n\n#### 并发请求\n\n```js\nfunction getUserAcount() {\n  // 返回一个 promise 对象\n  return axios.get('/user/1234');\n}\nfunction getUserPermissions() {\n  // 返回一个 promise 对象\n  return axios.get('/user/1234/getUserPermissions');\n}\n\n// 一次性返回两个接口\naxios.all([getUserAccount(), getUserPerssions()]).then(\n  axios.spread((acct, perms) => {\n    // spread 展开两个返回的结果\n    // 两个请求现已完成\n  })\n);\n```\n\n### 全局封装、异常处理\n\n在项目中，如果每次请求都写一堆 `config` 会存在大量重复代码，一般我们会封装成一个方法，把一些必要的参数配置好，同理，全局的异常还有鉴权等都统一配置。单次请求数据只做和数据相关的业务逻辑。下面来看一下 Axios 的全局封装例子。\n\n#### 封装\n\n```js\nimport axios from 'axios';\nimport qs from 'qs';\n\n// POST 方法封装  (原生 form 提交)\nexport const postRequest = (url, params) => {\n  return axios({\n    method: 'post',\n    url: url,\n    data: params,\n    transformRequest: [\n      function(data) {\n        return qs.stringify(data);\n      }\n    ],\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded'\n    }\n  });\n};\n\n// POST 方法封装  (文件上传)\nexport const uploadFileRequest = (url, params) => {\n  return axios({\n    method: 'post',\n    url: url,\n    data: params,\n    headers: {\n      'Content-Type': 'multipart/form-data'\n    }\n  });\n};\n\n// GET 方法封装\nexport const getRequest = url => {\n  return axios({\n    method: 'get',\n    url: url\n  });\n};\n\n// PUT 方法封装\nexport const putRequest = (url, params) => {\n  return axios({\n    method: 'put',\n    url: url,\n    data: params,\n    transformRequest: [\n      function(data) {\n        return qs.stringify(data);\n      }\n    ],\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded'\n    }\n  });\n};\n\n// DELETE 方法封装\nexport const deleteRequest = url => {\n  return axios({\n    method: 'delete',\n    url: url\n  });\n};\n```\n\n#### 异常处理\n\n```js\nimport axios from 'axios';\nimport { Message } from 'element-ui';\n\n//  请求拦截\naxios.interceptors.request.use(\n  config => {\n    // 请求前配置 config\n    return config;\n  },\n  err => {\n    // 错误处理\n    Message.error({ message: '请求超时!' });\n    return Promise.resolve(err);\n  }\n);\n\n// 响应拦截\naxios.interceptors.response.use(\n  data => {\n    // 请求后处理对应的数据\n\n    // 方式一：和后端约定响应码 `code`\n    switch (data.code) {\n      case '0':\n        // 正常直接返回\n        return data;\n      // 需要重新登录\n      case '-1':\n        // some code here..\n        break;\n      default:\n    }\n\n    // 方式二：仅判断 HTTP 状态码\n    if (data.status && data.status == 200 && data.data.status == 'error') {\n      Message.error({ message: data.data.msg });\n      return;\n    }\n    return data;\n  },\n  err => {\n    // 错误处理\n    if (err && err.response) {\n      switch (err.response.status) {\n        case 400:\n          err.message = '请求错误 (400)';\n          break;\n        case 401:\n          err.message = '未授权，请重新登录 (401)';\n          break;\n        case 403:\n          err.message = '拒绝访问 (403)';\n          break;\n        case 404:\n          err.message = '请求出错 (404)';\n          break;\n        case 408:\n          err.message = '请求超时 (408)';\n          break;\n        case 500:\n          err.message = '服务器错误 (500)';\n          break;\n        case 501:\n          err.message = '服务未实现 (501)';\n          break;\n        case 502:\n          err.message = '网络错误 (502)';\n          break;\n        case 503:\n          err.message = '服务不可用 (503)';\n          break;\n        case 504:\n          err.message = '网络超时 (504)';\n          break;\n        case 505:\n          err.message = 'HTTP 版本不受支持 (505)';\n          break;\n        default:\n          err.message = `连接出错 (${err.response.status})!`;\n      }\n    } else {\n      err.message = '连接服务器失败!';\n    }\n    Message.err({ message: err.message });\n    return Promise.resolve(err);\n  }\n);\n```\n\n<div class=\"tip\">\n请求出错的时候执行的是：`Promise.resolve(err)`，而不是 `Promise.reject(err)`，这样无论请求成功还是失败，在成功的回调中都能收到通知。\n</div>\n\n### 其它配置\n\n#### baseURL\n\n通过 `axios.defaults.baseURL` 来设置 API 的根域名。\n\n```js\nif (process.env.NODE_ENV == 'development') {\n  axios.defaults.baseURL = 'https://dev.server.com/';\n} else if (process.env.NODE_ENV == 'debug') {\n  axios.defaults.baseURL = 'https://debug.server.com/';\n} else if (process.env.NODE_ENV == 'production') {\n  axios.defaults.baseURL = 'https://pro.server.com/';\n}\n```\n\n<div class=\"tip\">\n`process.env` 是 Node.js 提供的全局变量，我们可以在 npm scripts 里通过 cross-env 这个工具统一配置不同的环境，cross-env 做了各种系统平台的兼容处理。一般用这个设置环境变量。\n</div>\n\n#### 请求超时\n\n通过 `axios.defaults.timeout` 设置默认的请求超时时间。例如超过了 10s，就会告知用户当前请求超时，请刷新等。\n\n```js\naxios.defaults.timeout = 10000;\n```\n\n#### 单独设置 POST 的请求头\n\n比如设置 POST 提交（原生 form）时单独配置。\n\n```js\naxios.defaults.headers.post['Content-Type'] =\n  'application/x-www-form-urlencoded;charset=UTF-8';\n```\n\n### 附: 完整代码\n\n```js\nimport axios from 'axios';\nimport QS from 'qs';\nimport { Toast } from 'vant';\n\n// 环境的切换\nif (process.env.NODE_ENV == 'development') {\n  axios.defaults.baseURL = 'https://dev.server.com/';\n} else if (process.env.NODE_ENV == 'debug') {\n  axios.defaults.baseURL = 'https://debug.server.com/';\n} else if (process.env.NODE_ENV == 'production') {\n  axios.defaults.baseURL = 'https://pro.server.com/';\n}\n\n// 请求超时时间\naxios.defaults.timeout = 10000;\n\n// POST 请求头\naxios.defaults.headers.post['Content-Type'] =\n  'application/x-www-form-urlencoded;charset=UTF-8';\n\n// 请求拦截器\naxios.interceptors.request.use(\n  config = > {\n    const token = store.state.token;\n    token && (config.headers.Authorization = token);\n    return config;\n  }, error = > {\n    return Promise.error(error);\n  }\n)\n\n// 响应拦截器\naxios.interceptors.response.use(\n  response = > {\n    if (response.status === 200) {\n      return Promise.resolve(response);\n    } else {\n      return Promise.reject(response);\n    }\n  },\n  // 服务器状态码不是 200 的情况\n  error = > {\n    if (error.response.status) {\n      switch (error.response.status) {\n        case 401:\n          router.replace({\n            path: '/login',\n            query: {\n              redirect: router.currentRoute.fullPath\n            }\n          });\n          break;\n        case 403:\n          Toast({\n            message: '登录过期，请重新登录',\n            duration: 1000,\n            forbidClick: true\n          });\n          break;\n          // 404 请求不存在\n        case 404:\n          Toast({\n            message: '网络请求不存在',\n            duration: 1500,\n            forbidClick: true\n          });\n          break;\n          // 其他错误，直接抛出错误提示\n        default:\n          Toast({\n            message: error.response.data.message,\n            duration: 1500,\n            forbidClick: true\n          });\n      }\n      return Promise.reject(error.response);\n    }\n  }\n);\n\n// GET 请求\nexport function get(url, params) {\n  return new Promise((resolve, reject) => {\n    axios\n      .get(url, { params: params })\n      .then(res => {\n        resolve(res.data);\n      })\n      .catch (err => {\n        reject(err.data)\n      })\n  });\n}\n\n// POST 请求\nexport function post(url, params) {\n  return new Promise((resolve, reject) => {\n    axios\n      .post(url, QS.stringify(params))\n      .then(res = > {\n        resolve(res.data);\n      })\n      .catch (err => {\n        reject(err.data)\n      })\n  });\n}\n```\n\n### 附: Content-Type\n\n说到和服务端数据交互，总是绕不开这个，必须要扫盲一下了！😂😂\n\n> Content-Type 用于指定内容类型，一般是指网页中存在的 Content-Type，Content-Type 属性指定请求和响应的 HTTP 内容类型。如果未指定 ContentType，默认为 `text/html`。\n\n常见类型有：\n\n- text/html\n- application/x-www-form-urlencoded\n- multipart/form-data\n- application/json\n- application/xml\n\n`application/x-www-form-urlencoded`、`multipart/form-data`、`application/json`、`application/xml` 这四个则是 ajax 请求需要指定的类型，表单提交或上传文件常用的资源类型。\n\n#### application/x-www-form-urlencoded\n\n这是表单默认提交方式，格式为 URL 编码 `key=value&key1=value1`。\n\n<div style=\"max-width: 500px\">![image](https://user-images.githubusercontent.com/9158841/32037816-ade83a36-b9ec-11e7-9f07-4f72a99c6aaa.png)</div>\n\n注：Chrome 浏览器会自动格式化成易读的格式\n\n#### multipart/form-data\n\n使用表单上传文件时，必须指定表单的 enctype 属性值为 `multipart/form-data`。\n请求体被分割成多部分，每部分使用 `--boundary` 分割，使用 `--boundary--\\r\\n` 结束。\n\n表单上传文件 Demo:\n\n```html\n<form action=\"/upload\" enctype=\"multipart/form-data\" method=\"post\">\n    用户名: <input type=\"text\" name=\"username\">\n    密码: <input type=\"password\" name=\"password\">\n    上传文件: <input type=\"file\" name=\"file\">\n    <input type=\"submit\" value=\"提交\">\n</form>\n```\n\n<div style=\"max-width: 500px\">![image](https://user-images.githubusercontent.com/9158841/32038354-1201f94c-b9ef-11e7-8817-fb9031b2b036.png)</div>\n\n#### application/json\n\nAxios 默认 `POST` 提交方式就是 `application/json`，所以，在使用 axios 提交表单时需要注意后端能不能解析，不能解析需要设置 `POST` 常用格式 `application/x-www-form-urlencoded`，且提交的数据需要使用 qs 模块序列化格式。\n\n```js\naxios.post(\n  'https://jsonplaceholder.typicode.com/posts',\n  {\n    userId: 1,\n    name: 'ifyour',\n    arr: [1, 2, 3, 4]\n  },\n  {\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded'\n    },\n    transformRequest: [\n      function(data) {\n        return qs.stringify(data);\n      }\n    ]\n  }\n);\n```\n\n<div style=\"max-width: 400px\">![image](https://user-images.githubusercontent.com/15377484/45913317-a939a580-be62-11e8-9d96-1a097337da44.png)</div>\n\n#### application/xml\n\n```text\nPOST http://www.example.com HTTP/1.1\nContent-Type: text/xml\n```\n\n```xml\n<?xml version=\"1.0\"?>\n<resource>\n    <id>123</id>\n    <params>\n        <name>\n            <value>example</value>\n        </name>\n        <age>\n            <value>21</value>\n        </age>\n    </params>\n</resource>\n```\n\n### 参考\n\n- [Axios 官方文档 @GitHub](https://github.com/axios/axios#installing)\n- [HTTP Content-Type 对照表 @OSChina](http://tool.oschina.net/commons)\n- [HTTP 请求方法 @MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods)\n","slug":"Axios-使用姿势指南","published":1,"updated":"2019-12-07T04:53:18.084Z","layout":"post","photos":[],"link":"","_id":"ck3v60jt80006r9q9kvbjbebj","content":"<p>最近几个项目都用到了 Axios，它是一个更现代的 API 请求库，基于 Promise，能运行在浏览器和 Node.js 里。在项目里，一般都是需要进行一次封装再来使用，比如处理鉴权、还有全局的请求 Loading 动画等。今天来总结一下。</p>\n<a id=\"more\"></a>\n<h3 id=\"Axios-简介\"><a href=\"#Axios-简介\" class=\"headerlink\" title=\"Axios 简介\"></a>Axios 简介</h3><p><a href=\"https://github.com/axios/axios\" target=\"_blank\" rel=\"noopener\">Axios</a> 是一个基于 Promise 用于浏览器和 nodejs 的 HTTP 客户端。它有以下功能：</p>\n<ul>\n<li>从浏览器中创建 XMLHttpRequest</li>\n<li>从 Node.js 发出 HTTP 请求</li>\n<li>支持 Promise API</li>\n<li>拦截请求和响应</li>\n<li>转换请求数据和响应数据</li>\n<li>自动转换 JSON 数据</li>\n<li>客户端防止 CSRF/XSRF</li>\n</ul>\n<h3 id=\"基础-API\"><a href=\"#基础-API\" class=\"headerlink\" title=\"基础 API\"></a>基础 API</h3><ul>\n<li><code>axios.request(config)</code></li>\n<li><code>axios.get(url [,config])</code></li>\n<li><code>axios.delete(url [,config])</code></li>\n<li><code>axios.head(url [,config])</code></li>\n<li><code>axios.options(url [,config])</code></li>\n<li><code>axios.post(url [,data [,config]])</code></li>\n<li><code>axios.put(url [,data [,config]])</code></li>\n<li><code>axios.patch(url [,data [,config]])</code></li>\n</ul>\n<div class=\"tip\"><br>  HTTP 请求方法一般会按照它具体的含义来执行相关的动作，这里有一份 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods\" target=\"_blank\" rel=\"noopener\">HTTP 动词对应解释 @MDN</a>。<br></div>\n\n<h3 id=\"用法示例\"><a href=\"#用法示例\" class=\"headerlink\" title=\"用法示例\"></a>用法示例</h3><h4 id=\"GET\"><a href=\"#GET\" class=\"headerlink\" title=\"GET\"></a>GET</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 向具有指定 ID 的用户发出请求（参数在 URL 上）</span></span><br><span class=\"line\">axios</span><br><span class=\"line\">  .get(<span class=\"string\">'/user?ID=12345'</span>)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(res);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(error);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 也可以通过 params 对象传递参数</span></span><br><span class=\"line\">axios</span><br><span class=\"line\">  .get(<span class=\"string\">'/user'</span>, &#123;</span><br><span class=\"line\">    params: &#123;</span><br><span class=\"line\">      ID: <span class=\"number\">12345</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">response</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(response);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(error);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"POST\"><a href=\"#POST\" class=\"headerlink\" title=\"POST\"></a>POST</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios</span><br><span class=\"line\">  .post(</span><br><span class=\"line\">    <span class=\"string\">'/user'</span>,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      userId: <span class=\"string\">'123'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      headers: &#123;</span><br><span class=\"line\">        token: <span class=\"string\">'abc'</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  )</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(res);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(error);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"直接使用-config\"><a href=\"#直接使用-config\" class=\"headerlink\" title=\"直接使用 config\"></a>直接使用 config</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// GET</span></span><br><span class=\"line\">axios(&#123;</span><br><span class=\"line\">  url: <span class=\"string\">'pakage.json'</span>,</span><br><span class=\"line\">  method: <span class=\"string\">'get'</span>,</span><br><span class=\"line\">  params: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// get 在 params 中定义</span></span><br><span class=\"line\">    userId: <span class=\"string\">'123'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  headers: &#123;</span><br><span class=\"line\">    token: <span class=\"string\">'http-test'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res.data);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// POST</span></span><br><span class=\"line\">axios(&#123;</span><br><span class=\"line\">  url: <span class=\"string\">'pakage.json'</span>,</span><br><span class=\"line\">  method: <span class=\"string\">'post'</span>,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// post 在 data 中定义</span></span><br><span class=\"line\">    userId: <span class=\"string\">'123'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  headers: &#123;</span><br><span class=\"line\">    token: <span class=\"string\">'http-test'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res.data);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"并发请求\"><a href=\"#并发请求\" class=\"headerlink\" title=\"并发请求\"></a>并发请求</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getUserAcount</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 返回一个 promise 对象</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> axios.get(<span class=\"string\">'/user/1234'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getUserPermissions</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 返回一个 promise 对象</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> axios.get(<span class=\"string\">'/user/1234/getUserPermissions'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 一次性返回两个接口</span></span><br><span class=\"line\">axios.all([getUserAccount(), getUserPerssions()]).then(</span><br><span class=\"line\">  axios.spread(<span class=\"function\">(<span class=\"params\">acct, perms</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// spread 展开两个返回的结果</span></span><br><span class=\"line\">    <span class=\"comment\">// 两个请求现已完成</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h3 id=\"全局封装、异常处理\"><a href=\"#全局封装、异常处理\" class=\"headerlink\" title=\"全局封装、异常处理\"></a>全局封装、异常处理</h3><p>在项目中，如果每次请求都写一堆 <code>config</code> 会存在大量重复代码，一般我们会封装成一个方法，把一些必要的参数配置好，同理，全局的异常还有鉴权等都统一配置。单次请求数据只做和数据相关的业务逻辑。下面来看一下 Axios 的全局封装例子。</p>\n<h4 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> axios <span class=\"keyword\">from</span> <span class=\"string\">'axios'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> qs <span class=\"keyword\">from</span> <span class=\"string\">'qs'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// POST 方法封装  (原生 form 提交)</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> postRequest = <span class=\"function\">(<span class=\"params\">url, params</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> axios(&#123;</span><br><span class=\"line\">    method: <span class=\"string\">'post'</span>,</span><br><span class=\"line\">    url: url,</span><br><span class=\"line\">    data: params,</span><br><span class=\"line\">    transformRequest: [</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> qs.stringify(data);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    headers: &#123;</span><br><span class=\"line\">      <span class=\"string\">'Content-Type'</span>: <span class=\"string\">'application/x-www-form-urlencoded'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// POST 方法封装  (文件上传)</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> uploadFileRequest = <span class=\"function\">(<span class=\"params\">url, params</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> axios(&#123;</span><br><span class=\"line\">    method: <span class=\"string\">'post'</span>,</span><br><span class=\"line\">    url: url,</span><br><span class=\"line\">    data: params,</span><br><span class=\"line\">    headers: &#123;</span><br><span class=\"line\">      <span class=\"string\">'Content-Type'</span>: <span class=\"string\">'multipart/form-data'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// GET 方法封装</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> getRequest = <span class=\"function\"><span class=\"params\">url</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> axios(&#123;</span><br><span class=\"line\">    method: <span class=\"string\">'get'</span>,</span><br><span class=\"line\">    url: url</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// PUT 方法封装</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> putRequest = <span class=\"function\">(<span class=\"params\">url, params</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> axios(&#123;</span><br><span class=\"line\">    method: <span class=\"string\">'put'</span>,</span><br><span class=\"line\">    url: url,</span><br><span class=\"line\">    data: params,</span><br><span class=\"line\">    transformRequest: [</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> qs.stringify(data);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    headers: &#123;</span><br><span class=\"line\">      <span class=\"string\">'Content-Type'</span>: <span class=\"string\">'application/x-www-form-urlencoded'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// DELETE 方法封装</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> deleteRequest = <span class=\"function\"><span class=\"params\">url</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> axios(&#123;</span><br><span class=\"line\">    method: <span class=\"string\">'delete'</span>,</span><br><span class=\"line\">    url: url</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> axios <span class=\"keyword\">from</span> <span class=\"string\">'axios'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Message &#125; <span class=\"keyword\">from</span> <span class=\"string\">'element-ui'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  请求拦截</span></span><br><span class=\"line\">axios.interceptors.request.use(</span><br><span class=\"line\">  config =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 请求前配置 config</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> config;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  err =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 错误处理</span></span><br><span class=\"line\">    Message.error(&#123; <span class=\"attr\">message</span>: <span class=\"string\">'请求超时!'</span> &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.resolve(err);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 响应拦截</span></span><br><span class=\"line\">axios.interceptors.response.use(</span><br><span class=\"line\">  data =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 请求后处理对应的数据</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 方式一：和后端约定响应码 `code`</span></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (data.code) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">'0'</span>:</span><br><span class=\"line\">        <span class=\"comment\">// 正常直接返回</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> data;</span><br><span class=\"line\">      <span class=\"comment\">// 需要重新登录</span></span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">'-1'</span>:</span><br><span class=\"line\">        <span class=\"comment\">// some code here..</span></span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"keyword\">default</span>:</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 方式二：仅判断 HTTP 状态码</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data.status &amp;&amp; data.status == <span class=\"number\">200</span> &amp;&amp; data.data.status == <span class=\"string\">'error'</span>) &#123;</span><br><span class=\"line\">      Message.error(&#123; <span class=\"attr\">message</span>: data.data.msg &#125;);</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> data;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  err =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 错误处理</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err &amp;&amp; err.response) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">switch</span> (err.response.status) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">400</span>:</span><br><span class=\"line\">          err.message = <span class=\"string\">'请求错误 (400)'</span>;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">401</span>:</span><br><span class=\"line\">          err.message = <span class=\"string\">'未授权，请重新登录 (401)'</span>;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">403</span>:</span><br><span class=\"line\">          err.message = <span class=\"string\">'拒绝访问 (403)'</span>;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">404</span>:</span><br><span class=\"line\">          err.message = <span class=\"string\">'请求出错 (404)'</span>;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">408</span>:</span><br><span class=\"line\">          err.message = <span class=\"string\">'请求超时 (408)'</span>;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">500</span>:</span><br><span class=\"line\">          err.message = <span class=\"string\">'服务器错误 (500)'</span>;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">501</span>:</span><br><span class=\"line\">          err.message = <span class=\"string\">'服务未实现 (501)'</span>;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">502</span>:</span><br><span class=\"line\">          err.message = <span class=\"string\">'网络错误 (502)'</span>;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">503</span>:</span><br><span class=\"line\">          err.message = <span class=\"string\">'服务不可用 (503)'</span>;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">504</span>:</span><br><span class=\"line\">          err.message = <span class=\"string\">'网络超时 (504)'</span>;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">505</span>:</span><br><span class=\"line\">          err.message = <span class=\"string\">'HTTP 版本不受支持 (505)'</span>;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">          err.message = <span class=\"string\">`连接出错 (<span class=\"subst\">$&#123;err.response.status&#125;</span>)!`</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      err.message = <span class=\"string\">'连接服务器失败!'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Message.err(&#123; <span class=\"attr\">message</span>: err.message &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.resolve(err);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<div class=\"tip\"><br>请求出错的时候执行的是：<code>Promise.resolve(err)</code>，而不是 <code>Promise.reject(err)</code>，这样无论请求成功还是失败，在成功的回调中都能收到通知。<br></div>\n\n<h3 id=\"其它配置\"><a href=\"#其它配置\" class=\"headerlink\" title=\"其它配置\"></a>其它配置</h3><h4 id=\"baseURL\"><a href=\"#baseURL\" class=\"headerlink\" title=\"baseURL\"></a>baseURL</h4><p>通过 <code>axios.defaults.baseURL</code> 来设置 API 的根域名。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (process.env.NODE_ENV == <span class=\"string\">'development'</span>) &#123;</span><br><span class=\"line\">  axios.defaults.baseURL = <span class=\"string\">'https://dev.server.com/'</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (process.env.NODE_ENV == <span class=\"string\">'debug'</span>) &#123;</span><br><span class=\"line\">  axios.defaults.baseURL = <span class=\"string\">'https://debug.server.com/'</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (process.env.NODE_ENV == <span class=\"string\">'production'</span>) &#123;</span><br><span class=\"line\">  axios.defaults.baseURL = <span class=\"string\">'https://pro.server.com/'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<div class=\"tip\"><br><code>process.env</code> 是 Node.js 提供的全局变量，我们可以在 npm scripts 里通过 cross-env 这个工具统一配置不同的环境，cross-env 做了各种系统平台的兼容处理。一般用这个设置环境变量。<br></div>\n\n<h4 id=\"请求超时\"><a href=\"#请求超时\" class=\"headerlink\" title=\"请求超时\"></a>请求超时</h4><p>通过 <code>axios.defaults.timeout</code> 设置默认的请求超时时间。例如超过了 10s，就会告知用户当前请求超时，请刷新等。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios.defaults.timeout = <span class=\"number\">10000</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"单独设置-POST-的请求头\"><a href=\"#单独设置-POST-的请求头\" class=\"headerlink\" title=\"单独设置 POST 的请求头\"></a>单独设置 POST 的请求头</h4><p>比如设置 POST 提交（原生 form）时单独配置。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios.defaults.headers.post[<span class=\"string\">'Content-Type'</span>] =</span><br><span class=\"line\">  <span class=\"string\">'application/x-www-form-urlencoded;charset=UTF-8'</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"附-完整代码\"><a href=\"#附-完整代码\" class=\"headerlink\" title=\"附: 完整代码\"></a>附: 完整代码</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> axios <span class=\"keyword\">from</span> <span class=\"string\">'axios'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> QS <span class=\"keyword\">from</span> <span class=\"string\">'qs'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Toast &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vant'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 环境的切换</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (process.env.NODE_ENV == <span class=\"string\">'development'</span>) &#123;</span><br><span class=\"line\">  axios.defaults.baseURL = <span class=\"string\">'https://dev.server.com/'</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (process.env.NODE_ENV == <span class=\"string\">'debug'</span>) &#123;</span><br><span class=\"line\">  axios.defaults.baseURL = <span class=\"string\">'https://debug.server.com/'</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (process.env.NODE_ENV == <span class=\"string\">'production'</span>) &#123;</span><br><span class=\"line\">  axios.defaults.baseURL = <span class=\"string\">'https://pro.server.com/'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 请求超时时间</span></span><br><span class=\"line\">axios.defaults.timeout = <span class=\"number\">10000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// POST 请求头</span></span><br><span class=\"line\">axios.defaults.headers.post[<span class=\"string\">'Content-Type'</span>] =</span><br><span class=\"line\">  <span class=\"string\">'application/x-www-form-urlencoded;charset=UTF-8'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 请求拦截器</span></span><br><span class=\"line\">axios.interceptors.request.use(</span><br><span class=\"line\">  config = &gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> token = store.state.token;</span><br><span class=\"line\">    token &amp;&amp; (config.headers.Authorization = token);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> config;</span><br><span class=\"line\">  &#125;, error = &gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.error(error);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 响应拦截器</span></span><br><span class=\"line\">axios.interceptors.response.use(</span><br><span class=\"line\">  response = &gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (response.status === <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.resolve(response);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.reject(response);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// 服务器状态码不是 200 的情况</span></span><br><span class=\"line\">  error = &gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (error.response.status) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">switch</span> (error.response.status) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">401</span>:</span><br><span class=\"line\">          router.replace(&#123;</span><br><span class=\"line\">            path: <span class=\"string\">'/login'</span>,</span><br><span class=\"line\">            query: &#123;</span><br><span class=\"line\">              redirect: router.currentRoute.fullPath</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">403</span>:</span><br><span class=\"line\">          Toast(&#123;</span><br><span class=\"line\">            message: <span class=\"string\">'登录过期，请重新登录'</span>,</span><br><span class=\"line\">            duration: <span class=\"number\">1000</span>,</span><br><span class=\"line\">            forbidClick: <span class=\"literal\">true</span></span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          <span class=\"comment\">// 404 请求不存在</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">404</span>:</span><br><span class=\"line\">          Toast(&#123;</span><br><span class=\"line\">            message: <span class=\"string\">'网络请求不存在'</span>,</span><br><span class=\"line\">            duration: <span class=\"number\">1500</span>,</span><br><span class=\"line\">            forbidClick: <span class=\"literal\">true</span></span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          <span class=\"comment\">// 其他错误，直接抛出错误提示</span></span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">          Toast(&#123;</span><br><span class=\"line\">            message: error.response.data.message,</span><br><span class=\"line\">            duration: <span class=\"number\">1500</span>,</span><br><span class=\"line\">            forbidClick: <span class=\"literal\">true</span></span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.reject(error.response);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// GET 请求</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">get</span>(<span class=\"params\">url, params</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    axios</span><br><span class=\"line\">      .get(url, &#123; <span class=\"attr\">params</span>: params &#125;)</span><br><span class=\"line\">      .then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">        resolve(res.data);</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      .catch (<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</span><br><span class=\"line\">        reject(err.data)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// POST 请求</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">post</span>(<span class=\"params\">url, params</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    axios</span><br><span class=\"line\">      .post(url, QS.stringify(params))</span><br><span class=\"line\">      .then(res = &gt; &#123;</span><br><span class=\"line\">        resolve(res.data);</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      .catch (<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</span><br><span class=\"line\">        reject(err.data)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"附-Content-Type\"><a href=\"#附-Content-Type\" class=\"headerlink\" title=\"附: Content-Type\"></a>附: Content-Type</h3><p>说到和服务端数据交互，总是绕不开这个，必须要扫盲一下了！😂😂</p>\n<blockquote>\n<p>Content-Type 用于指定内容类型，一般是指网页中存在的 Content-Type，Content-Type 属性指定请求和响应的 HTTP 内容类型。如果未指定 ContentType，默认为 <code>text/html</code>。</p>\n</blockquote>\n<p>常见类型有：</p>\n<ul>\n<li>text/html</li>\n<li>application/x-www-form-urlencoded</li>\n<li>multipart/form-data</li>\n<li>application/json</li>\n<li>application/xml</li>\n</ul>\n<p><code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>application/json</code>、<code>application/xml</code> 这四个则是 ajax 请求需要指定的类型，表单提交或上传文件常用的资源类型。</p>\n<h4 id=\"application-x-www-form-urlencoded\"><a href=\"#application-x-www-form-urlencoded\" class=\"headerlink\" title=\"application/x-www-form-urlencoded\"></a>application/x-www-form-urlencoded</h4><p>这是表单默认提交方式，格式为 URL 编码 <code>key=value&amp;key1=value1</code>。</p>\n<div style=\"max-width: 500px\"><img src=\"https://user-images.githubusercontent.com/9158841/32037816-ade83a36-b9ec-11e7-9f07-4f72a99c6aaa.png\" alt=\"image\"></div>\n\n<p>注：Chrome 浏览器会自动格式化成易读的格式</p>\n<h4 id=\"multipart-form-data\"><a href=\"#multipart-form-data\" class=\"headerlink\" title=\"multipart/form-data\"></a>multipart/form-data</h4><p>使用表单上传文件时，必须指定表单的 enctype 属性值为 <code>multipart/form-data</code>。<br>请求体被分割成多部分，每部分使用 <code>--boundary</code> 分割，使用 <code>--boundary--\\r\\n</code> 结束。</p>\n<p>表单上传文件 Demo:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">\"/upload\"</span> <span class=\"attr\">enctype</span>=<span class=\"string\">\"multipart/form-data\"</span> <span class=\"attr\">method</span>=<span class=\"string\">\"post\"</span>&gt;</span></span><br><span class=\"line\">    用户名: <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"username\"</span>&gt;</span></span><br><span class=\"line\">    密码: <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"password\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"password\"</span>&gt;</span></span><br><span class=\"line\">    上传文件: <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"file\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"file\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"submit\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"提交\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<div style=\"max-width: 500px\"><img src=\"https://user-images.githubusercontent.com/9158841/32038354-1201f94c-b9ef-11e7-8817-fb9031b2b036.png\" alt=\"image\"></div>\n\n<h4 id=\"application-json\"><a href=\"#application-json\" class=\"headerlink\" title=\"application/json\"></a>application/json</h4><p>Axios 默认 <code>POST</code> 提交方式就是 <code>application/json</code>，所以，在使用 axios 提交表单时需要注意后端能不能解析，不能解析需要设置 <code>POST</code> 常用格式 <code>application/x-www-form-urlencoded</code>，且提交的数据需要使用 qs 模块序列化格式。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios.post(</span><br><span class=\"line\">  <span class=\"string\">'https://jsonplaceholder.typicode.com/posts'</span>,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    userId: <span class=\"number\">1</span>,</span><br><span class=\"line\">    name: <span class=\"string\">'ifyour'</span>,</span><br><span class=\"line\">    arr: [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    headers: &#123;</span><br><span class=\"line\">      <span class=\"string\">'Content-Type'</span>: <span class=\"string\">'application/x-www-form-urlencoded'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    transformRequest: [</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> qs.stringify(data);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<div style=\"max-width: 400px\"><img src=\"https://user-images.githubusercontent.com/15377484/45913317-a939a580-be62-11e8-9d96-1a097337da44.png\" alt=\"image\"></div>\n\n<h4 id=\"application-xml\"><a href=\"#application-xml\" class=\"headerlink\" title=\"application/xml\"></a>application/xml</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST http://www.example.com HTTP/1.1</span><br><span class=\"line\">Content-Type: text/xml</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\"?&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">resource</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>123<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">params</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>example<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">age</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>21<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">age</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">params</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">resource</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><a href=\"https://github.com/axios/axios#installing\" target=\"_blank\" rel=\"noopener\">Axios 官方文档 @GitHub</a></li>\n<li><a href=\"http://tool.oschina.net/commons\" target=\"_blank\" rel=\"noopener\">HTTP Content-Type 对照表 @OSChina</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods\" target=\"_blank\" rel=\"noopener\">HTTP 请求方法 @MDN</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>最近几个项目都用到了 Axios，它是一个更现代的 API 请求库，基于 Promise，能运行在浏览器和 Node.js 里。在项目里，一般都是需要进行一次封装再来使用，比如处理鉴权、还有全局的请求 Loading 动画等。今天来总结一下。</p>","more":"<h3 id=\"Axios-简介\"><a href=\"#Axios-简介\" class=\"headerlink\" title=\"Axios 简介\"></a>Axios 简介</h3><p><a href=\"https://github.com/axios/axios\" target=\"_blank\" rel=\"noopener\">Axios</a> 是一个基于 Promise 用于浏览器和 nodejs 的 HTTP 客户端。它有以下功能：</p>\n<ul>\n<li>从浏览器中创建 XMLHttpRequest</li>\n<li>从 Node.js 发出 HTTP 请求</li>\n<li>支持 Promise API</li>\n<li>拦截请求和响应</li>\n<li>转换请求数据和响应数据</li>\n<li>自动转换 JSON 数据</li>\n<li>客户端防止 CSRF/XSRF</li>\n</ul>\n<h3 id=\"基础-API\"><a href=\"#基础-API\" class=\"headerlink\" title=\"基础 API\"></a>基础 API</h3><ul>\n<li><code>axios.request(config)</code></li>\n<li><code>axios.get(url [,config])</code></li>\n<li><code>axios.delete(url [,config])</code></li>\n<li><code>axios.head(url [,config])</code></li>\n<li><code>axios.options(url [,config])</code></li>\n<li><code>axios.post(url [,data [,config]])</code></li>\n<li><code>axios.put(url [,data [,config]])</code></li>\n<li><code>axios.patch(url [,data [,config]])</code></li>\n</ul>\n<div class=\"tip\"><br>  HTTP 请求方法一般会按照它具体的含义来执行相关的动作，这里有一份 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods\" target=\"_blank\" rel=\"noopener\">HTTP 动词对应解释 @MDN</a>。<br></div>\n\n<h3 id=\"用法示例\"><a href=\"#用法示例\" class=\"headerlink\" title=\"用法示例\"></a>用法示例</h3><h4 id=\"GET\"><a href=\"#GET\" class=\"headerlink\" title=\"GET\"></a>GET</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 向具有指定 ID 的用户发出请求（参数在 URL 上）</span></span><br><span class=\"line\">axios</span><br><span class=\"line\">  .get(<span class=\"string\">'/user?ID=12345'</span>)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(res);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(error);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 也可以通过 params 对象传递参数</span></span><br><span class=\"line\">axios</span><br><span class=\"line\">  .get(<span class=\"string\">'/user'</span>, &#123;</span><br><span class=\"line\">    params: &#123;</span><br><span class=\"line\">      ID: <span class=\"number\">12345</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">response</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(response);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(error);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"POST\"><a href=\"#POST\" class=\"headerlink\" title=\"POST\"></a>POST</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios</span><br><span class=\"line\">  .post(</span><br><span class=\"line\">    <span class=\"string\">'/user'</span>,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      userId: <span class=\"string\">'123'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      headers: &#123;</span><br><span class=\"line\">        token: <span class=\"string\">'abc'</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  )</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(res);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(error);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"直接使用-config\"><a href=\"#直接使用-config\" class=\"headerlink\" title=\"直接使用 config\"></a>直接使用 config</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// GET</span></span><br><span class=\"line\">axios(&#123;</span><br><span class=\"line\">  url: <span class=\"string\">'pakage.json'</span>,</span><br><span class=\"line\">  method: <span class=\"string\">'get'</span>,</span><br><span class=\"line\">  params: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// get 在 params 中定义</span></span><br><span class=\"line\">    userId: <span class=\"string\">'123'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  headers: &#123;</span><br><span class=\"line\">    token: <span class=\"string\">'http-test'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res.data);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// POST</span></span><br><span class=\"line\">axios(&#123;</span><br><span class=\"line\">  url: <span class=\"string\">'pakage.json'</span>,</span><br><span class=\"line\">  method: <span class=\"string\">'post'</span>,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// post 在 data 中定义</span></span><br><span class=\"line\">    userId: <span class=\"string\">'123'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  headers: &#123;</span><br><span class=\"line\">    token: <span class=\"string\">'http-test'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res.data);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"并发请求\"><a href=\"#并发请求\" class=\"headerlink\" title=\"并发请求\"></a>并发请求</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getUserAcount</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 返回一个 promise 对象</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> axios.get(<span class=\"string\">'/user/1234'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getUserPermissions</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 返回一个 promise 对象</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> axios.get(<span class=\"string\">'/user/1234/getUserPermissions'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 一次性返回两个接口</span></span><br><span class=\"line\">axios.all([getUserAccount(), getUserPerssions()]).then(</span><br><span class=\"line\">  axios.spread(<span class=\"function\">(<span class=\"params\">acct, perms</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// spread 展开两个返回的结果</span></span><br><span class=\"line\">    <span class=\"comment\">// 两个请求现已完成</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h3 id=\"全局封装、异常处理\"><a href=\"#全局封装、异常处理\" class=\"headerlink\" title=\"全局封装、异常处理\"></a>全局封装、异常处理</h3><p>在项目中，如果每次请求都写一堆 <code>config</code> 会存在大量重复代码，一般我们会封装成一个方法，把一些必要的参数配置好，同理，全局的异常还有鉴权等都统一配置。单次请求数据只做和数据相关的业务逻辑。下面来看一下 Axios 的全局封装例子。</p>\n<h4 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> axios <span class=\"keyword\">from</span> <span class=\"string\">'axios'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> qs <span class=\"keyword\">from</span> <span class=\"string\">'qs'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// POST 方法封装  (原生 form 提交)</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> postRequest = <span class=\"function\">(<span class=\"params\">url, params</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> axios(&#123;</span><br><span class=\"line\">    method: <span class=\"string\">'post'</span>,</span><br><span class=\"line\">    url: url,</span><br><span class=\"line\">    data: params,</span><br><span class=\"line\">    transformRequest: [</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> qs.stringify(data);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    headers: &#123;</span><br><span class=\"line\">      <span class=\"string\">'Content-Type'</span>: <span class=\"string\">'application/x-www-form-urlencoded'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// POST 方法封装  (文件上传)</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> uploadFileRequest = <span class=\"function\">(<span class=\"params\">url, params</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> axios(&#123;</span><br><span class=\"line\">    method: <span class=\"string\">'post'</span>,</span><br><span class=\"line\">    url: url,</span><br><span class=\"line\">    data: params,</span><br><span class=\"line\">    headers: &#123;</span><br><span class=\"line\">      <span class=\"string\">'Content-Type'</span>: <span class=\"string\">'multipart/form-data'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// GET 方法封装</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> getRequest = <span class=\"function\"><span class=\"params\">url</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> axios(&#123;</span><br><span class=\"line\">    method: <span class=\"string\">'get'</span>,</span><br><span class=\"line\">    url: url</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// PUT 方法封装</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> putRequest = <span class=\"function\">(<span class=\"params\">url, params</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> axios(&#123;</span><br><span class=\"line\">    method: <span class=\"string\">'put'</span>,</span><br><span class=\"line\">    url: url,</span><br><span class=\"line\">    data: params,</span><br><span class=\"line\">    transformRequest: [</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> qs.stringify(data);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    headers: &#123;</span><br><span class=\"line\">      <span class=\"string\">'Content-Type'</span>: <span class=\"string\">'application/x-www-form-urlencoded'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// DELETE 方法封装</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> deleteRequest = <span class=\"function\"><span class=\"params\">url</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> axios(&#123;</span><br><span class=\"line\">    method: <span class=\"string\">'delete'</span>,</span><br><span class=\"line\">    url: url</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> axios <span class=\"keyword\">from</span> <span class=\"string\">'axios'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Message &#125; <span class=\"keyword\">from</span> <span class=\"string\">'element-ui'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  请求拦截</span></span><br><span class=\"line\">axios.interceptors.request.use(</span><br><span class=\"line\">  config =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 请求前配置 config</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> config;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  err =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 错误处理</span></span><br><span class=\"line\">    Message.error(&#123; <span class=\"attr\">message</span>: <span class=\"string\">'请求超时!'</span> &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.resolve(err);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 响应拦截</span></span><br><span class=\"line\">axios.interceptors.response.use(</span><br><span class=\"line\">  data =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 请求后处理对应的数据</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 方式一：和后端约定响应码 `code`</span></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (data.code) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">'0'</span>:</span><br><span class=\"line\">        <span class=\"comment\">// 正常直接返回</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> data;</span><br><span class=\"line\">      <span class=\"comment\">// 需要重新登录</span></span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">'-1'</span>:</span><br><span class=\"line\">        <span class=\"comment\">// some code here..</span></span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"keyword\">default</span>:</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 方式二：仅判断 HTTP 状态码</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data.status &amp;&amp; data.status == <span class=\"number\">200</span> &amp;&amp; data.data.status == <span class=\"string\">'error'</span>) &#123;</span><br><span class=\"line\">      Message.error(&#123; <span class=\"attr\">message</span>: data.data.msg &#125;);</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> data;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  err =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 错误处理</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err &amp;&amp; err.response) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">switch</span> (err.response.status) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">400</span>:</span><br><span class=\"line\">          err.message = <span class=\"string\">'请求错误 (400)'</span>;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">401</span>:</span><br><span class=\"line\">          err.message = <span class=\"string\">'未授权，请重新登录 (401)'</span>;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">403</span>:</span><br><span class=\"line\">          err.message = <span class=\"string\">'拒绝访问 (403)'</span>;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">404</span>:</span><br><span class=\"line\">          err.message = <span class=\"string\">'请求出错 (404)'</span>;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">408</span>:</span><br><span class=\"line\">          err.message = <span class=\"string\">'请求超时 (408)'</span>;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">500</span>:</span><br><span class=\"line\">          err.message = <span class=\"string\">'服务器错误 (500)'</span>;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">501</span>:</span><br><span class=\"line\">          err.message = <span class=\"string\">'服务未实现 (501)'</span>;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">502</span>:</span><br><span class=\"line\">          err.message = <span class=\"string\">'网络错误 (502)'</span>;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">503</span>:</span><br><span class=\"line\">          err.message = <span class=\"string\">'服务不可用 (503)'</span>;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">504</span>:</span><br><span class=\"line\">          err.message = <span class=\"string\">'网络超时 (504)'</span>;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">505</span>:</span><br><span class=\"line\">          err.message = <span class=\"string\">'HTTP 版本不受支持 (505)'</span>;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">          err.message = <span class=\"string\">`连接出错 (<span class=\"subst\">$&#123;err.response.status&#125;</span>)!`</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      err.message = <span class=\"string\">'连接服务器失败!'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Message.err(&#123; <span class=\"attr\">message</span>: err.message &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.resolve(err);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<div class=\"tip\"><br>请求出错的时候执行的是：<code>Promise.resolve(err)</code>，而不是 <code>Promise.reject(err)</code>，这样无论请求成功还是失败，在成功的回调中都能收到通知。<br></div>\n\n<h3 id=\"其它配置\"><a href=\"#其它配置\" class=\"headerlink\" title=\"其它配置\"></a>其它配置</h3><h4 id=\"baseURL\"><a href=\"#baseURL\" class=\"headerlink\" title=\"baseURL\"></a>baseURL</h4><p>通过 <code>axios.defaults.baseURL</code> 来设置 API 的根域名。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (process.env.NODE_ENV == <span class=\"string\">'development'</span>) &#123;</span><br><span class=\"line\">  axios.defaults.baseURL = <span class=\"string\">'https://dev.server.com/'</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (process.env.NODE_ENV == <span class=\"string\">'debug'</span>) &#123;</span><br><span class=\"line\">  axios.defaults.baseURL = <span class=\"string\">'https://debug.server.com/'</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (process.env.NODE_ENV == <span class=\"string\">'production'</span>) &#123;</span><br><span class=\"line\">  axios.defaults.baseURL = <span class=\"string\">'https://pro.server.com/'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<div class=\"tip\"><br><code>process.env</code> 是 Node.js 提供的全局变量，我们可以在 npm scripts 里通过 cross-env 这个工具统一配置不同的环境，cross-env 做了各种系统平台的兼容处理。一般用这个设置环境变量。<br></div>\n\n<h4 id=\"请求超时\"><a href=\"#请求超时\" class=\"headerlink\" title=\"请求超时\"></a>请求超时</h4><p>通过 <code>axios.defaults.timeout</code> 设置默认的请求超时时间。例如超过了 10s，就会告知用户当前请求超时，请刷新等。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios.defaults.timeout = <span class=\"number\">10000</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"单独设置-POST-的请求头\"><a href=\"#单独设置-POST-的请求头\" class=\"headerlink\" title=\"单独设置 POST 的请求头\"></a>单独设置 POST 的请求头</h4><p>比如设置 POST 提交（原生 form）时单独配置。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios.defaults.headers.post[<span class=\"string\">'Content-Type'</span>] =</span><br><span class=\"line\">  <span class=\"string\">'application/x-www-form-urlencoded;charset=UTF-8'</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"附-完整代码\"><a href=\"#附-完整代码\" class=\"headerlink\" title=\"附: 完整代码\"></a>附: 完整代码</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> axios <span class=\"keyword\">from</span> <span class=\"string\">'axios'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> QS <span class=\"keyword\">from</span> <span class=\"string\">'qs'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Toast &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vant'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 环境的切换</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (process.env.NODE_ENV == <span class=\"string\">'development'</span>) &#123;</span><br><span class=\"line\">  axios.defaults.baseURL = <span class=\"string\">'https://dev.server.com/'</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (process.env.NODE_ENV == <span class=\"string\">'debug'</span>) &#123;</span><br><span class=\"line\">  axios.defaults.baseURL = <span class=\"string\">'https://debug.server.com/'</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (process.env.NODE_ENV == <span class=\"string\">'production'</span>) &#123;</span><br><span class=\"line\">  axios.defaults.baseURL = <span class=\"string\">'https://pro.server.com/'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 请求超时时间</span></span><br><span class=\"line\">axios.defaults.timeout = <span class=\"number\">10000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// POST 请求头</span></span><br><span class=\"line\">axios.defaults.headers.post[<span class=\"string\">'Content-Type'</span>] =</span><br><span class=\"line\">  <span class=\"string\">'application/x-www-form-urlencoded;charset=UTF-8'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 请求拦截器</span></span><br><span class=\"line\">axios.interceptors.request.use(</span><br><span class=\"line\">  config = &gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> token = store.state.token;</span><br><span class=\"line\">    token &amp;&amp; (config.headers.Authorization = token);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> config;</span><br><span class=\"line\">  &#125;, error = &gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.error(error);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 响应拦截器</span></span><br><span class=\"line\">axios.interceptors.response.use(</span><br><span class=\"line\">  response = &gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (response.status === <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.resolve(response);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.reject(response);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// 服务器状态码不是 200 的情况</span></span><br><span class=\"line\">  error = &gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (error.response.status) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">switch</span> (error.response.status) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">401</span>:</span><br><span class=\"line\">          router.replace(&#123;</span><br><span class=\"line\">            path: <span class=\"string\">'/login'</span>,</span><br><span class=\"line\">            query: &#123;</span><br><span class=\"line\">              redirect: router.currentRoute.fullPath</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">403</span>:</span><br><span class=\"line\">          Toast(&#123;</span><br><span class=\"line\">            message: <span class=\"string\">'登录过期，请重新登录'</span>,</span><br><span class=\"line\">            duration: <span class=\"number\">1000</span>,</span><br><span class=\"line\">            forbidClick: <span class=\"literal\">true</span></span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          <span class=\"comment\">// 404 请求不存在</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">404</span>:</span><br><span class=\"line\">          Toast(&#123;</span><br><span class=\"line\">            message: <span class=\"string\">'网络请求不存在'</span>,</span><br><span class=\"line\">            duration: <span class=\"number\">1500</span>,</span><br><span class=\"line\">            forbidClick: <span class=\"literal\">true</span></span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          <span class=\"comment\">// 其他错误，直接抛出错误提示</span></span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">          Toast(&#123;</span><br><span class=\"line\">            message: error.response.data.message,</span><br><span class=\"line\">            duration: <span class=\"number\">1500</span>,</span><br><span class=\"line\">            forbidClick: <span class=\"literal\">true</span></span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.reject(error.response);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// GET 请求</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">get</span>(<span class=\"params\">url, params</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    axios</span><br><span class=\"line\">      .get(url, &#123; <span class=\"attr\">params</span>: params &#125;)</span><br><span class=\"line\">      .then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">        resolve(res.data);</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      .catch (<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</span><br><span class=\"line\">        reject(err.data)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// POST 请求</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">post</span>(<span class=\"params\">url, params</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    axios</span><br><span class=\"line\">      .post(url, QS.stringify(params))</span><br><span class=\"line\">      .then(res = &gt; &#123;</span><br><span class=\"line\">        resolve(res.data);</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      .catch (<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</span><br><span class=\"line\">        reject(err.data)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"附-Content-Type\"><a href=\"#附-Content-Type\" class=\"headerlink\" title=\"附: Content-Type\"></a>附: Content-Type</h3><p>说到和服务端数据交互，总是绕不开这个，必须要扫盲一下了！😂😂</p>\n<blockquote>\n<p>Content-Type 用于指定内容类型，一般是指网页中存在的 Content-Type，Content-Type 属性指定请求和响应的 HTTP 内容类型。如果未指定 ContentType，默认为 <code>text/html</code>。</p>\n</blockquote>\n<p>常见类型有：</p>\n<ul>\n<li>text/html</li>\n<li>application/x-www-form-urlencoded</li>\n<li>multipart/form-data</li>\n<li>application/json</li>\n<li>application/xml</li>\n</ul>\n<p><code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>application/json</code>、<code>application/xml</code> 这四个则是 ajax 请求需要指定的类型，表单提交或上传文件常用的资源类型。</p>\n<h4 id=\"application-x-www-form-urlencoded\"><a href=\"#application-x-www-form-urlencoded\" class=\"headerlink\" title=\"application/x-www-form-urlencoded\"></a>application/x-www-form-urlencoded</h4><p>这是表单默认提交方式，格式为 URL 编码 <code>key=value&amp;key1=value1</code>。</p>\n<div style=\"max-width: 500px\"><img src=\"https://user-images.githubusercontent.com/9158841/32037816-ade83a36-b9ec-11e7-9f07-4f72a99c6aaa.png\" alt=\"image\"></div>\n\n<p>注：Chrome 浏览器会自动格式化成易读的格式</p>\n<h4 id=\"multipart-form-data\"><a href=\"#multipart-form-data\" class=\"headerlink\" title=\"multipart/form-data\"></a>multipart/form-data</h4><p>使用表单上传文件时，必须指定表单的 enctype 属性值为 <code>multipart/form-data</code>。<br>请求体被分割成多部分，每部分使用 <code>--boundary</code> 分割，使用 <code>--boundary--\\r\\n</code> 结束。</p>\n<p>表单上传文件 Demo:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">\"/upload\"</span> <span class=\"attr\">enctype</span>=<span class=\"string\">\"multipart/form-data\"</span> <span class=\"attr\">method</span>=<span class=\"string\">\"post\"</span>&gt;</span></span><br><span class=\"line\">    用户名: <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"username\"</span>&gt;</span></span><br><span class=\"line\">    密码: <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"password\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"password\"</span>&gt;</span></span><br><span class=\"line\">    上传文件: <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"file\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"file\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"submit\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"提交\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<div style=\"max-width: 500px\"><img src=\"https://user-images.githubusercontent.com/9158841/32038354-1201f94c-b9ef-11e7-8817-fb9031b2b036.png\" alt=\"image\"></div>\n\n<h4 id=\"application-json\"><a href=\"#application-json\" class=\"headerlink\" title=\"application/json\"></a>application/json</h4><p>Axios 默认 <code>POST</code> 提交方式就是 <code>application/json</code>，所以，在使用 axios 提交表单时需要注意后端能不能解析，不能解析需要设置 <code>POST</code> 常用格式 <code>application/x-www-form-urlencoded</code>，且提交的数据需要使用 qs 模块序列化格式。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios.post(</span><br><span class=\"line\">  <span class=\"string\">'https://jsonplaceholder.typicode.com/posts'</span>,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    userId: <span class=\"number\">1</span>,</span><br><span class=\"line\">    name: <span class=\"string\">'ifyour'</span>,</span><br><span class=\"line\">    arr: [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    headers: &#123;</span><br><span class=\"line\">      <span class=\"string\">'Content-Type'</span>: <span class=\"string\">'application/x-www-form-urlencoded'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    transformRequest: [</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> qs.stringify(data);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<div style=\"max-width: 400px\"><img src=\"https://user-images.githubusercontent.com/15377484/45913317-a939a580-be62-11e8-9d96-1a097337da44.png\" alt=\"image\"></div>\n\n<h4 id=\"application-xml\"><a href=\"#application-xml\" class=\"headerlink\" title=\"application/xml\"></a>application/xml</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST http://www.example.com HTTP/1.1</span><br><span class=\"line\">Content-Type: text/xml</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\"?&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">resource</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>123<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">params</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>example<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">age</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>21<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">age</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">params</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">resource</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><a href=\"https://github.com/axios/axios#installing\" target=\"_blank\" rel=\"noopener\">Axios 官方文档 @GitHub</a></li>\n<li><a href=\"http://tool.oschina.net/commons\" target=\"_blank\" rel=\"noopener\">HTTP Content-Type 对照表 @OSChina</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods\" target=\"_blank\" rel=\"noopener\">HTTP 请求方法 @MDN</a></li>\n</ul>"},{"title":"ES6 Promise 简明指南","comments":1,"date":"2018-05-29T14:28:41.000Z","from":"https://codeburst.io/a-simple-guide-to-es6-promises-d71bacd2e13a","_content":"\nPromise 是 JavaScriptES6 中最令人兴奋的新增功能之一. ES5 中使用回调函数来处理异步操作. 过度使用回调则会产生回调地狱和多级嵌套缩带来的问题. Promise 通过将异步代码转化成同步执行的方式, 大大简化了异步编程方式.\n\n<!-- more -->\n\n这篇文章中, 我们来学习一下什么是 Promise 以及在开发中的实践.\n\n### 什么是 Promise\n\n简单来说 Promise 就是一个存放着未来才会有计算结果的占位符. 稍微想想, 你会发现, 这和我们平常在谈话过程中说的承诺很像. 举个例子: 你准备去印度旅行, 你订了一张去印度的机票. 这个机票上写着多少号, 座位号是多少. 这个场景下, 机票就是航空公司给你许下的承诺: 在你准备出发那天给你预留了一个头等舱！😎\n\n还有一个简单的例子, 你承诺你的朋友, 当你读完《计算机编程艺术》这本书后, 你就把这本书还回去. 在这里, 你所说的话就好比是一个占位符, 需要返回的值就是这本书.\n\n你还可以想到其他一些类似承诺的例子, 比如在医生办公室等着、在餐馆点餐、在图书馆写书等等. 都涉及某种形式的承诺.\n\n### 生成一个 Promise\n\n当某项任务的完成时间不确定或太长时, 就可以使用 Promise. 例如, 网络请求可能需要 10ms 到 200ms（或更长）的时间, 具体取决于网速. 我们不想在获取数据时等待. 200 毫秒对你来说可能不太重要, 但对于一台电脑来说, 这是一段很长的时间. Promise 就是要让这种异步变得简单、轻松. 使用 Promise 构造函数, 来实例化一个 myPromise 实例, 像这样:\n\n```js\nconst myPromise = new Promise((resolve, reject) => {\n  if (Math.random() * 100 <= 90) {\n    resolve('Hello, Promises!');\n  }\n  reject(new Error('In 10% of the cases, I fail. Miserably.'));\n});\n```\n\n来看一下这个接收两个参数的函数. `new Promise()` 被称为执行器函数, 它描述了要完成的计算. 它的这两个参数通常被叫做 `resolve` 和 `reject`, 可以理解为 **执行** 和 **拒绝**, 它们用来标记执行器函数最终的计算结果. `resolve` 和 `reject` 本身是一个函数, 它用来返回一个值给我们的 Promise 实例.\n\n当运算结果成功时, 或者未来着这个值准备就绪时, 我们就使用这个 `resolve` 函数来返回一个值, 我们就说: 我践行了当初许下的这个承诺.\n\n同理, 当计算结果失败时, 或者计算过程中遇到了错误, 我们就使用 `reject` 函数, 我们就说: 我拒绝履行这个承诺. `reject` 函数可以接收任何值来作为参数, 但是比较推荐的是我们可以传递一个 `Error` 对象, 即: 抛出一个错误, 用来帮助我们调试代码, 这样就可以根据具体的抛出错误信息去解决问题啦.\n\n在上面的这个例子中, `Math.random()` 用来生成一个随机数, 在 90% 的情况下, 这个 Promise 都应该被执行 (假设等概率分布), 剩余的情况下都是拒绝执行的.\n\n### 如何使用 Promises\n\n在上面的代码例子中, 我们生成了一个 Promise 实例 `myPromise`, 那么如何通过 `resolve` 和 `reject` 函数访问计算完成后的值呢? 所有的 `Promise` 实例都有一个 `.then()` 方法, 我们来瞧瞧:\n\n```js\nconst myPromise = new Promise((resolve, reject) => {\n  if (Math.random() * 100 < 90) {\n    console.log('resolving the promise ...');\n    resolve('Hello, Promises!');\n  }\n  reject(new Error('In 10% of the cases, I fail. Miserably.'));\n});\n\n// Two functions\nconst onResolved = resolvedValue => console.log(resolvedValue);\nconst onRejected = error => console.log(error);\n\nmyPromise.then(onResolved, onRejected);\n\n// Same as above, written concisely\nmyPromise.then(\n  resolvedValue => {\n    console.log(resolvedValue);\n  },\n  error => {\n    console.log(error);\n  }\n);\n\n// Output (in 90% of the cases)\n\n// resolving the promise ...\n// Hello, Promises!\n// Hello, Promises!\n```\n\n`.then()` 方法接收 2 个回调函数, 第一个回调函数是当我们的 Promise 实例被执行 (resolve) 时调用, 第二个则是被拒绝 (reject) 时调用. 在上面的代码中, 我们使用 `onResolved` 和 `onRejected` 定义了这两个函数, 然后把它放到 `.then` 函数里, 当然, 你也可以按照常规写法, 直接在 `.then` 函数里写两个函数, 都是一样的.\n\n在这个例子中, 有几点非常重要, 我们来说一下:\n\n* 一个 `promise` 只能是成功或者失败状态中的一个. 它不能成功或者失败多次. 也不能从成功状态切换到失败状态, 失败反之亦然.\n* 你可以在成功或者失败状态后, 去定义这样一个回调函数. 当他们 `resolve` 或者 `reject` 仍然能正确调用.\n\n这就说明, `Promise` 最终只有一个状态, 即使你多次使用 `.then` 处理函数, 这个状态不能更改 (计算结果也不会重复执行).\n\n为了验证这点, 你可以看到在第 3 行代码中, `console.log` 语句, 当你多次使用 `.then` 处理程序运行上述代码时, `console.log` 的语句只会被打印一次. 这就说明了 Promise 会缓存计算结果的, 当有一些相同的结果时, 缓存结果会被返回.\n\n另一个重要的要注意的是, Promise 是 [及早求值 (evaluated eagerly)](https://zh.wikipedia.org/wiki/%E5%8F%8A%E6%97%A9%E6%B1%82%E5%80%BC) 的: 只要声明并将其赋值到变量上, 它已经开始在内存中执行了. 没有 `.start` 或 `.begin` 方法. 就像它在前面的例子中开始的那样.\n\n为了确保 Promise 能被延迟调用, 我们通常还需要在它的外层包裹一个函数, 稍后的例子中我们会解释这个.\n\n### 捕获 Promise\n\n到目前为止, 我们已经看到了 `resolve` 的场景, 那么当执行函数中出现一个错误时, 会发生什么呢? 在 `.then()` 函数中的第二个参数, 就是上面例子中的 `onRejected` 会被执行, 来看一个例子:\n\n```js\nconst myPromise = new Promise((resolve, reject) => {\n  if (Math.random() * 100 < 90) {\n    reject(new Error('The promise was rejected by using reject function.'));\n  }\n  throw new Error('The promise was rejected by throwing an error');\n});\n\nmyPromise.then(\n  () => console.log('resolved'),\n  error => console.log(error.message)\n);\n\n// Output (in 90% of cases)\n\n// The promise was rejected by using reject function.\n```\n\n和第一个例子一样的, 但是现在 90% 的情况是被 `reject` 的, 另外 10% 的情况则是抛出一个错误语句.\n\n在第一个例子中, 我们分别定义了 `onResolved` 和 `onRejected` 方法, `onRejected` 方法将在错误发生时被调用, 可以看到 `reject` 函数的参数可以直接是错误提示, 没必要必须 `new Error`, 两个写法都一样.\n\n健壮的程序代码离不开错误处理, `.then` 方法的第二个参数给了我们这样一个捷径. 当需要处理一个错误时, 可以用 `.catch(onRejected)` 来代替 `.then(null, () => {...})`, `catch` 方法接收一个回调函数 `onRejected`, 因此, 上面的代码, 可以使用 `catch` 来简化写法:\n\n```js\nmyPromise.catch(error => console.log(error.message));\n```\n\n记住: `.catch` 方法仅仅是 `.then(undefined, onRejected)` 的语法糖而已.\n\n### 链式 Promise\n\n`.then()` 和 `.catch()` 方法永远会返回一个 Promise 实例, 所以你可以链式使用多个 `.then` 一起来调用. 让我们来举个例子理解它.\n\n首先, 我们写一个函数, 来延迟返回一个 Promise 实例. 这个返回的 Promise 将在稍后的时间内 `resolve`. 这里是实现方法:\n\n```js\nconst delay = ms => new Promise(resolve => setTimeout(resolve, ms));\n```\n\n在这个例子中, 我们正在使用一个函数来包裹我们的 Promise 实例, 所以它并不会立即执行. 这个 `delay` 函数接收一个时间来作为参数. 这个执行函数将接收 `ms` 作为他的参数, 它还包含一个 `setTimeout` , 它在 `ms` 毫秒后调用 `resolve` 函数, 从而正确执行. 看这个例子:\n\n```js\ndelay(5000).then(() => console.log('Resolved after 5 seconds'));\n```\n\n`.then` 中的回调语句将在 `delay(5000)` 后执行. 当你执行上面的代码 5 秒后, 你就可以在控制台上看到输出结果了.\n\n这里, 我们可以使用多个 `.then()` 方法来链式调用:\n\n```js\nconst delay = ms => new Promise(resolve => setTimeout(resolve, ms));\n\ndelay(2000)\n  .then(() => {\n    console.log('Resolved after 2 seconds');\n    return delay(1500);\n  })\n  .then(() => {\n    console.log('Resolved after 1.5 seconds');\n    return delay(3000);\n  })\n  .then(() => {\n    console.log('Resolved after 3 seconds');\n    throw new Error();\n  })\n  .catch(() => {\n    console.log('Caught an error.');\n  })\n  .then(() => {\n    console.log('Done.');\n  });\n\n// Resolved after 2 seconds\n// Resolved after 1.5 seconds\n// Resolved after 3 seconds\n// Caught an error.\n// Done.\n```\n\n从第 3 行开始, 它的执行步骤是这样的:\n\n* `delay(2000)` 函数执行, 它返回一个稍后 2 秒即将执行的 Promise 实例.\n* 第 1 个 `.then()` 执行, 它输出语句 `Resolved after 2 seconds`, 然后它执行 `delay(1500)` 又返回一个 Promise 实例, 如果一个 `.then()` 返回了一个 Promise 实例, 那么它的 `resolve` 将被转发给下一个 `.then` 方法调用, 技术上叫: 沉降 (settlement).\n* 只要像这样继续串联下去, 它会继续执行.\n\n注意在第三个 `.then()` 方法时, 我们在 `.then` 中抛出了一个错误. 这意味着当前的 Promise 被拒绝. 然后它会在下一个 `.catch` 语句中被捕获, `Caught an error` 将会被输出. 然而一个 `.catch` 语句它自己永远是被 `resolve` 的, 所以不需要在语句里再写 `reject` (除非你故意抛出一个错误), 这也是为什么在 `.catch` 语句后还可以继续写 `.then` 的原因.\n\n比较推荐的做法是在 `.then` 方法后执行 `.catch` 而不是使用 `onResolved` 和 `onRejected`, 我们来举个例子说明一下:\n\n```js\nconst promiseThatResolves = () =>\n  new Promise((resolve, reject) => {\n    resolve();\n  });\n\n// Leads to UnhandledPromiseRejection\npromiseThatResolves().then(\n  () => {\n    throw new Error();\n  },\n  err => console.log(err)\n);\n\n// Proper error handling\npromiseThatResolves()\n  .then(() => {\n    throw new Error();\n  })\n  .catch(err => console.log(err));\n```\n\n我们创造一个永远能被 `resolve` 的 Promise 实例, 当你执行 `.then` 时, 可以带两个回调函数: `onResolved` 和 `onRejected`, 第一种写法, 在 `then` 种放入两个回调函数, 但是: 如果在第一个回调函数中继续抛出错误, 那么这个错误是不能被捕获的. 😅\n\n第二种写法, 在 `.then` 语句的后面使用 `.catch` 捕获, 不光能捕获到执行函数 `promiseThatResolves` 的错误, 而且在 `.then()` 中的错误也是能被捕获到. 知道这样写的好处了吧!😁\n\n### 总结\n\n你可以执行上面的所有代码片段来更深入的学习. 一种比较好的实践就是, 把所有基于回调的函数都用 Promise 来重新实现. 如果你写 Node.js 的话, 你会发现 `fs` 还有其他模块都是基于回调函数来实现的. 所以会存在一些工具库, 它们把所有基于回调的实现方式使用 Promise 来实现了. 比如 Node.js 的 [util.promisify](https://nodejs.org/api/util.html#util_util_promisify_original) 和 [pify](https://github.com/sindresorhus/pify). 如果你在学习的话, 那么尽可能的尝试自己去实现. 或者说去读这些 Promise 实现库的源代码. 然后你就可以把这些最佳实践用于你的产品中啦!\n\n还有一些关于 Promise 的东西没有完全讲到, 比如 `Promise.all` 和 `Promise.race` 方法, 处理 Promise 中的错误, 以及一些常见的反模式和细节等. 你可以参考下面的链接来学习更多关于 Promise 的知识.\n\n### 参考\n\n* [ECMA Promise Specification](http://www.ecma-international.org/ecma-262/6.0/#sec-promise-objects)\n* [Mozilla Docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)\n* [Google’s Developer’s Guide on Promises written by Jake Archibald](https://developers.google.com/web/fundamentals/primers/promises#promise-api-reference)\n* [Exploring JS’s Chapter on Promises](http://exploringjs.com/es6/ch_promises.html#sec_first-example-promises)\n* [Introduction to Promises](http://jamesknelson.com/grokking-es6-promises-the-four-functions-you-need-to-avoid-callback-hell/)\n","source":"_posts/ES6-Promise-简明指南.md","raw":"---\ntitle: ES6 Promise 简明指南\ncomments: true\ndate: 2018-05-29 22:28:41\ntags:\nfrom: https://codeburst.io/a-simple-guide-to-es6-promises-d71bacd2e13a\n---\n\nPromise 是 JavaScriptES6 中最令人兴奋的新增功能之一. ES5 中使用回调函数来处理异步操作. 过度使用回调则会产生回调地狱和多级嵌套缩带来的问题. Promise 通过将异步代码转化成同步执行的方式, 大大简化了异步编程方式.\n\n<!-- more -->\n\n这篇文章中, 我们来学习一下什么是 Promise 以及在开发中的实践.\n\n### 什么是 Promise\n\n简单来说 Promise 就是一个存放着未来才会有计算结果的占位符. 稍微想想, 你会发现, 这和我们平常在谈话过程中说的承诺很像. 举个例子: 你准备去印度旅行, 你订了一张去印度的机票. 这个机票上写着多少号, 座位号是多少. 这个场景下, 机票就是航空公司给你许下的承诺: 在你准备出发那天给你预留了一个头等舱！😎\n\n还有一个简单的例子, 你承诺你的朋友, 当你读完《计算机编程艺术》这本书后, 你就把这本书还回去. 在这里, 你所说的话就好比是一个占位符, 需要返回的值就是这本书.\n\n你还可以想到其他一些类似承诺的例子, 比如在医生办公室等着、在餐馆点餐、在图书馆写书等等. 都涉及某种形式的承诺.\n\n### 生成一个 Promise\n\n当某项任务的完成时间不确定或太长时, 就可以使用 Promise. 例如, 网络请求可能需要 10ms 到 200ms（或更长）的时间, 具体取决于网速. 我们不想在获取数据时等待. 200 毫秒对你来说可能不太重要, 但对于一台电脑来说, 这是一段很长的时间. Promise 就是要让这种异步变得简单、轻松. 使用 Promise 构造函数, 来实例化一个 myPromise 实例, 像这样:\n\n```js\nconst myPromise = new Promise((resolve, reject) => {\n  if (Math.random() * 100 <= 90) {\n    resolve('Hello, Promises!');\n  }\n  reject(new Error('In 10% of the cases, I fail. Miserably.'));\n});\n```\n\n来看一下这个接收两个参数的函数. `new Promise()` 被称为执行器函数, 它描述了要完成的计算. 它的这两个参数通常被叫做 `resolve` 和 `reject`, 可以理解为 **执行** 和 **拒绝**, 它们用来标记执行器函数最终的计算结果. `resolve` 和 `reject` 本身是一个函数, 它用来返回一个值给我们的 Promise 实例.\n\n当运算结果成功时, 或者未来着这个值准备就绪时, 我们就使用这个 `resolve` 函数来返回一个值, 我们就说: 我践行了当初许下的这个承诺.\n\n同理, 当计算结果失败时, 或者计算过程中遇到了错误, 我们就使用 `reject` 函数, 我们就说: 我拒绝履行这个承诺. `reject` 函数可以接收任何值来作为参数, 但是比较推荐的是我们可以传递一个 `Error` 对象, 即: 抛出一个错误, 用来帮助我们调试代码, 这样就可以根据具体的抛出错误信息去解决问题啦.\n\n在上面的这个例子中, `Math.random()` 用来生成一个随机数, 在 90% 的情况下, 这个 Promise 都应该被执行 (假设等概率分布), 剩余的情况下都是拒绝执行的.\n\n### 如何使用 Promises\n\n在上面的代码例子中, 我们生成了一个 Promise 实例 `myPromise`, 那么如何通过 `resolve` 和 `reject` 函数访问计算完成后的值呢? 所有的 `Promise` 实例都有一个 `.then()` 方法, 我们来瞧瞧:\n\n```js\nconst myPromise = new Promise((resolve, reject) => {\n  if (Math.random() * 100 < 90) {\n    console.log('resolving the promise ...');\n    resolve('Hello, Promises!');\n  }\n  reject(new Error('In 10% of the cases, I fail. Miserably.'));\n});\n\n// Two functions\nconst onResolved = resolvedValue => console.log(resolvedValue);\nconst onRejected = error => console.log(error);\n\nmyPromise.then(onResolved, onRejected);\n\n// Same as above, written concisely\nmyPromise.then(\n  resolvedValue => {\n    console.log(resolvedValue);\n  },\n  error => {\n    console.log(error);\n  }\n);\n\n// Output (in 90% of the cases)\n\n// resolving the promise ...\n// Hello, Promises!\n// Hello, Promises!\n```\n\n`.then()` 方法接收 2 个回调函数, 第一个回调函数是当我们的 Promise 实例被执行 (resolve) 时调用, 第二个则是被拒绝 (reject) 时调用. 在上面的代码中, 我们使用 `onResolved` 和 `onRejected` 定义了这两个函数, 然后把它放到 `.then` 函数里, 当然, 你也可以按照常规写法, 直接在 `.then` 函数里写两个函数, 都是一样的.\n\n在这个例子中, 有几点非常重要, 我们来说一下:\n\n* 一个 `promise` 只能是成功或者失败状态中的一个. 它不能成功或者失败多次. 也不能从成功状态切换到失败状态, 失败反之亦然.\n* 你可以在成功或者失败状态后, 去定义这样一个回调函数. 当他们 `resolve` 或者 `reject` 仍然能正确调用.\n\n这就说明, `Promise` 最终只有一个状态, 即使你多次使用 `.then` 处理函数, 这个状态不能更改 (计算结果也不会重复执行).\n\n为了验证这点, 你可以看到在第 3 行代码中, `console.log` 语句, 当你多次使用 `.then` 处理程序运行上述代码时, `console.log` 的语句只会被打印一次. 这就说明了 Promise 会缓存计算结果的, 当有一些相同的结果时, 缓存结果会被返回.\n\n另一个重要的要注意的是, Promise 是 [及早求值 (evaluated eagerly)](https://zh.wikipedia.org/wiki/%E5%8F%8A%E6%97%A9%E6%B1%82%E5%80%BC) 的: 只要声明并将其赋值到变量上, 它已经开始在内存中执行了. 没有 `.start` 或 `.begin` 方法. 就像它在前面的例子中开始的那样.\n\n为了确保 Promise 能被延迟调用, 我们通常还需要在它的外层包裹一个函数, 稍后的例子中我们会解释这个.\n\n### 捕获 Promise\n\n到目前为止, 我们已经看到了 `resolve` 的场景, 那么当执行函数中出现一个错误时, 会发生什么呢? 在 `.then()` 函数中的第二个参数, 就是上面例子中的 `onRejected` 会被执行, 来看一个例子:\n\n```js\nconst myPromise = new Promise((resolve, reject) => {\n  if (Math.random() * 100 < 90) {\n    reject(new Error('The promise was rejected by using reject function.'));\n  }\n  throw new Error('The promise was rejected by throwing an error');\n});\n\nmyPromise.then(\n  () => console.log('resolved'),\n  error => console.log(error.message)\n);\n\n// Output (in 90% of cases)\n\n// The promise was rejected by using reject function.\n```\n\n和第一个例子一样的, 但是现在 90% 的情况是被 `reject` 的, 另外 10% 的情况则是抛出一个错误语句.\n\n在第一个例子中, 我们分别定义了 `onResolved` 和 `onRejected` 方法, `onRejected` 方法将在错误发生时被调用, 可以看到 `reject` 函数的参数可以直接是错误提示, 没必要必须 `new Error`, 两个写法都一样.\n\n健壮的程序代码离不开错误处理, `.then` 方法的第二个参数给了我们这样一个捷径. 当需要处理一个错误时, 可以用 `.catch(onRejected)` 来代替 `.then(null, () => {...})`, `catch` 方法接收一个回调函数 `onRejected`, 因此, 上面的代码, 可以使用 `catch` 来简化写法:\n\n```js\nmyPromise.catch(error => console.log(error.message));\n```\n\n记住: `.catch` 方法仅仅是 `.then(undefined, onRejected)` 的语法糖而已.\n\n### 链式 Promise\n\n`.then()` 和 `.catch()` 方法永远会返回一个 Promise 实例, 所以你可以链式使用多个 `.then` 一起来调用. 让我们来举个例子理解它.\n\n首先, 我们写一个函数, 来延迟返回一个 Promise 实例. 这个返回的 Promise 将在稍后的时间内 `resolve`. 这里是实现方法:\n\n```js\nconst delay = ms => new Promise(resolve => setTimeout(resolve, ms));\n```\n\n在这个例子中, 我们正在使用一个函数来包裹我们的 Promise 实例, 所以它并不会立即执行. 这个 `delay` 函数接收一个时间来作为参数. 这个执行函数将接收 `ms` 作为他的参数, 它还包含一个 `setTimeout` , 它在 `ms` 毫秒后调用 `resolve` 函数, 从而正确执行. 看这个例子:\n\n```js\ndelay(5000).then(() => console.log('Resolved after 5 seconds'));\n```\n\n`.then` 中的回调语句将在 `delay(5000)` 后执行. 当你执行上面的代码 5 秒后, 你就可以在控制台上看到输出结果了.\n\n这里, 我们可以使用多个 `.then()` 方法来链式调用:\n\n```js\nconst delay = ms => new Promise(resolve => setTimeout(resolve, ms));\n\ndelay(2000)\n  .then(() => {\n    console.log('Resolved after 2 seconds');\n    return delay(1500);\n  })\n  .then(() => {\n    console.log('Resolved after 1.5 seconds');\n    return delay(3000);\n  })\n  .then(() => {\n    console.log('Resolved after 3 seconds');\n    throw new Error();\n  })\n  .catch(() => {\n    console.log('Caught an error.');\n  })\n  .then(() => {\n    console.log('Done.');\n  });\n\n// Resolved after 2 seconds\n// Resolved after 1.5 seconds\n// Resolved after 3 seconds\n// Caught an error.\n// Done.\n```\n\n从第 3 行开始, 它的执行步骤是这样的:\n\n* `delay(2000)` 函数执行, 它返回一个稍后 2 秒即将执行的 Promise 实例.\n* 第 1 个 `.then()` 执行, 它输出语句 `Resolved after 2 seconds`, 然后它执行 `delay(1500)` 又返回一个 Promise 实例, 如果一个 `.then()` 返回了一个 Promise 实例, 那么它的 `resolve` 将被转发给下一个 `.then` 方法调用, 技术上叫: 沉降 (settlement).\n* 只要像这样继续串联下去, 它会继续执行.\n\n注意在第三个 `.then()` 方法时, 我们在 `.then` 中抛出了一个错误. 这意味着当前的 Promise 被拒绝. 然后它会在下一个 `.catch` 语句中被捕获, `Caught an error` 将会被输出. 然而一个 `.catch` 语句它自己永远是被 `resolve` 的, 所以不需要在语句里再写 `reject` (除非你故意抛出一个错误), 这也是为什么在 `.catch` 语句后还可以继续写 `.then` 的原因.\n\n比较推荐的做法是在 `.then` 方法后执行 `.catch` 而不是使用 `onResolved` 和 `onRejected`, 我们来举个例子说明一下:\n\n```js\nconst promiseThatResolves = () =>\n  new Promise((resolve, reject) => {\n    resolve();\n  });\n\n// Leads to UnhandledPromiseRejection\npromiseThatResolves().then(\n  () => {\n    throw new Error();\n  },\n  err => console.log(err)\n);\n\n// Proper error handling\npromiseThatResolves()\n  .then(() => {\n    throw new Error();\n  })\n  .catch(err => console.log(err));\n```\n\n我们创造一个永远能被 `resolve` 的 Promise 实例, 当你执行 `.then` 时, 可以带两个回调函数: `onResolved` 和 `onRejected`, 第一种写法, 在 `then` 种放入两个回调函数, 但是: 如果在第一个回调函数中继续抛出错误, 那么这个错误是不能被捕获的. 😅\n\n第二种写法, 在 `.then` 语句的后面使用 `.catch` 捕获, 不光能捕获到执行函数 `promiseThatResolves` 的错误, 而且在 `.then()` 中的错误也是能被捕获到. 知道这样写的好处了吧!😁\n\n### 总结\n\n你可以执行上面的所有代码片段来更深入的学习. 一种比较好的实践就是, 把所有基于回调的函数都用 Promise 来重新实现. 如果你写 Node.js 的话, 你会发现 `fs` 还有其他模块都是基于回调函数来实现的. 所以会存在一些工具库, 它们把所有基于回调的实现方式使用 Promise 来实现了. 比如 Node.js 的 [util.promisify](https://nodejs.org/api/util.html#util_util_promisify_original) 和 [pify](https://github.com/sindresorhus/pify). 如果你在学习的话, 那么尽可能的尝试自己去实现. 或者说去读这些 Promise 实现库的源代码. 然后你就可以把这些最佳实践用于你的产品中啦!\n\n还有一些关于 Promise 的东西没有完全讲到, 比如 `Promise.all` 和 `Promise.race` 方法, 处理 Promise 中的错误, 以及一些常见的反模式和细节等. 你可以参考下面的链接来学习更多关于 Promise 的知识.\n\n### 参考\n\n* [ECMA Promise Specification](http://www.ecma-international.org/ecma-262/6.0/#sec-promise-objects)\n* [Mozilla Docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)\n* [Google’s Developer’s Guide on Promises written by Jake Archibald](https://developers.google.com/web/fundamentals/primers/promises#promise-api-reference)\n* [Exploring JS’s Chapter on Promises](http://exploringjs.com/es6/ch_promises.html#sec_first-example-promises)\n* [Introduction to Promises](http://jamesknelson.com/grokking-es6-promises-the-four-functions-you-need-to-avoid-callback-hell/)\n","slug":"ES6-Promise-简明指南","published":1,"updated":"2018-12-26T16:01:04.000Z","layout":"post","photos":[],"link":"","_id":"ck3v60jt90007r9q9qnoci6eo","content":"<p>Promise 是 JavaScriptES6 中最令人兴奋的新增功能之一. ES5 中使用回调函数来处理异步操作. 过度使用回调则会产生回调地狱和多级嵌套缩带来的问题. Promise 通过将异步代码转化成同步执行的方式, 大大简化了异步编程方式.</p>\n<a id=\"more\"></a>\n<p>这篇文章中, 我们来学习一下什么是 Promise 以及在开发中的实践.</p>\n<h3 id=\"什么是-Promise\"><a href=\"#什么是-Promise\" class=\"headerlink\" title=\"什么是 Promise\"></a>什么是 Promise</h3><p>简单来说 Promise 就是一个存放着未来才会有计算结果的占位符. 稍微想想, 你会发现, 这和我们平常在谈话过程中说的承诺很像. 举个例子: 你准备去印度旅行, 你订了一张去印度的机票. 这个机票上写着多少号, 座位号是多少. 这个场景下, 机票就是航空公司给你许下的承诺: 在你准备出发那天给你预留了一个头等舱！😎</p>\n<p>还有一个简单的例子, 你承诺你的朋友, 当你读完《计算机编程艺术》这本书后, 你就把这本书还回去. 在这里, 你所说的话就好比是一个占位符, 需要返回的值就是这本书.</p>\n<p>你还可以想到其他一些类似承诺的例子, 比如在医生办公室等着、在餐馆点餐、在图书馆写书等等. 都涉及某种形式的承诺.</p>\n<h3 id=\"生成一个-Promise\"><a href=\"#生成一个-Promise\" class=\"headerlink\" title=\"生成一个 Promise\"></a>生成一个 Promise</h3><p>当某项任务的完成时间不确定或太长时, 就可以使用 Promise. 例如, 网络请求可能需要 10ms 到 200ms（或更长）的时间, 具体取决于网速. 我们不想在获取数据时等待. 200 毫秒对你来说可能不太重要, 但对于一台电脑来说, 这是一段很长的时间. Promise 就是要让这种异步变得简单、轻松. 使用 Promise 构造函数, 来实例化一个 myPromise 实例, 像这样:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myPromise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">Math</span>.random() * <span class=\"number\">100</span> &lt;= <span class=\"number\">90</span>) &#123;</span><br><span class=\"line\">    resolve(<span class=\"string\">'Hello, Promises!'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'In 10% of the cases, I fail. Miserably.'</span>));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>来看一下这个接收两个参数的函数. <code>new Promise()</code> 被称为执行器函数, 它描述了要完成的计算. 它的这两个参数通常被叫做 <code>resolve</code> 和 <code>reject</code>, 可以理解为 <strong>执行</strong> 和 <strong>拒绝</strong>, 它们用来标记执行器函数最终的计算结果. <code>resolve</code> 和 <code>reject</code> 本身是一个函数, 它用来返回一个值给我们的 Promise 实例.</p>\n<p>当运算结果成功时, 或者未来着这个值准备就绪时, 我们就使用这个 <code>resolve</code> 函数来返回一个值, 我们就说: 我践行了当初许下的这个承诺.</p>\n<p>同理, 当计算结果失败时, 或者计算过程中遇到了错误, 我们就使用 <code>reject</code> 函数, 我们就说: 我拒绝履行这个承诺. <code>reject</code> 函数可以接收任何值来作为参数, 但是比较推荐的是我们可以传递一个 <code>Error</code> 对象, 即: 抛出一个错误, 用来帮助我们调试代码, 这样就可以根据具体的抛出错误信息去解决问题啦.</p>\n<p>在上面的这个例子中, <code>Math.random()</code> 用来生成一个随机数, 在 90% 的情况下, 这个 Promise 都应该被执行 (假设等概率分布), 剩余的情况下都是拒绝执行的.</p>\n<h3 id=\"如何使用-Promises\"><a href=\"#如何使用-Promises\" class=\"headerlink\" title=\"如何使用 Promises\"></a>如何使用 Promises</h3><p>在上面的代码例子中, 我们生成了一个 Promise 实例 <code>myPromise</code>, 那么如何通过 <code>resolve</code> 和 <code>reject</code> 函数访问计算完成后的值呢? 所有的 <code>Promise</code> 实例都有一个 <code>.then()</code> 方法, 我们来瞧瞧:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myPromise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">Math</span>.random() * <span class=\"number\">100</span> &lt; <span class=\"number\">90</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'resolving the promise ...'</span>);</span><br><span class=\"line\">    resolve(<span class=\"string\">'Hello, Promises!'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'In 10% of the cases, I fail. Miserably.'</span>));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Two functions</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> onResolved = <span class=\"function\"><span class=\"params\">resolvedValue</span> =&gt;</span> <span class=\"built_in\">console</span>.log(resolvedValue);</span><br><span class=\"line\"><span class=\"keyword\">const</span> onRejected = <span class=\"function\"><span class=\"params\">error</span> =&gt;</span> <span class=\"built_in\">console</span>.log(error);</span><br><span class=\"line\"></span><br><span class=\"line\">myPromise.then(onResolved, onRejected);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Same as above, written concisely</span></span><br><span class=\"line\">myPromise.then(</span><br><span class=\"line\">  resolvedValue =&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(resolvedValue);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  error =&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(error);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Output (in 90% of the cases)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// resolving the promise ...</span></span><br><span class=\"line\"><span class=\"comment\">// Hello, Promises!</span></span><br><span class=\"line\"><span class=\"comment\">// Hello, Promises!</span></span><br></pre></td></tr></table></figure>\n<p><code>.then()</code> 方法接收 2 个回调函数, 第一个回调函数是当我们的 Promise 实例被执行 (resolve) 时调用, 第二个则是被拒绝 (reject) 时调用. 在上面的代码中, 我们使用 <code>onResolved</code> 和 <code>onRejected</code> 定义了这两个函数, 然后把它放到 <code>.then</code> 函数里, 当然, 你也可以按照常规写法, 直接在 <code>.then</code> 函数里写两个函数, 都是一样的.</p>\n<p>在这个例子中, 有几点非常重要, 我们来说一下:</p>\n<ul>\n<li>一个 <code>promise</code> 只能是成功或者失败状态中的一个. 它不能成功或者失败多次. 也不能从成功状态切换到失败状态, 失败反之亦然.</li>\n<li>你可以在成功或者失败状态后, 去定义这样一个回调函数. 当他们 <code>resolve</code> 或者 <code>reject</code> 仍然能正确调用.</li>\n</ul>\n<p>这就说明, <code>Promise</code> 最终只有一个状态, 即使你多次使用 <code>.then</code> 处理函数, 这个状态不能更改 (计算结果也不会重复执行).</p>\n<p>为了验证这点, 你可以看到在第 3 行代码中, <code>console.log</code> 语句, 当你多次使用 <code>.then</code> 处理程序运行上述代码时, <code>console.log</code> 的语句只会被打印一次. 这就说明了 Promise 会缓存计算结果的, 当有一些相同的结果时, 缓存结果会被返回.</p>\n<p>另一个重要的要注意的是, Promise 是 <a href=\"https://zh.wikipedia.org/wiki/%E5%8F%8A%E6%97%A9%E6%B1%82%E5%80%BC\" target=\"_blank\" rel=\"noopener\">及早求值 (evaluated eagerly)</a> 的: 只要声明并将其赋值到变量上, 它已经开始在内存中执行了. 没有 <code>.start</code> 或 <code>.begin</code> 方法. 就像它在前面的例子中开始的那样.</p>\n<p>为了确保 Promise 能被延迟调用, 我们通常还需要在它的外层包裹一个函数, 稍后的例子中我们会解释这个.</p>\n<h3 id=\"捕获-Promise\"><a href=\"#捕获-Promise\" class=\"headerlink\" title=\"捕获 Promise\"></a>捕获 Promise</h3><p>到目前为止, 我们已经看到了 <code>resolve</code> 的场景, 那么当执行函数中出现一个错误时, 会发生什么呢? 在 <code>.then()</code> 函数中的第二个参数, 就是上面例子中的 <code>onRejected</code> 会被执行, 来看一个例子:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myPromise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">Math</span>.random() * <span class=\"number\">100</span> &lt; <span class=\"number\">90</span>) &#123;</span><br><span class=\"line\">    reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'The promise was rejected by using reject function.'</span>));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'The promise was rejected by throwing an error'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">myPromise.then(</span><br><span class=\"line\">  () =&gt; <span class=\"built_in\">console</span>.log(<span class=\"string\">'resolved'</span>),</span><br><span class=\"line\">  error =&gt; <span class=\"built_in\">console</span>.log(error.message)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Output (in 90% of cases)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The promise was rejected by using reject function.</span></span><br></pre></td></tr></table></figure>\n<p>和第一个例子一样的, 但是现在 90% 的情况是被 <code>reject</code> 的, 另外 10% 的情况则是抛出一个错误语句.</p>\n<p>在第一个例子中, 我们分别定义了 <code>onResolved</code> 和 <code>onRejected</code> 方法, <code>onRejected</code> 方法将在错误发生时被调用, 可以看到 <code>reject</code> 函数的参数可以直接是错误提示, 没必要必须 <code>new Error</code>, 两个写法都一样.</p>\n<p>健壮的程序代码离不开错误处理, <code>.then</code> 方法的第二个参数给了我们这样一个捷径. 当需要处理一个错误时, 可以用 <code>.catch(onRejected)</code> 来代替 <code>.then(null, () =&gt; {...})</code>, <code>catch</code> 方法接收一个回调函数 <code>onRejected</code>, 因此, 上面的代码, 可以使用 <code>catch</code> 来简化写法:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myPromise.catch(<span class=\"function\"><span class=\"params\">error</span> =&gt;</span> <span class=\"built_in\">console</span>.log(error.message));</span><br></pre></td></tr></table></figure>\n<p>记住: <code>.catch</code> 方法仅仅是 <code>.then(undefined, onRejected)</code> 的语法糖而已.</p>\n<h3 id=\"链式-Promise\"><a href=\"#链式-Promise\" class=\"headerlink\" title=\"链式 Promise\"></a>链式 Promise</h3><p><code>.then()</code> 和 <code>.catch()</code> 方法永远会返回一个 Promise 实例, 所以你可以链式使用多个 <code>.then</code> 一起来调用. 让我们来举个例子理解它.</p>\n<p>首先, 我们写一个函数, 来延迟返回一个 Promise 实例. 这个返回的 Promise 将在稍后的时间内 <code>resolve</code>. 这里是实现方法:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> delay = <span class=\"function\"><span class=\"params\">ms</span> =&gt;</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> setTimeout(resolve, ms));</span><br></pre></td></tr></table></figure>\n<p>在这个例子中, 我们正在使用一个函数来包裹我们的 Promise 实例, 所以它并不会立即执行. 这个 <code>delay</code> 函数接收一个时间来作为参数. 这个执行函数将接收 <code>ms</code> 作为他的参数, 它还包含一个 <code>setTimeout</code> , 它在 <code>ms</code> 毫秒后调用 <code>resolve</code> 函数, 从而正确执行. 看这个例子:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">delay(<span class=\"number\">5000</span>).then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'Resolved after 5 seconds'</span>));</span><br></pre></td></tr></table></figure>\n<p><code>.then</code> 中的回调语句将在 <code>delay(5000)</code> 后执行. 当你执行上面的代码 5 秒后, 你就可以在控制台上看到输出结果了.</p>\n<p>这里, 我们可以使用多个 <code>.then()</code> 方法来链式调用:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> delay = <span class=\"function\"><span class=\"params\">ms</span> =&gt;</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> setTimeout(resolve, ms));</span><br><span class=\"line\"></span><br><span class=\"line\">delay(<span class=\"number\">2000</span>)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Resolved after 2 seconds'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> delay(<span class=\"number\">1500</span>);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Resolved after 1.5 seconds'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> delay(<span class=\"number\">3000</span>);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Resolved after 3 seconds'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>();</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Caught an error.'</span>);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Done.'</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Resolved after 2 seconds</span></span><br><span class=\"line\"><span class=\"comment\">// Resolved after 1.5 seconds</span></span><br><span class=\"line\"><span class=\"comment\">// Resolved after 3 seconds</span></span><br><span class=\"line\"><span class=\"comment\">// Caught an error.</span></span><br><span class=\"line\"><span class=\"comment\">// Done.</span></span><br></pre></td></tr></table></figure>\n<p>从第 3 行开始, 它的执行步骤是这样的:</p>\n<ul>\n<li><code>delay(2000)</code> 函数执行, 它返回一个稍后 2 秒即将执行的 Promise 实例.</li>\n<li>第 1 个 <code>.then()</code> 执行, 它输出语句 <code>Resolved after 2 seconds</code>, 然后它执行 <code>delay(1500)</code> 又返回一个 Promise 实例, 如果一个 <code>.then()</code> 返回了一个 Promise 实例, 那么它的 <code>resolve</code> 将被转发给下一个 <code>.then</code> 方法调用, 技术上叫: 沉降 (settlement).</li>\n<li>只要像这样继续串联下去, 它会继续执行.</li>\n</ul>\n<p>注意在第三个 <code>.then()</code> 方法时, 我们在 <code>.then</code> 中抛出了一个错误. 这意味着当前的 Promise 被拒绝. 然后它会在下一个 <code>.catch</code> 语句中被捕获, <code>Caught an error</code> 将会被输出. 然而一个 <code>.catch</code> 语句它自己永远是被 <code>resolve</code> 的, 所以不需要在语句里再写 <code>reject</code> (除非你故意抛出一个错误), 这也是为什么在 <code>.catch</code> 语句后还可以继续写 <code>.then</code> 的原因.</p>\n<p>比较推荐的做法是在 <code>.then</code> 方法后执行 <code>.catch</code> 而不是使用 <code>onResolved</code> 和 <code>onRejected</code>, 我们来举个例子说明一下:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> promiseThatResolves = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span></span><br><span class=\"line\">  <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    resolve();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Leads to UnhandledPromiseRejection</span></span><br><span class=\"line\">promiseThatResolves().then(</span><br><span class=\"line\">  () =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>();</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  err =&gt; <span class=\"built_in\">console</span>.log(err)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Proper error handling</span></span><br><span class=\"line\">promiseThatResolves()</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>();</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> <span class=\"built_in\">console</span>.log(err));</span><br></pre></td></tr></table></figure>\n<p>我们创造一个永远能被 <code>resolve</code> 的 Promise 实例, 当你执行 <code>.then</code> 时, 可以带两个回调函数: <code>onResolved</code> 和 <code>onRejected</code>, 第一种写法, 在 <code>then</code> 种放入两个回调函数, 但是: 如果在第一个回调函数中继续抛出错误, 那么这个错误是不能被捕获的. 😅</p>\n<p>第二种写法, 在 <code>.then</code> 语句的后面使用 <code>.catch</code> 捕获, 不光能捕获到执行函数 <code>promiseThatResolves</code> 的错误, 而且在 <code>.then()</code> 中的错误也是能被捕获到. 知道这样写的好处了吧!😁</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>你可以执行上面的所有代码片段来更深入的学习. 一种比较好的实践就是, 把所有基于回调的函数都用 Promise 来重新实现. 如果你写 Node.js 的话, 你会发现 <code>fs</code> 还有其他模块都是基于回调函数来实现的. 所以会存在一些工具库, 它们把所有基于回调的实现方式使用 Promise 来实现了. 比如 Node.js 的 <a href=\"https://nodejs.org/api/util.html#util_util_promisify_original\" target=\"_blank\" rel=\"noopener\">util.promisify</a> 和 <a href=\"https://github.com/sindresorhus/pify\" target=\"_blank\" rel=\"noopener\">pify</a>. 如果你在学习的话, 那么尽可能的尝试自己去实现. 或者说去读这些 Promise 实现库的源代码. 然后你就可以把这些最佳实践用于你的产品中啦!</p>\n<p>还有一些关于 Promise 的东西没有完全讲到, 比如 <code>Promise.all</code> 和 <code>Promise.race</code> 方法, 处理 Promise 中的错误, 以及一些常见的反模式和细节等. 你可以参考下面的链接来学习更多关于 Promise 的知识.</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><a href=\"http://www.ecma-international.org/ecma-262/6.0/#sec-promise-objects\" target=\"_blank\" rel=\"noopener\">ECMA Promise Specification</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\" target=\"_blank\" rel=\"noopener\">Mozilla Docs</a></li>\n<li><a href=\"https://developers.google.com/web/fundamentals/primers/promises#promise-api-reference\" target=\"_blank\" rel=\"noopener\">Google’s Developer’s Guide on Promises written by Jake Archibald</a></li>\n<li><a href=\"http://exploringjs.com/es6/ch_promises.html#sec_first-example-promises\" target=\"_blank\" rel=\"noopener\">Exploring JS’s Chapter on Promises</a></li>\n<li><a href=\"http://jamesknelson.com/grokking-es6-promises-the-four-functions-you-need-to-avoid-callback-hell/\" target=\"_blank\" rel=\"noopener\">Introduction to Promises</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>Promise 是 JavaScriptES6 中最令人兴奋的新增功能之一. ES5 中使用回调函数来处理异步操作. 过度使用回调则会产生回调地狱和多级嵌套缩带来的问题. Promise 通过将异步代码转化成同步执行的方式, 大大简化了异步编程方式.</p>","more":"<p>这篇文章中, 我们来学习一下什么是 Promise 以及在开发中的实践.</p>\n<h3 id=\"什么是-Promise\"><a href=\"#什么是-Promise\" class=\"headerlink\" title=\"什么是 Promise\"></a>什么是 Promise</h3><p>简单来说 Promise 就是一个存放着未来才会有计算结果的占位符. 稍微想想, 你会发现, 这和我们平常在谈话过程中说的承诺很像. 举个例子: 你准备去印度旅行, 你订了一张去印度的机票. 这个机票上写着多少号, 座位号是多少. 这个场景下, 机票就是航空公司给你许下的承诺: 在你准备出发那天给你预留了一个头等舱！😎</p>\n<p>还有一个简单的例子, 你承诺你的朋友, 当你读完《计算机编程艺术》这本书后, 你就把这本书还回去. 在这里, 你所说的话就好比是一个占位符, 需要返回的值就是这本书.</p>\n<p>你还可以想到其他一些类似承诺的例子, 比如在医生办公室等着、在餐馆点餐、在图书馆写书等等. 都涉及某种形式的承诺.</p>\n<h3 id=\"生成一个-Promise\"><a href=\"#生成一个-Promise\" class=\"headerlink\" title=\"生成一个 Promise\"></a>生成一个 Promise</h3><p>当某项任务的完成时间不确定或太长时, 就可以使用 Promise. 例如, 网络请求可能需要 10ms 到 200ms（或更长）的时间, 具体取决于网速. 我们不想在获取数据时等待. 200 毫秒对你来说可能不太重要, 但对于一台电脑来说, 这是一段很长的时间. Promise 就是要让这种异步变得简单、轻松. 使用 Promise 构造函数, 来实例化一个 myPromise 实例, 像这样:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myPromise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">Math</span>.random() * <span class=\"number\">100</span> &lt;= <span class=\"number\">90</span>) &#123;</span><br><span class=\"line\">    resolve(<span class=\"string\">'Hello, Promises!'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'In 10% of the cases, I fail. Miserably.'</span>));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>来看一下这个接收两个参数的函数. <code>new Promise()</code> 被称为执行器函数, 它描述了要完成的计算. 它的这两个参数通常被叫做 <code>resolve</code> 和 <code>reject</code>, 可以理解为 <strong>执行</strong> 和 <strong>拒绝</strong>, 它们用来标记执行器函数最终的计算结果. <code>resolve</code> 和 <code>reject</code> 本身是一个函数, 它用来返回一个值给我们的 Promise 实例.</p>\n<p>当运算结果成功时, 或者未来着这个值准备就绪时, 我们就使用这个 <code>resolve</code> 函数来返回一个值, 我们就说: 我践行了当初许下的这个承诺.</p>\n<p>同理, 当计算结果失败时, 或者计算过程中遇到了错误, 我们就使用 <code>reject</code> 函数, 我们就说: 我拒绝履行这个承诺. <code>reject</code> 函数可以接收任何值来作为参数, 但是比较推荐的是我们可以传递一个 <code>Error</code> 对象, 即: 抛出一个错误, 用来帮助我们调试代码, 这样就可以根据具体的抛出错误信息去解决问题啦.</p>\n<p>在上面的这个例子中, <code>Math.random()</code> 用来生成一个随机数, 在 90% 的情况下, 这个 Promise 都应该被执行 (假设等概率分布), 剩余的情况下都是拒绝执行的.</p>\n<h3 id=\"如何使用-Promises\"><a href=\"#如何使用-Promises\" class=\"headerlink\" title=\"如何使用 Promises\"></a>如何使用 Promises</h3><p>在上面的代码例子中, 我们生成了一个 Promise 实例 <code>myPromise</code>, 那么如何通过 <code>resolve</code> 和 <code>reject</code> 函数访问计算完成后的值呢? 所有的 <code>Promise</code> 实例都有一个 <code>.then()</code> 方法, 我们来瞧瞧:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myPromise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">Math</span>.random() * <span class=\"number\">100</span> &lt; <span class=\"number\">90</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'resolving the promise ...'</span>);</span><br><span class=\"line\">    resolve(<span class=\"string\">'Hello, Promises!'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'In 10% of the cases, I fail. Miserably.'</span>));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Two functions</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> onResolved = <span class=\"function\"><span class=\"params\">resolvedValue</span> =&gt;</span> <span class=\"built_in\">console</span>.log(resolvedValue);</span><br><span class=\"line\"><span class=\"keyword\">const</span> onRejected = <span class=\"function\"><span class=\"params\">error</span> =&gt;</span> <span class=\"built_in\">console</span>.log(error);</span><br><span class=\"line\"></span><br><span class=\"line\">myPromise.then(onResolved, onRejected);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Same as above, written concisely</span></span><br><span class=\"line\">myPromise.then(</span><br><span class=\"line\">  resolvedValue =&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(resolvedValue);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  error =&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(error);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Output (in 90% of the cases)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// resolving the promise ...</span></span><br><span class=\"line\"><span class=\"comment\">// Hello, Promises!</span></span><br><span class=\"line\"><span class=\"comment\">// Hello, Promises!</span></span><br></pre></td></tr></table></figure>\n<p><code>.then()</code> 方法接收 2 个回调函数, 第一个回调函数是当我们的 Promise 实例被执行 (resolve) 时调用, 第二个则是被拒绝 (reject) 时调用. 在上面的代码中, 我们使用 <code>onResolved</code> 和 <code>onRejected</code> 定义了这两个函数, 然后把它放到 <code>.then</code> 函数里, 当然, 你也可以按照常规写法, 直接在 <code>.then</code> 函数里写两个函数, 都是一样的.</p>\n<p>在这个例子中, 有几点非常重要, 我们来说一下:</p>\n<ul>\n<li>一个 <code>promise</code> 只能是成功或者失败状态中的一个. 它不能成功或者失败多次. 也不能从成功状态切换到失败状态, 失败反之亦然.</li>\n<li>你可以在成功或者失败状态后, 去定义这样一个回调函数. 当他们 <code>resolve</code> 或者 <code>reject</code> 仍然能正确调用.</li>\n</ul>\n<p>这就说明, <code>Promise</code> 最终只有一个状态, 即使你多次使用 <code>.then</code> 处理函数, 这个状态不能更改 (计算结果也不会重复执行).</p>\n<p>为了验证这点, 你可以看到在第 3 行代码中, <code>console.log</code> 语句, 当你多次使用 <code>.then</code> 处理程序运行上述代码时, <code>console.log</code> 的语句只会被打印一次. 这就说明了 Promise 会缓存计算结果的, 当有一些相同的结果时, 缓存结果会被返回.</p>\n<p>另一个重要的要注意的是, Promise 是 <a href=\"https://zh.wikipedia.org/wiki/%E5%8F%8A%E6%97%A9%E6%B1%82%E5%80%BC\" target=\"_blank\" rel=\"noopener\">及早求值 (evaluated eagerly)</a> 的: 只要声明并将其赋值到变量上, 它已经开始在内存中执行了. 没有 <code>.start</code> 或 <code>.begin</code> 方法. 就像它在前面的例子中开始的那样.</p>\n<p>为了确保 Promise 能被延迟调用, 我们通常还需要在它的外层包裹一个函数, 稍后的例子中我们会解释这个.</p>\n<h3 id=\"捕获-Promise\"><a href=\"#捕获-Promise\" class=\"headerlink\" title=\"捕获 Promise\"></a>捕获 Promise</h3><p>到目前为止, 我们已经看到了 <code>resolve</code> 的场景, 那么当执行函数中出现一个错误时, 会发生什么呢? 在 <code>.then()</code> 函数中的第二个参数, 就是上面例子中的 <code>onRejected</code> 会被执行, 来看一个例子:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myPromise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">Math</span>.random() * <span class=\"number\">100</span> &lt; <span class=\"number\">90</span>) &#123;</span><br><span class=\"line\">    reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'The promise was rejected by using reject function.'</span>));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'The promise was rejected by throwing an error'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">myPromise.then(</span><br><span class=\"line\">  () =&gt; <span class=\"built_in\">console</span>.log(<span class=\"string\">'resolved'</span>),</span><br><span class=\"line\">  error =&gt; <span class=\"built_in\">console</span>.log(error.message)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Output (in 90% of cases)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The promise was rejected by using reject function.</span></span><br></pre></td></tr></table></figure>\n<p>和第一个例子一样的, 但是现在 90% 的情况是被 <code>reject</code> 的, 另外 10% 的情况则是抛出一个错误语句.</p>\n<p>在第一个例子中, 我们分别定义了 <code>onResolved</code> 和 <code>onRejected</code> 方法, <code>onRejected</code> 方法将在错误发生时被调用, 可以看到 <code>reject</code> 函数的参数可以直接是错误提示, 没必要必须 <code>new Error</code>, 两个写法都一样.</p>\n<p>健壮的程序代码离不开错误处理, <code>.then</code> 方法的第二个参数给了我们这样一个捷径. 当需要处理一个错误时, 可以用 <code>.catch(onRejected)</code> 来代替 <code>.then(null, () =&gt; {...})</code>, <code>catch</code> 方法接收一个回调函数 <code>onRejected</code>, 因此, 上面的代码, 可以使用 <code>catch</code> 来简化写法:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myPromise.catch(<span class=\"function\"><span class=\"params\">error</span> =&gt;</span> <span class=\"built_in\">console</span>.log(error.message));</span><br></pre></td></tr></table></figure>\n<p>记住: <code>.catch</code> 方法仅仅是 <code>.then(undefined, onRejected)</code> 的语法糖而已.</p>\n<h3 id=\"链式-Promise\"><a href=\"#链式-Promise\" class=\"headerlink\" title=\"链式 Promise\"></a>链式 Promise</h3><p><code>.then()</code> 和 <code>.catch()</code> 方法永远会返回一个 Promise 实例, 所以你可以链式使用多个 <code>.then</code> 一起来调用. 让我们来举个例子理解它.</p>\n<p>首先, 我们写一个函数, 来延迟返回一个 Promise 实例. 这个返回的 Promise 将在稍后的时间内 <code>resolve</code>. 这里是实现方法:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> delay = <span class=\"function\"><span class=\"params\">ms</span> =&gt;</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> setTimeout(resolve, ms));</span><br></pre></td></tr></table></figure>\n<p>在这个例子中, 我们正在使用一个函数来包裹我们的 Promise 实例, 所以它并不会立即执行. 这个 <code>delay</code> 函数接收一个时间来作为参数. 这个执行函数将接收 <code>ms</code> 作为他的参数, 它还包含一个 <code>setTimeout</code> , 它在 <code>ms</code> 毫秒后调用 <code>resolve</code> 函数, 从而正确执行. 看这个例子:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">delay(<span class=\"number\">5000</span>).then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'Resolved after 5 seconds'</span>));</span><br></pre></td></tr></table></figure>\n<p><code>.then</code> 中的回调语句将在 <code>delay(5000)</code> 后执行. 当你执行上面的代码 5 秒后, 你就可以在控制台上看到输出结果了.</p>\n<p>这里, 我们可以使用多个 <code>.then()</code> 方法来链式调用:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> delay = <span class=\"function\"><span class=\"params\">ms</span> =&gt;</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> setTimeout(resolve, ms));</span><br><span class=\"line\"></span><br><span class=\"line\">delay(<span class=\"number\">2000</span>)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Resolved after 2 seconds'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> delay(<span class=\"number\">1500</span>);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Resolved after 1.5 seconds'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> delay(<span class=\"number\">3000</span>);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Resolved after 3 seconds'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>();</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Caught an error.'</span>);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Done.'</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Resolved after 2 seconds</span></span><br><span class=\"line\"><span class=\"comment\">// Resolved after 1.5 seconds</span></span><br><span class=\"line\"><span class=\"comment\">// Resolved after 3 seconds</span></span><br><span class=\"line\"><span class=\"comment\">// Caught an error.</span></span><br><span class=\"line\"><span class=\"comment\">// Done.</span></span><br></pre></td></tr></table></figure>\n<p>从第 3 行开始, 它的执行步骤是这样的:</p>\n<ul>\n<li><code>delay(2000)</code> 函数执行, 它返回一个稍后 2 秒即将执行的 Promise 实例.</li>\n<li>第 1 个 <code>.then()</code> 执行, 它输出语句 <code>Resolved after 2 seconds</code>, 然后它执行 <code>delay(1500)</code> 又返回一个 Promise 实例, 如果一个 <code>.then()</code> 返回了一个 Promise 实例, 那么它的 <code>resolve</code> 将被转发给下一个 <code>.then</code> 方法调用, 技术上叫: 沉降 (settlement).</li>\n<li>只要像这样继续串联下去, 它会继续执行.</li>\n</ul>\n<p>注意在第三个 <code>.then()</code> 方法时, 我们在 <code>.then</code> 中抛出了一个错误. 这意味着当前的 Promise 被拒绝. 然后它会在下一个 <code>.catch</code> 语句中被捕获, <code>Caught an error</code> 将会被输出. 然而一个 <code>.catch</code> 语句它自己永远是被 <code>resolve</code> 的, 所以不需要在语句里再写 <code>reject</code> (除非你故意抛出一个错误), 这也是为什么在 <code>.catch</code> 语句后还可以继续写 <code>.then</code> 的原因.</p>\n<p>比较推荐的做法是在 <code>.then</code> 方法后执行 <code>.catch</code> 而不是使用 <code>onResolved</code> 和 <code>onRejected</code>, 我们来举个例子说明一下:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> promiseThatResolves = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span></span><br><span class=\"line\">  <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    resolve();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Leads to UnhandledPromiseRejection</span></span><br><span class=\"line\">promiseThatResolves().then(</span><br><span class=\"line\">  () =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>();</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  err =&gt; <span class=\"built_in\">console</span>.log(err)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Proper error handling</span></span><br><span class=\"line\">promiseThatResolves()</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>();</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> <span class=\"built_in\">console</span>.log(err));</span><br></pre></td></tr></table></figure>\n<p>我们创造一个永远能被 <code>resolve</code> 的 Promise 实例, 当你执行 <code>.then</code> 时, 可以带两个回调函数: <code>onResolved</code> 和 <code>onRejected</code>, 第一种写法, 在 <code>then</code> 种放入两个回调函数, 但是: 如果在第一个回调函数中继续抛出错误, 那么这个错误是不能被捕获的. 😅</p>\n<p>第二种写法, 在 <code>.then</code> 语句的后面使用 <code>.catch</code> 捕获, 不光能捕获到执行函数 <code>promiseThatResolves</code> 的错误, 而且在 <code>.then()</code> 中的错误也是能被捕获到. 知道这样写的好处了吧!😁</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>你可以执行上面的所有代码片段来更深入的学习. 一种比较好的实践就是, 把所有基于回调的函数都用 Promise 来重新实现. 如果你写 Node.js 的话, 你会发现 <code>fs</code> 还有其他模块都是基于回调函数来实现的. 所以会存在一些工具库, 它们把所有基于回调的实现方式使用 Promise 来实现了. 比如 Node.js 的 <a href=\"https://nodejs.org/api/util.html#util_util_promisify_original\" target=\"_blank\" rel=\"noopener\">util.promisify</a> 和 <a href=\"https://github.com/sindresorhus/pify\" target=\"_blank\" rel=\"noopener\">pify</a>. 如果你在学习的话, 那么尽可能的尝试自己去实现. 或者说去读这些 Promise 实现库的源代码. 然后你就可以把这些最佳实践用于你的产品中啦!</p>\n<p>还有一些关于 Promise 的东西没有完全讲到, 比如 <code>Promise.all</code> 和 <code>Promise.race</code> 方法, 处理 Promise 中的错误, 以及一些常见的反模式和细节等. 你可以参考下面的链接来学习更多关于 Promise 的知识.</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><a href=\"http://www.ecma-international.org/ecma-262/6.0/#sec-promise-objects\" target=\"_blank\" rel=\"noopener\">ECMA Promise Specification</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\" target=\"_blank\" rel=\"noopener\">Mozilla Docs</a></li>\n<li><a href=\"https://developers.google.com/web/fundamentals/primers/promises#promise-api-reference\" target=\"_blank\" rel=\"noopener\">Google’s Developer’s Guide on Promises written by Jake Archibald</a></li>\n<li><a href=\"http://exploringjs.com/es6/ch_promises.html#sec_first-example-promises\" target=\"_blank\" rel=\"noopener\">Exploring JS’s Chapter on Promises</a></li>\n<li><a href=\"http://jamesknelson.com/grokking-es6-promises-the-four-functions-you-need-to-avoid-callback-hell/\" target=\"_blank\" rel=\"noopener\">Introduction to Promises</a></li>\n</ul>"},{"title":"JavaScript 中的 this 用法总结","date":"2016-02-19T11:23:36.000Z","comments":0,"_content":"\n`this` 是 Javascript 语言的一个关键字。它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。随着函数使用场合的不同，`this` 的值会发生变化。但是有一个总的原则，那就是 `this` 指的是，调用函数的那个对象。\n\n<!-- more -->\n### 四种情况\n#### 纯粹的函数调用\n\n```js\n// eg:1\nconsole.log(this);// => window 对象\n\n// eg:2\nfunction fun(){\n    this.x = 1;\n}\nconsole.log(x); // => 1\n// this 指向全局对象，即 DOM 中的 window 对象\n```\n\n#### 作为对象方法的调用\n\n```js\nvar user = {\n    count: 1,\n\n    getCount: function() {\n        return this.count;\n    }\n};\n\nconsole.log(user.getCount());// 1\n// this 指向调用 getCount 方法的对象 user\n```\n\n#### 作为构造函数的调用\n```js\nvar x = 2;\n\nfunction fun(){\n    this.x = 1;\n}\n\nvar obj = new fun();\nconsole.log(obj.x); // => 1\nconsole.log(x); // => 2\n//this 就指向构造器创建的新对象 obj\n```\n\n#### apply/call 调用\n`apply()` 是函数对象的一个方法，它的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象，无参数时传入 window 对象。因此，`this` 指的就是这第一个参数。\n```js\nvar x = 0;\n\nfunction fun(){\n    console.log(this.x);\n}\n\nvar obj = {};\nobj.x = 1;\nobj.m = fun;\n\nobj.m(); //           => 1  this 指向调用方法的对象即：obj\nobj.m.apply();  //    => 0  this 指向的是全局对象即：window\nobj.m.apply(obj);//   => 1  this 指向的第一个参数即：obj\nobj.m.call(obj);//    => 1  this 指向的第一个参数即：obj\n```\n\n### 总结\n1. 纯粹的函数调用: `this` 就代表全局对象 Global（浏览器下就是 window）\n2. 作为对象方法的调用: `this` 指向调用方法的对象\n3. 作为构造函数调用：`this` 就指向构造器创建的新对象\n4. `apply`, `call` 调用：`this` 指向就是这些函数的第一个参数\n\n下一篇文章总结一下：`apply`、`call`、`bind` 的用法 :P\n","source":"_posts/JavaScript-中的-this-用法总结.md","raw":"---\ntitle: JavaScript 中的 this 用法总结\ndate: 2016-02-19 19:23:36\ntags:\ncomments: false\n---\n\n`this` 是 Javascript 语言的一个关键字。它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。随着函数使用场合的不同，`this` 的值会发生变化。但是有一个总的原则，那就是 `this` 指的是，调用函数的那个对象。\n\n<!-- more -->\n### 四种情况\n#### 纯粹的函数调用\n\n```js\n// eg:1\nconsole.log(this);// => window 对象\n\n// eg:2\nfunction fun(){\n    this.x = 1;\n}\nconsole.log(x); // => 1\n// this 指向全局对象，即 DOM 中的 window 对象\n```\n\n#### 作为对象方法的调用\n\n```js\nvar user = {\n    count: 1,\n\n    getCount: function() {\n        return this.count;\n    }\n};\n\nconsole.log(user.getCount());// 1\n// this 指向调用 getCount 方法的对象 user\n```\n\n#### 作为构造函数的调用\n```js\nvar x = 2;\n\nfunction fun(){\n    this.x = 1;\n}\n\nvar obj = new fun();\nconsole.log(obj.x); // => 1\nconsole.log(x); // => 2\n//this 就指向构造器创建的新对象 obj\n```\n\n#### apply/call 调用\n`apply()` 是函数对象的一个方法，它的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象，无参数时传入 window 对象。因此，`this` 指的就是这第一个参数。\n```js\nvar x = 0;\n\nfunction fun(){\n    console.log(this.x);\n}\n\nvar obj = {};\nobj.x = 1;\nobj.m = fun;\n\nobj.m(); //           => 1  this 指向调用方法的对象即：obj\nobj.m.apply();  //    => 0  this 指向的是全局对象即：window\nobj.m.apply(obj);//   => 1  this 指向的第一个参数即：obj\nobj.m.call(obj);//    => 1  this 指向的第一个参数即：obj\n```\n\n### 总结\n1. 纯粹的函数调用: `this` 就代表全局对象 Global（浏览器下就是 window）\n2. 作为对象方法的调用: `this` 指向调用方法的对象\n3. 作为构造函数调用：`this` 就指向构造器创建的新对象\n4. `apply`, `call` 调用：`this` 指向就是这些函数的第一个参数\n\n下一篇文章总结一下：`apply`、`call`、`bind` 的用法 :P\n","slug":"JavaScript-中的-this-用法总结","published":1,"updated":"2018-12-26T16:01:04.000Z","layout":"post","photos":[],"link":"","_id":"ck3v60jta0008r9q94edjg6t8","content":"<p><code>this</code> 是 Javascript 语言的一个关键字。它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。随着函数使用场合的不同，<code>this</code> 的值会发生变化。但是有一个总的原则，那就是 <code>this</code> 指的是，调用函数的那个对象。</p>\n<a id=\"more\"></a>\n<h3 id=\"四种情况\"><a href=\"#四种情况\" class=\"headerlink\" title=\"四种情况\"></a>四种情况</h3><h4 id=\"纯粹的函数调用\"><a href=\"#纯粹的函数调用\" class=\"headerlink\" title=\"纯粹的函数调用\"></a>纯粹的函数调用</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// eg:1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);<span class=\"comment\">// =&gt; window 对象</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// eg:2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.x = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x); <span class=\"comment\">// =&gt; 1</span></span><br><span class=\"line\"><span class=\"comment\">// this 指向全局对象，即 DOM 中的 window 对象</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"作为对象方法的调用\"><a href=\"#作为对象方法的调用\" class=\"headerlink\" title=\"作为对象方法的调用\"></a>作为对象方法的调用</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> user = &#123;</span><br><span class=\"line\">    count: <span class=\"number\">1</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">    getCount: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user.getCount());<span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// this 指向调用 getCount 方法的对象 user</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"作为构造函数的调用\"><a href=\"#作为构造函数的调用\" class=\"headerlink\" title=\"作为构造函数的调用\"></a>作为构造函数的调用</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.x = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> fun();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.x); <span class=\"comment\">// =&gt; 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x); <span class=\"comment\">// =&gt; 2</span></span><br><span class=\"line\"><span class=\"comment\">//this 就指向构造器创建的新对象 obj</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"apply-call-调用\"><a href=\"#apply-call-调用\" class=\"headerlink\" title=\"apply/call 调用\"></a>apply/call 调用</h4><p><code>apply()</code> 是函数对象的一个方法，它的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象，无参数时传入 window 对象。因此，<code>this</code> 指的就是这第一个参数。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br><span class=\"line\">obj.x = <span class=\"number\">1</span>;</span><br><span class=\"line\">obj.m = fun;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.m(); <span class=\"comment\">//           =&gt; 1  this 指向调用方法的对象即：obj</span></span><br><span class=\"line\">obj.m.apply();  <span class=\"comment\">//    =&gt; 0  this 指向的是全局对象即：window</span></span><br><span class=\"line\">obj.m.apply(obj);<span class=\"comment\">//   =&gt; 1  this 指向的第一个参数即：obj</span></span><br><span class=\"line\">obj.m.call(obj);<span class=\"comment\">//    =&gt; 1  this 指向的第一个参数即：obj</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ol>\n<li>纯粹的函数调用: <code>this</code> 就代表全局对象 Global（浏览器下就是 window）</li>\n<li>作为对象方法的调用: <code>this</code> 指向调用方法的对象</li>\n<li>作为构造函数调用：<code>this</code> 就指向构造器创建的新对象</li>\n<li><code>apply</code>, <code>call</code> 调用：<code>this</code> 指向就是这些函数的第一个参数</li>\n</ol>\n<p>下一篇文章总结一下：<code>apply</code>、<code>call</code>、<code>bind</code> 的用法 :P</p>\n","site":{"data":{}},"excerpt":"<p><code>this</code> 是 Javascript 语言的一个关键字。它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。随着函数使用场合的不同，<code>this</code> 的值会发生变化。但是有一个总的原则，那就是 <code>this</code> 指的是，调用函数的那个对象。</p>","more":"<h3 id=\"四种情况\"><a href=\"#四种情况\" class=\"headerlink\" title=\"四种情况\"></a>四种情况</h3><h4 id=\"纯粹的函数调用\"><a href=\"#纯粹的函数调用\" class=\"headerlink\" title=\"纯粹的函数调用\"></a>纯粹的函数调用</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// eg:1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);<span class=\"comment\">// =&gt; window 对象</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// eg:2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.x = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x); <span class=\"comment\">// =&gt; 1</span></span><br><span class=\"line\"><span class=\"comment\">// this 指向全局对象，即 DOM 中的 window 对象</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"作为对象方法的调用\"><a href=\"#作为对象方法的调用\" class=\"headerlink\" title=\"作为对象方法的调用\"></a>作为对象方法的调用</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> user = &#123;</span><br><span class=\"line\">    count: <span class=\"number\">1</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">    getCount: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user.getCount());<span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// this 指向调用 getCount 方法的对象 user</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"作为构造函数的调用\"><a href=\"#作为构造函数的调用\" class=\"headerlink\" title=\"作为构造函数的调用\"></a>作为构造函数的调用</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.x = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> fun();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.x); <span class=\"comment\">// =&gt; 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x); <span class=\"comment\">// =&gt; 2</span></span><br><span class=\"line\"><span class=\"comment\">//this 就指向构造器创建的新对象 obj</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"apply-call-调用\"><a href=\"#apply-call-调用\" class=\"headerlink\" title=\"apply/call 调用\"></a>apply/call 调用</h4><p><code>apply()</code> 是函数对象的一个方法，它的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象，无参数时传入 window 对象。因此，<code>this</code> 指的就是这第一个参数。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br><span class=\"line\">obj.x = <span class=\"number\">1</span>;</span><br><span class=\"line\">obj.m = fun;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.m(); <span class=\"comment\">//           =&gt; 1  this 指向调用方法的对象即：obj</span></span><br><span class=\"line\">obj.m.apply();  <span class=\"comment\">//    =&gt; 0  this 指向的是全局对象即：window</span></span><br><span class=\"line\">obj.m.apply(obj);<span class=\"comment\">//   =&gt; 1  this 指向的第一个参数即：obj</span></span><br><span class=\"line\">obj.m.call(obj);<span class=\"comment\">//    =&gt; 1  this 指向的第一个参数即：obj</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ol>\n<li>纯粹的函数调用: <code>this</code> 就代表全局对象 Global（浏览器下就是 window）</li>\n<li>作为对象方法的调用: <code>this</code> 指向调用方法的对象</li>\n<li>作为构造函数调用：<code>this</code> 就指向构造器创建的新对象</li>\n<li><code>apply</code>, <code>call</code> 调用：<code>this</code> 指向就是这些函数的第一个参数</li>\n</ol>\n<p>下一篇文章总结一下：<code>apply</code>、<code>call</code>、<code>bind</code> 的用法 :P</p>"},{"title":"Mongodb 学习笔记 -- 增删改查","date":"2016-01-05T13:24:40.000Z","comments":0,"_content":"\n记录 Mongodb 的学习之旅，从环境配置，到基础命令行使用，算是一个简单的入门教程，同时也是学习总结，还有把踩到的坑都记录下来，以后遇到同样的问题不至于在同一个地方继续踩坑。\n<!-- more -->\n### Mongodb 介绍\n> MongoDB 是一种文档导向***数据库管理系统***，由 C++撰写而成，旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。2007 年 10 月，MongoDB 由 10gen 团队所发展。2009 年 2 月首度推出。 --- ***维基百科***\n\nMongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。听着很饶，其实就是非关系数据库。那什么又是 ***关系型数据库*** 呢？关系型数据库以行和列的形式存储数据，这一系列的行和列被称为表，一组表组成了数据库。表与表之间的数据记录有关系。\n\n### Mongodb 安装\n本人的操作系统是：MacOS，且已经安装了 [brew](http://brew.sh/index_zh-cn.html) ，所以图省事，我就使用 brew 一键安装了。没用过 brew 的同学可以去[这里看看](http://www.cnblogs.com/TankXiao/p/3247113.html)，用起来还是挺方便的。\n\n```bash\nbrew install mongodb\n```\n安装速度取决于你的网络情况，这里稍等片刻。brew 默认的安装位置在 `/usr/local/Cellar/` 一会的功夫，我们就能在这里看到，Mongodb 乖乖的躺在这了。因为 Mongodb 会默认读取 `/data/db` 目录下的数据库，所以方便省事，我们把默认的数据库就创建在这个位置，并且给 `/data` 执行权限，执行以下命令即可。\n\n```bash\nsudo mkdir -p /data/db         # sudo 表示以管理员权限运行，-p 表示创建多层目录\nsudo chown -R  UserName /data  # UserName 表示你当前的系统用户名\n```\n安装成功后，就可以在 Mongodb 的安装目录下 找到 `bin` 目录了，这里面放着所有需要用到的命令。\n```bash\ncd /usr/local/Cellar/mongodb/3.4.0/bin\n./mongod   # 执行 Mongodb 进程后，浏览器打开 http://127.0.0.1:27017/\n```\n浏览器显示下面的内容，就表示安装成功啦。\n```text\nIt looks like you are trying to access MongoDB over HTTP on the native driver port.\n```\n接下来打开终端，执行下面的命令，验证我们确实安装成功了。在 Mongodb 的控制台中，可以执行很多命令来操作数据库。\n```bash\ncd /usr/local/Cellar/mongodb/3.4.0/bin\n./mongo\n\n# 进入 MongoDB shell 后，光标会变成下面过的状态，执行 show dbs 后，显示如下则大功告成！\n> show dbs\nadmin  0.000GB\nlocal  0.000GB\n```\n接下来，为了方便下次执行 Mongodb ，我们把 `bin` 目录放到环境变量中，这样下次直接在终端输入 `mongod` 即可启用服务，输入命令 `mongo` 即可进入 shell 控制台。\n\n```bash\n# 添加环境变量，语法：echo \"export PATH=xxxxxx:$PATH\" >> ~/.bash_profile\necho 'export PATH=/usr/local/Cellar/mongodb/3.4.0/bin:$PATH'>>~/.bash_profile\n```\n### Mongodb 使用\n使用之前，在明白几个概念，相比关系型数据库，非关系数据库采用了 ***数据库***、***集合***、***文档***、的概念。其实对比 SQL 数据库，就很容易理解，集合就好比是一张表，文档好比就是一整行数据。库的概念是一致的。就这点区别。在终端输入 `mongo` 进入 shell 控制台。\n```bash\nmongo\n```\n#### 基础命令\n新增数据\n- 显示数据库：`show dbs`\n- 使用/创建数据库：`use 数据库名`\n- 显示集合：`show collections`\n- 保存数据：`db.collection.save({\"key\":\"value\",\"key2\":\"value2\"})`\n- 插入数据：`db.collection.insert({\"key\":\"value\",\"key2\":\"value2\"})`\n\n<div class=\"tip\">\n若新增的数据主键已经存在，insert()会不做操作并提示错误，而save()则更改原来的内容为新内容。\n</div>\n\n删除数据\n- 删除所有文档：`db.collection.remove({})`\n- 删除指定文档：`db.collection.remove({\"key\":\"value\"})`\n- 删除集合：`db.collection.drop()` 或者 `db.runCommand({\"drop\":\"collection\"})`\n- 删除数据库：`db.runCommand({\"dropDatabase\": 1})` 注意：1 没有引号\n\n查找数据\n- 查找所有数据： `db.collection.find({})`\n- 查到单条数据：`db.collection.findOne({})`\n- 条件查找：`db.collection.find({\"key\":\"value\"})`\n- 条件查找 key < value：`db.collection.find({\"key\":{$lt:value}})`\n- 条件查找 key > value：`db.collection.find({\"key\":{$gt:value}})`\n- 条件查找 key >= value：`db.collection.find({\"key\":{$gte:value}})`\n- 范围查找：`db.collection.find({\"key\":{$gt:value1,$lt:value2 } })`\n- 模运算查找：`db.collection.find({\"key\":{$mod:[10,1]}})`\n- 范围在查找：`db.collection.find({\"key\":{$in:[1,2,3]}})`\n- 范围不在在查找：`db.collection.find({\"key\":{$nin:[1,2,3]}})`\n- 数组长度查找：`db.collection.find({\"key\":{$size:1}})` key 必须是数组\n- 字段存在查找：`db.collection.find({\"key\":{$exists:true|false}})`\n- 多条件查找：`db.collection.find({$or:[{a:1},{b:2}]})`\n- 内嵌对象中的值查找：`db.collection.find({\"key.subkey\":value})`\n- 排序：`db.collection.find({}).sort({\"key1\":1,\"key2\":-1})` 1 升序 -1 降序\n- 对字段建立索引：`db.collection.find({})ensureIndex({\"key\":1})` 1 升序 -1 降序\n- 范围控制查找：`db.collection.find().skip(5).limit(5)` 跳过 5 条，读取 5 条\n- 查询结果集统计：`db.collection.find().count()`\n- 模糊查找：`db.collection.find({\"key\":/ab/})` 正则\n\n\n更改数据\n- `db.collection.update({\"targetKey\":\"targetValue\"},{\"newKey\":\"newVlue\"})`\n\n#### GUI 工具\n![](http://ww1.sinaimg.cn/large/6057861cgw1fbfwwdbu8qj20zq0dbqah.jpg)\n***Robomongo*** 可视化 Mongodb 数据库管理工具 ，点击[这里](https://robomongo.org/download)下载，官方网站：https://robomongo.org/ 。\n\n###  Mongoose 介绍\n[Mongoose](http://mongoosejs.com/) 简而言之就是在 Node 环境中操作 MongoDB 数据库的一种对象模型工具，Mongoose 将数据库中的数据转换为 JavaScript 对象供开发人员使用。\n\n#### 配置\n安装 Mongoose\n```bash\nnpm install mongoose --save\n```\n引入到项目文件中并创建链接\n```js\n// app.js\nvar mongoose = require('mongoose');\nmongoose.connect('mongodb://localhost/my_database');\n```\n\n#### 新增数据\n```js\n// 引入模块\nvar mongoose = require('mongoose');\n// 连接数据库\nvar db = mongoose.createConnection('mongodb://127.0.0.1:27017/test');\n// 设置数据类型\nvar monSchema = new mongooose.Schema({\n    name:{type:String,default:\"username\"},\n    age：{type:Number},\n    sex:{type:String}\n});\n// 选择集合\nvar monModel = db.model('user',monSchema);\n// 数据集\nvar content = {name:\"Nick\",age:23,sex:'男'};\n// 实例化对象并插入数据\nvar monInsert = new monModel(content);\nmonInsert.save(function(err){\n  if(err){\n    console.log(err);\n  }else{\n    console.log('成功插入数据');\n  }\n  db.close();\n});\n```\n#### 删除数据\n```js\n// 引入模块\nvar mongoose = require('mongoose');\n// 连接数据库\nvar db = mongoose.createConnection('mongodb://127.0.0.1:27017/test');\n// cosole.log(db);\n// 设置数据类型\nvar monSchema = new mongooose.Schema({\n    name:{type:String,default:\"name\"},\n    age：{type:Number},\n    sex:{type:String}\n});\n// 选择集合\nvar monModel = db.model('user',monSchema);\n// 原数据字段值\nvar oldValue  = {name:\"Nick\"};\n// 单条件更新\nvar newData1 = {$set:{name:\"内容\"}};\n// 多条件更新\nvar newData2 = {$set:{name:\"内容\",age:2}};\nmonModel.update(oldValue,newData,function(err,result){\n  if(err){\n    console.log(err);\n  }else{\n    console.log(\"update\");\n  }\n  db.close();\n});\n```\n\n#### 查询数据\n```js\n// 引入模块\nvar mongoose = require('mongoose');\n// 连接数据库\nvar db = mongoose.createConnection('mongodb://127.0.0.1:27017/test');\n// cosole.log(db);\n// 设置数据类型\nvar monSchema = new mongooose.Schema({\n    name:{type:String,default:\"name\"},\n    age：{type:Number},\n    sex:{type:String}\n});\n// 选择集合\nvar monModel = db.model('user',monSchema);\nvar content = {name:\"姓名2\"};\nvar field = {name:1,age:1,sex:1};\nmonModel.find(content,field,function(err,result){\n  if(err){\n    console.log(err);\n  }else{\n    console.log(result);\n  }\n  db.close();\n});\n```\n\n\n#### 修改数据\n```js\n// 引入模块\nvar mongoose = require('mongoose');\n// 连接数据库\nvar db = mongoose.createConnection('mongodb://127.0.0.1:27017/test');\n// cosole.log(db);\n// 设置数据类型\nvar monSchema = new mongooose.Schema({\n    name:{type:String,default:\"name\"},\n    age：{type:Number},\n    sex:{type:String}\n});\n// 选择集合\nvar monModel = db.model('user',monSchema);\n// 原数据字段值\nvar oldValue  = {name:\"Nick\"};\n// 单条件更新\nvar newData1 = {$set:{name:\"内容\"}};\n// 多条件更新\nvar newData2 = {$set:{name:\"内容\",age:2}};\nmonModel.update(oldValue,newData,function(err,result){\n  if(err){\n    console.log(err);\n  }else{\n    console.log(\"update\");\n  }\n  db.close();\n});\n```\n","source":"_posts/Mongodb-学习笔记----增删改查.md","raw":"---\ntitle: 'Mongodb 学习笔记 -- 增删改查'\ndate: 2016-01-05 21:24:40\ntags:\ncomments: false\n---\n\n记录 Mongodb 的学习之旅，从环境配置，到基础命令行使用，算是一个简单的入门教程，同时也是学习总结，还有把踩到的坑都记录下来，以后遇到同样的问题不至于在同一个地方继续踩坑。\n<!-- more -->\n### Mongodb 介绍\n> MongoDB 是一种文档导向***数据库管理系统***，由 C++撰写而成，旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。2007 年 10 月，MongoDB 由 10gen 团队所发展。2009 年 2 月首度推出。 --- ***维基百科***\n\nMongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。听着很饶，其实就是非关系数据库。那什么又是 ***关系型数据库*** 呢？关系型数据库以行和列的形式存储数据，这一系列的行和列被称为表，一组表组成了数据库。表与表之间的数据记录有关系。\n\n### Mongodb 安装\n本人的操作系统是：MacOS，且已经安装了 [brew](http://brew.sh/index_zh-cn.html) ，所以图省事，我就使用 brew 一键安装了。没用过 brew 的同学可以去[这里看看](http://www.cnblogs.com/TankXiao/p/3247113.html)，用起来还是挺方便的。\n\n```bash\nbrew install mongodb\n```\n安装速度取决于你的网络情况，这里稍等片刻。brew 默认的安装位置在 `/usr/local/Cellar/` 一会的功夫，我们就能在这里看到，Mongodb 乖乖的躺在这了。因为 Mongodb 会默认读取 `/data/db` 目录下的数据库，所以方便省事，我们把默认的数据库就创建在这个位置，并且给 `/data` 执行权限，执行以下命令即可。\n\n```bash\nsudo mkdir -p /data/db         # sudo 表示以管理员权限运行，-p 表示创建多层目录\nsudo chown -R  UserName /data  # UserName 表示你当前的系统用户名\n```\n安装成功后，就可以在 Mongodb 的安装目录下 找到 `bin` 目录了，这里面放着所有需要用到的命令。\n```bash\ncd /usr/local/Cellar/mongodb/3.4.0/bin\n./mongod   # 执行 Mongodb 进程后，浏览器打开 http://127.0.0.1:27017/\n```\n浏览器显示下面的内容，就表示安装成功啦。\n```text\nIt looks like you are trying to access MongoDB over HTTP on the native driver port.\n```\n接下来打开终端，执行下面的命令，验证我们确实安装成功了。在 Mongodb 的控制台中，可以执行很多命令来操作数据库。\n```bash\ncd /usr/local/Cellar/mongodb/3.4.0/bin\n./mongo\n\n# 进入 MongoDB shell 后，光标会变成下面过的状态，执行 show dbs 后，显示如下则大功告成！\n> show dbs\nadmin  0.000GB\nlocal  0.000GB\n```\n接下来，为了方便下次执行 Mongodb ，我们把 `bin` 目录放到环境变量中，这样下次直接在终端输入 `mongod` 即可启用服务，输入命令 `mongo` 即可进入 shell 控制台。\n\n```bash\n# 添加环境变量，语法：echo \"export PATH=xxxxxx:$PATH\" >> ~/.bash_profile\necho 'export PATH=/usr/local/Cellar/mongodb/3.4.0/bin:$PATH'>>~/.bash_profile\n```\n### Mongodb 使用\n使用之前，在明白几个概念，相比关系型数据库，非关系数据库采用了 ***数据库***、***集合***、***文档***、的概念。其实对比 SQL 数据库，就很容易理解，集合就好比是一张表，文档好比就是一整行数据。库的概念是一致的。就这点区别。在终端输入 `mongo` 进入 shell 控制台。\n```bash\nmongo\n```\n#### 基础命令\n新增数据\n- 显示数据库：`show dbs`\n- 使用/创建数据库：`use 数据库名`\n- 显示集合：`show collections`\n- 保存数据：`db.collection.save({\"key\":\"value\",\"key2\":\"value2\"})`\n- 插入数据：`db.collection.insert({\"key\":\"value\",\"key2\":\"value2\"})`\n\n<div class=\"tip\">\n若新增的数据主键已经存在，insert()会不做操作并提示错误，而save()则更改原来的内容为新内容。\n</div>\n\n删除数据\n- 删除所有文档：`db.collection.remove({})`\n- 删除指定文档：`db.collection.remove({\"key\":\"value\"})`\n- 删除集合：`db.collection.drop()` 或者 `db.runCommand({\"drop\":\"collection\"})`\n- 删除数据库：`db.runCommand({\"dropDatabase\": 1})` 注意：1 没有引号\n\n查找数据\n- 查找所有数据： `db.collection.find({})`\n- 查到单条数据：`db.collection.findOne({})`\n- 条件查找：`db.collection.find({\"key\":\"value\"})`\n- 条件查找 key < value：`db.collection.find({\"key\":{$lt:value}})`\n- 条件查找 key > value：`db.collection.find({\"key\":{$gt:value}})`\n- 条件查找 key >= value：`db.collection.find({\"key\":{$gte:value}})`\n- 范围查找：`db.collection.find({\"key\":{$gt:value1,$lt:value2 } })`\n- 模运算查找：`db.collection.find({\"key\":{$mod:[10,1]}})`\n- 范围在查找：`db.collection.find({\"key\":{$in:[1,2,3]}})`\n- 范围不在在查找：`db.collection.find({\"key\":{$nin:[1,2,3]}})`\n- 数组长度查找：`db.collection.find({\"key\":{$size:1}})` key 必须是数组\n- 字段存在查找：`db.collection.find({\"key\":{$exists:true|false}})`\n- 多条件查找：`db.collection.find({$or:[{a:1},{b:2}]})`\n- 内嵌对象中的值查找：`db.collection.find({\"key.subkey\":value})`\n- 排序：`db.collection.find({}).sort({\"key1\":1,\"key2\":-1})` 1 升序 -1 降序\n- 对字段建立索引：`db.collection.find({})ensureIndex({\"key\":1})` 1 升序 -1 降序\n- 范围控制查找：`db.collection.find().skip(5).limit(5)` 跳过 5 条，读取 5 条\n- 查询结果集统计：`db.collection.find().count()`\n- 模糊查找：`db.collection.find({\"key\":/ab/})` 正则\n\n\n更改数据\n- `db.collection.update({\"targetKey\":\"targetValue\"},{\"newKey\":\"newVlue\"})`\n\n#### GUI 工具\n![](http://ww1.sinaimg.cn/large/6057861cgw1fbfwwdbu8qj20zq0dbqah.jpg)\n***Robomongo*** 可视化 Mongodb 数据库管理工具 ，点击[这里](https://robomongo.org/download)下载，官方网站：https://robomongo.org/ 。\n\n###  Mongoose 介绍\n[Mongoose](http://mongoosejs.com/) 简而言之就是在 Node 环境中操作 MongoDB 数据库的一种对象模型工具，Mongoose 将数据库中的数据转换为 JavaScript 对象供开发人员使用。\n\n#### 配置\n安装 Mongoose\n```bash\nnpm install mongoose --save\n```\n引入到项目文件中并创建链接\n```js\n// app.js\nvar mongoose = require('mongoose');\nmongoose.connect('mongodb://localhost/my_database');\n```\n\n#### 新增数据\n```js\n// 引入模块\nvar mongoose = require('mongoose');\n// 连接数据库\nvar db = mongoose.createConnection('mongodb://127.0.0.1:27017/test');\n// 设置数据类型\nvar monSchema = new mongooose.Schema({\n    name:{type:String,default:\"username\"},\n    age：{type:Number},\n    sex:{type:String}\n});\n// 选择集合\nvar monModel = db.model('user',monSchema);\n// 数据集\nvar content = {name:\"Nick\",age:23,sex:'男'};\n// 实例化对象并插入数据\nvar monInsert = new monModel(content);\nmonInsert.save(function(err){\n  if(err){\n    console.log(err);\n  }else{\n    console.log('成功插入数据');\n  }\n  db.close();\n});\n```\n#### 删除数据\n```js\n// 引入模块\nvar mongoose = require('mongoose');\n// 连接数据库\nvar db = mongoose.createConnection('mongodb://127.0.0.1:27017/test');\n// cosole.log(db);\n// 设置数据类型\nvar monSchema = new mongooose.Schema({\n    name:{type:String,default:\"name\"},\n    age：{type:Number},\n    sex:{type:String}\n});\n// 选择集合\nvar monModel = db.model('user',monSchema);\n// 原数据字段值\nvar oldValue  = {name:\"Nick\"};\n// 单条件更新\nvar newData1 = {$set:{name:\"内容\"}};\n// 多条件更新\nvar newData2 = {$set:{name:\"内容\",age:2}};\nmonModel.update(oldValue,newData,function(err,result){\n  if(err){\n    console.log(err);\n  }else{\n    console.log(\"update\");\n  }\n  db.close();\n});\n```\n\n#### 查询数据\n```js\n// 引入模块\nvar mongoose = require('mongoose');\n// 连接数据库\nvar db = mongoose.createConnection('mongodb://127.0.0.1:27017/test');\n// cosole.log(db);\n// 设置数据类型\nvar monSchema = new mongooose.Schema({\n    name:{type:String,default:\"name\"},\n    age：{type:Number},\n    sex:{type:String}\n});\n// 选择集合\nvar monModel = db.model('user',monSchema);\nvar content = {name:\"姓名2\"};\nvar field = {name:1,age:1,sex:1};\nmonModel.find(content,field,function(err,result){\n  if(err){\n    console.log(err);\n  }else{\n    console.log(result);\n  }\n  db.close();\n});\n```\n\n\n#### 修改数据\n```js\n// 引入模块\nvar mongoose = require('mongoose');\n// 连接数据库\nvar db = mongoose.createConnection('mongodb://127.0.0.1:27017/test');\n// cosole.log(db);\n// 设置数据类型\nvar monSchema = new mongooose.Schema({\n    name:{type:String,default:\"name\"},\n    age：{type:Number},\n    sex:{type:String}\n});\n// 选择集合\nvar monModel = db.model('user',monSchema);\n// 原数据字段值\nvar oldValue  = {name:\"Nick\"};\n// 单条件更新\nvar newData1 = {$set:{name:\"内容\"}};\n// 多条件更新\nvar newData2 = {$set:{name:\"内容\",age:2}};\nmonModel.update(oldValue,newData,function(err,result){\n  if(err){\n    console.log(err);\n  }else{\n    console.log(\"update\");\n  }\n  db.close();\n});\n```\n","slug":"Mongodb-学习笔记----增删改查","published":1,"updated":"2019-12-07T04:59:33.834Z","layout":"post","photos":[],"link":"","_id":"ck3v60jta0009r9q9d21kz1bp","content":"<p>记录 Mongodb 的学习之旅，从环境配置，到基础命令行使用，算是一个简单的入门教程，同时也是学习总结，还有把踩到的坑都记录下来，以后遇到同样的问题不至于在同一个地方继续踩坑。<br><a id=\"more\"></a></p>\n<h3 id=\"Mongodb-介绍\"><a href=\"#Mongodb-介绍\" class=\"headerlink\" title=\"Mongodb 介绍\"></a>Mongodb 介绍</h3><blockquote>\n<p>MongoDB 是一种文档导向<strong><em>数据库管理系统</em></strong>，由 C++撰写而成，旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。2007 年 10 月，MongoDB 由 10gen 团队所发展。2009 年 2 月首度推出。 — <strong><em>维基百科</em></strong></p>\n</blockquote>\n<p>MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。听着很饶，其实就是非关系数据库。那什么又是 <strong><em>关系型数据库</em></strong> 呢？关系型数据库以行和列的形式存储数据，这一系列的行和列被称为表，一组表组成了数据库。表与表之间的数据记录有关系。</p>\n<h3 id=\"Mongodb-安装\"><a href=\"#Mongodb-安装\" class=\"headerlink\" title=\"Mongodb 安装\"></a>Mongodb 安装</h3><p>本人的操作系统是：MacOS，且已经安装了 <a href=\"http://brew.sh/index_zh-cn.html\" target=\"_blank\" rel=\"noopener\">brew</a> ，所以图省事，我就使用 brew 一键安装了。没用过 brew 的同学可以去<a href=\"http://www.cnblogs.com/TankXiao/p/3247113.html\" target=\"_blank\" rel=\"noopener\">这里看看</a>，用起来还是挺方便的。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install mongodb</span><br></pre></td></tr></table></figure>\n<p>安装速度取决于你的网络情况，这里稍等片刻。brew 默认的安装位置在 <code>/usr/local/Cellar/</code> 一会的功夫，我们就能在这里看到，Mongodb 乖乖的躺在这了。因为 Mongodb 会默认读取 <code>/data/db</code> 目录下的数据库，所以方便省事，我们把默认的数据库就创建在这个位置，并且给 <code>/data</code> 执行权限，执行以下命令即可。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo mkdir -p /data/db         <span class=\"comment\"># sudo 表示以管理员权限运行，-p 表示创建多层目录</span></span><br><span class=\"line\">sudo chown -R  UserName /data  <span class=\"comment\"># UserName 表示你当前的系统用户名</span></span><br></pre></td></tr></table></figure>\n<p>安装成功后，就可以在 Mongodb 的安装目录下 找到 <code>bin</code> 目录了，这里面放着所有需要用到的命令。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/Cellar/mongodb/3.4.0/bin</span><br><span class=\"line\">./mongod   <span class=\"comment\"># 执行 Mongodb 进程后，浏览器打开 http://127.0.0.1:27017/</span></span><br></pre></td></tr></table></figure></p>\n<p>浏览器显示下面的内容，就表示安装成功啦。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">It looks like you are trying to access MongoDB over HTTP on the native driver port.</span><br></pre></td></tr></table></figure></p>\n<p>接下来打开终端，执行下面的命令，验证我们确实安装成功了。在 Mongodb 的控制台中，可以执行很多命令来操作数据库。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/Cellar/mongodb/3.4.0/bin</span><br><span class=\"line\">./mongo</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 进入 MongoDB shell 后，光标会变成下面过的状态，执行 show dbs 后，显示如下则大功告成！</span></span><br><span class=\"line\">&gt; show dbs</span><br><span class=\"line\">admin  0.000GB</span><br><span class=\"line\"><span class=\"built_in\">local</span>  0.000GB</span><br></pre></td></tr></table></figure></p>\n<p>接下来，为了方便下次执行 Mongodb ，我们把 <code>bin</code> 目录放到环境变量中，这样下次直接在终端输入 <code>mongod</code> 即可启用服务，输入命令 <code>mongo</code> 即可进入 shell 控制台。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 添加环境变量，语法：echo \"export PATH=xxxxxx:$PATH\" &gt;&gt; ~/.bash_profile</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">'export PATH=/usr/local/Cellar/mongodb/3.4.0/bin:$PATH'</span>&gt;&gt;~/.bash_profile</span><br></pre></td></tr></table></figure>\n<h3 id=\"Mongodb-使用\"><a href=\"#Mongodb-使用\" class=\"headerlink\" title=\"Mongodb 使用\"></a>Mongodb 使用</h3><p>使用之前，在明白几个概念，相比关系型数据库，非关系数据库采用了 <strong><em>数据库</em></strong>、<strong><em>集合</em></strong>、<strong><em>文档</em></strong>、的概念。其实对比 SQL 数据库，就很容易理解，集合就好比是一张表，文档好比就是一整行数据。库的概念是一致的。就这点区别。在终端输入 <code>mongo</code> 进入 shell 控制台。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mongo</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"基础命令\"><a href=\"#基础命令\" class=\"headerlink\" title=\"基础命令\"></a>基础命令</h4><p>新增数据</p>\n<ul>\n<li>显示数据库：<code>show dbs</code></li>\n<li>使用/创建数据库：<code>use 数据库名</code></li>\n<li>显示集合：<code>show collections</code></li>\n<li>保存数据：<code>db.collection.save({&quot;key&quot;:&quot;value&quot;,&quot;key2&quot;:&quot;value2&quot;})</code></li>\n<li>插入数据：<code>db.collection.insert({&quot;key&quot;:&quot;value&quot;,&quot;key2&quot;:&quot;value2&quot;})</code></li>\n</ul>\n<div class=\"tip\"><br>若新增的数据主键已经存在，insert()会不做操作并提示错误，而save()则更改原来的内容为新内容。<br></div>\n\n<p>删除数据</p>\n<ul>\n<li>删除所有文档：<code>db.collection.remove({})</code></li>\n<li>删除指定文档：<code>db.collection.remove({&quot;key&quot;:&quot;value&quot;})</code></li>\n<li>删除集合：<code>db.collection.drop()</code> 或者 <code>db.runCommand({&quot;drop&quot;:&quot;collection&quot;})</code></li>\n<li>删除数据库：<code>db.runCommand({&quot;dropDatabase&quot;: 1})</code> 注意：1 没有引号</li>\n</ul>\n<p>查找数据</p>\n<ul>\n<li>查找所有数据： <code>db.collection.find({})</code></li>\n<li>查到单条数据：<code>db.collection.findOne({})</code></li>\n<li>条件查找：<code>db.collection.find({&quot;key&quot;:&quot;value&quot;})</code></li>\n<li>条件查找 key &lt; value：<code>db.collection.find({&quot;key&quot;:{$lt:value}})</code></li>\n<li>条件查找 key &gt; value：<code>db.collection.find({&quot;key&quot;:{$gt:value}})</code></li>\n<li>条件查找 key &gt;= value：<code>db.collection.find({&quot;key&quot;:{$gte:value}})</code></li>\n<li>范围查找：<code>db.collection.find({&quot;key&quot;:{$gt:value1,$lt:value2 } })</code></li>\n<li>模运算查找：<code>db.collection.find({&quot;key&quot;:{$mod:[10,1]}})</code></li>\n<li>范围在查找：<code>db.collection.find({&quot;key&quot;:{$in:[1,2,3]}})</code></li>\n<li>范围不在在查找：<code>db.collection.find({&quot;key&quot;:{$nin:[1,2,3]}})</code></li>\n<li>数组长度查找：<code>db.collection.find({&quot;key&quot;:{$size:1}})</code> key 必须是数组</li>\n<li>字段存在查找：<code>db.collection.find({&quot;key&quot;:{$exists:true|false}})</code></li>\n<li>多条件查找：<code>db.collection.find({$or:[{a:1},{b:2}]})</code></li>\n<li>内嵌对象中的值查找：<code>db.collection.find({&quot;key.subkey&quot;:value})</code></li>\n<li>排序：<code>db.collection.find({}).sort({&quot;key1&quot;:1,&quot;key2&quot;:-1})</code> 1 升序 -1 降序</li>\n<li>对字段建立索引：<code>db.collection.find({})ensureIndex({&quot;key&quot;:1})</code> 1 升序 -1 降序</li>\n<li>范围控制查找：<code>db.collection.find().skip(5).limit(5)</code> 跳过 5 条，读取 5 条</li>\n<li>查询结果集统计：<code>db.collection.find().count()</code></li>\n<li>模糊查找：<code>db.collection.find({&quot;key&quot;:/ab/})</code> 正则</li>\n</ul>\n<p>更改数据</p>\n<ul>\n<li><code>db.collection.update({&quot;targetKey&quot;:&quot;targetValue&quot;},{&quot;newKey&quot;:&quot;newVlue&quot;})</code></li>\n</ul>\n<h4 id=\"GUI-工具\"><a href=\"#GUI-工具\" class=\"headerlink\" title=\"GUI 工具\"></a>GUI 工具</h4><p><img src=\"http://ww1.sinaimg.cn/large/6057861cgw1fbfwwdbu8qj20zq0dbqah.jpg\" alt=\"\"><br><strong><em>Robomongo</em></strong> 可视化 Mongodb 数据库管理工具 ，点击<a href=\"https://robomongo.org/download\" target=\"_blank\" rel=\"noopener\">这里</a>下载，官方网站：<a href=\"https://robomongo.org/\" target=\"_blank\" rel=\"noopener\">https://robomongo.org/</a> 。</p>\n<h3 id=\"Mongoose-介绍\"><a href=\"#Mongoose-介绍\" class=\"headerlink\" title=\"Mongoose 介绍\"></a>Mongoose 介绍</h3><p><a href=\"http://mongoosejs.com/\" target=\"_blank\" rel=\"noopener\">Mongoose</a> 简而言之就是在 Node 环境中操作 MongoDB 数据库的一种对象模型工具，Mongoose 将数据库中的数据转换为 JavaScript 对象供开发人员使用。</p>\n<h4 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h4><p>安装 Mongoose<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install mongoose --save</span><br></pre></td></tr></table></figure></p>\n<p>引入到项目文件中并创建链接<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// app.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> mongoose = <span class=\"built_in\">require</span>(<span class=\"string\">'mongoose'</span>);</span><br><span class=\"line\">mongoose.connect(<span class=\"string\">'mongodb://localhost/my_database'</span>);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"新增数据\"><a href=\"#新增数据\" class=\"headerlink\" title=\"新增数据\"></a>新增数据</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引入模块</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> mongoose = <span class=\"built_in\">require</span>(<span class=\"string\">'mongoose'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 连接数据库</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> db = mongoose.createConnection(<span class=\"string\">'mongodb://127.0.0.1:27017/test'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 设置数据类型</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> monSchema = <span class=\"keyword\">new</span> mongooose.Schema(&#123;</span><br><span class=\"line\">    name:&#123;<span class=\"attr\">type</span>:<span class=\"built_in\">String</span>,<span class=\"attr\">default</span>:<span class=\"string\">\"username\"</span>&#125;,</span><br><span class=\"line\">    age：&#123;<span class=\"attr\">type</span>:<span class=\"built_in\">Number</span>&#125;,</span><br><span class=\"line\">    sex:&#123;<span class=\"attr\">type</span>:<span class=\"built_in\">String</span>&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 选择集合</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> monModel = db.model(<span class=\"string\">'user'</span>,monSchema);</span><br><span class=\"line\"><span class=\"comment\">// 数据集</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> content = &#123;<span class=\"attr\">name</span>:<span class=\"string\">\"Nick\"</span>,<span class=\"attr\">age</span>:<span class=\"number\">23</span>,<span class=\"attr\">sex</span>:<span class=\"string\">'男'</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 实例化对象并插入数据</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> monInsert = <span class=\"keyword\">new</span> monModel(content);</span><br><span class=\"line\">monInsert.save(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(err)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'成功插入数据'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  db.close();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"删除数据\"><a href=\"#删除数据\" class=\"headerlink\" title=\"删除数据\"></a>删除数据</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引入模块</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> mongoose = <span class=\"built_in\">require</span>(<span class=\"string\">'mongoose'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 连接数据库</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> db = mongoose.createConnection(<span class=\"string\">'mongodb://127.0.0.1:27017/test'</span>);</span><br><span class=\"line\"><span class=\"comment\">// cosole.log(db);</span></span><br><span class=\"line\"><span class=\"comment\">// 设置数据类型</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> monSchema = <span class=\"keyword\">new</span> mongooose.Schema(&#123;</span><br><span class=\"line\">    name:&#123;<span class=\"attr\">type</span>:<span class=\"built_in\">String</span>,<span class=\"attr\">default</span>:<span class=\"string\">\"name\"</span>&#125;,</span><br><span class=\"line\">    age：&#123;<span class=\"attr\">type</span>:<span class=\"built_in\">Number</span>&#125;,</span><br><span class=\"line\">    sex:&#123;<span class=\"attr\">type</span>:<span class=\"built_in\">String</span>&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 选择集合</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> monModel = db.model(<span class=\"string\">'user'</span>,monSchema);</span><br><span class=\"line\"><span class=\"comment\">// 原数据字段值</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> oldValue  = &#123;<span class=\"attr\">name</span>:<span class=\"string\">\"Nick\"</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 单条件更新</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> newData1 = &#123;<span class=\"attr\">$set</span>:&#123;<span class=\"attr\">name</span>:<span class=\"string\">\"内容\"</span>&#125;&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 多条件更新</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> newData2 = &#123;<span class=\"attr\">$set</span>:&#123;<span class=\"attr\">name</span>:<span class=\"string\">\"内容\"</span>,<span class=\"attr\">age</span>:<span class=\"number\">2</span>&#125;&#125;;</span><br><span class=\"line\">monModel.update(oldValue,newData,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err,result</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(err)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"update\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  db.close();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"查询数据\"><a href=\"#查询数据\" class=\"headerlink\" title=\"查询数据\"></a>查询数据</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引入模块</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> mongoose = <span class=\"built_in\">require</span>(<span class=\"string\">'mongoose'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 连接数据库</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> db = mongoose.createConnection(<span class=\"string\">'mongodb://127.0.0.1:27017/test'</span>);</span><br><span class=\"line\"><span class=\"comment\">// cosole.log(db);</span></span><br><span class=\"line\"><span class=\"comment\">// 设置数据类型</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> monSchema = <span class=\"keyword\">new</span> mongooose.Schema(&#123;</span><br><span class=\"line\">    name:&#123;<span class=\"attr\">type</span>:<span class=\"built_in\">String</span>,<span class=\"attr\">default</span>:<span class=\"string\">\"name\"</span>&#125;,</span><br><span class=\"line\">    age：&#123;<span class=\"attr\">type</span>:<span class=\"built_in\">Number</span>&#125;,</span><br><span class=\"line\">    sex:&#123;<span class=\"attr\">type</span>:<span class=\"built_in\">String</span>&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 选择集合</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> monModel = db.model(<span class=\"string\">'user'</span>,monSchema);</span><br><span class=\"line\"><span class=\"keyword\">var</span> content = &#123;<span class=\"attr\">name</span>:<span class=\"string\">\"姓名2\"</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> field = &#123;<span class=\"attr\">name</span>:<span class=\"number\">1</span>,<span class=\"attr\">age</span>:<span class=\"number\">1</span>,<span class=\"attr\">sex</span>:<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">monModel.find(content,field,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err,result</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(err)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(result);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  db.close();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"修改数据\"><a href=\"#修改数据\" class=\"headerlink\" title=\"修改数据\"></a>修改数据</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引入模块</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> mongoose = <span class=\"built_in\">require</span>(<span class=\"string\">'mongoose'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 连接数据库</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> db = mongoose.createConnection(<span class=\"string\">'mongodb://127.0.0.1:27017/test'</span>);</span><br><span class=\"line\"><span class=\"comment\">// cosole.log(db);</span></span><br><span class=\"line\"><span class=\"comment\">// 设置数据类型</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> monSchema = <span class=\"keyword\">new</span> mongooose.Schema(&#123;</span><br><span class=\"line\">    name:&#123;<span class=\"attr\">type</span>:<span class=\"built_in\">String</span>,<span class=\"attr\">default</span>:<span class=\"string\">\"name\"</span>&#125;,</span><br><span class=\"line\">    age：&#123;<span class=\"attr\">type</span>:<span class=\"built_in\">Number</span>&#125;,</span><br><span class=\"line\">    sex:&#123;<span class=\"attr\">type</span>:<span class=\"built_in\">String</span>&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 选择集合</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> monModel = db.model(<span class=\"string\">'user'</span>,monSchema);</span><br><span class=\"line\"><span class=\"comment\">// 原数据字段值</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> oldValue  = &#123;<span class=\"attr\">name</span>:<span class=\"string\">\"Nick\"</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 单条件更新</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> newData1 = &#123;<span class=\"attr\">$set</span>:&#123;<span class=\"attr\">name</span>:<span class=\"string\">\"内容\"</span>&#125;&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 多条件更新</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> newData2 = &#123;<span class=\"attr\">$set</span>:&#123;<span class=\"attr\">name</span>:<span class=\"string\">\"内容\"</span>,<span class=\"attr\">age</span>:<span class=\"number\">2</span>&#125;&#125;;</span><br><span class=\"line\">monModel.update(oldValue,newData,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err,result</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(err)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"update\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  db.close();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>记录 Mongodb 的学习之旅，从环境配置，到基础命令行使用，算是一个简单的入门教程，同时也是学习总结，还有把踩到的坑都记录下来，以后遇到同样的问题不至于在同一个地方继续踩坑。<br>","more":"</p>\n<h3 id=\"Mongodb-介绍\"><a href=\"#Mongodb-介绍\" class=\"headerlink\" title=\"Mongodb 介绍\"></a>Mongodb 介绍</h3><blockquote>\n<p>MongoDB 是一种文档导向<strong><em>数据库管理系统</em></strong>，由 C++撰写而成，旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。2007 年 10 月，MongoDB 由 10gen 团队所发展。2009 年 2 月首度推出。 — <strong><em>维基百科</em></strong></p>\n</blockquote>\n<p>MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。听着很饶，其实就是非关系数据库。那什么又是 <strong><em>关系型数据库</em></strong> 呢？关系型数据库以行和列的形式存储数据，这一系列的行和列被称为表，一组表组成了数据库。表与表之间的数据记录有关系。</p>\n<h3 id=\"Mongodb-安装\"><a href=\"#Mongodb-安装\" class=\"headerlink\" title=\"Mongodb 安装\"></a>Mongodb 安装</h3><p>本人的操作系统是：MacOS，且已经安装了 <a href=\"http://brew.sh/index_zh-cn.html\" target=\"_blank\" rel=\"noopener\">brew</a> ，所以图省事，我就使用 brew 一键安装了。没用过 brew 的同学可以去<a href=\"http://www.cnblogs.com/TankXiao/p/3247113.html\" target=\"_blank\" rel=\"noopener\">这里看看</a>，用起来还是挺方便的。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install mongodb</span><br></pre></td></tr></table></figure>\n<p>安装速度取决于你的网络情况，这里稍等片刻。brew 默认的安装位置在 <code>/usr/local/Cellar/</code> 一会的功夫，我们就能在这里看到，Mongodb 乖乖的躺在这了。因为 Mongodb 会默认读取 <code>/data/db</code> 目录下的数据库，所以方便省事，我们把默认的数据库就创建在这个位置，并且给 <code>/data</code> 执行权限，执行以下命令即可。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo mkdir -p /data/db         <span class=\"comment\"># sudo 表示以管理员权限运行，-p 表示创建多层目录</span></span><br><span class=\"line\">sudo chown -R  UserName /data  <span class=\"comment\"># UserName 表示你当前的系统用户名</span></span><br></pre></td></tr></table></figure>\n<p>安装成功后，就可以在 Mongodb 的安装目录下 找到 <code>bin</code> 目录了，这里面放着所有需要用到的命令。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/Cellar/mongodb/3.4.0/bin</span><br><span class=\"line\">./mongod   <span class=\"comment\"># 执行 Mongodb 进程后，浏览器打开 http://127.0.0.1:27017/</span></span><br></pre></td></tr></table></figure></p>\n<p>浏览器显示下面的内容，就表示安装成功啦。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">It looks like you are trying to access MongoDB over HTTP on the native driver port.</span><br></pre></td></tr></table></figure></p>\n<p>接下来打开终端，执行下面的命令，验证我们确实安装成功了。在 Mongodb 的控制台中，可以执行很多命令来操作数据库。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/Cellar/mongodb/3.4.0/bin</span><br><span class=\"line\">./mongo</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 进入 MongoDB shell 后，光标会变成下面过的状态，执行 show dbs 后，显示如下则大功告成！</span></span><br><span class=\"line\">&gt; show dbs</span><br><span class=\"line\">admin  0.000GB</span><br><span class=\"line\"><span class=\"built_in\">local</span>  0.000GB</span><br></pre></td></tr></table></figure></p>\n<p>接下来，为了方便下次执行 Mongodb ，我们把 <code>bin</code> 目录放到环境变量中，这样下次直接在终端输入 <code>mongod</code> 即可启用服务，输入命令 <code>mongo</code> 即可进入 shell 控制台。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 添加环境变量，语法：echo \"export PATH=xxxxxx:$PATH\" &gt;&gt; ~/.bash_profile</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">'export PATH=/usr/local/Cellar/mongodb/3.4.0/bin:$PATH'</span>&gt;&gt;~/.bash_profile</span><br></pre></td></tr></table></figure>\n<h3 id=\"Mongodb-使用\"><a href=\"#Mongodb-使用\" class=\"headerlink\" title=\"Mongodb 使用\"></a>Mongodb 使用</h3><p>使用之前，在明白几个概念，相比关系型数据库，非关系数据库采用了 <strong><em>数据库</em></strong>、<strong><em>集合</em></strong>、<strong><em>文档</em></strong>、的概念。其实对比 SQL 数据库，就很容易理解，集合就好比是一张表，文档好比就是一整行数据。库的概念是一致的。就这点区别。在终端输入 <code>mongo</code> 进入 shell 控制台。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mongo</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"基础命令\"><a href=\"#基础命令\" class=\"headerlink\" title=\"基础命令\"></a>基础命令</h4><p>新增数据</p>\n<ul>\n<li>显示数据库：<code>show dbs</code></li>\n<li>使用/创建数据库：<code>use 数据库名</code></li>\n<li>显示集合：<code>show collections</code></li>\n<li>保存数据：<code>db.collection.save({&quot;key&quot;:&quot;value&quot;,&quot;key2&quot;:&quot;value2&quot;})</code></li>\n<li>插入数据：<code>db.collection.insert({&quot;key&quot;:&quot;value&quot;,&quot;key2&quot;:&quot;value2&quot;})</code></li>\n</ul>\n<div class=\"tip\"><br>若新增的数据主键已经存在，insert()会不做操作并提示错误，而save()则更改原来的内容为新内容。<br></div>\n\n<p>删除数据</p>\n<ul>\n<li>删除所有文档：<code>db.collection.remove({})</code></li>\n<li>删除指定文档：<code>db.collection.remove({&quot;key&quot;:&quot;value&quot;})</code></li>\n<li>删除集合：<code>db.collection.drop()</code> 或者 <code>db.runCommand({&quot;drop&quot;:&quot;collection&quot;})</code></li>\n<li>删除数据库：<code>db.runCommand({&quot;dropDatabase&quot;: 1})</code> 注意：1 没有引号</li>\n</ul>\n<p>查找数据</p>\n<ul>\n<li>查找所有数据： <code>db.collection.find({})</code></li>\n<li>查到单条数据：<code>db.collection.findOne({})</code></li>\n<li>条件查找：<code>db.collection.find({&quot;key&quot;:&quot;value&quot;})</code></li>\n<li>条件查找 key &lt; value：<code>db.collection.find({&quot;key&quot;:{$lt:value}})</code></li>\n<li>条件查找 key &gt; value：<code>db.collection.find({&quot;key&quot;:{$gt:value}})</code></li>\n<li>条件查找 key &gt;= value：<code>db.collection.find({&quot;key&quot;:{$gte:value}})</code></li>\n<li>范围查找：<code>db.collection.find({&quot;key&quot;:{$gt:value1,$lt:value2 } })</code></li>\n<li>模运算查找：<code>db.collection.find({&quot;key&quot;:{$mod:[10,1]}})</code></li>\n<li>范围在查找：<code>db.collection.find({&quot;key&quot;:{$in:[1,2,3]}})</code></li>\n<li>范围不在在查找：<code>db.collection.find({&quot;key&quot;:{$nin:[1,2,3]}})</code></li>\n<li>数组长度查找：<code>db.collection.find({&quot;key&quot;:{$size:1}})</code> key 必须是数组</li>\n<li>字段存在查找：<code>db.collection.find({&quot;key&quot;:{$exists:true|false}})</code></li>\n<li>多条件查找：<code>db.collection.find({$or:[{a:1},{b:2}]})</code></li>\n<li>内嵌对象中的值查找：<code>db.collection.find({&quot;key.subkey&quot;:value})</code></li>\n<li>排序：<code>db.collection.find({}).sort({&quot;key1&quot;:1,&quot;key2&quot;:-1})</code> 1 升序 -1 降序</li>\n<li>对字段建立索引：<code>db.collection.find({})ensureIndex({&quot;key&quot;:1})</code> 1 升序 -1 降序</li>\n<li>范围控制查找：<code>db.collection.find().skip(5).limit(5)</code> 跳过 5 条，读取 5 条</li>\n<li>查询结果集统计：<code>db.collection.find().count()</code></li>\n<li>模糊查找：<code>db.collection.find({&quot;key&quot;:/ab/})</code> 正则</li>\n</ul>\n<p>更改数据</p>\n<ul>\n<li><code>db.collection.update({&quot;targetKey&quot;:&quot;targetValue&quot;},{&quot;newKey&quot;:&quot;newVlue&quot;})</code></li>\n</ul>\n<h4 id=\"GUI-工具\"><a href=\"#GUI-工具\" class=\"headerlink\" title=\"GUI 工具\"></a>GUI 工具</h4><p><img src=\"http://ww1.sinaimg.cn/large/6057861cgw1fbfwwdbu8qj20zq0dbqah.jpg\" alt=\"\"><br><strong><em>Robomongo</em></strong> 可视化 Mongodb 数据库管理工具 ，点击<a href=\"https://robomongo.org/download\" target=\"_blank\" rel=\"noopener\">这里</a>下载，官方网站：<a href=\"https://robomongo.org/\" target=\"_blank\" rel=\"noopener\">https://robomongo.org/</a> 。</p>\n<h3 id=\"Mongoose-介绍\"><a href=\"#Mongoose-介绍\" class=\"headerlink\" title=\"Mongoose 介绍\"></a>Mongoose 介绍</h3><p><a href=\"http://mongoosejs.com/\" target=\"_blank\" rel=\"noopener\">Mongoose</a> 简而言之就是在 Node 环境中操作 MongoDB 数据库的一种对象模型工具，Mongoose 将数据库中的数据转换为 JavaScript 对象供开发人员使用。</p>\n<h4 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h4><p>安装 Mongoose<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install mongoose --save</span><br></pre></td></tr></table></figure></p>\n<p>引入到项目文件中并创建链接<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// app.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> mongoose = <span class=\"built_in\">require</span>(<span class=\"string\">'mongoose'</span>);</span><br><span class=\"line\">mongoose.connect(<span class=\"string\">'mongodb://localhost/my_database'</span>);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"新增数据\"><a href=\"#新增数据\" class=\"headerlink\" title=\"新增数据\"></a>新增数据</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引入模块</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> mongoose = <span class=\"built_in\">require</span>(<span class=\"string\">'mongoose'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 连接数据库</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> db = mongoose.createConnection(<span class=\"string\">'mongodb://127.0.0.1:27017/test'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 设置数据类型</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> monSchema = <span class=\"keyword\">new</span> mongooose.Schema(&#123;</span><br><span class=\"line\">    name:&#123;<span class=\"attr\">type</span>:<span class=\"built_in\">String</span>,<span class=\"attr\">default</span>:<span class=\"string\">\"username\"</span>&#125;,</span><br><span class=\"line\">    age：&#123;<span class=\"attr\">type</span>:<span class=\"built_in\">Number</span>&#125;,</span><br><span class=\"line\">    sex:&#123;<span class=\"attr\">type</span>:<span class=\"built_in\">String</span>&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 选择集合</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> monModel = db.model(<span class=\"string\">'user'</span>,monSchema);</span><br><span class=\"line\"><span class=\"comment\">// 数据集</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> content = &#123;<span class=\"attr\">name</span>:<span class=\"string\">\"Nick\"</span>,<span class=\"attr\">age</span>:<span class=\"number\">23</span>,<span class=\"attr\">sex</span>:<span class=\"string\">'男'</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 实例化对象并插入数据</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> monInsert = <span class=\"keyword\">new</span> monModel(content);</span><br><span class=\"line\">monInsert.save(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(err)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'成功插入数据'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  db.close();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"删除数据\"><a href=\"#删除数据\" class=\"headerlink\" title=\"删除数据\"></a>删除数据</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引入模块</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> mongoose = <span class=\"built_in\">require</span>(<span class=\"string\">'mongoose'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 连接数据库</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> db = mongoose.createConnection(<span class=\"string\">'mongodb://127.0.0.1:27017/test'</span>);</span><br><span class=\"line\"><span class=\"comment\">// cosole.log(db);</span></span><br><span class=\"line\"><span class=\"comment\">// 设置数据类型</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> monSchema = <span class=\"keyword\">new</span> mongooose.Schema(&#123;</span><br><span class=\"line\">    name:&#123;<span class=\"attr\">type</span>:<span class=\"built_in\">String</span>,<span class=\"attr\">default</span>:<span class=\"string\">\"name\"</span>&#125;,</span><br><span class=\"line\">    age：&#123;<span class=\"attr\">type</span>:<span class=\"built_in\">Number</span>&#125;,</span><br><span class=\"line\">    sex:&#123;<span class=\"attr\">type</span>:<span class=\"built_in\">String</span>&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 选择集合</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> monModel = db.model(<span class=\"string\">'user'</span>,monSchema);</span><br><span class=\"line\"><span class=\"comment\">// 原数据字段值</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> oldValue  = &#123;<span class=\"attr\">name</span>:<span class=\"string\">\"Nick\"</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 单条件更新</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> newData1 = &#123;<span class=\"attr\">$set</span>:&#123;<span class=\"attr\">name</span>:<span class=\"string\">\"内容\"</span>&#125;&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 多条件更新</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> newData2 = &#123;<span class=\"attr\">$set</span>:&#123;<span class=\"attr\">name</span>:<span class=\"string\">\"内容\"</span>,<span class=\"attr\">age</span>:<span class=\"number\">2</span>&#125;&#125;;</span><br><span class=\"line\">monModel.update(oldValue,newData,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err,result</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(err)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"update\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  db.close();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"查询数据\"><a href=\"#查询数据\" class=\"headerlink\" title=\"查询数据\"></a>查询数据</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引入模块</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> mongoose = <span class=\"built_in\">require</span>(<span class=\"string\">'mongoose'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 连接数据库</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> db = mongoose.createConnection(<span class=\"string\">'mongodb://127.0.0.1:27017/test'</span>);</span><br><span class=\"line\"><span class=\"comment\">// cosole.log(db);</span></span><br><span class=\"line\"><span class=\"comment\">// 设置数据类型</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> monSchema = <span class=\"keyword\">new</span> mongooose.Schema(&#123;</span><br><span class=\"line\">    name:&#123;<span class=\"attr\">type</span>:<span class=\"built_in\">String</span>,<span class=\"attr\">default</span>:<span class=\"string\">\"name\"</span>&#125;,</span><br><span class=\"line\">    age：&#123;<span class=\"attr\">type</span>:<span class=\"built_in\">Number</span>&#125;,</span><br><span class=\"line\">    sex:&#123;<span class=\"attr\">type</span>:<span class=\"built_in\">String</span>&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 选择集合</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> monModel = db.model(<span class=\"string\">'user'</span>,monSchema);</span><br><span class=\"line\"><span class=\"keyword\">var</span> content = &#123;<span class=\"attr\">name</span>:<span class=\"string\">\"姓名2\"</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> field = &#123;<span class=\"attr\">name</span>:<span class=\"number\">1</span>,<span class=\"attr\">age</span>:<span class=\"number\">1</span>,<span class=\"attr\">sex</span>:<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">monModel.find(content,field,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err,result</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(err)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(result);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  db.close();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"修改数据\"><a href=\"#修改数据\" class=\"headerlink\" title=\"修改数据\"></a>修改数据</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引入模块</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> mongoose = <span class=\"built_in\">require</span>(<span class=\"string\">'mongoose'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 连接数据库</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> db = mongoose.createConnection(<span class=\"string\">'mongodb://127.0.0.1:27017/test'</span>);</span><br><span class=\"line\"><span class=\"comment\">// cosole.log(db);</span></span><br><span class=\"line\"><span class=\"comment\">// 设置数据类型</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> monSchema = <span class=\"keyword\">new</span> mongooose.Schema(&#123;</span><br><span class=\"line\">    name:&#123;<span class=\"attr\">type</span>:<span class=\"built_in\">String</span>,<span class=\"attr\">default</span>:<span class=\"string\">\"name\"</span>&#125;,</span><br><span class=\"line\">    age：&#123;<span class=\"attr\">type</span>:<span class=\"built_in\">Number</span>&#125;,</span><br><span class=\"line\">    sex:&#123;<span class=\"attr\">type</span>:<span class=\"built_in\">String</span>&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 选择集合</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> monModel = db.model(<span class=\"string\">'user'</span>,monSchema);</span><br><span class=\"line\"><span class=\"comment\">// 原数据字段值</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> oldValue  = &#123;<span class=\"attr\">name</span>:<span class=\"string\">\"Nick\"</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 单条件更新</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> newData1 = &#123;<span class=\"attr\">$set</span>:&#123;<span class=\"attr\">name</span>:<span class=\"string\">\"内容\"</span>&#125;&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 多条件更新</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> newData2 = &#123;<span class=\"attr\">$set</span>:&#123;<span class=\"attr\">name</span>:<span class=\"string\">\"内容\"</span>,<span class=\"attr\">age</span>:<span class=\"number\">2</span>&#125;&#125;;</span><br><span class=\"line\">monModel.update(oldValue,newData,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err,result</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(err)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"update\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  db.close();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>"},{"title":"Node.JS 学习笔记 [01] -- 入门","date":"2015-01-02T11:00:24.000Z","comments":0,"_content":"\n整理记录 Node.js 学习笔记，作为前端人员，非常有必要了解后端的一些知识，方便与后端的同事协作，提高效率，搞好前端后，也可以尝试往后端发展，成为一名全栈工程师！:P\n<!-- more -->\n![](http://ww4.sinaimg.cn/mw690/6057861cgw1fb6vlzd7i7j20go08cjro.jpg)\n### Node.js 介绍\nNode.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。Node.js 的包管理器 npm，是全球最大的开源库生态系统。\n\n#### Node.js 和 JavaScript 的区别\n- Node.js 是一个可以运行 JavaScript 的平台，基于 ChromeV8 引擎，是对 JavaScript 的增强，使 JavaScript 具备了服务器语言的开发能力，比如操作文件、读取系统信息、网络传输等。\n- JavaScript 是一门编程语言，只要有 JavaScript 引擎就能运行并且如果 JavaScript 运行在浏览器中，浏览器对 JavaScript 加入了浏览器和文档操作的接口（方法）。\n\n<div class=\"tip\">\n简单理解：浏览器中 JavaScript 主要是操作 BOM 和 DOM，而 Node.js 则是具有服务端语言处理能力（处理网络请求，保存数据到数据库等）。\n</div>\n\n#### 官方网站\n- 英文社区： https://www.npmjs.com/\n- 中文社区：http://cnodejs.org/\n\n#### Node.js 安装及运行\n在 Node.js 的官方提供的[下载频道](https://nodejs.org/en/download/)选择对应的平台及安装程序安装即可。Node.js 提供了 `REPL（Read-Evaluate-Print-Loop）` 模式，即 ***交互式命令行解析器***，可以直接输入命令行，编写 Node.js 代码。安装成功后，我们可以在终端里输入 `node -v` 获取当前的 Node.js 版本号，能获取表示成功安装。\n\n### Node.js 模块\n模块对于 Node.js 来说是一个非常重要的概念，一个特定功能的文件就是一个模块。模块之间可能会存在一定的依赖关系，比如我写了一个 jQuery 轮播的插件，它就依赖 jQuery 库，在 Node.js 中可以非常方便的表示清楚这种依赖关系。说到模块，还需要说一个就是编写模块的规范。\n\n#### 模块规范\n- ***AMD*** (Asynchronous Module Definition)，这种规范是异步的加载模块，RequireR.js 应用了这一规范,适合客户端浏览器环境。\n- ***CMD*** (Common Module Definition), 是 Sea.js 推崇的规范。\n- ***CommonJS*** , 是诞生比较早的。Node.js 就采用了 CommonJS 的规范来定义模块。但是 CommonJs 采用的是同步加载文件方式，只适用于服务端（Node.js 平台）。\n\n#### 使用模块\n模块定义完成后，就可以使用模块，通过命令行参数传递给 Node.js 以启动程序的模块被称为 ***主模块***。主模块负责调度组成整个程序的其它模块完成工作。其实就类似网站中的 `index.html`，Node.js 中的主模块通常是 `main.js` 或者 `index.js`。\n```js\nvar http = require('http');// 通过 require 引入 http 模块\n```\n\n#### 模块组成\n在上条命令中，我们通过 require 引入了一个 http 模块，实际上作为一个单独的模块文件，Node.js 为我们在外层嵌套了一个函数，正因为有了这个函数，在这个文件中声明的变量就是私有变量啦，那么每个模块之间就不会产生干扰了。那么来看看这个函数长什么样子。\n```js\nfunction (exports, require, module, __filename, __dirname) {\n    var http = require('http');// 通过 require 引入 http 模块\n}\n```\n最外层，Node.js 为我们的代码包裹了这样一个函数，这个函数传入了几个参数，我来解释一下：\n- exports ：用于在当前模块中加载和使用别的模块，传入一个模块名，返回一个模块导出对象。\n- require：当前模块的导出对象，用于导出模块公有方法和属性。\n- module：访问到当前模块的一些相关信息，但最多的用途是替换当前模块的导出对象。\n- __filename：当前模块的文件名\n- __dirname：当前模块的目录名\n\n#### 模块分类\nNode.js 提供两种模块类型：\n1. 核心模块：是由 Node.js 平台提供的模块，也可以称为“系统模块”。\n2. 文件模块：以 `..` 或 `.` 和 `/` 开始的标识符，这里都被当做文件模块来处理。\n\n#### node_modules 文件夹\n该文件夹是 Node.js 中的特殊文件夹，用来存放 node 模块，如果一个模块既不是系统模块，也不是文件模块，那么它会被存放在 node_modules 文件夹中。使用 `console.log(module.paths);` 可以打印 Node.js 会遍历的 node_modules 目录。\n```js\n[ '/Users/wangmingming/Documents/Projects/JSstudy/12.26/node_modules',\n  '/Users/wangmingming/Documents/Projects/JSstudy/node_modules',\n  '/Users/wangmingming/Documents/Projects/node_modules',\n  '/Users/wangmingming/Documents/node_modules',\n  '/Users/wangmingming/node_modules',\n  '/Users/node_modules',\n  '/node_modules' ]\n```\n<div class=\"tip\">\n在调用一个模块时，Node.js 沿路径向上逐级递归，直到根目录下的 node_modules 目录。CommonJS 模规范也允许在标识符中不包含文件扩展名，这种情况下，Node 会按 js、json、node 的次序补足扩展名，依次尝试。\n</div>\n\n### 包 (Package)\n把由多个子模块组成的大模块称做包，并把所有子模块放在同一个目录里。在一个包中，会用 `package.json` 文件中的 `main` 属性用来描述这个包的主文件。\n\n#### NPM (Node Package Manager)\n大名鼎鼎的 NPM 实际上就是用来管理包的一个工具，借助 NPM 我们可以快速的安装和管理依赖包。下面是我整理的 npm 常用命令。\n```bash\nnpm init                   #  初始化包，要求填入包名等信息\nnpm install <name>         #  本地安装一个包\nnpm install <name> -g      #  全局安装一个包\nnpm install <name> --save  #  本地安装并写入 package.json 依赖中\nnpm remove <name>          #  移除\nnpm update <name>          #  更新\n\n```\n- 本地安装：将安装包放在 `./node_modules` 下（运行 npm 命令时所在的目录），如果没有 node_modules 目录，会在当前执行 npm 命令的目录下生成 node_modules 目录。可以通过 `require()` 来引入本地安装的包。\n- 全局安装：将安装包放在 `/usr/local` 下或者你 node 的安装目录，可以直接在命令行里使用。\n","source":"_posts/Node.JS-学习笔记-[01]----入门.md","raw":"---\ntitle: 'Node.JS 学习笔记 [01] -- 入门'\ndate: 2015-1-2 19:00:24\ntags:\ncomments: false\n---\n\n整理记录 Node.js 学习笔记，作为前端人员，非常有必要了解后端的一些知识，方便与后端的同事协作，提高效率，搞好前端后，也可以尝试往后端发展，成为一名全栈工程师！:P\n<!-- more -->\n![](http://ww4.sinaimg.cn/mw690/6057861cgw1fb6vlzd7i7j20go08cjro.jpg)\n### Node.js 介绍\nNode.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。Node.js 的包管理器 npm，是全球最大的开源库生态系统。\n\n#### Node.js 和 JavaScript 的区别\n- Node.js 是一个可以运行 JavaScript 的平台，基于 ChromeV8 引擎，是对 JavaScript 的增强，使 JavaScript 具备了服务器语言的开发能力，比如操作文件、读取系统信息、网络传输等。\n- JavaScript 是一门编程语言，只要有 JavaScript 引擎就能运行并且如果 JavaScript 运行在浏览器中，浏览器对 JavaScript 加入了浏览器和文档操作的接口（方法）。\n\n<div class=\"tip\">\n简单理解：浏览器中 JavaScript 主要是操作 BOM 和 DOM，而 Node.js 则是具有服务端语言处理能力（处理网络请求，保存数据到数据库等）。\n</div>\n\n#### 官方网站\n- 英文社区： https://www.npmjs.com/\n- 中文社区：http://cnodejs.org/\n\n#### Node.js 安装及运行\n在 Node.js 的官方提供的[下载频道](https://nodejs.org/en/download/)选择对应的平台及安装程序安装即可。Node.js 提供了 `REPL（Read-Evaluate-Print-Loop）` 模式，即 ***交互式命令行解析器***，可以直接输入命令行，编写 Node.js 代码。安装成功后，我们可以在终端里输入 `node -v` 获取当前的 Node.js 版本号，能获取表示成功安装。\n\n### Node.js 模块\n模块对于 Node.js 来说是一个非常重要的概念，一个特定功能的文件就是一个模块。模块之间可能会存在一定的依赖关系，比如我写了一个 jQuery 轮播的插件，它就依赖 jQuery 库，在 Node.js 中可以非常方便的表示清楚这种依赖关系。说到模块，还需要说一个就是编写模块的规范。\n\n#### 模块规范\n- ***AMD*** (Asynchronous Module Definition)，这种规范是异步的加载模块，RequireR.js 应用了这一规范,适合客户端浏览器环境。\n- ***CMD*** (Common Module Definition), 是 Sea.js 推崇的规范。\n- ***CommonJS*** , 是诞生比较早的。Node.js 就采用了 CommonJS 的规范来定义模块。但是 CommonJs 采用的是同步加载文件方式，只适用于服务端（Node.js 平台）。\n\n#### 使用模块\n模块定义完成后，就可以使用模块，通过命令行参数传递给 Node.js 以启动程序的模块被称为 ***主模块***。主模块负责调度组成整个程序的其它模块完成工作。其实就类似网站中的 `index.html`，Node.js 中的主模块通常是 `main.js` 或者 `index.js`。\n```js\nvar http = require('http');// 通过 require 引入 http 模块\n```\n\n#### 模块组成\n在上条命令中，我们通过 require 引入了一个 http 模块，实际上作为一个单独的模块文件，Node.js 为我们在外层嵌套了一个函数，正因为有了这个函数，在这个文件中声明的变量就是私有变量啦，那么每个模块之间就不会产生干扰了。那么来看看这个函数长什么样子。\n```js\nfunction (exports, require, module, __filename, __dirname) {\n    var http = require('http');// 通过 require 引入 http 模块\n}\n```\n最外层，Node.js 为我们的代码包裹了这样一个函数，这个函数传入了几个参数，我来解释一下：\n- exports ：用于在当前模块中加载和使用别的模块，传入一个模块名，返回一个模块导出对象。\n- require：当前模块的导出对象，用于导出模块公有方法和属性。\n- module：访问到当前模块的一些相关信息，但最多的用途是替换当前模块的导出对象。\n- __filename：当前模块的文件名\n- __dirname：当前模块的目录名\n\n#### 模块分类\nNode.js 提供两种模块类型：\n1. 核心模块：是由 Node.js 平台提供的模块，也可以称为“系统模块”。\n2. 文件模块：以 `..` 或 `.` 和 `/` 开始的标识符，这里都被当做文件模块来处理。\n\n#### node_modules 文件夹\n该文件夹是 Node.js 中的特殊文件夹，用来存放 node 模块，如果一个模块既不是系统模块，也不是文件模块，那么它会被存放在 node_modules 文件夹中。使用 `console.log(module.paths);` 可以打印 Node.js 会遍历的 node_modules 目录。\n```js\n[ '/Users/wangmingming/Documents/Projects/JSstudy/12.26/node_modules',\n  '/Users/wangmingming/Documents/Projects/JSstudy/node_modules',\n  '/Users/wangmingming/Documents/Projects/node_modules',\n  '/Users/wangmingming/Documents/node_modules',\n  '/Users/wangmingming/node_modules',\n  '/Users/node_modules',\n  '/node_modules' ]\n```\n<div class=\"tip\">\n在调用一个模块时，Node.js 沿路径向上逐级递归，直到根目录下的 node_modules 目录。CommonJS 模规范也允许在标识符中不包含文件扩展名，这种情况下，Node 会按 js、json、node 的次序补足扩展名，依次尝试。\n</div>\n\n### 包 (Package)\n把由多个子模块组成的大模块称做包，并把所有子模块放在同一个目录里。在一个包中，会用 `package.json` 文件中的 `main` 属性用来描述这个包的主文件。\n\n#### NPM (Node Package Manager)\n大名鼎鼎的 NPM 实际上就是用来管理包的一个工具，借助 NPM 我们可以快速的安装和管理依赖包。下面是我整理的 npm 常用命令。\n```bash\nnpm init                   #  初始化包，要求填入包名等信息\nnpm install <name>         #  本地安装一个包\nnpm install <name> -g      #  全局安装一个包\nnpm install <name> --save  #  本地安装并写入 package.json 依赖中\nnpm remove <name>          #  移除\nnpm update <name>          #  更新\n\n```\n- 本地安装：将安装包放在 `./node_modules` 下（运行 npm 命令时所在的目录），如果没有 node_modules 目录，会在当前执行 npm 命令的目录下生成 node_modules 目录。可以通过 `require()` 来引入本地安装的包。\n- 全局安装：将安装包放在 `/usr/local` 下或者你 node 的安装目录，可以直接在命令行里使用。\n","slug":"Node.JS-学习笔记-[01]----入门","published":1,"updated":"2019-12-07T04:59:33.895Z","layout":"post","photos":[],"link":"","_id":"ck3v60jtb000ar9q90mhsaep4","content":"<p>整理记录 Node.js 学习笔记，作为前端人员，非常有必要了解后端的一些知识，方便与后端的同事协作，提高效率，搞好前端后，也可以尝试往后端发展，成为一名全栈工程师！:P<br><a id=\"more\"></a><br><img src=\"http://ww4.sinaimg.cn/mw690/6057861cgw1fb6vlzd7i7j20go08cjro.jpg\" alt=\"\"></p>\n<h3 id=\"Node-js-介绍\"><a href=\"#Node-js-介绍\" class=\"headerlink\" title=\"Node.js 介绍\"></a>Node.js 介绍</h3><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。Node.js 的包管理器 npm，是全球最大的开源库生态系统。</p>\n<h4 id=\"Node-js-和-JavaScript-的区别\"><a href=\"#Node-js-和-JavaScript-的区别\" class=\"headerlink\" title=\"Node.js 和 JavaScript 的区别\"></a>Node.js 和 JavaScript 的区别</h4><ul>\n<li>Node.js 是一个可以运行 JavaScript 的平台，基于 ChromeV8 引擎，是对 JavaScript 的增强，使 JavaScript 具备了服务器语言的开发能力，比如操作文件、读取系统信息、网络传输等。</li>\n<li>JavaScript 是一门编程语言，只要有 JavaScript 引擎就能运行并且如果 JavaScript 运行在浏览器中，浏览器对 JavaScript 加入了浏览器和文档操作的接口（方法）。</li>\n</ul>\n<div class=\"tip\"><br>简单理解：浏览器中 JavaScript 主要是操作 BOM 和 DOM，而 Node.js 则是具有服务端语言处理能力（处理网络请求，保存数据到数据库等）。<br></div>\n\n<h4 id=\"官方网站\"><a href=\"#官方网站\" class=\"headerlink\" title=\"官方网站\"></a>官方网站</h4><ul>\n<li>英文社区： <a href=\"https://www.npmjs.com/\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/</a></li>\n<li>中文社区：<a href=\"http://cnodejs.org/\" target=\"_blank\" rel=\"noopener\">http://cnodejs.org/</a></li>\n</ul>\n<h4 id=\"Node-js-安装及运行\"><a href=\"#Node-js-安装及运行\" class=\"headerlink\" title=\"Node.js 安装及运行\"></a>Node.js 安装及运行</h4><p>在 Node.js 的官方提供的<a href=\"https://nodejs.org/en/download/\" target=\"_blank\" rel=\"noopener\">下载频道</a>选择对应的平台及安装程序安装即可。Node.js 提供了 <code>REPL（Read-Evaluate-Print-Loop）</code> 模式，即 <strong><em>交互式命令行解析器</em></strong>，可以直接输入命令行，编写 Node.js 代码。安装成功后，我们可以在终端里输入 <code>node -v</code> 获取当前的 Node.js 版本号，能获取表示成功安装。</p>\n<h3 id=\"Node-js-模块\"><a href=\"#Node-js-模块\" class=\"headerlink\" title=\"Node.js 模块\"></a>Node.js 模块</h3><p>模块对于 Node.js 来说是一个非常重要的概念，一个特定功能的文件就是一个模块。模块之间可能会存在一定的依赖关系，比如我写了一个 jQuery 轮播的插件，它就依赖 jQuery 库，在 Node.js 中可以非常方便的表示清楚这种依赖关系。说到模块，还需要说一个就是编写模块的规范。</p>\n<h4 id=\"模块规范\"><a href=\"#模块规范\" class=\"headerlink\" title=\"模块规范\"></a>模块规范</h4><ul>\n<li><strong><em>AMD</em></strong> (Asynchronous Module Definition)，这种规范是异步的加载模块，RequireR.js 应用了这一规范,适合客户端浏览器环境。</li>\n<li><strong><em>CMD</em></strong> (Common Module Definition), 是 Sea.js 推崇的规范。</li>\n<li><strong><em>CommonJS</em></strong> , 是诞生比较早的。Node.js 就采用了 CommonJS 的规范来定义模块。但是 CommonJs 采用的是同步加载文件方式，只适用于服务端（Node.js 平台）。</li>\n</ul>\n<h4 id=\"使用模块\"><a href=\"#使用模块\" class=\"headerlink\" title=\"使用模块\"></a>使用模块</h4><p>模块定义完成后，就可以使用模块，通过命令行参数传递给 Node.js 以启动程序的模块被称为 <strong><em>主模块</em></strong>。主模块负责调度组成整个程序的其它模块完成工作。其实就类似网站中的 <code>index.html</code>，Node.js 中的主模块通常是 <code>main.js</code> 或者 <code>index.js</code>。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);<span class=\"comment\">// 通过 require 引入 http 模块</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"模块组成\"><a href=\"#模块组成\" class=\"headerlink\" title=\"模块组成\"></a>模块组成</h4><p>在上条命令中，我们通过 require 引入了一个 http 模块，实际上作为一个单独的模块文件，Node.js 为我们在外层嵌套了一个函数，正因为有了这个函数，在这个文件中声明的变量就是私有变量啦，那么每个模块之间就不会产生干扰了。那么来看看这个函数长什么样子。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">exports, require, module, __filename, __dirname</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);<span class=\"comment\">// 通过 require 引入 http 模块</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>最外层，Node.js 为我们的代码包裹了这样一个函数，这个函数传入了几个参数，我来解释一下：</p>\n<ul>\n<li>exports ：用于在当前模块中加载和使用别的模块，传入一个模块名，返回一个模块导出对象。</li>\n<li>require：当前模块的导出对象，用于导出模块公有方法和属性。</li>\n<li>module：访问到当前模块的一些相关信息，但最多的用途是替换当前模块的导出对象。</li>\n<li>__filename：当前模块的文件名</li>\n<li>__dirname：当前模块的目录名</li>\n</ul>\n<h4 id=\"模块分类\"><a href=\"#模块分类\" class=\"headerlink\" title=\"模块分类\"></a>模块分类</h4><p>Node.js 提供两种模块类型：</p>\n<ol>\n<li>核心模块：是由 Node.js 平台提供的模块，也可以称为“系统模块”。</li>\n<li>文件模块：以 <code>..</code> 或 <code>.</code> 和 <code>/</code> 开始的标识符，这里都被当做文件模块来处理。</li>\n</ol>\n<h4 id=\"node-modules-文件夹\"><a href=\"#node-modules-文件夹\" class=\"headerlink\" title=\"node_modules 文件夹\"></a>node_modules 文件夹</h4><p>该文件夹是 Node.js 中的特殊文件夹，用来存放 node 模块，如果一个模块既不是系统模块，也不是文件模块，那么它会被存放在 node_modules 文件夹中。使用 <code>console.log(module.paths);</code> 可以打印 Node.js 会遍历的 node_modules 目录。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ <span class=\"string\">'/Users/wangmingming/Documents/Projects/JSstudy/12.26/node_modules'</span>,</span><br><span class=\"line\">  <span class=\"string\">'/Users/wangmingming/Documents/Projects/JSstudy/node_modules'</span>,</span><br><span class=\"line\">  <span class=\"string\">'/Users/wangmingming/Documents/Projects/node_modules'</span>,</span><br><span class=\"line\">  <span class=\"string\">'/Users/wangmingming/Documents/node_modules'</span>,</span><br><span class=\"line\">  <span class=\"string\">'/Users/wangmingming/node_modules'</span>,</span><br><span class=\"line\">  <span class=\"string\">'/Users/node_modules'</span>,</span><br><span class=\"line\">  <span class=\"string\">'/node_modules'</span> ]</span><br></pre></td></tr></table></figure></p>\n<div class=\"tip\"><br>在调用一个模块时，Node.js 沿路径向上逐级递归，直到根目录下的 node_modules 目录。CommonJS 模规范也允许在标识符中不包含文件扩展名，这种情况下，Node 会按 js、json、node 的次序补足扩展名，依次尝试。<br></div>\n\n<h3 id=\"包-Package\"><a href=\"#包-Package\" class=\"headerlink\" title=\"包 (Package)\"></a>包 (Package)</h3><p>把由多个子模块组成的大模块称做包，并把所有子模块放在同一个目录里。在一个包中，会用 <code>package.json</code> 文件中的 <code>main</code> 属性用来描述这个包的主文件。</p>\n<h4 id=\"NPM-Node-Package-Manager\"><a href=\"#NPM-Node-Package-Manager\" class=\"headerlink\" title=\"NPM (Node Package Manager)\"></a>NPM (Node Package Manager)</h4><p>大名鼎鼎的 NPM 实际上就是用来管理包的一个工具，借助 NPM 我们可以快速的安装和管理依赖包。下面是我整理的 npm 常用命令。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm init                   <span class=\"comment\">#  初始化包，要求填入包名等信息</span></span><br><span class=\"line\">npm install &lt;name&gt;         <span class=\"comment\">#  本地安装一个包</span></span><br><span class=\"line\">npm install &lt;name&gt; -g      <span class=\"comment\">#  全局安装一个包</span></span><br><span class=\"line\">npm install &lt;name&gt; --save  <span class=\"comment\">#  本地安装并写入 package.json 依赖中</span></span><br><span class=\"line\">npm remove &lt;name&gt;          <span class=\"comment\">#  移除</span></span><br><span class=\"line\">npm update &lt;name&gt;          <span class=\"comment\">#  更新</span></span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>本地安装：将安装包放在 <code>./node_modules</code> 下（运行 npm 命令时所在的目录），如果没有 node_modules 目录，会在当前执行 npm 命令的目录下生成 node_modules 目录。可以通过 <code>require()</code> 来引入本地安装的包。</li>\n<li>全局安装：将安装包放在 <code>/usr/local</code> 下或者你 node 的安装目录，可以直接在命令行里使用。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>整理记录 Node.js 学习笔记，作为前端人员，非常有必要了解后端的一些知识，方便与后端的同事协作，提高效率，搞好前端后，也可以尝试往后端发展，成为一名全栈工程师！:P<br>","more":"<br><img src=\"http://ww4.sinaimg.cn/mw690/6057861cgw1fb6vlzd7i7j20go08cjro.jpg\" alt=\"\"></p>\n<h3 id=\"Node-js-介绍\"><a href=\"#Node-js-介绍\" class=\"headerlink\" title=\"Node.js 介绍\"></a>Node.js 介绍</h3><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。Node.js 的包管理器 npm，是全球最大的开源库生态系统。</p>\n<h4 id=\"Node-js-和-JavaScript-的区别\"><a href=\"#Node-js-和-JavaScript-的区别\" class=\"headerlink\" title=\"Node.js 和 JavaScript 的区别\"></a>Node.js 和 JavaScript 的区别</h4><ul>\n<li>Node.js 是一个可以运行 JavaScript 的平台，基于 ChromeV8 引擎，是对 JavaScript 的增强，使 JavaScript 具备了服务器语言的开发能力，比如操作文件、读取系统信息、网络传输等。</li>\n<li>JavaScript 是一门编程语言，只要有 JavaScript 引擎就能运行并且如果 JavaScript 运行在浏览器中，浏览器对 JavaScript 加入了浏览器和文档操作的接口（方法）。</li>\n</ul>\n<div class=\"tip\"><br>简单理解：浏览器中 JavaScript 主要是操作 BOM 和 DOM，而 Node.js 则是具有服务端语言处理能力（处理网络请求，保存数据到数据库等）。<br></div>\n\n<h4 id=\"官方网站\"><a href=\"#官方网站\" class=\"headerlink\" title=\"官方网站\"></a>官方网站</h4><ul>\n<li>英文社区： <a href=\"https://www.npmjs.com/\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/</a></li>\n<li>中文社区：<a href=\"http://cnodejs.org/\" target=\"_blank\" rel=\"noopener\">http://cnodejs.org/</a></li>\n</ul>\n<h4 id=\"Node-js-安装及运行\"><a href=\"#Node-js-安装及运行\" class=\"headerlink\" title=\"Node.js 安装及运行\"></a>Node.js 安装及运行</h4><p>在 Node.js 的官方提供的<a href=\"https://nodejs.org/en/download/\" target=\"_blank\" rel=\"noopener\">下载频道</a>选择对应的平台及安装程序安装即可。Node.js 提供了 <code>REPL（Read-Evaluate-Print-Loop）</code> 模式，即 <strong><em>交互式命令行解析器</em></strong>，可以直接输入命令行，编写 Node.js 代码。安装成功后，我们可以在终端里输入 <code>node -v</code> 获取当前的 Node.js 版本号，能获取表示成功安装。</p>\n<h3 id=\"Node-js-模块\"><a href=\"#Node-js-模块\" class=\"headerlink\" title=\"Node.js 模块\"></a>Node.js 模块</h3><p>模块对于 Node.js 来说是一个非常重要的概念，一个特定功能的文件就是一个模块。模块之间可能会存在一定的依赖关系，比如我写了一个 jQuery 轮播的插件，它就依赖 jQuery 库，在 Node.js 中可以非常方便的表示清楚这种依赖关系。说到模块，还需要说一个就是编写模块的规范。</p>\n<h4 id=\"模块规范\"><a href=\"#模块规范\" class=\"headerlink\" title=\"模块规范\"></a>模块规范</h4><ul>\n<li><strong><em>AMD</em></strong> (Asynchronous Module Definition)，这种规范是异步的加载模块，RequireR.js 应用了这一规范,适合客户端浏览器环境。</li>\n<li><strong><em>CMD</em></strong> (Common Module Definition), 是 Sea.js 推崇的规范。</li>\n<li><strong><em>CommonJS</em></strong> , 是诞生比较早的。Node.js 就采用了 CommonJS 的规范来定义模块。但是 CommonJs 采用的是同步加载文件方式，只适用于服务端（Node.js 平台）。</li>\n</ul>\n<h4 id=\"使用模块\"><a href=\"#使用模块\" class=\"headerlink\" title=\"使用模块\"></a>使用模块</h4><p>模块定义完成后，就可以使用模块，通过命令行参数传递给 Node.js 以启动程序的模块被称为 <strong><em>主模块</em></strong>。主模块负责调度组成整个程序的其它模块完成工作。其实就类似网站中的 <code>index.html</code>，Node.js 中的主模块通常是 <code>main.js</code> 或者 <code>index.js</code>。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);<span class=\"comment\">// 通过 require 引入 http 模块</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"模块组成\"><a href=\"#模块组成\" class=\"headerlink\" title=\"模块组成\"></a>模块组成</h4><p>在上条命令中，我们通过 require 引入了一个 http 模块，实际上作为一个单独的模块文件，Node.js 为我们在外层嵌套了一个函数，正因为有了这个函数，在这个文件中声明的变量就是私有变量啦，那么每个模块之间就不会产生干扰了。那么来看看这个函数长什么样子。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">exports, require, module, __filename, __dirname</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);<span class=\"comment\">// 通过 require 引入 http 模块</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>最外层，Node.js 为我们的代码包裹了这样一个函数，这个函数传入了几个参数，我来解释一下：</p>\n<ul>\n<li>exports ：用于在当前模块中加载和使用别的模块，传入一个模块名，返回一个模块导出对象。</li>\n<li>require：当前模块的导出对象，用于导出模块公有方法和属性。</li>\n<li>module：访问到当前模块的一些相关信息，但最多的用途是替换当前模块的导出对象。</li>\n<li>__filename：当前模块的文件名</li>\n<li>__dirname：当前模块的目录名</li>\n</ul>\n<h4 id=\"模块分类\"><a href=\"#模块分类\" class=\"headerlink\" title=\"模块分类\"></a>模块分类</h4><p>Node.js 提供两种模块类型：</p>\n<ol>\n<li>核心模块：是由 Node.js 平台提供的模块，也可以称为“系统模块”。</li>\n<li>文件模块：以 <code>..</code> 或 <code>.</code> 和 <code>/</code> 开始的标识符，这里都被当做文件模块来处理。</li>\n</ol>\n<h4 id=\"node-modules-文件夹\"><a href=\"#node-modules-文件夹\" class=\"headerlink\" title=\"node_modules 文件夹\"></a>node_modules 文件夹</h4><p>该文件夹是 Node.js 中的特殊文件夹，用来存放 node 模块，如果一个模块既不是系统模块，也不是文件模块，那么它会被存放在 node_modules 文件夹中。使用 <code>console.log(module.paths);</code> 可以打印 Node.js 会遍历的 node_modules 目录。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ <span class=\"string\">'/Users/wangmingming/Documents/Projects/JSstudy/12.26/node_modules'</span>,</span><br><span class=\"line\">  <span class=\"string\">'/Users/wangmingming/Documents/Projects/JSstudy/node_modules'</span>,</span><br><span class=\"line\">  <span class=\"string\">'/Users/wangmingming/Documents/Projects/node_modules'</span>,</span><br><span class=\"line\">  <span class=\"string\">'/Users/wangmingming/Documents/node_modules'</span>,</span><br><span class=\"line\">  <span class=\"string\">'/Users/wangmingming/node_modules'</span>,</span><br><span class=\"line\">  <span class=\"string\">'/Users/node_modules'</span>,</span><br><span class=\"line\">  <span class=\"string\">'/node_modules'</span> ]</span><br></pre></td></tr></table></figure></p>\n<div class=\"tip\"><br>在调用一个模块时，Node.js 沿路径向上逐级递归，直到根目录下的 node_modules 目录。CommonJS 模规范也允许在标识符中不包含文件扩展名，这种情况下，Node 会按 js、json、node 的次序补足扩展名，依次尝试。<br></div>\n\n<h3 id=\"包-Package\"><a href=\"#包-Package\" class=\"headerlink\" title=\"包 (Package)\"></a>包 (Package)</h3><p>把由多个子模块组成的大模块称做包，并把所有子模块放在同一个目录里。在一个包中，会用 <code>package.json</code> 文件中的 <code>main</code> 属性用来描述这个包的主文件。</p>\n<h4 id=\"NPM-Node-Package-Manager\"><a href=\"#NPM-Node-Package-Manager\" class=\"headerlink\" title=\"NPM (Node Package Manager)\"></a>NPM (Node Package Manager)</h4><p>大名鼎鼎的 NPM 实际上就是用来管理包的一个工具，借助 NPM 我们可以快速的安装和管理依赖包。下面是我整理的 npm 常用命令。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm init                   <span class=\"comment\">#  初始化包，要求填入包名等信息</span></span><br><span class=\"line\">npm install &lt;name&gt;         <span class=\"comment\">#  本地安装一个包</span></span><br><span class=\"line\">npm install &lt;name&gt; -g      <span class=\"comment\">#  全局安装一个包</span></span><br><span class=\"line\">npm install &lt;name&gt; --save  <span class=\"comment\">#  本地安装并写入 package.json 依赖中</span></span><br><span class=\"line\">npm remove &lt;name&gt;          <span class=\"comment\">#  移除</span></span><br><span class=\"line\">npm update &lt;name&gt;          <span class=\"comment\">#  更新</span></span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>本地安装：将安装包放在 <code>./node_modules</code> 下（运行 npm 命令时所在的目录），如果没有 node_modules 目录，会在当前执行 npm 命令的目录下生成 node_modules 目录。可以通过 <code>require()</code> 来引入本地安装的包。</li>\n<li>全局安装：将安装包放在 <code>/usr/local</code> 下或者你 node 的安装目录，可以直接在命令行里使用。</li>\n</ul>"},{"title":"Node.JS 学习笔记 [02] -- 同步异步","date":"2015-01-03T00:27:02.000Z","comments":0,"_content":"\n在使用 npm 的时候，我发现在速度实在太慢，安装小一点的包确实没啥问题，装大一点的，依赖多一点的包的时候，问题就来了。速度慢，响应迟钝。***nrm*** 是一个非常好的解决方案，安装 nrm 后，可以使用简单的命令快速来切换 npm 源，比如切换到 cnpm、taobao 源等，详细的使用方法可以点[这里](https://github.com/Pana/nrm#install)进去了解下。\n<!-- more -->\n### Node.js 使用\n\n#### Node.js 控制台\n前面说了，Node.js 提供了 REPL 模式来解析输入的每条命令，现在可以实战一下了，打开终端，然后输入 `node` 进入 Node.js 开始敲命令吧！\n```js\nconsole.log('hello,world!'); // 普通输入\nconsole.error('错误消息');    // 错误输出\nconsole.time('time');        // 会计算在这个表达式之间的代码块执行耗时\n// {...}\nconsole.time('time');\nconsole.assert(3>10,'str..');// 断言：表达式不成立，会输出后面的字符串\n```\n\n#### Node.js 作用域\n- 全局作用域：没有使用 `var` 隐式声明的一个变量，会享受全局作用域，或者在 `global` 上挂载的变量，也具有全局作用域的属性，全局变量可以被其它模块使用。\n- 局部作用域：在 Node.js 中一个文件就是一个模块，在这个模块中定义的变量，只能在这个模块中使用。\n\n```js\n// 这些变量都属于全局变量\nname = 'ifyour';\nglobal.age = 18; // Node.js 中的 global 类似 JavaScript 中的 window\n```\n<div class='tip'>\n尽量避免使用全局变量，会造成变量污染。\n</div>\n\n#### 回调函数\nNode.js 中大量使用了回调函数，关于回调函数，我之前在简书写了一篇，我的理解心得，有兴趣的可以[去看看](http://www.jianshu.com/p/1383f4cb9a75)。关于回调函数，我也正是在 Node.js 中对它的理解更为深刻了，Node.js 大量的异步代码都借助回调函数实现，正因如此，性能更高呀。看一个非常简单的例子。\n\n```js\n// 定义回调函数\nfunction cb(){\n  console.log('Hello,callback!');\n}\n\n// 把回调函数的引用（指针）传入该函数，一秒后执行\nsetTimeout(cb,1000);\n```\n借助这个例子，可以看到回调函数的实现机制：\n- 定义一个普通函数（其实它就是回调函数）\n- 将该函数的引用地址作为参数传给调用者，调用者本身也是一个函数，例子中的 `setTimeout`\n- 当特定条件发生时，调用者使用这个引用地址去执行该函数\n\n回调函数的用途很多，比如实现事件注册、异步代码等。在 jQuery 中的动画就是回调函数的经典用法，`animate(x,y,z,function(){...})`,当一个动画执行完成后，执行回调函数。当点击一个按钮时，需要执行的函数块，这些都是回调函数。\n\n### Node.js 事件\nNode.js 中的 event 模块就是提供事件编程的 API，所有具有触发事件的对象都继承或内部包含了 `EventEmitter` 对象。来一个简单的例子吧！\n```js\n//events 模块中的 EventEmitter 对象，定义了事件对象的基础信息和行为\nvar EventEmitter = require('events').EventEmitter;\nvar event = new EventEmitter();// 实例化一个 event 对象\nevent.on('myevent',function(name){ // 绑定 myevent 事件\n    console.log('Hi!' + name);\n});\nevent.emit('myevent','ifyour');// 触发事件\n```\n#### 事件常用方法\n\n|方法                               | 描述                                                     |\n|:---------------------------------|:---------------------------------------------------------|\n|addListener(event, listener)      | 为指定事件添加一个监听器到监听器数组的尾部。与 on 等价          |\n|on(event, listener)               | 为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数 |\n|once(event, listener)             | 为指定事件注册一个单次监听器                                |\n|removeListener(event,listener)    |移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器  |\n|removeAllListeners([event])       |移除所有事件的所有监听器如果指定事件，则移除该事件的所有监听器  |\n|setMaxListeners(n)                |setMaxListeners 函数用于提高监听器的默认限制的数量，默认是 10 |\n|listeners(event)                  |返回指定事件的监听器数组                                    |\n|emit(event, [arg1], [arg2], [...])|按顺序执行监听器，如果事件有注册监听返回 true，否则返回 false |\n\n\n### Node.js 异步与同步\n\n***同步***：一个任务执行完成后，才能执行下一个任务，执行总时间等于所有任务消耗时间之和。\n***异步***：几个任务同时执行，不限制先后，执行总时间等于执行耗时最长的那个任务的消耗时间。\n\n在 Node.js 中每一个任务有一个或多个回调函数，前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。\n\n#### 异步的实现\n- 回调函数\n- 事件（基于回调函数）\n- Promise （ES6）\n\n前面已经讲了回调函数的实现方式，下面举两个例子来说明 Node.js 中 ***事件*** 和 ***Promise*** 实现异步。\n```js\n// 事件（基于回调函数）实现异步\nvar fs = require('fs');\n\nvar stream = fs.createReadStream('./data');// 调用 fs 模块创建一个读取流对象\nstream.on('data',getData);// 读取事件，每次读取时触发调用回调函数 getData\nstream.on('end',getDataDone);// 读取完毕调用回调函数 getDataDone\n\nfunction getDataDone() {\n    console.log('read done!');\n}\nfunction getData(data) {\n    console.log(data.toString());\n}\n```\n上面的代码中，当读取多个 `data` 文件时，输出的内容的顺序可能不一致，因为事件采用回调函数实现了异步操作。可以看出，事件实现异步，本质上还是回调函数。\n\n> 所谓 Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。\n\n下面来看看 `Promise` 的一个实例：\n```js\nvar fs = require('fs');\n\nvar p = new Promise(function (resolve, reject) {// 使用 Promise 生成实例\n    fs.readFile('./1', 'utf-8', function (err, data) {// readFile 是一个异步方法\n        if (!err) {\n            resolve(data);\n        } else {\n            reject(err);\n        }\n    })\n});\n\np.then(function (data) {// 调用实例的 then 方法\n    console.log(data);\n}, function (err) {\n    console.log(err);\n});\n```\nES6 规定，Promise 对象是一个构造函数，用来生成 Promise 实例。Promise 构造函数接受一个函数作为参数，该函数的两个参数分别是 `resolve` 和 `reject`。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。\n\n- resolve : 在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；\n- reject  : 在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。\n\nPromise 实例生成以后，可以用 `then` 方法分别指定 Resolved 状态和 Reject 状态的回调函数。\n```js\npromise.then(function(value) {\n  // success\n}, function(error) {\n  // failure\n});\n```\n有了 Promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise 对象提供统一的接口，使得控制异步操作更加容易。\n\n下面这个例子，在未使用 `Promise` 时，我们想要 `p1` 读取完数据后，紧接着 `p2` 、`p3` 读取，就需要在 `p1` 的回调读取成功函数里继续写 `p2` 的读取，类似的 `p3` 也要在 `p2` 的回调函数中写，这就造成了 ***层层嵌套*** 不利于代码阅读。而使用 `Promise` 后，`then` 方法把里面的回调函数统一提取出来， 可读性更好了，也方便理解。\n```js\n// Promise 提供的 then 方法避免层次嵌套，相当于实现 then 的链式操作\n// p1 执行完 then 方法后，通过 return p2 ，让 p2 继续执行 then 方法\np1.then(function(data){\n    console.log(data);\n    return p2;\n},function(err){\n    console.log(err);\n    return p2;\n}).then(function(data){\n    console.log(data);\n    return p3;\n},function(err){\n    console.log(err);\n    return p3;\n}).then(function(data){\n    console.log(data);\n},function(){\n    console.log(err);\n});\n```\n更多 Promise 语法，可以参考阮一峰的《[ECMAScript 6 入门](http://es6.ruanyifeng.com/#docs/promise#基本用法)》。\n","source":"_posts/Node.JS-学习笔记-[02]----同步异步.md","raw":"---\ntitle: 'Node.JS 学习笔记 [02] -- 同步异步'\ndate: 2015-1-3 08:27:02\ncomments: false\n---\n\n在使用 npm 的时候，我发现在速度实在太慢，安装小一点的包确实没啥问题，装大一点的，依赖多一点的包的时候，问题就来了。速度慢，响应迟钝。***nrm*** 是一个非常好的解决方案，安装 nrm 后，可以使用简单的命令快速来切换 npm 源，比如切换到 cnpm、taobao 源等，详细的使用方法可以点[这里](https://github.com/Pana/nrm#install)进去了解下。\n<!-- more -->\n### Node.js 使用\n\n#### Node.js 控制台\n前面说了，Node.js 提供了 REPL 模式来解析输入的每条命令，现在可以实战一下了，打开终端，然后输入 `node` 进入 Node.js 开始敲命令吧！\n```js\nconsole.log('hello,world!'); // 普通输入\nconsole.error('错误消息');    // 错误输出\nconsole.time('time');        // 会计算在这个表达式之间的代码块执行耗时\n// {...}\nconsole.time('time');\nconsole.assert(3>10,'str..');// 断言：表达式不成立，会输出后面的字符串\n```\n\n#### Node.js 作用域\n- 全局作用域：没有使用 `var` 隐式声明的一个变量，会享受全局作用域，或者在 `global` 上挂载的变量，也具有全局作用域的属性，全局变量可以被其它模块使用。\n- 局部作用域：在 Node.js 中一个文件就是一个模块，在这个模块中定义的变量，只能在这个模块中使用。\n\n```js\n// 这些变量都属于全局变量\nname = 'ifyour';\nglobal.age = 18; // Node.js 中的 global 类似 JavaScript 中的 window\n```\n<div class='tip'>\n尽量避免使用全局变量，会造成变量污染。\n</div>\n\n#### 回调函数\nNode.js 中大量使用了回调函数，关于回调函数，我之前在简书写了一篇，我的理解心得，有兴趣的可以[去看看](http://www.jianshu.com/p/1383f4cb9a75)。关于回调函数，我也正是在 Node.js 中对它的理解更为深刻了，Node.js 大量的异步代码都借助回调函数实现，正因如此，性能更高呀。看一个非常简单的例子。\n\n```js\n// 定义回调函数\nfunction cb(){\n  console.log('Hello,callback!');\n}\n\n// 把回调函数的引用（指针）传入该函数，一秒后执行\nsetTimeout(cb,1000);\n```\n借助这个例子，可以看到回调函数的实现机制：\n- 定义一个普通函数（其实它就是回调函数）\n- 将该函数的引用地址作为参数传给调用者，调用者本身也是一个函数，例子中的 `setTimeout`\n- 当特定条件发生时，调用者使用这个引用地址去执行该函数\n\n回调函数的用途很多，比如实现事件注册、异步代码等。在 jQuery 中的动画就是回调函数的经典用法，`animate(x,y,z,function(){...})`,当一个动画执行完成后，执行回调函数。当点击一个按钮时，需要执行的函数块，这些都是回调函数。\n\n### Node.js 事件\nNode.js 中的 event 模块就是提供事件编程的 API，所有具有触发事件的对象都继承或内部包含了 `EventEmitter` 对象。来一个简单的例子吧！\n```js\n//events 模块中的 EventEmitter 对象，定义了事件对象的基础信息和行为\nvar EventEmitter = require('events').EventEmitter;\nvar event = new EventEmitter();// 实例化一个 event 对象\nevent.on('myevent',function(name){ // 绑定 myevent 事件\n    console.log('Hi!' + name);\n});\nevent.emit('myevent','ifyour');// 触发事件\n```\n#### 事件常用方法\n\n|方法                               | 描述                                                     |\n|:---------------------------------|:---------------------------------------------------------|\n|addListener(event, listener)      | 为指定事件添加一个监听器到监听器数组的尾部。与 on 等价          |\n|on(event, listener)               | 为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数 |\n|once(event, listener)             | 为指定事件注册一个单次监听器                                |\n|removeListener(event,listener)    |移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器  |\n|removeAllListeners([event])       |移除所有事件的所有监听器如果指定事件，则移除该事件的所有监听器  |\n|setMaxListeners(n)                |setMaxListeners 函数用于提高监听器的默认限制的数量，默认是 10 |\n|listeners(event)                  |返回指定事件的监听器数组                                    |\n|emit(event, [arg1], [arg2], [...])|按顺序执行监听器，如果事件有注册监听返回 true，否则返回 false |\n\n\n### Node.js 异步与同步\n\n***同步***：一个任务执行完成后，才能执行下一个任务，执行总时间等于所有任务消耗时间之和。\n***异步***：几个任务同时执行，不限制先后，执行总时间等于执行耗时最长的那个任务的消耗时间。\n\n在 Node.js 中每一个任务有一个或多个回调函数，前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。\n\n#### 异步的实现\n- 回调函数\n- 事件（基于回调函数）\n- Promise （ES6）\n\n前面已经讲了回调函数的实现方式，下面举两个例子来说明 Node.js 中 ***事件*** 和 ***Promise*** 实现异步。\n```js\n// 事件（基于回调函数）实现异步\nvar fs = require('fs');\n\nvar stream = fs.createReadStream('./data');// 调用 fs 模块创建一个读取流对象\nstream.on('data',getData);// 读取事件，每次读取时触发调用回调函数 getData\nstream.on('end',getDataDone);// 读取完毕调用回调函数 getDataDone\n\nfunction getDataDone() {\n    console.log('read done!');\n}\nfunction getData(data) {\n    console.log(data.toString());\n}\n```\n上面的代码中，当读取多个 `data` 文件时，输出的内容的顺序可能不一致，因为事件采用回调函数实现了异步操作。可以看出，事件实现异步，本质上还是回调函数。\n\n> 所谓 Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。\n\n下面来看看 `Promise` 的一个实例：\n```js\nvar fs = require('fs');\n\nvar p = new Promise(function (resolve, reject) {// 使用 Promise 生成实例\n    fs.readFile('./1', 'utf-8', function (err, data) {// readFile 是一个异步方法\n        if (!err) {\n            resolve(data);\n        } else {\n            reject(err);\n        }\n    })\n});\n\np.then(function (data) {// 调用实例的 then 方法\n    console.log(data);\n}, function (err) {\n    console.log(err);\n});\n```\nES6 规定，Promise 对象是一个构造函数，用来生成 Promise 实例。Promise 构造函数接受一个函数作为参数，该函数的两个参数分别是 `resolve` 和 `reject`。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。\n\n- resolve : 在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；\n- reject  : 在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。\n\nPromise 实例生成以后，可以用 `then` 方法分别指定 Resolved 状态和 Reject 状态的回调函数。\n```js\npromise.then(function(value) {\n  // success\n}, function(error) {\n  // failure\n});\n```\n有了 Promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise 对象提供统一的接口，使得控制异步操作更加容易。\n\n下面这个例子，在未使用 `Promise` 时，我们想要 `p1` 读取完数据后，紧接着 `p2` 、`p3` 读取，就需要在 `p1` 的回调读取成功函数里继续写 `p2` 的读取，类似的 `p3` 也要在 `p2` 的回调函数中写，这就造成了 ***层层嵌套*** 不利于代码阅读。而使用 `Promise` 后，`then` 方法把里面的回调函数统一提取出来， 可读性更好了，也方便理解。\n```js\n// Promise 提供的 then 方法避免层次嵌套，相当于实现 then 的链式操作\n// p1 执行完 then 方法后，通过 return p2 ，让 p2 继续执行 then 方法\np1.then(function(data){\n    console.log(data);\n    return p2;\n},function(err){\n    console.log(err);\n    return p2;\n}).then(function(data){\n    console.log(data);\n    return p3;\n},function(err){\n    console.log(err);\n    return p3;\n}).then(function(data){\n    console.log(data);\n},function(){\n    console.log(err);\n});\n```\n更多 Promise 语法，可以参考阮一峰的《[ECMAScript 6 入门](http://es6.ruanyifeng.com/#docs/promise#基本用法)》。\n","slug":"Node.JS-学习笔记-[02]----同步异步","published":1,"updated":"2019-12-07T04:59:34.071Z","layout":"post","photos":[],"link":"","_id":"ck3v60jtd000br9q9qdnxvxhf","content":"<p>在使用 npm 的时候，我发现在速度实在太慢，安装小一点的包确实没啥问题，装大一点的，依赖多一点的包的时候，问题就来了。速度慢，响应迟钝。<strong><em>nrm</em></strong> 是一个非常好的解决方案，安装 nrm 后，可以使用简单的命令快速来切换 npm 源，比如切换到 cnpm、taobao 源等，详细的使用方法可以点<a href=\"https://github.com/Pana/nrm#install\" target=\"_blank\" rel=\"noopener\">这里</a>进去了解下。<br><a id=\"more\"></a></p>\n<h3 id=\"Node-js-使用\"><a href=\"#Node-js-使用\" class=\"headerlink\" title=\"Node.js 使用\"></a>Node.js 使用</h3><h4 id=\"Node-js-控制台\"><a href=\"#Node-js-控制台\" class=\"headerlink\" title=\"Node.js 控制台\"></a>Node.js 控制台</h4><p>前面说了，Node.js 提供了 REPL 模式来解析输入的每条命令，现在可以实战一下了，打开终端，然后输入 <code>node</code> 进入 Node.js 开始敲命令吧！<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'hello,world!'</span>); <span class=\"comment\">// 普通输入</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.error(<span class=\"string\">'错误消息'</span>);    <span class=\"comment\">// 错误输出</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.time(<span class=\"string\">'time'</span>);        <span class=\"comment\">// 会计算在这个表达式之间的代码块执行耗时</span></span><br><span class=\"line\"><span class=\"comment\">// &#123;...&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.time(<span class=\"string\">'time'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.assert(<span class=\"number\">3</span>&gt;<span class=\"number\">10</span>,<span class=\"string\">'str..'</span>);<span class=\"comment\">// 断言：表达式不成立，会输出后面的字符串</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Node-js-作用域\"><a href=\"#Node-js-作用域\" class=\"headerlink\" title=\"Node.js 作用域\"></a>Node.js 作用域</h4><ul>\n<li>全局作用域：没有使用 <code>var</code> 隐式声明的一个变量，会享受全局作用域，或者在 <code>global</code> 上挂载的变量，也具有全局作用域的属性，全局变量可以被其它模块使用。</li>\n<li>局部作用域：在 Node.js 中一个文件就是一个模块，在这个模块中定义的变量，只能在这个模块中使用。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这些变量都属于全局变量</span></span><br><span class=\"line\">name = <span class=\"string\">'ifyour'</span>;</span><br><span class=\"line\">global.age = <span class=\"number\">18</span>; <span class=\"comment\">// Node.js 中的 global 类似 JavaScript 中的 window</span></span><br></pre></td></tr></table></figure>\n<div class=\"tip\"><br>尽量避免使用全局变量，会造成变量污染。<br></div>\n\n<h4 id=\"回调函数\"><a href=\"#回调函数\" class=\"headerlink\" title=\"回调函数\"></a>回调函数</h4><p>Node.js 中大量使用了回调函数，关于回调函数，我之前在简书写了一篇，我的理解心得，有兴趣的可以<a href=\"http://www.jianshu.com/p/1383f4cb9a75\" target=\"_blank\" rel=\"noopener\">去看看</a>。关于回调函数，我也正是在 Node.js 中对它的理解更为深刻了，Node.js 大量的异步代码都借助回调函数实现，正因如此，性能更高呀。看一个非常简单的例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义回调函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">cb</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hello,callback!'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 把回调函数的引用（指针）传入该函数，一秒后执行</span></span><br><span class=\"line\">setTimeout(cb,<span class=\"number\">1000</span>);</span><br></pre></td></tr></table></figure>\n<p>借助这个例子，可以看到回调函数的实现机制：</p>\n<ul>\n<li>定义一个普通函数（其实它就是回调函数）</li>\n<li>将该函数的引用地址作为参数传给调用者，调用者本身也是一个函数，例子中的 <code>setTimeout</code></li>\n<li>当特定条件发生时，调用者使用这个引用地址去执行该函数</li>\n</ul>\n<p>回调函数的用途很多，比如实现事件注册、异步代码等。在 jQuery 中的动画就是回调函数的经典用法，<code>animate(x,y,z,function(){...})</code>,当一个动画执行完成后，执行回调函数。当点击一个按钮时，需要执行的函数块，这些都是回调函数。</p>\n<h3 id=\"Node-js-事件\"><a href=\"#Node-js-事件\" class=\"headerlink\" title=\"Node.js 事件\"></a>Node.js 事件</h3><p>Node.js 中的 event 模块就是提供事件编程的 API，所有具有触发事件的对象都继承或内部包含了 <code>EventEmitter</code> 对象。来一个简单的例子吧！<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//events 模块中的 EventEmitter 对象，定义了事件对象的基础信息和行为</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> EventEmitter = <span class=\"built_in\">require</span>(<span class=\"string\">'events'</span>).EventEmitter;</span><br><span class=\"line\"><span class=\"keyword\">var</span> event = <span class=\"keyword\">new</span> EventEmitter();<span class=\"comment\">// 实例化一个 event 对象</span></span><br><span class=\"line\">event.on(<span class=\"string\">'myevent'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>)</span>&#123; <span class=\"comment\">// 绑定 myevent 事件</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hi!'</span> + name);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">event.emit(<span class=\"string\">'myevent'</span>,<span class=\"string\">'ifyour'</span>);<span class=\"comment\">// 触发事件</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"事件常用方法\"><a href=\"#事件常用方法\" class=\"headerlink\" title=\"事件常用方法\"></a>事件常用方法</h4><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">方法</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">addListener(event, listener)</td>\n<td style=\"text-align:left\">为指定事件添加一个监听器到监听器数组的尾部。与 on 等价</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">on(event, listener)</td>\n<td style=\"text-align:left\">为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">once(event, listener)</td>\n<td style=\"text-align:left\">为指定事件注册一个单次监听器</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">removeListener(event,listener)</td>\n<td style=\"text-align:left\">移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">removeAllListeners([event])</td>\n<td style=\"text-align:left\">移除所有事件的所有监听器如果指定事件，则移除该事件的所有监听器</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">setMaxListeners(n)</td>\n<td style=\"text-align:left\">setMaxListeners 函数用于提高监听器的默认限制的数量，默认是 10</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">listeners(event)</td>\n<td style=\"text-align:left\">返回指定事件的监听器数组</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">emit(event, [arg1], [arg2], […])</td>\n<td style=\"text-align:left\">按顺序执行监听器，如果事件有注册监听返回 true，否则返回 false</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Node-js-异步与同步\"><a href=\"#Node-js-异步与同步\" class=\"headerlink\" title=\"Node.js 异步与同步\"></a>Node.js 异步与同步</h3><p><strong><em>同步</em></strong>：一个任务执行完成后，才能执行下一个任务，执行总时间等于所有任务消耗时间之和。<br><strong><em>异步</em></strong>：几个任务同时执行，不限制先后，执行总时间等于执行耗时最长的那个任务的消耗时间。</p>\n<p>在 Node.js 中每一个任务有一个或多个回调函数，前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。</p>\n<h4 id=\"异步的实现\"><a href=\"#异步的实现\" class=\"headerlink\" title=\"异步的实现\"></a>异步的实现</h4><ul>\n<li>回调函数</li>\n<li>事件（基于回调函数）</li>\n<li>Promise （ES6）</li>\n</ul>\n<p>前面已经讲了回调函数的实现方式，下面举两个例子来说明 Node.js 中 <strong><em>事件</em></strong> 和 <strong><em>Promise</em></strong> 实现异步。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 事件（基于回调函数）实现异步</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> stream = fs.createReadStream(<span class=\"string\">'./data'</span>);<span class=\"comment\">// 调用 fs 模块创建一个读取流对象</span></span><br><span class=\"line\">stream.on(<span class=\"string\">'data'</span>,getData);<span class=\"comment\">// 读取事件，每次读取时触发调用回调函数 getData</span></span><br><span class=\"line\">stream.on(<span class=\"string\">'end'</span>,getDataDone);<span class=\"comment\">// 读取完毕调用回调函数 getDataDone</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getDataDone</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'read done!'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getData</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data.toString());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面的代码中，当读取多个 <code>data</code> 文件时，输出的内容的顺序可能不一致，因为事件采用回调函数实现了异步操作。可以看出，事件实现异步，本质上还是回调函数。</p>\n<blockquote>\n<p>所谓 Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。</p>\n</blockquote>\n<p>下面来看看 <code>Promise</code> 的一个实例：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;<span class=\"comment\">// 使用 Promise 生成实例</span></span><br><span class=\"line\">    fs.readFile(<span class=\"string\">'./1'</span>, <span class=\"string\">'utf-8'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, data</span>) </span>&#123;<span class=\"comment\">// readFile 是一个异步方法</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!err) &#123;</span><br><span class=\"line\">            resolve(data);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            reject(err);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">p.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;<span class=\"comment\">// 调用实例的 then 方法</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>ES6 规定，Promise 对象是一个构造函数，用来生成 Promise 实例。Promise 构造函数接受一个函数作为参数，该函数的两个参数分别是 <code>resolve</code> 和 <code>reject</code>。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</p>\n<ul>\n<li>resolve : 在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；</li>\n<li>reject  : 在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</li>\n</ul>\n<p>Promise 实例生成以后，可以用 <code>then</code> 方法分别指定 Resolved 状态和 Reject 状态的回调函数。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// success</span></span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// failure</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>有了 Promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise 对象提供统一的接口，使得控制异步操作更加容易。</p>\n<p>下面这个例子，在未使用 <code>Promise</code> 时，我们想要 <code>p1</code> 读取完数据后，紧接着 <code>p2</code> 、<code>p3</code> 读取，就需要在 <code>p1</code> 的回调读取成功函数里继续写 <code>p2</code> 的读取，类似的 <code>p3</code> 也要在 <code>p2</code> 的回调函数中写，这就造成了 <strong><em>层层嵌套</em></strong> 不利于代码阅读。而使用 <code>Promise</code> 后，<code>then</code> 方法把里面的回调函数统一提取出来， 可读性更好了，也方便理解。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Promise 提供的 then 方法避免层次嵌套，相当于实现 then 的链式操作</span></span><br><span class=\"line\"><span class=\"comment\">// p1 执行完 then 方法后，通过 return p2 ，让 p2 继续执行 then 方法</span></span><br><span class=\"line\">p1.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p2;</span><br><span class=\"line\">&#125;,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p2;</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p3;</span><br><span class=\"line\">&#125;,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p3;</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">&#125;,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>更多 Promise 语法，可以参考阮一峰的《<a href=\"http://es6.ruanyifeng.com/#docs/promise#基本用法\" target=\"_blank\" rel=\"noopener\">ECMAScript 6 入门</a>》。</p>\n","site":{"data":{}},"excerpt":"<p>在使用 npm 的时候，我发现在速度实在太慢，安装小一点的包确实没啥问题，装大一点的，依赖多一点的包的时候，问题就来了。速度慢，响应迟钝。<strong><em>nrm</em></strong> 是一个非常好的解决方案，安装 nrm 后，可以使用简单的命令快速来切换 npm 源，比如切换到 cnpm、taobao 源等，详细的使用方法可以点<a href=\"https://github.com/Pana/nrm#install\" target=\"_blank\" rel=\"noopener\">这里</a>进去了解下。<br>","more":"</p>\n<h3 id=\"Node-js-使用\"><a href=\"#Node-js-使用\" class=\"headerlink\" title=\"Node.js 使用\"></a>Node.js 使用</h3><h4 id=\"Node-js-控制台\"><a href=\"#Node-js-控制台\" class=\"headerlink\" title=\"Node.js 控制台\"></a>Node.js 控制台</h4><p>前面说了，Node.js 提供了 REPL 模式来解析输入的每条命令，现在可以实战一下了，打开终端，然后输入 <code>node</code> 进入 Node.js 开始敲命令吧！<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'hello,world!'</span>); <span class=\"comment\">// 普通输入</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.error(<span class=\"string\">'错误消息'</span>);    <span class=\"comment\">// 错误输出</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.time(<span class=\"string\">'time'</span>);        <span class=\"comment\">// 会计算在这个表达式之间的代码块执行耗时</span></span><br><span class=\"line\"><span class=\"comment\">// &#123;...&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.time(<span class=\"string\">'time'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.assert(<span class=\"number\">3</span>&gt;<span class=\"number\">10</span>,<span class=\"string\">'str..'</span>);<span class=\"comment\">// 断言：表达式不成立，会输出后面的字符串</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Node-js-作用域\"><a href=\"#Node-js-作用域\" class=\"headerlink\" title=\"Node.js 作用域\"></a>Node.js 作用域</h4><ul>\n<li>全局作用域：没有使用 <code>var</code> 隐式声明的一个变量，会享受全局作用域，或者在 <code>global</code> 上挂载的变量，也具有全局作用域的属性，全局变量可以被其它模块使用。</li>\n<li>局部作用域：在 Node.js 中一个文件就是一个模块，在这个模块中定义的变量，只能在这个模块中使用。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这些变量都属于全局变量</span></span><br><span class=\"line\">name = <span class=\"string\">'ifyour'</span>;</span><br><span class=\"line\">global.age = <span class=\"number\">18</span>; <span class=\"comment\">// Node.js 中的 global 类似 JavaScript 中的 window</span></span><br></pre></td></tr></table></figure>\n<div class=\"tip\"><br>尽量避免使用全局变量，会造成变量污染。<br></div>\n\n<h4 id=\"回调函数\"><a href=\"#回调函数\" class=\"headerlink\" title=\"回调函数\"></a>回调函数</h4><p>Node.js 中大量使用了回调函数，关于回调函数，我之前在简书写了一篇，我的理解心得，有兴趣的可以<a href=\"http://www.jianshu.com/p/1383f4cb9a75\" target=\"_blank\" rel=\"noopener\">去看看</a>。关于回调函数，我也正是在 Node.js 中对它的理解更为深刻了，Node.js 大量的异步代码都借助回调函数实现，正因如此，性能更高呀。看一个非常简单的例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义回调函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">cb</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hello,callback!'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 把回调函数的引用（指针）传入该函数，一秒后执行</span></span><br><span class=\"line\">setTimeout(cb,<span class=\"number\">1000</span>);</span><br></pre></td></tr></table></figure>\n<p>借助这个例子，可以看到回调函数的实现机制：</p>\n<ul>\n<li>定义一个普通函数（其实它就是回调函数）</li>\n<li>将该函数的引用地址作为参数传给调用者，调用者本身也是一个函数，例子中的 <code>setTimeout</code></li>\n<li>当特定条件发生时，调用者使用这个引用地址去执行该函数</li>\n</ul>\n<p>回调函数的用途很多，比如实现事件注册、异步代码等。在 jQuery 中的动画就是回调函数的经典用法，<code>animate(x,y,z,function(){...})</code>,当一个动画执行完成后，执行回调函数。当点击一个按钮时，需要执行的函数块，这些都是回调函数。</p>\n<h3 id=\"Node-js-事件\"><a href=\"#Node-js-事件\" class=\"headerlink\" title=\"Node.js 事件\"></a>Node.js 事件</h3><p>Node.js 中的 event 模块就是提供事件编程的 API，所有具有触发事件的对象都继承或内部包含了 <code>EventEmitter</code> 对象。来一个简单的例子吧！<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//events 模块中的 EventEmitter 对象，定义了事件对象的基础信息和行为</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> EventEmitter = <span class=\"built_in\">require</span>(<span class=\"string\">'events'</span>).EventEmitter;</span><br><span class=\"line\"><span class=\"keyword\">var</span> event = <span class=\"keyword\">new</span> EventEmitter();<span class=\"comment\">// 实例化一个 event 对象</span></span><br><span class=\"line\">event.on(<span class=\"string\">'myevent'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>)</span>&#123; <span class=\"comment\">// 绑定 myevent 事件</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hi!'</span> + name);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">event.emit(<span class=\"string\">'myevent'</span>,<span class=\"string\">'ifyour'</span>);<span class=\"comment\">// 触发事件</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"事件常用方法\"><a href=\"#事件常用方法\" class=\"headerlink\" title=\"事件常用方法\"></a>事件常用方法</h4><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">方法</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">addListener(event, listener)</td>\n<td style=\"text-align:left\">为指定事件添加一个监听器到监听器数组的尾部。与 on 等价</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">on(event, listener)</td>\n<td style=\"text-align:left\">为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">once(event, listener)</td>\n<td style=\"text-align:left\">为指定事件注册一个单次监听器</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">removeListener(event,listener)</td>\n<td style=\"text-align:left\">移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">removeAllListeners([event])</td>\n<td style=\"text-align:left\">移除所有事件的所有监听器如果指定事件，则移除该事件的所有监听器</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">setMaxListeners(n)</td>\n<td style=\"text-align:left\">setMaxListeners 函数用于提高监听器的默认限制的数量，默认是 10</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">listeners(event)</td>\n<td style=\"text-align:left\">返回指定事件的监听器数组</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">emit(event, [arg1], [arg2], […])</td>\n<td style=\"text-align:left\">按顺序执行监听器，如果事件有注册监听返回 true，否则返回 false</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Node-js-异步与同步\"><a href=\"#Node-js-异步与同步\" class=\"headerlink\" title=\"Node.js 异步与同步\"></a>Node.js 异步与同步</h3><p><strong><em>同步</em></strong>：一个任务执行完成后，才能执行下一个任务，执行总时间等于所有任务消耗时间之和。<br><strong><em>异步</em></strong>：几个任务同时执行，不限制先后，执行总时间等于执行耗时最长的那个任务的消耗时间。</p>\n<p>在 Node.js 中每一个任务有一个或多个回调函数，前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。</p>\n<h4 id=\"异步的实现\"><a href=\"#异步的实现\" class=\"headerlink\" title=\"异步的实现\"></a>异步的实现</h4><ul>\n<li>回调函数</li>\n<li>事件（基于回调函数）</li>\n<li>Promise （ES6）</li>\n</ul>\n<p>前面已经讲了回调函数的实现方式，下面举两个例子来说明 Node.js 中 <strong><em>事件</em></strong> 和 <strong><em>Promise</em></strong> 实现异步。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 事件（基于回调函数）实现异步</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> stream = fs.createReadStream(<span class=\"string\">'./data'</span>);<span class=\"comment\">// 调用 fs 模块创建一个读取流对象</span></span><br><span class=\"line\">stream.on(<span class=\"string\">'data'</span>,getData);<span class=\"comment\">// 读取事件，每次读取时触发调用回调函数 getData</span></span><br><span class=\"line\">stream.on(<span class=\"string\">'end'</span>,getDataDone);<span class=\"comment\">// 读取完毕调用回调函数 getDataDone</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getDataDone</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'read done!'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getData</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data.toString());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面的代码中，当读取多个 <code>data</code> 文件时，输出的内容的顺序可能不一致，因为事件采用回调函数实现了异步操作。可以看出，事件实现异步，本质上还是回调函数。</p>\n<blockquote>\n<p>所谓 Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。</p>\n</blockquote>\n<p>下面来看看 <code>Promise</code> 的一个实例：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;<span class=\"comment\">// 使用 Promise 生成实例</span></span><br><span class=\"line\">    fs.readFile(<span class=\"string\">'./1'</span>, <span class=\"string\">'utf-8'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, data</span>) </span>&#123;<span class=\"comment\">// readFile 是一个异步方法</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!err) &#123;</span><br><span class=\"line\">            resolve(data);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            reject(err);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">p.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;<span class=\"comment\">// 调用实例的 then 方法</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>ES6 规定，Promise 对象是一个构造函数，用来生成 Promise 实例。Promise 构造函数接受一个函数作为参数，该函数的两个参数分别是 <code>resolve</code> 和 <code>reject</code>。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</p>\n<ul>\n<li>resolve : 在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；</li>\n<li>reject  : 在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</li>\n</ul>\n<p>Promise 实例生成以后，可以用 <code>then</code> 方法分别指定 Resolved 状态和 Reject 状态的回调函数。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// success</span></span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// failure</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>有了 Promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise 对象提供统一的接口，使得控制异步操作更加容易。</p>\n<p>下面这个例子，在未使用 <code>Promise</code> 时，我们想要 <code>p1</code> 读取完数据后，紧接着 <code>p2</code> 、<code>p3</code> 读取，就需要在 <code>p1</code> 的回调读取成功函数里继续写 <code>p2</code> 的读取，类似的 <code>p3</code> 也要在 <code>p2</code> 的回调函数中写，这就造成了 <strong><em>层层嵌套</em></strong> 不利于代码阅读。而使用 <code>Promise</code> 后，<code>then</code> 方法把里面的回调函数统一提取出来， 可读性更好了，也方便理解。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Promise 提供的 then 方法避免层次嵌套，相当于实现 then 的链式操作</span></span><br><span class=\"line\"><span class=\"comment\">// p1 执行完 then 方法后，通过 return p2 ，让 p2 继续执行 then 方法</span></span><br><span class=\"line\">p1.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p2;</span><br><span class=\"line\">&#125;,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p2;</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p3;</span><br><span class=\"line\">&#125;,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p3;</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">&#125;,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>更多 Promise 语法，可以参考阮一峰的《<a href=\"http://es6.ruanyifeng.com/#docs/promise#基本用法\" target=\"_blank\" rel=\"noopener\">ECMAScript 6 入门</a>》。</p>"},{"title":"Promise 查漏补缺","comments":1,"date":"2018-07-15T01:17:58.000Z","from":null,"_content":"\nPromise 的重要性不用多说, 曾经看到关于 JavaScript 的描述 --- JS 的三座大山就是: `原型`/`作用域`/`异步`, 所以如果说你是一个合格的 JavaScript 程序员, 这三块的内容肯定是要吃透的. 纵观 JavaScript 的异步史, 它经历了 `callback` -> `Promise` -> `Generator` -> `async-await` 这样一个历程, 前前后后编写异步代码的变化. 从变化中就可以体会到, 确实越来越简洁, 越来越易读. 掌握它们, 你能写出更优雅的代码.\n\n<!-- more -->\n\n### Promise 简介\n\n![image](https://user-images.githubusercontent.com/15377484/42730799-8a283548-8830-11e8-9cc0-adb620f7f71a.png)\n\nECMAscript6 原生提供了 Promise 对象, 由浏览器直接支持, 目前大多数浏览器都已经实现了, 低版本浏览器可以使用 *es6-promise* 库来填平兼容性问题. Promise 最大的好处是把执行代码和处理代码分离开, 使异步操作逻辑更加清晰.\n\n### Promise 特点\n\n1. 对象的状态不受外界影响 Promise 对象代表一个异步操作, 有三种状态:\n  * pending - 初始状态\n  * fulfilled - 操作成功完成\n  * rejected - 操作失败\n2. 一旦状态改变, 就不会再发生变化. Promise 对象的状态改变. 只有两种情况: 从 `Pending` 变为 `Resolved` 和从 `Pending` 变为 `Rejected`. 只要这两种情况发生, 状态就会固定, 不会再变了, 会一直保持这个结果, 与事件不同的是, 就算改变已经发生了, 再对 Promise 对象添加回调函数, 也会立即得到这个结果, 而事件一旦错过再去监听, 就不会得到结果.\n\n![image](https://user-images.githubusercontent.com/15377484/42730787-1d531df2-8830-11e8-8514-0a810d945440.png)\n\n<div class=\"tip\"> 只有异步操作的结果可以决定当前是哪一种状态, 其他操作都不会影响状态改变, 这也是 Promise 最本质的特性, 对于调用者的一种承诺 </div>\n\n### Promise 优缺点\n\n优点:\n\n  * 可以将异步操作以同步操作的流程表达出来, 避免了层层嵌套的回调函数 Promise\n  * 对象提供统一的接口, 使得控制异步操作更加容易\n\n缺点:\n\n  * 无法取消 Promise, 一旦新建它就会立即执行, 无法中途取消\n  * 如果不设置回调函数, Promise 内部抛出的错误, 不会反应到外部\n  * 当处于 `Pending` 状态时, 无法得知目前进展到哪一个阶段（刚刚开始或者即将完成）\n\n### Promise.prototype.then\n\nPromise.prototype.then 方法返回的是一个新的 Promise 对象, 因此可以采用链式写法\n\n```js\najax('http://some.api.com/')\n  .then((json) => {\n    return json.post;\n  })\n  .then((post) => {\n    // post 处理\n  });\n```\n\n👆 代码中使用了两个 then 方法, 分别指定了对应的回调参数. 第一个回调函数完成后, 会将返回结果作为参数, 传入第二个 then 中的回调函数执行.\n\n```js\najax('http://some.api.com/')\n  .then((jsonURL) => {\n    return ajax(jsonURL);\n  })\n  .then((post) => {\n    // post 处理\n  });\n```\n\n👆 如果第一个回调函数返回的是 Promise 对象, 后一个回调函数会等待该 Promise 对象的运行结果, 等 Promise 运行结果返回, 再进一步调用. 这种设计使得嵌套的异步操作, 可以被很容易得改写, 把回调函数的 \"横向发展\" 改为了 \"向下发展\".\n\n### Promise.prototype.catch\n\nPromise.prototype.catch 错误捕捉方法是 `Promise.prototype.then(null, rejection)` 的别名, 用来指定发生错误时的处理函数.\n\n```js\najax('http://some.api.com/')\n  .then((post) => {\n    throw Error();\n  })\n  .catch((error) => {\n    // 捕捉回调函数运行时发生的错误进行处理\n    console.log('error:' + error);\n  });\n```\n\nPromise 对象的错误具有 \"冒泡\" 性质, 会一直向后传递, 直到被捕获为止.\n\n```js\najax('http://some.api.com/')\n  .then((jsonURL) => {\n    return ajax(jsonURL);\n  })\n  .then((comments) => {\n    throw Error();\n  })\n  .catch((error) => {\n    // 处理前两个回调函数的错误\n    console.log('error:' + error);\n  });\n```\n\n### Promise.resolve\n\nPromise.resolve 方法可以将现有对象转为 Promise 对象. 如果 Promise.resolve 方法的参数, 不是 thenable 对象 (具有 then 方法的对象), 则返回一个新的 Promise 对象, 且它的状态为 `fulfilled`.\n\n```js\nconst resolve = Promise.resolve('promise resolve');\n\nresolve.then((s) => {\n  console.log(s);\n});\n\n// output 👇\npromise resolve\n```\n\n如果 Promise 对象的实例状态为 `fulfilled`, 回调函数会立即执行, Promise.resolve 方法的参数就是回调函数的参数. 如果 Promise.resolve 方法的参数是一个 Promise 对象的实例, 则会返回该 Promise 实例.\n\n### Promise.reject\n\nPromise.reject(reason) 方法与 resolve 方法类似, 也会返回一个新的 Promise 实例, 但该实例的状态为 `rejected`. Promise.reject 方法的参数, 会被传递给实例的回调函数.\n\n```js\nconst reject = Promise.reject('promise reject');\n\nreject.then(null, (err) => {\n  console.log(err)\n});\n\n// output 👇\npromise reject\n```\n\n### Promise.all\n\nPromise.all 方法用于将多个 Promise 实例, 包装成一个新的 Promise 实例, 该方法一般接受一个数组作为参数, 但不一定是数组, 只要具有 iterator 接口. 且返回的每个成员都是 Promise 实例.\n\n```js\nconst getRandom = () => +(Math.random() * 1000).toFixed(0);\nconst ajax = (taskID) => new Promise(resolve => {\n  let timeout = getRandom();\n  console.log(`taskID=${taskID} start.`);\n  setTimeout(function() {\n    console.log(`taskID=${taskID} finished in time=${timeout}.`);\n    resolve(taskID)\n  }, timeout);\n});\n\nPromise.all([ajax(1), ajax(2), ajax(3)])\n  .then(resultList => {\n    console.log('results:', resultList);\n  });\n```\n\n输出结果 👇:\n\n```text\ntaskID=1 start.\ntaskID=2 start.\ntaskID=3 start.\ntaskID=2 finished in time=27.\ntaskID=3 finished in time=257.\ntaskID=1 finished in time=876.\nresults: [1, 2, 3]\n```\n\nPromise.all 状态分为两种:\n\n* 只有 ajax(1)、ajax(2)、ajax(3) 的状态都变成 `fulfilled`, Promise.all 返回的状态才会变成 `fulfilled`, 此时 ajax(1)、ajax(2)、ajax(3) 的返回值组成一个数组, 传递给 Promise.all 的回调函数.\n* 只要 ajax(1)、ajax(2)、ajax(3) 之中有一个是 `rejected`, Promise.all 返回的状态就变成 `rejected`, 此时第一个被 reject 的实例的返回值, 会传递给 Promise.all 的回调函数.\n\n### Promise.race\n\nPromise.race 方法也是将多个 Promise 实例, 包装成一个新的 Promise 实例, 与 Promise.all 不同的是一旦有状态改变, 就会返回第一个状态改变的 Promise 实例返回值.\n\n```js\nconst getRandom = () => +(Math.random() * 1000).toFixed(0);\nconst ajax = (taskID) => new Promise(resolve => {\n  let timeout = getRandom();\n  console.log(`taskID=${taskID} start.`);\n  setTimeout(function() {\n    console.log(`taskID=${taskID} finished in time=${timeout}.`);\n    resolve(taskID)\n  }, timeout);\n});\n\nPromise.race([ajax(1), ajax(2), ajax(3)])\n  .then(result => {\n    console.log('results:', result);\n  });\n```\n\n输出结果 👇:\n\n```text\ntaskID=1 start.\ntaskID=2 start.\ntaskID=3 start.\ntaskID=2 finished in time=59.\nresults: 2\ntaskID=3 finished in time=707.\ntaskID=1 finished in time=854.\n```\n\nPromise.race 虽然 **返回第一个状态改变的 Promise 实例**, 但不能阻止其他 Promise 实例状态改变.\n\n如果 `Promise.all` 和 `Promise.race` 的参数不是 Promise 实例, 它们就会调用 Promise.resolve 方法, 将参数转为 Promise 实例, 再进一步处理.\n\n### 参考\n\n* [js-async-tutorial @GitHub](https://github.com/wangfupeng1988/js-async-tutorial)\n* [Promise constructor @MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise)\n","source":"_posts/Promise-查漏补缺.md","raw":"---\ntitle: Promise 查漏补缺\ncomments: true\ndate: 2018-07-15 09:17:58\ntags:\nfrom:\n---\n\nPromise 的重要性不用多说, 曾经看到关于 JavaScript 的描述 --- JS 的三座大山就是: `原型`/`作用域`/`异步`, 所以如果说你是一个合格的 JavaScript 程序员, 这三块的内容肯定是要吃透的. 纵观 JavaScript 的异步史, 它经历了 `callback` -> `Promise` -> `Generator` -> `async-await` 这样一个历程, 前前后后编写异步代码的变化. 从变化中就可以体会到, 确实越来越简洁, 越来越易读. 掌握它们, 你能写出更优雅的代码.\n\n<!-- more -->\n\n### Promise 简介\n\n![image](https://user-images.githubusercontent.com/15377484/42730799-8a283548-8830-11e8-9cc0-adb620f7f71a.png)\n\nECMAscript6 原生提供了 Promise 对象, 由浏览器直接支持, 目前大多数浏览器都已经实现了, 低版本浏览器可以使用 *es6-promise* 库来填平兼容性问题. Promise 最大的好处是把执行代码和处理代码分离开, 使异步操作逻辑更加清晰.\n\n### Promise 特点\n\n1. 对象的状态不受外界影响 Promise 对象代表一个异步操作, 有三种状态:\n  * pending - 初始状态\n  * fulfilled - 操作成功完成\n  * rejected - 操作失败\n2. 一旦状态改变, 就不会再发生变化. Promise 对象的状态改变. 只有两种情况: 从 `Pending` 变为 `Resolved` 和从 `Pending` 变为 `Rejected`. 只要这两种情况发生, 状态就会固定, 不会再变了, 会一直保持这个结果, 与事件不同的是, 就算改变已经发生了, 再对 Promise 对象添加回调函数, 也会立即得到这个结果, 而事件一旦错过再去监听, 就不会得到结果.\n\n![image](https://user-images.githubusercontent.com/15377484/42730787-1d531df2-8830-11e8-8514-0a810d945440.png)\n\n<div class=\"tip\"> 只有异步操作的结果可以决定当前是哪一种状态, 其他操作都不会影响状态改变, 这也是 Promise 最本质的特性, 对于调用者的一种承诺 </div>\n\n### Promise 优缺点\n\n优点:\n\n  * 可以将异步操作以同步操作的流程表达出来, 避免了层层嵌套的回调函数 Promise\n  * 对象提供统一的接口, 使得控制异步操作更加容易\n\n缺点:\n\n  * 无法取消 Promise, 一旦新建它就会立即执行, 无法中途取消\n  * 如果不设置回调函数, Promise 内部抛出的错误, 不会反应到外部\n  * 当处于 `Pending` 状态时, 无法得知目前进展到哪一个阶段（刚刚开始或者即将完成）\n\n### Promise.prototype.then\n\nPromise.prototype.then 方法返回的是一个新的 Promise 对象, 因此可以采用链式写法\n\n```js\najax('http://some.api.com/')\n  .then((json) => {\n    return json.post;\n  })\n  .then((post) => {\n    // post 处理\n  });\n```\n\n👆 代码中使用了两个 then 方法, 分别指定了对应的回调参数. 第一个回调函数完成后, 会将返回结果作为参数, 传入第二个 then 中的回调函数执行.\n\n```js\najax('http://some.api.com/')\n  .then((jsonURL) => {\n    return ajax(jsonURL);\n  })\n  .then((post) => {\n    // post 处理\n  });\n```\n\n👆 如果第一个回调函数返回的是 Promise 对象, 后一个回调函数会等待该 Promise 对象的运行结果, 等 Promise 运行结果返回, 再进一步调用. 这种设计使得嵌套的异步操作, 可以被很容易得改写, 把回调函数的 \"横向发展\" 改为了 \"向下发展\".\n\n### Promise.prototype.catch\n\nPromise.prototype.catch 错误捕捉方法是 `Promise.prototype.then(null, rejection)` 的别名, 用来指定发生错误时的处理函数.\n\n```js\najax('http://some.api.com/')\n  .then((post) => {\n    throw Error();\n  })\n  .catch((error) => {\n    // 捕捉回调函数运行时发生的错误进行处理\n    console.log('error:' + error);\n  });\n```\n\nPromise 对象的错误具有 \"冒泡\" 性质, 会一直向后传递, 直到被捕获为止.\n\n```js\najax('http://some.api.com/')\n  .then((jsonURL) => {\n    return ajax(jsonURL);\n  })\n  .then((comments) => {\n    throw Error();\n  })\n  .catch((error) => {\n    // 处理前两个回调函数的错误\n    console.log('error:' + error);\n  });\n```\n\n### Promise.resolve\n\nPromise.resolve 方法可以将现有对象转为 Promise 对象. 如果 Promise.resolve 方法的参数, 不是 thenable 对象 (具有 then 方法的对象), 则返回一个新的 Promise 对象, 且它的状态为 `fulfilled`.\n\n```js\nconst resolve = Promise.resolve('promise resolve');\n\nresolve.then((s) => {\n  console.log(s);\n});\n\n// output 👇\npromise resolve\n```\n\n如果 Promise 对象的实例状态为 `fulfilled`, 回调函数会立即执行, Promise.resolve 方法的参数就是回调函数的参数. 如果 Promise.resolve 方法的参数是一个 Promise 对象的实例, 则会返回该 Promise 实例.\n\n### Promise.reject\n\nPromise.reject(reason) 方法与 resolve 方法类似, 也会返回一个新的 Promise 实例, 但该实例的状态为 `rejected`. Promise.reject 方法的参数, 会被传递给实例的回调函数.\n\n```js\nconst reject = Promise.reject('promise reject');\n\nreject.then(null, (err) => {\n  console.log(err)\n});\n\n// output 👇\npromise reject\n```\n\n### Promise.all\n\nPromise.all 方法用于将多个 Promise 实例, 包装成一个新的 Promise 实例, 该方法一般接受一个数组作为参数, 但不一定是数组, 只要具有 iterator 接口. 且返回的每个成员都是 Promise 实例.\n\n```js\nconst getRandom = () => +(Math.random() * 1000).toFixed(0);\nconst ajax = (taskID) => new Promise(resolve => {\n  let timeout = getRandom();\n  console.log(`taskID=${taskID} start.`);\n  setTimeout(function() {\n    console.log(`taskID=${taskID} finished in time=${timeout}.`);\n    resolve(taskID)\n  }, timeout);\n});\n\nPromise.all([ajax(1), ajax(2), ajax(3)])\n  .then(resultList => {\n    console.log('results:', resultList);\n  });\n```\n\n输出结果 👇:\n\n```text\ntaskID=1 start.\ntaskID=2 start.\ntaskID=3 start.\ntaskID=2 finished in time=27.\ntaskID=3 finished in time=257.\ntaskID=1 finished in time=876.\nresults: [1, 2, 3]\n```\n\nPromise.all 状态分为两种:\n\n* 只有 ajax(1)、ajax(2)、ajax(3) 的状态都变成 `fulfilled`, Promise.all 返回的状态才会变成 `fulfilled`, 此时 ajax(1)、ajax(2)、ajax(3) 的返回值组成一个数组, 传递给 Promise.all 的回调函数.\n* 只要 ajax(1)、ajax(2)、ajax(3) 之中有一个是 `rejected`, Promise.all 返回的状态就变成 `rejected`, 此时第一个被 reject 的实例的返回值, 会传递给 Promise.all 的回调函数.\n\n### Promise.race\n\nPromise.race 方法也是将多个 Promise 实例, 包装成一个新的 Promise 实例, 与 Promise.all 不同的是一旦有状态改变, 就会返回第一个状态改变的 Promise 实例返回值.\n\n```js\nconst getRandom = () => +(Math.random() * 1000).toFixed(0);\nconst ajax = (taskID) => new Promise(resolve => {\n  let timeout = getRandom();\n  console.log(`taskID=${taskID} start.`);\n  setTimeout(function() {\n    console.log(`taskID=${taskID} finished in time=${timeout}.`);\n    resolve(taskID)\n  }, timeout);\n});\n\nPromise.race([ajax(1), ajax(2), ajax(3)])\n  .then(result => {\n    console.log('results:', result);\n  });\n```\n\n输出结果 👇:\n\n```text\ntaskID=1 start.\ntaskID=2 start.\ntaskID=3 start.\ntaskID=2 finished in time=59.\nresults: 2\ntaskID=3 finished in time=707.\ntaskID=1 finished in time=854.\n```\n\nPromise.race 虽然 **返回第一个状态改变的 Promise 实例**, 但不能阻止其他 Promise 实例状态改变.\n\n如果 `Promise.all` 和 `Promise.race` 的参数不是 Promise 实例, 它们就会调用 Promise.resolve 方法, 将参数转为 Promise 实例, 再进一步处理.\n\n### 参考\n\n* [js-async-tutorial @GitHub](https://github.com/wangfupeng1988/js-async-tutorial)\n* [Promise constructor @MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise)\n","slug":"Promise-查漏补缺","published":1,"updated":"2019-12-07T04:59:34.322Z","layout":"post","photos":[],"link":"","_id":"ck3v60jte000cr9q9ct55mrd2","content":"<p>Promise 的重要性不用多说, 曾经看到关于 JavaScript 的描述 — JS 的三座大山就是: <code>原型</code>/<code>作用域</code>/<code>异步</code>, 所以如果说你是一个合格的 JavaScript 程序员, 这三块的内容肯定是要吃透的. 纵观 JavaScript 的异步史, 它经历了 <code>callback</code> -&gt; <code>Promise</code> -&gt; <code>Generator</code> -&gt; <code>async-await</code> 这样一个历程, 前前后后编写异步代码的变化. 从变化中就可以体会到, 确实越来越简洁, 越来越易读. 掌握它们, 你能写出更优雅的代码.</p>\n<a id=\"more\"></a>\n<h3 id=\"Promise-简介\"><a href=\"#Promise-简介\" class=\"headerlink\" title=\"Promise 简介\"></a>Promise 简介</h3><p><img src=\"https://user-images.githubusercontent.com/15377484/42730799-8a283548-8830-11e8-9cc0-adb620f7f71a.png\" alt=\"image\"></p>\n<p>ECMAscript6 原生提供了 Promise 对象, 由浏览器直接支持, 目前大多数浏览器都已经实现了, 低版本浏览器可以使用 <em>es6-promise</em> 库来填平兼容性问题. Promise 最大的好处是把执行代码和处理代码分离开, 使异步操作逻辑更加清晰.</p>\n<h3 id=\"Promise-特点\"><a href=\"#Promise-特点\" class=\"headerlink\" title=\"Promise 特点\"></a>Promise 特点</h3><ol>\n<li>对象的状态不受外界影响 Promise 对象代表一个异步操作, 有三种状态:<ul>\n<li>pending - 初始状态</li>\n<li>fulfilled - 操作成功完成</li>\n<li>rejected - 操作失败</li>\n</ul>\n</li>\n<li>一旦状态改变, 就不会再发生变化. Promise 对象的状态改变. 只有两种情况: 从 <code>Pending</code> 变为 <code>Resolved</code> 和从 <code>Pending</code> 变为 <code>Rejected</code>. 只要这两种情况发生, 状态就会固定, 不会再变了, 会一直保持这个结果, 与事件不同的是, 就算改变已经发生了, 再对 Promise 对象添加回调函数, 也会立即得到这个结果, 而事件一旦错过再去监听, 就不会得到结果.</li>\n</ol>\n<p><img src=\"https://user-images.githubusercontent.com/15377484/42730787-1d531df2-8830-11e8-8514-0a810d945440.png\" alt=\"image\"></p>\n<div class=\"tip\"> 只有异步操作的结果可以决定当前是哪一种状态, 其他操作都不会影响状态改变, 这也是 Promise 最本质的特性, 对于调用者的一种承诺 </div>\n\n<h3 id=\"Promise-优缺点\"><a href=\"#Promise-优缺点\" class=\"headerlink\" title=\"Promise 优缺点\"></a>Promise 优缺点</h3><p>优点:</p>\n<ul>\n<li>可以将异步操作以同步操作的流程表达出来, 避免了层层嵌套的回调函数 Promise</li>\n<li>对象提供统一的接口, 使得控制异步操作更加容易</li>\n</ul>\n<p>缺点:</p>\n<ul>\n<li>无法取消 Promise, 一旦新建它就会立即执行, 无法中途取消</li>\n<li>如果不设置回调函数, Promise 内部抛出的错误, 不会反应到外部</li>\n<li>当处于 <code>Pending</code> 状态时, 无法得知目前进展到哪一个阶段（刚刚开始或者即将完成）</li>\n</ul>\n<h3 id=\"Promise-prototype-then\"><a href=\"#Promise-prototype-then\" class=\"headerlink\" title=\"Promise.prototype.then\"></a>Promise.prototype.then</h3><p>Promise.prototype.then 方法返回的是一个新的 Promise 对象, 因此可以采用链式写法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ajax(<span class=\"string\">'http://some.api.com/'</span>)</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">json</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> json.post;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">post</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// post 处理</span></span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<p>👆 代码中使用了两个 then 方法, 分别指定了对应的回调参数. 第一个回调函数完成后, 会将返回结果作为参数, 传入第二个 then 中的回调函数执行.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ajax(<span class=\"string\">'http://some.api.com/'</span>)</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">jsonURL</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ajax(jsonURL);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">post</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// post 处理</span></span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<p>👆 如果第一个回调函数返回的是 Promise 对象, 后一个回调函数会等待该 Promise 对象的运行结果, 等 Promise 运行结果返回, 再进一步调用. 这种设计使得嵌套的异步操作, 可以被很容易得改写, 把回调函数的 “横向发展” 改为了 “向下发展”.</p>\n<h3 id=\"Promise-prototype-catch\"><a href=\"#Promise-prototype-catch\" class=\"headerlink\" title=\"Promise.prototype.catch\"></a>Promise.prototype.catch</h3><p>Promise.prototype.catch 错误捕捉方法是 <code>Promise.prototype.then(null, rejection)</code> 的别名, 用来指定发生错误时的处理函数.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ajax(<span class=\"string\">'http://some.api.com/'</span>)</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">post</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"built_in\">Error</span>();</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\">(<span class=\"params\">error</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 捕捉回调函数运行时发生的错误进行处理</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'error:'</span> + error);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<p>Promise 对象的错误具有 “冒泡” 性质, 会一直向后传递, 直到被捕获为止.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ajax(<span class=\"string\">'http://some.api.com/'</span>)</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">jsonURL</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ajax(jsonURL);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">comments</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"built_in\">Error</span>();</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\">(<span class=\"params\">error</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 处理前两个回调函数的错误</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'error:'</span> + error);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"Promise-resolve\"><a href=\"#Promise-resolve\" class=\"headerlink\" title=\"Promise.resolve\"></a>Promise.resolve</h3><p>Promise.resolve 方法可以将现有对象转为 Promise 对象. 如果 Promise.resolve 方法的参数, 不是 thenable 对象 (具有 then 方法的对象), 则返回一个新的 Promise 对象, 且它的状态为 <code>fulfilled</code>.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> resolve = <span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'promise resolve'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">resolve.then(<span class=\"function\">(<span class=\"params\">s</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(s);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output 👇</span></span><br><span class=\"line\">promise resolve</span><br></pre></td></tr></table></figure>\n<p>如果 Promise 对象的实例状态为 <code>fulfilled</code>, 回调函数会立即执行, Promise.resolve 方法的参数就是回调函数的参数. 如果 Promise.resolve 方法的参数是一个 Promise 对象的实例, 则会返回该 Promise 实例.</p>\n<h3 id=\"Promise-reject\"><a href=\"#Promise-reject\" class=\"headerlink\" title=\"Promise.reject\"></a>Promise.reject</h3><p>Promise.reject(reason) 方法与 resolve 方法类似, 也会返回一个新的 Promise 实例, 但该实例的状态为 <code>rejected</code>. Promise.reject 方法的参数, 会被传递给实例的回调函数.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> reject = <span class=\"built_in\">Promise</span>.reject(<span class=\"string\">'promise reject'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">reject.then(<span class=\"literal\">null</span>, (err) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(err)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output 👇</span></span><br><span class=\"line\">promise reject</span><br></pre></td></tr></table></figure>\n<h3 id=\"Promise-all\"><a href=\"#Promise-all\" class=\"headerlink\" title=\"Promise.all\"></a>Promise.all</h3><p>Promise.all 方法用于将多个 Promise 实例, 包装成一个新的 Promise 实例, 该方法一般接受一个数组作为参数, 但不一定是数组, 只要具有 iterator 接口. 且返回的每个成员都是 Promise 实例.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> getRandom = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> +(<span class=\"built_in\">Math</span>.random() * <span class=\"number\">1000</span>).toFixed(<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> ajax = <span class=\"function\">(<span class=\"params\">taskID</span>) =&gt;</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> timeout = getRandom();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`taskID=<span class=\"subst\">$&#123;taskID&#125;</span> start.`</span>);</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`taskID=<span class=\"subst\">$&#123;taskID&#125;</span> finished in time=<span class=\"subst\">$&#123;timeout&#125;</span>.`</span>);</span><br><span class=\"line\">    resolve(taskID)</span><br><span class=\"line\">  &#125;, timeout);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.all([ajax(<span class=\"number\">1</span>), ajax(<span class=\"number\">2</span>), ajax(<span class=\"number\">3</span>)])</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">resultList</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'results:'</span>, resultList);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<p>输出结果 👇:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">taskID=1 start.</span><br><span class=\"line\">taskID=2 start.</span><br><span class=\"line\">taskID=3 start.</span><br><span class=\"line\">taskID=2 finished in time=27.</span><br><span class=\"line\">taskID=3 finished in time=257.</span><br><span class=\"line\">taskID=1 finished in time=876.</span><br><span class=\"line\">results: [1, 2, 3]</span><br></pre></td></tr></table></figure>\n<p>Promise.all 状态分为两种:</p>\n<ul>\n<li>只有 ajax(1)、ajax(2)、ajax(3) 的状态都变成 <code>fulfilled</code>, Promise.all 返回的状态才会变成 <code>fulfilled</code>, 此时 ajax(1)、ajax(2)、ajax(3) 的返回值组成一个数组, 传递给 Promise.all 的回调函数.</li>\n<li>只要 ajax(1)、ajax(2)、ajax(3) 之中有一个是 <code>rejected</code>, Promise.all 返回的状态就变成 <code>rejected</code>, 此时第一个被 reject 的实例的返回值, 会传递给 Promise.all 的回调函数.</li>\n</ul>\n<h3 id=\"Promise-race\"><a href=\"#Promise-race\" class=\"headerlink\" title=\"Promise.race\"></a>Promise.race</h3><p>Promise.race 方法也是将多个 Promise 实例, 包装成一个新的 Promise 实例, 与 Promise.all 不同的是一旦有状态改变, 就会返回第一个状态改变的 Promise 实例返回值.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> getRandom = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> +(<span class=\"built_in\">Math</span>.random() * <span class=\"number\">1000</span>).toFixed(<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> ajax = <span class=\"function\">(<span class=\"params\">taskID</span>) =&gt;</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> timeout = getRandom();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`taskID=<span class=\"subst\">$&#123;taskID&#125;</span> start.`</span>);</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`taskID=<span class=\"subst\">$&#123;taskID&#125;</span> finished in time=<span class=\"subst\">$&#123;timeout&#125;</span>.`</span>);</span><br><span class=\"line\">    resolve(taskID)</span><br><span class=\"line\">  &#125;, timeout);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.race([ajax(<span class=\"number\">1</span>), ajax(<span class=\"number\">2</span>), ajax(<span class=\"number\">3</span>)])</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">result</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'results:'</span>, result);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<p>输出结果 👇:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">taskID=1 start.</span><br><span class=\"line\">taskID=2 start.</span><br><span class=\"line\">taskID=3 start.</span><br><span class=\"line\">taskID=2 finished in time=59.</span><br><span class=\"line\">results: 2</span><br><span class=\"line\">taskID=3 finished in time=707.</span><br><span class=\"line\">taskID=1 finished in time=854.</span><br></pre></td></tr></table></figure>\n<p>Promise.race 虽然 <strong>返回第一个状态改变的 Promise 实例</strong>, 但不能阻止其他 Promise 实例状态改变.</p>\n<p>如果 <code>Promise.all</code> 和 <code>Promise.race</code> 的参数不是 Promise 实例, 它们就会调用 Promise.resolve 方法, 将参数转为 Promise 实例, 再进一步处理.</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><a href=\"https://github.com/wangfupeng1988/js-async-tutorial\" target=\"_blank\" rel=\"noopener\">js-async-tutorial @GitHub</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise\" target=\"_blank\" rel=\"noopener\">Promise constructor @MDN</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>Promise 的重要性不用多说, 曾经看到关于 JavaScript 的描述 — JS 的三座大山就是: <code>原型</code>/<code>作用域</code>/<code>异步</code>, 所以如果说你是一个合格的 JavaScript 程序员, 这三块的内容肯定是要吃透的. 纵观 JavaScript 的异步史, 它经历了 <code>callback</code> -&gt; <code>Promise</code> -&gt; <code>Generator</code> -&gt; <code>async-await</code> 这样一个历程, 前前后后编写异步代码的变化. 从变化中就可以体会到, 确实越来越简洁, 越来越易读. 掌握它们, 你能写出更优雅的代码.</p>","more":"<h3 id=\"Promise-简介\"><a href=\"#Promise-简介\" class=\"headerlink\" title=\"Promise 简介\"></a>Promise 简介</h3><p><img src=\"https://user-images.githubusercontent.com/15377484/42730799-8a283548-8830-11e8-9cc0-adb620f7f71a.png\" alt=\"image\"></p>\n<p>ECMAscript6 原生提供了 Promise 对象, 由浏览器直接支持, 目前大多数浏览器都已经实现了, 低版本浏览器可以使用 <em>es6-promise</em> 库来填平兼容性问题. Promise 最大的好处是把执行代码和处理代码分离开, 使异步操作逻辑更加清晰.</p>\n<h3 id=\"Promise-特点\"><a href=\"#Promise-特点\" class=\"headerlink\" title=\"Promise 特点\"></a>Promise 特点</h3><ol>\n<li>对象的状态不受外界影响 Promise 对象代表一个异步操作, 有三种状态:<ul>\n<li>pending - 初始状态</li>\n<li>fulfilled - 操作成功完成</li>\n<li>rejected - 操作失败</li>\n</ul>\n</li>\n<li>一旦状态改变, 就不会再发生变化. Promise 对象的状态改变. 只有两种情况: 从 <code>Pending</code> 变为 <code>Resolved</code> 和从 <code>Pending</code> 变为 <code>Rejected</code>. 只要这两种情况发生, 状态就会固定, 不会再变了, 会一直保持这个结果, 与事件不同的是, 就算改变已经发生了, 再对 Promise 对象添加回调函数, 也会立即得到这个结果, 而事件一旦错过再去监听, 就不会得到结果.</li>\n</ol>\n<p><img src=\"https://user-images.githubusercontent.com/15377484/42730787-1d531df2-8830-11e8-8514-0a810d945440.png\" alt=\"image\"></p>\n<div class=\"tip\"> 只有异步操作的结果可以决定当前是哪一种状态, 其他操作都不会影响状态改变, 这也是 Promise 最本质的特性, 对于调用者的一种承诺 </div>\n\n<h3 id=\"Promise-优缺点\"><a href=\"#Promise-优缺点\" class=\"headerlink\" title=\"Promise 优缺点\"></a>Promise 优缺点</h3><p>优点:</p>\n<ul>\n<li>可以将异步操作以同步操作的流程表达出来, 避免了层层嵌套的回调函数 Promise</li>\n<li>对象提供统一的接口, 使得控制异步操作更加容易</li>\n</ul>\n<p>缺点:</p>\n<ul>\n<li>无法取消 Promise, 一旦新建它就会立即执行, 无法中途取消</li>\n<li>如果不设置回调函数, Promise 内部抛出的错误, 不会反应到外部</li>\n<li>当处于 <code>Pending</code> 状态时, 无法得知目前进展到哪一个阶段（刚刚开始或者即将完成）</li>\n</ul>\n<h3 id=\"Promise-prototype-then\"><a href=\"#Promise-prototype-then\" class=\"headerlink\" title=\"Promise.prototype.then\"></a>Promise.prototype.then</h3><p>Promise.prototype.then 方法返回的是一个新的 Promise 对象, 因此可以采用链式写法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ajax(<span class=\"string\">'http://some.api.com/'</span>)</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">json</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> json.post;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">post</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// post 处理</span></span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<p>👆 代码中使用了两个 then 方法, 分别指定了对应的回调参数. 第一个回调函数完成后, 会将返回结果作为参数, 传入第二个 then 中的回调函数执行.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ajax(<span class=\"string\">'http://some.api.com/'</span>)</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">jsonURL</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ajax(jsonURL);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">post</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// post 处理</span></span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<p>👆 如果第一个回调函数返回的是 Promise 对象, 后一个回调函数会等待该 Promise 对象的运行结果, 等 Promise 运行结果返回, 再进一步调用. 这种设计使得嵌套的异步操作, 可以被很容易得改写, 把回调函数的 “横向发展” 改为了 “向下发展”.</p>\n<h3 id=\"Promise-prototype-catch\"><a href=\"#Promise-prototype-catch\" class=\"headerlink\" title=\"Promise.prototype.catch\"></a>Promise.prototype.catch</h3><p>Promise.prototype.catch 错误捕捉方法是 <code>Promise.prototype.then(null, rejection)</code> 的别名, 用来指定发生错误时的处理函数.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ajax(<span class=\"string\">'http://some.api.com/'</span>)</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">post</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"built_in\">Error</span>();</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\">(<span class=\"params\">error</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 捕捉回调函数运行时发生的错误进行处理</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'error:'</span> + error);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<p>Promise 对象的错误具有 “冒泡” 性质, 会一直向后传递, 直到被捕获为止.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ajax(<span class=\"string\">'http://some.api.com/'</span>)</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">jsonURL</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ajax(jsonURL);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">comments</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"built_in\">Error</span>();</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\">(<span class=\"params\">error</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 处理前两个回调函数的错误</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'error:'</span> + error);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"Promise-resolve\"><a href=\"#Promise-resolve\" class=\"headerlink\" title=\"Promise.resolve\"></a>Promise.resolve</h3><p>Promise.resolve 方法可以将现有对象转为 Promise 对象. 如果 Promise.resolve 方法的参数, 不是 thenable 对象 (具有 then 方法的对象), 则返回一个新的 Promise 对象, 且它的状态为 <code>fulfilled</code>.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> resolve = <span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'promise resolve'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">resolve.then(<span class=\"function\">(<span class=\"params\">s</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(s);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output 👇</span></span><br><span class=\"line\">promise resolve</span><br></pre></td></tr></table></figure>\n<p>如果 Promise 对象的实例状态为 <code>fulfilled</code>, 回调函数会立即执行, Promise.resolve 方法的参数就是回调函数的参数. 如果 Promise.resolve 方法的参数是一个 Promise 对象的实例, 则会返回该 Promise 实例.</p>\n<h3 id=\"Promise-reject\"><a href=\"#Promise-reject\" class=\"headerlink\" title=\"Promise.reject\"></a>Promise.reject</h3><p>Promise.reject(reason) 方法与 resolve 方法类似, 也会返回一个新的 Promise 实例, 但该实例的状态为 <code>rejected</code>. Promise.reject 方法的参数, 会被传递给实例的回调函数.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> reject = <span class=\"built_in\">Promise</span>.reject(<span class=\"string\">'promise reject'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">reject.then(<span class=\"literal\">null</span>, (err) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(err)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output 👇</span></span><br><span class=\"line\">promise reject</span><br></pre></td></tr></table></figure>\n<h3 id=\"Promise-all\"><a href=\"#Promise-all\" class=\"headerlink\" title=\"Promise.all\"></a>Promise.all</h3><p>Promise.all 方法用于将多个 Promise 实例, 包装成一个新的 Promise 实例, 该方法一般接受一个数组作为参数, 但不一定是数组, 只要具有 iterator 接口. 且返回的每个成员都是 Promise 实例.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> getRandom = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> +(<span class=\"built_in\">Math</span>.random() * <span class=\"number\">1000</span>).toFixed(<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> ajax = <span class=\"function\">(<span class=\"params\">taskID</span>) =&gt;</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> timeout = getRandom();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`taskID=<span class=\"subst\">$&#123;taskID&#125;</span> start.`</span>);</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`taskID=<span class=\"subst\">$&#123;taskID&#125;</span> finished in time=<span class=\"subst\">$&#123;timeout&#125;</span>.`</span>);</span><br><span class=\"line\">    resolve(taskID)</span><br><span class=\"line\">  &#125;, timeout);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.all([ajax(<span class=\"number\">1</span>), ajax(<span class=\"number\">2</span>), ajax(<span class=\"number\">3</span>)])</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">resultList</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'results:'</span>, resultList);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<p>输出结果 👇:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">taskID=1 start.</span><br><span class=\"line\">taskID=2 start.</span><br><span class=\"line\">taskID=3 start.</span><br><span class=\"line\">taskID=2 finished in time=27.</span><br><span class=\"line\">taskID=3 finished in time=257.</span><br><span class=\"line\">taskID=1 finished in time=876.</span><br><span class=\"line\">results: [1, 2, 3]</span><br></pre></td></tr></table></figure>\n<p>Promise.all 状态分为两种:</p>\n<ul>\n<li>只有 ajax(1)、ajax(2)、ajax(3) 的状态都变成 <code>fulfilled</code>, Promise.all 返回的状态才会变成 <code>fulfilled</code>, 此时 ajax(1)、ajax(2)、ajax(3) 的返回值组成一个数组, 传递给 Promise.all 的回调函数.</li>\n<li>只要 ajax(1)、ajax(2)、ajax(3) 之中有一个是 <code>rejected</code>, Promise.all 返回的状态就变成 <code>rejected</code>, 此时第一个被 reject 的实例的返回值, 会传递给 Promise.all 的回调函数.</li>\n</ul>\n<h3 id=\"Promise-race\"><a href=\"#Promise-race\" class=\"headerlink\" title=\"Promise.race\"></a>Promise.race</h3><p>Promise.race 方法也是将多个 Promise 实例, 包装成一个新的 Promise 实例, 与 Promise.all 不同的是一旦有状态改变, 就会返回第一个状态改变的 Promise 实例返回值.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> getRandom = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> +(<span class=\"built_in\">Math</span>.random() * <span class=\"number\">1000</span>).toFixed(<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> ajax = <span class=\"function\">(<span class=\"params\">taskID</span>) =&gt;</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> timeout = getRandom();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`taskID=<span class=\"subst\">$&#123;taskID&#125;</span> start.`</span>);</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`taskID=<span class=\"subst\">$&#123;taskID&#125;</span> finished in time=<span class=\"subst\">$&#123;timeout&#125;</span>.`</span>);</span><br><span class=\"line\">    resolve(taskID)</span><br><span class=\"line\">  &#125;, timeout);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.race([ajax(<span class=\"number\">1</span>), ajax(<span class=\"number\">2</span>), ajax(<span class=\"number\">3</span>)])</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">result</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'results:'</span>, result);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<p>输出结果 👇:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">taskID=1 start.</span><br><span class=\"line\">taskID=2 start.</span><br><span class=\"line\">taskID=3 start.</span><br><span class=\"line\">taskID=2 finished in time=59.</span><br><span class=\"line\">results: 2</span><br><span class=\"line\">taskID=3 finished in time=707.</span><br><span class=\"line\">taskID=1 finished in time=854.</span><br></pre></td></tr></table></figure>\n<p>Promise.race 虽然 <strong>返回第一个状态改变的 Promise 实例</strong>, 但不能阻止其他 Promise 实例状态改变.</p>\n<p>如果 <code>Promise.all</code> 和 <code>Promise.race</code> 的参数不是 Promise 实例, 它们就会调用 Promise.resolve 方法, 将参数转为 Promise 实例, 再进一步处理.</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><a href=\"https://github.com/wangfupeng1988/js-async-tutorial\" target=\"_blank\" rel=\"noopener\">js-async-tutorial @GitHub</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise\" target=\"_blank\" rel=\"noopener\">Promise constructor @MDN</a></li>\n</ul>"},{"title":"Node.JS 学习笔记 [04] -- HTTP","date":"2015-01-05T07:05:10.000Z","comments":0,"_content":"\n本次的学习内容是 Node.js Web 模块，介绍了什么是 web 服务器，以及常见的几种模式，比如 B/S 模式（Browser/Server，浏览器/服务器模式），C/S 模式（Client/Server，客户端/服务器模式）等。Web 客户端通过使用 HTTP 协议就能访问到 Web 服务器上的数据，Web 服务器响应客户端的请求。\n<!-- more -->\n### HTTP\n#### HTTP 协议\n***HTTP***  协议是 Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网服务器传输超文本到本地浏览器的传送协议。用于定义 Web 浏览器与 Web 服务器之间交换数据的过程以及数据本身的格式。\n\n简单理解其实就是一种规范，以何种方式请求，以何种方式应答。特点嘛，***一次请求（Request）对应一次响应（Response）***。来看一个简单例子，访问 Google 首页的请求和应答。\n![](http://ww3.sinaimg.cn/large/6057861cgw1fbb9dlv1ylj20xy0ts7ct.jpg)\n\n在第一栏 General 中可以看到本次的请求目标，来解释一下这几个参数代表啥意思。\n\n- Request URL:https://www.google.com/  请求的 URL，这里我们访问的是 Google 首页。\n- Request Method:GET 请求方式，这里采用的是 GET 方式请求。\n- Status Code:200  状态码 200 ，表示 OK。\n- Remote Address:127.0.0.1:1080 这里表示请求的远端 IP 地址及端口，因为我是科学上网，这里才显示了一个回路地址。\n\n#### Node.js 搭建 http 服务器\nNode.js 提供了 http 模块，使用 HTTP 服务器或客户端功能必须调用 http 模块，Node.js 搭建一个 http 服务器非常简单，只需要几行代码，来看看把。:P\n```js\n// 引入 http 模块\nvar http = require('http');\n\n// 创建服务，回调函数处理请求（Request）和响应（Response），监听8080端口\nhttp.createServer(function (req, res) {\n    res.write('hello,world!');\n    res.end();\n}).listen(8080, function () {\n    console.log('Server running at http://127.0.0.1:8080/');\n});\n```\n打开浏览器，输入 http://127.0.0.1:8080/ 就可以看到刚刚创建的服务成功啦。\n![](http://ww4.sinaimg.cn/large/6057861cgw1fbbabbplavj20tg08mmyp.jpg)\n\n#### HTTP 响应内容\n问题来了，那么如何根据不同的 URL 来响应不同的内容呢？答案很简单，http 服务器在处理 URL 的时候，会根据 URL 的参数来分辨不同的请求内容，根据请求的内容来响应与之对应的内容。一个完整的 URL 长这个样子。\n```Text\nscheme://host.domain:port/path/filename?queryName=queryValue\n```\n- scheme：定义服务类型，常见的如 http\n- host：定义域主机，http 通常是 www\n- domain：定义域名，比如 google.com\n- :port：定义主机的端口号，默认是 80\n- path：定义路径，省略 `/` 表示根目录\n- filename：定义文件名\n- ?queryName=queryValue：查询字符串\n\n可以看出，想要响应不同的内容，就需要分析出 URL 中的 `path` 和 `filename` 以及对应的查询字符串。来看个简单的例子。\n```js\nvar http = require('http');\nvar fs = require('fs');\nvar url = require('url');// 引入 url 模块用于处理地址\nvar querystring = require('querystring'); // 引入 querystring 模块\n\nhttp.createServer(function (req, res) {\n    // 首页\n    var path = url.parse(req.url).pathname;\n    if (path == '/') {\n        fs.readFile('./html/index.html', 'utf-8', function (err, result) {\n            if (!err) {\n                res.write(result);\n                res.end();\n            }\n        });\n    }\n    // 登录\n    if (path == '/login'){\n        //{...}\n    }\n    // 登录验证\n    if (path == '/checkLogin') {\n        var queryObj = querystring.parse(url.parse(req.url).query);\n        // querystring.parse() 把查询字符串转成对象，{ usr: 'admin', pwd: '123' }\n        if (queryObj.usr == 'admin' && queryObj.pwd == '123') {\n            res.write('Login Success!');\n            res.end();\n        }\n    }\n}).listen(8080, function () {\n    console.log('Server running at http://127.0.0.1:8080/');\n});\n```\n\n#### HTTP 响应状态码\nHTTP 状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP 状态码共分为 5 种类型：\n\n|分类   |分类描述                                   |\n|:-----|:------------------------------------------|\n|1**   |信息，服务器收到请求，需要请求者继续执行操作   |\n|2**   |成功，操作被成功接收并处理                   |\n|3**   |重定向，需要进一步的操作以完成请求            |\n|4**   |客户端错误，请求包含语法错误或无法完成请求     |\n|5**   |服务器错误，服务器在处理请求的过程中发生了错误 |\n\n需要记住常见的几种就可以了，另外的可以[查手册](http://tools.jb51.net/table/http_status_code)找到非常详细的解释。\n- 200\tOK\t请求成功。一般用于 GET 与 POST 请求。\n- 304\tNot Modified\t未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。\n- 404\tNot Found\t服务器无法根据客户端的请求找到资源（网页）。\n- 500\tInternal Server Error\t服务器内部错误，无法完成请求。\n\n#### HTTP 响应不同的数据类型\n服务器具有返回各种数据的能力，但是返回数据时，应告诉浏览器返回的是一个什么文件。通过 `Content-Type` 可以设置，响应的数据类型。来看个简单的例子。\n```js\nvar http = require('http');\nvar fs = require('fs');\n\nhttp.createServer(function (req, res) {\n    // 设置响应的状态码，数据类型\n    res.writeHeader('200', {'Content-Type': 'image/png;charset=utf-8'});\n    fs.readFile('./hello.png', function (err, result) {\n        if (!err) {\n            res.write(result);\n            res.end();\n        }\n    })\n}).listen(8080, function () {\n    console.log('Server running at http://127.0.0.1:8080/');\n});\n```\n可以通过 [node-mime](https://github.com/broofa/node-mime) 来查询各种文件的数据类型。先用 npm 安装。\n```bash\nnpm install mime --save\n```\n```js\nvar mime = require('mime');\n\nconsole.log(mime.lookup('test.txt'));   // text/plain\nconsole.log(mime.lookup('test.html'));  // text/html\nconsole.log(mime.lookup('test.css'));   // text/css\nconsole.log(mime.lookup('test.js'));    // application/javascript\nconsole.log(mime.lookup('test.mp3'));   // audio/mpeg\n```\n### Web 客户端数据传递\n\n#### 通过 URL 传递\n```Text\nscheme://host.domain:port/path/filename?queryName=queryValue\n```\n其中 `?queryName=queryValue` 就是通过 URL 传递的数据，举个例子：`?usr=admin&pwd=123` 就表示传递一个 `usr` 为 `admin` ，`pwd` 为 `123` 的数据到后台。\n#### 通过表单传递\n```html\n<form action=\"/user\" method=\"get\">\n    用户名：<input type=\"text\" name=\"username\"/><br/>\n    密 码：<input type=\"password\" name=\"password\"><br/>\n    <input type=\"submit\" value=\"提交\"/>\n</form>\n```\n- action：提交到服务器处理程序的 url 地址\n- method：提交方式有 `GET` 和 `POST`\n- GET：会把表单数据作为 URL 的一部分显示在地址栏中，URL 长度有限制不能提交大量数据\n- POST：会把表单数据放到 HTTP 请求体中，相对安全，而且可以提交大量数据（比如文件）\n\n#### 数据类型\n前面讲了，在服务器端，返回给浏览器数据时，会通过 `Content-Type` 指定数据类型，同样的，浏览器向服务器传递数据时，也需要指定数据类型。在这两种数据传递方式中，表单传递数据时，`POST` 方式，必须指定数据类型，举个简单的例子。\n```html\n<form action=\"/user\" method=\"post\" enctype=\"multipart/form-data\">\n    <input type=\"file\">\n    <input type=\"submit\" value=\"上传\">\n</form>\n```\n`enctype` 指定 POST 的数据类型，默认是 `application/x-www-form-urlencoded`，上传文件时，就需要 `multipart/form-data` 类型了。\n","source":"_posts/Node.JS-学习笔记-[04]----HTTP.md","raw":"---\ntitle: 'Node.JS 学习笔记 [04] -- HTTP'\ndate: 2015-01-05 15:05:10\ntags:\ncomments: false\n---\n\n本次的学习内容是 Node.js Web 模块，介绍了什么是 web 服务器，以及常见的几种模式，比如 B/S 模式（Browser/Server，浏览器/服务器模式），C/S 模式（Client/Server，客户端/服务器模式）等。Web 客户端通过使用 HTTP 协议就能访问到 Web 服务器上的数据，Web 服务器响应客户端的请求。\n<!-- more -->\n### HTTP\n#### HTTP 协议\n***HTTP***  协议是 Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网服务器传输超文本到本地浏览器的传送协议。用于定义 Web 浏览器与 Web 服务器之间交换数据的过程以及数据本身的格式。\n\n简单理解其实就是一种规范，以何种方式请求，以何种方式应答。特点嘛，***一次请求（Request）对应一次响应（Response）***。来看一个简单例子，访问 Google 首页的请求和应答。\n![](http://ww3.sinaimg.cn/large/6057861cgw1fbb9dlv1ylj20xy0ts7ct.jpg)\n\n在第一栏 General 中可以看到本次的请求目标，来解释一下这几个参数代表啥意思。\n\n- Request URL:https://www.google.com/  请求的 URL，这里我们访问的是 Google 首页。\n- Request Method:GET 请求方式，这里采用的是 GET 方式请求。\n- Status Code:200  状态码 200 ，表示 OK。\n- Remote Address:127.0.0.1:1080 这里表示请求的远端 IP 地址及端口，因为我是科学上网，这里才显示了一个回路地址。\n\n#### Node.js 搭建 http 服务器\nNode.js 提供了 http 模块，使用 HTTP 服务器或客户端功能必须调用 http 模块，Node.js 搭建一个 http 服务器非常简单，只需要几行代码，来看看把。:P\n```js\n// 引入 http 模块\nvar http = require('http');\n\n// 创建服务，回调函数处理请求（Request）和响应（Response），监听8080端口\nhttp.createServer(function (req, res) {\n    res.write('hello,world!');\n    res.end();\n}).listen(8080, function () {\n    console.log('Server running at http://127.0.0.1:8080/');\n});\n```\n打开浏览器，输入 http://127.0.0.1:8080/ 就可以看到刚刚创建的服务成功啦。\n![](http://ww4.sinaimg.cn/large/6057861cgw1fbbabbplavj20tg08mmyp.jpg)\n\n#### HTTP 响应内容\n问题来了，那么如何根据不同的 URL 来响应不同的内容呢？答案很简单，http 服务器在处理 URL 的时候，会根据 URL 的参数来分辨不同的请求内容，根据请求的内容来响应与之对应的内容。一个完整的 URL 长这个样子。\n```Text\nscheme://host.domain:port/path/filename?queryName=queryValue\n```\n- scheme：定义服务类型，常见的如 http\n- host：定义域主机，http 通常是 www\n- domain：定义域名，比如 google.com\n- :port：定义主机的端口号，默认是 80\n- path：定义路径，省略 `/` 表示根目录\n- filename：定义文件名\n- ?queryName=queryValue：查询字符串\n\n可以看出，想要响应不同的内容，就需要分析出 URL 中的 `path` 和 `filename` 以及对应的查询字符串。来看个简单的例子。\n```js\nvar http = require('http');\nvar fs = require('fs');\nvar url = require('url');// 引入 url 模块用于处理地址\nvar querystring = require('querystring'); // 引入 querystring 模块\n\nhttp.createServer(function (req, res) {\n    // 首页\n    var path = url.parse(req.url).pathname;\n    if (path == '/') {\n        fs.readFile('./html/index.html', 'utf-8', function (err, result) {\n            if (!err) {\n                res.write(result);\n                res.end();\n            }\n        });\n    }\n    // 登录\n    if (path == '/login'){\n        //{...}\n    }\n    // 登录验证\n    if (path == '/checkLogin') {\n        var queryObj = querystring.parse(url.parse(req.url).query);\n        // querystring.parse() 把查询字符串转成对象，{ usr: 'admin', pwd: '123' }\n        if (queryObj.usr == 'admin' && queryObj.pwd == '123') {\n            res.write('Login Success!');\n            res.end();\n        }\n    }\n}).listen(8080, function () {\n    console.log('Server running at http://127.0.0.1:8080/');\n});\n```\n\n#### HTTP 响应状态码\nHTTP 状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP 状态码共分为 5 种类型：\n\n|分类   |分类描述                                   |\n|:-----|:------------------------------------------|\n|1**   |信息，服务器收到请求，需要请求者继续执行操作   |\n|2**   |成功，操作被成功接收并处理                   |\n|3**   |重定向，需要进一步的操作以完成请求            |\n|4**   |客户端错误，请求包含语法错误或无法完成请求     |\n|5**   |服务器错误，服务器在处理请求的过程中发生了错误 |\n\n需要记住常见的几种就可以了，另外的可以[查手册](http://tools.jb51.net/table/http_status_code)找到非常详细的解释。\n- 200\tOK\t请求成功。一般用于 GET 与 POST 请求。\n- 304\tNot Modified\t未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。\n- 404\tNot Found\t服务器无法根据客户端的请求找到资源（网页）。\n- 500\tInternal Server Error\t服务器内部错误，无法完成请求。\n\n#### HTTP 响应不同的数据类型\n服务器具有返回各种数据的能力，但是返回数据时，应告诉浏览器返回的是一个什么文件。通过 `Content-Type` 可以设置，响应的数据类型。来看个简单的例子。\n```js\nvar http = require('http');\nvar fs = require('fs');\n\nhttp.createServer(function (req, res) {\n    // 设置响应的状态码，数据类型\n    res.writeHeader('200', {'Content-Type': 'image/png;charset=utf-8'});\n    fs.readFile('./hello.png', function (err, result) {\n        if (!err) {\n            res.write(result);\n            res.end();\n        }\n    })\n}).listen(8080, function () {\n    console.log('Server running at http://127.0.0.1:8080/');\n});\n```\n可以通过 [node-mime](https://github.com/broofa/node-mime) 来查询各种文件的数据类型。先用 npm 安装。\n```bash\nnpm install mime --save\n```\n```js\nvar mime = require('mime');\n\nconsole.log(mime.lookup('test.txt'));   // text/plain\nconsole.log(mime.lookup('test.html'));  // text/html\nconsole.log(mime.lookup('test.css'));   // text/css\nconsole.log(mime.lookup('test.js'));    // application/javascript\nconsole.log(mime.lookup('test.mp3'));   // audio/mpeg\n```\n### Web 客户端数据传递\n\n#### 通过 URL 传递\n```Text\nscheme://host.domain:port/path/filename?queryName=queryValue\n```\n其中 `?queryName=queryValue` 就是通过 URL 传递的数据，举个例子：`?usr=admin&pwd=123` 就表示传递一个 `usr` 为 `admin` ，`pwd` 为 `123` 的数据到后台。\n#### 通过表单传递\n```html\n<form action=\"/user\" method=\"get\">\n    用户名：<input type=\"text\" name=\"username\"/><br/>\n    密 码：<input type=\"password\" name=\"password\"><br/>\n    <input type=\"submit\" value=\"提交\"/>\n</form>\n```\n- action：提交到服务器处理程序的 url 地址\n- method：提交方式有 `GET` 和 `POST`\n- GET：会把表单数据作为 URL 的一部分显示在地址栏中，URL 长度有限制不能提交大量数据\n- POST：会把表单数据放到 HTTP 请求体中，相对安全，而且可以提交大量数据（比如文件）\n\n#### 数据类型\n前面讲了，在服务器端，返回给浏览器数据时，会通过 `Content-Type` 指定数据类型，同样的，浏览器向服务器传递数据时，也需要指定数据类型。在这两种数据传递方式中，表单传递数据时，`POST` 方式，必须指定数据类型，举个简单的例子。\n```html\n<form action=\"/user\" method=\"post\" enctype=\"multipart/form-data\">\n    <input type=\"file\">\n    <input type=\"submit\" value=\"上传\">\n</form>\n```\n`enctype` 指定 POST 的数据类型，默认是 `application/x-www-form-urlencoded`，上传文件时，就需要 `multipart/form-data` 类型了。\n","slug":"Node.JS-学习笔记-[04]----HTTP","published":1,"updated":"2019-12-07T04:59:34.172Z","layout":"post","photos":[],"link":"","_id":"ck3v60jte000dr9q910rmytsz","content":"<p>本次的学习内容是 Node.js Web 模块，介绍了什么是 web 服务器，以及常见的几种模式，比如 B/S 模式（Browser/Server，浏览器/服务器模式），C/S 模式（Client/Server，客户端/服务器模式）等。Web 客户端通过使用 HTTP 协议就能访问到 Web 服务器上的数据，Web 服务器响应客户端的请求。<br><a id=\"more\"></a></p>\n<h3 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h3><h4 id=\"HTTP-协议\"><a href=\"#HTTP-协议\" class=\"headerlink\" title=\"HTTP 协议\"></a>HTTP 协议</h4><p><strong><em>HTTP</em></strong>  协议是 Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网服务器传输超文本到本地浏览器的传送协议。用于定义 Web 浏览器与 Web 服务器之间交换数据的过程以及数据本身的格式。</p>\n<p>简单理解其实就是一种规范，以何种方式请求，以何种方式应答。特点嘛，<strong><em>一次请求（Request）对应一次响应（Response）</em></strong>。来看一个简单例子，访问 Google 首页的请求和应答。<br><img src=\"http://ww3.sinaimg.cn/large/6057861cgw1fbb9dlv1ylj20xy0ts7ct.jpg\" alt=\"\"></p>\n<p>在第一栏 General 中可以看到本次的请求目标，来解释一下这几个参数代表啥意思。</p>\n<ul>\n<li>Request URL:<a href=\"https://www.google.com/\" target=\"_blank\" rel=\"noopener\">https://www.google.com/</a>  请求的 URL，这里我们访问的是 Google 首页。</li>\n<li>Request Method:GET 请求方式，这里采用的是 GET 方式请求。</li>\n<li>Status Code:200  状态码 200 ，表示 OK。</li>\n<li>Remote Address:127.0.0.1:1080 这里表示请求的远端 IP 地址及端口，因为我是科学上网，这里才显示了一个回路地址。</li>\n</ul>\n<h4 id=\"Node-js-搭建-http-服务器\"><a href=\"#Node-js-搭建-http-服务器\" class=\"headerlink\" title=\"Node.js 搭建 http 服务器\"></a>Node.js 搭建 http 服务器</h4><p>Node.js 提供了 http 模块，使用 HTTP 服务器或客户端功能必须调用 http 模块，Node.js 搭建一个 http 服务器非常简单，只需要几行代码，来看看把。:P<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引入 http 模块</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建服务，回调函数处理请求（Request）和响应（Response），监听8080端口</span></span><br><span class=\"line\">http.createServer(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">    res.write(<span class=\"string\">'hello,world!'</span>);</span><br><span class=\"line\">    res.end();</span><br><span class=\"line\">&#125;).listen(<span class=\"number\">8080</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Server running at http://127.0.0.1:8080/'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>打开浏览器，输入 <a href=\"http://127.0.0.1:8080/\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:8080/</a> 就可以看到刚刚创建的服务成功啦。<br><img src=\"http://ww4.sinaimg.cn/large/6057861cgw1fbbabbplavj20tg08mmyp.jpg\" alt=\"\"></p>\n<h4 id=\"HTTP-响应内容\"><a href=\"#HTTP-响应内容\" class=\"headerlink\" title=\"HTTP 响应内容\"></a>HTTP 响应内容</h4><p>问题来了，那么如何根据不同的 URL 来响应不同的内容呢？答案很简单，http 服务器在处理 URL 的时候，会根据 URL 的参数来分辨不同的请求内容，根据请求的内容来响应与之对应的内容。一个完整的 URL 长这个样子。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scheme://host.domain:port/path/filename?queryName=queryValue</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>scheme：定义服务类型，常见的如 http</li>\n<li>host：定义域主机，http 通常是 www</li>\n<li>domain：定义域名，比如 google.com</li>\n<li>:port：定义主机的端口号，默认是 80</li>\n<li>path：定义路径，省略 <code>/</code> 表示根目录</li>\n<li>filename：定义文件名</li>\n<li>?queryName=queryValue：查询字符串</li>\n</ul>\n<p>可以看出，想要响应不同的内容，就需要分析出 URL 中的 <code>path</code> 和 <code>filename</code> 以及对应的查询字符串。来看个简单的例子。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"built_in\">require</span>(<span class=\"string\">'url'</span>);<span class=\"comment\">// 引入 url 模块用于处理地址</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> querystring = <span class=\"built_in\">require</span>(<span class=\"string\">'querystring'</span>); <span class=\"comment\">// 引入 querystring 模块</span></span><br><span class=\"line\"></span><br><span class=\"line\">http.createServer(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 首页</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> path = url.parse(req.url).pathname;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (path == <span class=\"string\">'/'</span>) &#123;</span><br><span class=\"line\">        fs.readFile(<span class=\"string\">'./html/index.html'</span>, <span class=\"string\">'utf-8'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, result</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!err) &#123;</span><br><span class=\"line\">                res.write(result);</span><br><span class=\"line\">                res.end();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 登录</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (path == <span class=\"string\">'/login'</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//&#123;...&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 登录验证</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (path == <span class=\"string\">'/checkLogin'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> queryObj = querystring.parse(url.parse(req.url).query);</span><br><span class=\"line\">        <span class=\"comment\">// querystring.parse() 把查询字符串转成对象，&#123; usr: 'admin', pwd: '123' &#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (queryObj.usr == <span class=\"string\">'admin'</span> &amp;&amp; queryObj.pwd == <span class=\"string\">'123'</span>) &#123;</span><br><span class=\"line\">            res.write(<span class=\"string\">'Login Success!'</span>);</span><br><span class=\"line\">            res.end();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;).listen(<span class=\"number\">8080</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Server running at http://127.0.0.1:8080/'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"HTTP-响应状态码\"><a href=\"#HTTP-响应状态码\" class=\"headerlink\" title=\"HTTP 响应状态码\"></a>HTTP 响应状态码</h4><p>HTTP 状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP 状态码共分为 5 种类型：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">分类</th>\n<th style=\"text-align:left\">分类描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">1**</td>\n<td style=\"text-align:left\">信息，服务器收到请求，需要请求者继续执行操作</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2**</td>\n<td style=\"text-align:left\">成功，操作被成功接收并处理</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3**</td>\n<td style=\"text-align:left\">重定向，需要进一步的操作以完成请求</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">4**</td>\n<td style=\"text-align:left\">客户端错误，请求包含语法错误或无法完成请求</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">5**</td>\n<td style=\"text-align:left\">服务器错误，服务器在处理请求的过程中发生了错误</td>\n</tr>\n</tbody>\n</table>\n<p>需要记住常见的几种就可以了，另外的可以<a href=\"http://tools.jb51.net/table/http_status_code\" target=\"_blank\" rel=\"noopener\">查手册</a>找到非常详细的解释。</p>\n<ul>\n<li>200    OK    请求成功。一般用于 GET 与 POST 请求。</li>\n<li>304    Not Modified    未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。</li>\n<li>404    Not Found    服务器无法根据客户端的请求找到资源（网页）。</li>\n<li>500    Internal Server Error    服务器内部错误，无法完成请求。</li>\n</ul>\n<h4 id=\"HTTP-响应不同的数据类型\"><a href=\"#HTTP-响应不同的数据类型\" class=\"headerlink\" title=\"HTTP 响应不同的数据类型\"></a>HTTP 响应不同的数据类型</h4><p>服务器具有返回各种数据的能力，但是返回数据时，应告诉浏览器返回的是一个什么文件。通过 <code>Content-Type</code> 可以设置，响应的数据类型。来看个简单的例子。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">http.createServer(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 设置响应的状态码，数据类型</span></span><br><span class=\"line\">    res.writeHeader(<span class=\"string\">'200'</span>, &#123;<span class=\"string\">'Content-Type'</span>: <span class=\"string\">'image/png;charset=utf-8'</span>&#125;);</span><br><span class=\"line\">    fs.readFile(<span class=\"string\">'./hello.png'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, result</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!err) &#123;</span><br><span class=\"line\">            res.write(result);</span><br><span class=\"line\">            res.end();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;).listen(<span class=\"number\">8080</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Server running at http://127.0.0.1:8080/'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>可以通过 <a href=\"https://github.com/broofa/node-mime\" target=\"_blank\" rel=\"noopener\">node-mime</a> 来查询各种文件的数据类型。先用 npm 安装。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install mime --save</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mime = <span class=\"built_in\">require</span>(<span class=\"string\">'mime'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(mime.lookup(<span class=\"string\">'test.txt'</span>));   <span class=\"comment\">// text/plain</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(mime.lookup(<span class=\"string\">'test.html'</span>));  <span class=\"comment\">// text/html</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(mime.lookup(<span class=\"string\">'test.css'</span>));   <span class=\"comment\">// text/css</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(mime.lookup(<span class=\"string\">'test.js'</span>));    <span class=\"comment\">// application/javascript</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(mime.lookup(<span class=\"string\">'test.mp3'</span>));   <span class=\"comment\">// audio/mpeg</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Web-客户端数据传递\"><a href=\"#Web-客户端数据传递\" class=\"headerlink\" title=\"Web 客户端数据传递\"></a>Web 客户端数据传递</h3><h4 id=\"通过-URL-传递\"><a href=\"#通过-URL-传递\" class=\"headerlink\" title=\"通过 URL 传递\"></a>通过 URL 传递</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scheme://host.domain:port/path/filename?queryName=queryValue</span><br></pre></td></tr></table></figure>\n<p>其中 <code>?queryName=queryValue</code> 就是通过 URL 传递的数据，举个例子：<code>?usr=admin&amp;pwd=123</code> 就表示传递一个 <code>usr</code> 为 <code>admin</code> ，<code>pwd</code> 为 <code>123</code> 的数据到后台。</p>\n<h4 id=\"通过表单传递\"><a href=\"#通过表单传递\" class=\"headerlink\" title=\"通过表单传递\"></a>通过表单传递</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">\"/user\"</span> <span class=\"attr\">method</span>=<span class=\"string\">\"get\"</span>&gt;</span></span><br><span class=\"line\">    用户名：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"username\"</span>/&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>/&gt;</span></span><br><span class=\"line\">    密 码：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"password\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"password\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"submit\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"提交\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>action：提交到服务器处理程序的 url 地址</li>\n<li>method：提交方式有 <code>GET</code> 和 <code>POST</code></li>\n<li>GET：会把表单数据作为 URL 的一部分显示在地址栏中，URL 长度有限制不能提交大量数据</li>\n<li>POST：会把表单数据放到 HTTP 请求体中，相对安全，而且可以提交大量数据（比如文件）</li>\n</ul>\n<h4 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h4><p>前面讲了，在服务器端，返回给浏览器数据时，会通过 <code>Content-Type</code> 指定数据类型，同样的，浏览器向服务器传递数据时，也需要指定数据类型。在这两种数据传递方式中，表单传递数据时，<code>POST</code> 方式，必须指定数据类型，举个简单的例子。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">\"/user\"</span> <span class=\"attr\">method</span>=<span class=\"string\">\"post\"</span> <span class=\"attr\">enctype</span>=<span class=\"string\">\"multipart/form-data\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"file\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"submit\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"上传\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p><code>enctype</code> 指定 POST 的数据类型，默认是 <code>application/x-www-form-urlencoded</code>，上传文件时，就需要 <code>multipart/form-data</code> 类型了。</p>\n","site":{"data":{}},"excerpt":"<p>本次的学习内容是 Node.js Web 模块，介绍了什么是 web 服务器，以及常见的几种模式，比如 B/S 模式（Browser/Server，浏览器/服务器模式），C/S 模式（Client/Server，客户端/服务器模式）等。Web 客户端通过使用 HTTP 协议就能访问到 Web 服务器上的数据，Web 服务器响应客户端的请求。<br>","more":"</p>\n<h3 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h3><h4 id=\"HTTP-协议\"><a href=\"#HTTP-协议\" class=\"headerlink\" title=\"HTTP 协议\"></a>HTTP 协议</h4><p><strong><em>HTTP</em></strong>  协议是 Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网服务器传输超文本到本地浏览器的传送协议。用于定义 Web 浏览器与 Web 服务器之间交换数据的过程以及数据本身的格式。</p>\n<p>简单理解其实就是一种规范，以何种方式请求，以何种方式应答。特点嘛，<strong><em>一次请求（Request）对应一次响应（Response）</em></strong>。来看一个简单例子，访问 Google 首页的请求和应答。<br><img src=\"http://ww3.sinaimg.cn/large/6057861cgw1fbb9dlv1ylj20xy0ts7ct.jpg\" alt=\"\"></p>\n<p>在第一栏 General 中可以看到本次的请求目标，来解释一下这几个参数代表啥意思。</p>\n<ul>\n<li>Request URL:<a href=\"https://www.google.com/\" target=\"_blank\" rel=\"noopener\">https://www.google.com/</a>  请求的 URL，这里我们访问的是 Google 首页。</li>\n<li>Request Method:GET 请求方式，这里采用的是 GET 方式请求。</li>\n<li>Status Code:200  状态码 200 ，表示 OK。</li>\n<li>Remote Address:127.0.0.1:1080 这里表示请求的远端 IP 地址及端口，因为我是科学上网，这里才显示了一个回路地址。</li>\n</ul>\n<h4 id=\"Node-js-搭建-http-服务器\"><a href=\"#Node-js-搭建-http-服务器\" class=\"headerlink\" title=\"Node.js 搭建 http 服务器\"></a>Node.js 搭建 http 服务器</h4><p>Node.js 提供了 http 模块，使用 HTTP 服务器或客户端功能必须调用 http 模块，Node.js 搭建一个 http 服务器非常简单，只需要几行代码，来看看把。:P<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引入 http 模块</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建服务，回调函数处理请求（Request）和响应（Response），监听8080端口</span></span><br><span class=\"line\">http.createServer(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">    res.write(<span class=\"string\">'hello,world!'</span>);</span><br><span class=\"line\">    res.end();</span><br><span class=\"line\">&#125;).listen(<span class=\"number\">8080</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Server running at http://127.0.0.1:8080/'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>打开浏览器，输入 <a href=\"http://127.0.0.1:8080/\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:8080/</a> 就可以看到刚刚创建的服务成功啦。<br><img src=\"http://ww4.sinaimg.cn/large/6057861cgw1fbbabbplavj20tg08mmyp.jpg\" alt=\"\"></p>\n<h4 id=\"HTTP-响应内容\"><a href=\"#HTTP-响应内容\" class=\"headerlink\" title=\"HTTP 响应内容\"></a>HTTP 响应内容</h4><p>问题来了，那么如何根据不同的 URL 来响应不同的内容呢？答案很简单，http 服务器在处理 URL 的时候，会根据 URL 的参数来分辨不同的请求内容，根据请求的内容来响应与之对应的内容。一个完整的 URL 长这个样子。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scheme://host.domain:port/path/filename?queryName=queryValue</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>scheme：定义服务类型，常见的如 http</li>\n<li>host：定义域主机，http 通常是 www</li>\n<li>domain：定义域名，比如 google.com</li>\n<li>:port：定义主机的端口号，默认是 80</li>\n<li>path：定义路径，省略 <code>/</code> 表示根目录</li>\n<li>filename：定义文件名</li>\n<li>?queryName=queryValue：查询字符串</li>\n</ul>\n<p>可以看出，想要响应不同的内容，就需要分析出 URL 中的 <code>path</code> 和 <code>filename</code> 以及对应的查询字符串。来看个简单的例子。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"built_in\">require</span>(<span class=\"string\">'url'</span>);<span class=\"comment\">// 引入 url 模块用于处理地址</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> querystring = <span class=\"built_in\">require</span>(<span class=\"string\">'querystring'</span>); <span class=\"comment\">// 引入 querystring 模块</span></span><br><span class=\"line\"></span><br><span class=\"line\">http.createServer(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 首页</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> path = url.parse(req.url).pathname;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (path == <span class=\"string\">'/'</span>) &#123;</span><br><span class=\"line\">        fs.readFile(<span class=\"string\">'./html/index.html'</span>, <span class=\"string\">'utf-8'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, result</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!err) &#123;</span><br><span class=\"line\">                res.write(result);</span><br><span class=\"line\">                res.end();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 登录</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (path == <span class=\"string\">'/login'</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//&#123;...&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 登录验证</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (path == <span class=\"string\">'/checkLogin'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> queryObj = querystring.parse(url.parse(req.url).query);</span><br><span class=\"line\">        <span class=\"comment\">// querystring.parse() 把查询字符串转成对象，&#123; usr: 'admin', pwd: '123' &#125;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (queryObj.usr == <span class=\"string\">'admin'</span> &amp;&amp; queryObj.pwd == <span class=\"string\">'123'</span>) &#123;</span><br><span class=\"line\">            res.write(<span class=\"string\">'Login Success!'</span>);</span><br><span class=\"line\">            res.end();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;).listen(<span class=\"number\">8080</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Server running at http://127.0.0.1:8080/'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"HTTP-响应状态码\"><a href=\"#HTTP-响应状态码\" class=\"headerlink\" title=\"HTTP 响应状态码\"></a>HTTP 响应状态码</h4><p>HTTP 状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP 状态码共分为 5 种类型：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">分类</th>\n<th style=\"text-align:left\">分类描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">1**</td>\n<td style=\"text-align:left\">信息，服务器收到请求，需要请求者继续执行操作</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2**</td>\n<td style=\"text-align:left\">成功，操作被成功接收并处理</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3**</td>\n<td style=\"text-align:left\">重定向，需要进一步的操作以完成请求</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">4**</td>\n<td style=\"text-align:left\">客户端错误，请求包含语法错误或无法完成请求</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">5**</td>\n<td style=\"text-align:left\">服务器错误，服务器在处理请求的过程中发生了错误</td>\n</tr>\n</tbody>\n</table>\n<p>需要记住常见的几种就可以了，另外的可以<a href=\"http://tools.jb51.net/table/http_status_code\" target=\"_blank\" rel=\"noopener\">查手册</a>找到非常详细的解释。</p>\n<ul>\n<li>200    OK    请求成功。一般用于 GET 与 POST 请求。</li>\n<li>304    Not Modified    未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。</li>\n<li>404    Not Found    服务器无法根据客户端的请求找到资源（网页）。</li>\n<li>500    Internal Server Error    服务器内部错误，无法完成请求。</li>\n</ul>\n<h4 id=\"HTTP-响应不同的数据类型\"><a href=\"#HTTP-响应不同的数据类型\" class=\"headerlink\" title=\"HTTP 响应不同的数据类型\"></a>HTTP 响应不同的数据类型</h4><p>服务器具有返回各种数据的能力，但是返回数据时，应告诉浏览器返回的是一个什么文件。通过 <code>Content-Type</code> 可以设置，响应的数据类型。来看个简单的例子。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">http.createServer(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 设置响应的状态码，数据类型</span></span><br><span class=\"line\">    res.writeHeader(<span class=\"string\">'200'</span>, &#123;<span class=\"string\">'Content-Type'</span>: <span class=\"string\">'image/png;charset=utf-8'</span>&#125;);</span><br><span class=\"line\">    fs.readFile(<span class=\"string\">'./hello.png'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, result</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!err) &#123;</span><br><span class=\"line\">            res.write(result);</span><br><span class=\"line\">            res.end();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;).listen(<span class=\"number\">8080</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Server running at http://127.0.0.1:8080/'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>可以通过 <a href=\"https://github.com/broofa/node-mime\" target=\"_blank\" rel=\"noopener\">node-mime</a> 来查询各种文件的数据类型。先用 npm 安装。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install mime --save</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mime = <span class=\"built_in\">require</span>(<span class=\"string\">'mime'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(mime.lookup(<span class=\"string\">'test.txt'</span>));   <span class=\"comment\">// text/plain</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(mime.lookup(<span class=\"string\">'test.html'</span>));  <span class=\"comment\">// text/html</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(mime.lookup(<span class=\"string\">'test.css'</span>));   <span class=\"comment\">// text/css</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(mime.lookup(<span class=\"string\">'test.js'</span>));    <span class=\"comment\">// application/javascript</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(mime.lookup(<span class=\"string\">'test.mp3'</span>));   <span class=\"comment\">// audio/mpeg</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Web-客户端数据传递\"><a href=\"#Web-客户端数据传递\" class=\"headerlink\" title=\"Web 客户端数据传递\"></a>Web 客户端数据传递</h3><h4 id=\"通过-URL-传递\"><a href=\"#通过-URL-传递\" class=\"headerlink\" title=\"通过 URL 传递\"></a>通过 URL 传递</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scheme://host.domain:port/path/filename?queryName=queryValue</span><br></pre></td></tr></table></figure>\n<p>其中 <code>?queryName=queryValue</code> 就是通过 URL 传递的数据，举个例子：<code>?usr=admin&amp;pwd=123</code> 就表示传递一个 <code>usr</code> 为 <code>admin</code> ，<code>pwd</code> 为 <code>123</code> 的数据到后台。</p>\n<h4 id=\"通过表单传递\"><a href=\"#通过表单传递\" class=\"headerlink\" title=\"通过表单传递\"></a>通过表单传递</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">\"/user\"</span> <span class=\"attr\">method</span>=<span class=\"string\">\"get\"</span>&gt;</span></span><br><span class=\"line\">    用户名：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"username\"</span>/&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>/&gt;</span></span><br><span class=\"line\">    密 码：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"password\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"password\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"submit\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"提交\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>action：提交到服务器处理程序的 url 地址</li>\n<li>method：提交方式有 <code>GET</code> 和 <code>POST</code></li>\n<li>GET：会把表单数据作为 URL 的一部分显示在地址栏中，URL 长度有限制不能提交大量数据</li>\n<li>POST：会把表单数据放到 HTTP 请求体中，相对安全，而且可以提交大量数据（比如文件）</li>\n</ul>\n<h4 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h4><p>前面讲了，在服务器端，返回给浏览器数据时，会通过 <code>Content-Type</code> 指定数据类型，同样的，浏览器向服务器传递数据时，也需要指定数据类型。在这两种数据传递方式中，表单传递数据时，<code>POST</code> 方式，必须指定数据类型，举个简单的例子。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">\"/user\"</span> <span class=\"attr\">method</span>=<span class=\"string\">\"post\"</span> <span class=\"attr\">enctype</span>=<span class=\"string\">\"multipart/form-data\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"file\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"submit\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"上传\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p><code>enctype</code> 指定 POST 的数据类型，默认是 <code>application/x-www-form-urlencoded</code>，上传文件时，就需要 <code>multipart/form-data</code> 类型了。</p>"},{"title":"Node.JS 学习笔记 [03] -- Buffer fs path","date":"2015-01-04T13:57:05.000Z","comments":0,"_content":"\n今天学习了 Node.js 的缓冲区（Buffer）、文件系统（fs）、路径（path）模块，感受了一下 Node.js 作为 JavaScript 的扩展在后台方面的一些功能。给我最多的感受是，大量的异步代码和回调函数，让 Node.js 性能非常出色。来总结下今天学习的内容吧。\n<!-- more -->\n### 缓冲区 (Buffer)\nJavaScript 语言自身只有字符串数据类型，没有二进制数据类型。但在处理像 TCP 流或文件流时，必须使用到二进制数据。因此在 Node.js 中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。按照我的理解，Buffer 类很像我们的整数数组。有对应的索引，存储方式也和数组类似。来看看 Buffer 类是如何创建的。\n#### 创建 Buffer 类\n```js\n// 方法1\n// 创建长度为10字节的 Buffer 类\nvar buf = new Buffer(10); // 构造函数，注意这种创建形式\n\n// 方法2\n// 直接通过数组赋值的形式创建\nvar buf2 = new Buffer([1,2,3,4,5]);\n\n// 方法3\n// 通过字符串来创建\nvar buf3 = new Buffer('ifyour','utf-8');// utf-8 默认编码，可以省略\n```\n从代码我们可以看出这个 Buffer 类是一个构造函数，通过实例化一个 Buffer 对象，让它具有一些 Buffer 类的方法，总得来说常用的方法有下面三种。\n#### 写入缓冲区\n```js\n// 语法：  buf.write(string[, offset[, length]][, encoding])\n// 实例：\n\nvar b4 = new Buffer(14);\nlen = b4.write('this is buffer');\nconsole.log('Buffer 写入了 ' + len + ' 字节，内容为：' + b4.toString());\n// Buffer 写入了 14字节，内容为：this is buffer\n```\n#### 缓冲区读取\n```js\n// 语法： buf.toString([encoding[, start[, end]]])\n// 实例：\nbuf = new Buffer(26);\nfor (var i = 0 ; i < 26 ; i++) {\n  buf[i] = i + 97;\n}\n\nconsole.log( buf.toString('ascii'));       // 输出: abcdefghijklmnopqrstuvwxyz\nconsole.log( buf.toString('ascii',0,5));   // 输出: abcde\nconsole.log( buf.toString('utf8',0,5));    // 输出: abcde\nconsole.log( buf.toString(undefined,0,5)); // 使用 'utf8' 编码, 并输出: abcde\n```\n\n#### 缓冲区拷贝\n```js\n//语法： buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]])\n//实例：\nvar b5 = new Buffer([1,2,3,4,5]);\nvar b6 = new  Buffer(5);\n\nb5.copy(b6,1,0,2);// 把 b5 中的索引 0-2 （不包括2） 的值复制给 b6 的第 1 位置\nconsole.log(b6);\n```\n### 文件系统 (fs)\nNode.js 文件系统（fs 模块）模块中的方法均有异步和同步版本，例如读取文件内容的函数有异步的 `fs.readFile()` 和同步的 `fs.readFileSync()`。异步的方法函数最后一个参数为回调函数，回调函数的第一个参数包含了错误信息 (error)。相比同步，异步效率更高，性能更好，没有阻塞，但是在实际使用中，一定要处理好先后顺序。\n\n#### 文件读写方式\n文件读取方式，举个简单例子，好比先把整个数据源完整拿出来放到内存中，再使用 `writeFile` 方法或 `writeFileSync` 方法写入文件内容。显然，如果数据源非常大（10GB）使用这种方式，效率就很低了。说不定就死机了。:) 这时候，就需要下一节讲到的 ***流读取***。\n\n```Text\n// data.txt\nHello,Node.js!\n```\n```js\nvar fs = require(\"fs\");\n\n// 异步读取\nfs.readFile('data.txt', function (err, data) {\n   if (err) {\n       return console.error(err);\n   }\n   console.log(\"异步读取: \" + data.toString());\n});\n\n// 同步读取\nvar data = fs.readFileSync('data.txt');\nconsole.log(\"同步读取: \" + data.toString());\n\nconsole.log(\"程序执行完毕。\");\n```\n\n```Text\n同步读取: Hello,Node.js!\n程序执行完毕。\n\n异步读取: Hello,Node.js!\n```\n\n<div class=\"tip\">\nNode.js 中，先执行同步代码，后执行异步代码，异步代码会将回调函数放入调用 ***队列***，以 ***先进先出*** 的形式依次调用。\n</div>\n\n```js\nvar fs = require('fs');\n// 异步写入\nfs.writeFile('./data/d2.txt','我是一条数据',function (err) {\n    if (!err){\n        console.log('文件写入成功');\n    }else {\n        console.log('写入失败');\n    }\n});\n\n// 同步写入\nfs.writeFileSync('./data/d3','我是一条数据');\n\nvar data = fs.readFileSync('./data/d3');\n\nconsole.log(data.toString());// 我是一条数据\n```\n\n\n#### 流读写方式\n应用程序中，流是一组有序的、有起点和终点的 ***字节数据的传输方式***。在应用程序中各种对象之间交换与传输数据的时候，总是先将该对象中所包含的数据转换为各种形式的流数据（即字节数据），再通过流的传输，到达目的对象后再将流数据转换为该对象中可以使用的数据。\n\n```js\nvar fs = require('fs');\nvar data = '';\n// 流读取\nvar stream = fs.createReadStream('./data/d1.txt','utf-8');\nstream.on('data',function (result) {\n    data += result;\n});\n// data end 事件表示连贯的行为，字节流需要起点和终点。\nstream.on('end',function () {\n    console.log(data);\n});\n\nstream.on('error',function (err) {\n    console.log(err.stack);\n});\n\n// 流写入\nvar stream = fs.createWriteStream('./data/123.txt','utf-8');\nstream.write('hello','utf-8');\n\nstream.end();\n\nstream.on('finish',function () {// finish 事件触发，必须等 end 事件结束才可以\n   console.log('写入完成！');\n});\n\nstream.on('error', function(err){\n    console.log(err.stack);\n});\n```\n<div class=\"tip\">\n流读取会依次触发事件： data -> end -> error ,每个事件发生会有对应的回调函数处理。\n流写入会依次触发事件： end -> finish -> error ,每个事件发生会有对应的回调函数处理。\n</div>\n\n#### 管道流读写\n管道(pipe) 提供了一个输出流到输入流的机制。通常我们用于从一个流中获取数据并将数据传递到另外一个流中。通过管道，我们就可以实现大文件流入另外一个文件的复制过程。\n```js\nvar fs = require('fs');\n\nvar readStream = fs.createReadStream('./data/d1.txt');\n\nvar writeStrem = fs.createWriteStream('./data/d3.txt');\n\nreadStream.pipe(writeStrem);// 实现了 d1.txt 到 d3.txt 的传输过程\n```\n\n#### 链式流读写\n链式是通过连接输出流到另外一个流并创建多个对个流操作链的机制。链式流一般用于管道操作。接下来我们就是用管道和链式来压缩和解压文件。\n```js\n// compress.js\nvar fs = require('fs');\nvar zlib = require('zlib'); // 引入压缩模块\n\nfs.createReadStream('./data/123.txt')\n    .pipe(zlib.createGzip())\n    .pipe(fs.createWriteStream('./data/123.txt.gz'));// 链式操作\nconsole.log('文件压缩完成');\n```\n#### 文件、文件夹删除\n```js\nvar fs = require(\"fs\");\n// 文件目录读取，返回一个数组，包含文件及文件夹\nfs.readdir(\"./testdir\",function(err,files){\n    if (!err){\n        console.log(files);// [ 'index.html', 'main.css', 'subdir' ]\n    }else {\n        console.log(err);\n    }\n});\n\n// 文件删除\nconsole.log(\"准备删除文件！\");\nfs.unlink('./data/123.txt.gz', function(err) {\n    if (err) {\n        return err;\n    }\n    console.log(\"文件删除成功！\");\n});\n\n// 空文件夹删除\nfs.rmdir('./data',function (err) {\n    if (!err){\n        console.log('删除成功！');\n    }else {\n        console.log(err);\n    }\n});\n\n```\n一个递归删除的小练习，把前面的综合运用一下。\n```js\ndelDir('./testdir');\n\n// 传入一个文件夹路径，删除掉该文件夹所有内容\n// @param pathStr string 传入一个路径\nfunction delDir(pathStr) {\n    var fs = require('fs');\n    if (fs.existsSync(pathStr)){\n        var files = fs.readdirSync(pathStr);\n        for (var i = 0; i < files.length; i++) {\n            var curPath = pathStr + '/' + files[i];\n            var stats = fs.statSync(curPath);\n            if (stats.isFile()){\n                fs.unlink(curPath);\n            }else if(stats.isDirectory()){\n                delDir(curPath);// 递归调用，最终删除掉所有文件，只剩空目录\n            }\n        }\n        fs.rmdirSync(pathStr);// 收尾，删掉空目录\n    }else {\n        console.log('文件夹不存在');\n    }\n}\n```\n<div class=\"tip\">\n文件、文件夹的操作，都有同步和异步的代码，比如 `fs.unlink()` 和 `fs.unlinkSync()`,默认都是异步代码，异步代码会调用回调函数进行操作，同步代码会返回一个对象，进行后续的操作，可以认真观察上面代码的区别。使用异步代码的时候，一定注意执行顺序。\n</div>\n\n\n### 路径 (path)\npath 模块包含一套用于 ***处理和转换文件路径*** 的工具集，用于处理目录的对象，提高开发效率。用 Node.js 的 path 命令，与使用 Linux 下的 shell 脚本命令相似。几乎所有的方法仅对字符串进行转换，文件系统是不会检查路径是否真实有效。\n```js\n// 引入path对象\nvar path = require('path');\n\n/*\n* 格式化路径  path.normalize(p)\n* 特点：将不符合规范的路径格式化，简化开发人员中处理各种复杂的路径判断\n* */\npath.normalize('/foo/bar//baz/asdf/quux/..');\n// returns\n'/foo/bar/baz/asdf'\n\n/*\n* 路径联合 path.join([path1], [path2], [...])\n* 特点：将所有名称用path.seq串联起来，然后用normailze格式化\n* */\npath.join('///foo', 'bar', '//baz/asdf', 'quux', '..');\n// returns\n'/foo/bar/baz/asdf'\n\n/*\n* 路径寻航 path.resolve([from ...], to)\n* 特点：相当于不断的调用系统的cd命令\n* */\npath.resolve('foo/bar', '/tmp/file/', '..', 'a/../subfile');\n// 相当于终端命令：\n// cd foo/bar\n// cd /tmp/file/\n// cd ..\n// cd a/../subfile\n// pwd\n\n/*\n* 相对路径 path.relative(from, to)\n* 特点：返回某个路径下相对于另一个路径的相对位置串，\n* 相当于：path.resolve(from, path.relative(from, to)) == path.resolve(to)\n* */\n//简单理解： 地址一执行怎样的 shell 命令，到达地址二\npath.relative('/data/orandea/test/aaa', '/data/orandea/impl/bbb')\n// returns\n'../../impl/bbb'\n\n/*\n* 文件夹名称 path.dirname(p)\n* 特点：返回路径的上级路径\n* */\npath.dirname('/foo/bar/baz/asdf/quux')\n// returns\n'/foo/bar/baz/asdf'\n\n/*\n* 文件名称 path.basename(p, [ext])\n* 特点：返回指定的文件名，返回结果可去掉[ext]后缀字符串\n* */\npath.basename('/foo/bar/baz/asdf/quux.html')\n// returns\n'quux.html'\n\npath.basename('/foo/bar/baz/asdf/quux.html', '.html')\n// returns\n'quux'\n\n/*\n* 扩展名称 path.extname(p)\n* 特点：返回指定文件名的扩展名称\n* */\npath.extname('index.html')\n// returns\n'.html'\n\npath.extname('index.')\n// returns\n'.'\n\npath.extname('index')\n// returns\n''\n\n/*\n* 路径分隔符 path.sep\n* 特点：获取文件路径的分隔符，主要是与操作系统相关\n* 注意调用方式\n* */\n'foo/bar/baz'.split(path.sep)\n// returns\n['foo', 'bar', 'baz']\n```\n","source":"_posts/Node.JS-学习笔记-[03]----Buffer-fs-path.md","raw":"---\ntitle: 'Node.JS 学习笔记 [03] -- Buffer fs path'\ndate: 2015-1-4 21:57:05\ntags:\ncomments: false\n---\n\n今天学习了 Node.js 的缓冲区（Buffer）、文件系统（fs）、路径（path）模块，感受了一下 Node.js 作为 JavaScript 的扩展在后台方面的一些功能。给我最多的感受是，大量的异步代码和回调函数，让 Node.js 性能非常出色。来总结下今天学习的内容吧。\n<!-- more -->\n### 缓冲区 (Buffer)\nJavaScript 语言自身只有字符串数据类型，没有二进制数据类型。但在处理像 TCP 流或文件流时，必须使用到二进制数据。因此在 Node.js 中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。按照我的理解，Buffer 类很像我们的整数数组。有对应的索引，存储方式也和数组类似。来看看 Buffer 类是如何创建的。\n#### 创建 Buffer 类\n```js\n// 方法1\n// 创建长度为10字节的 Buffer 类\nvar buf = new Buffer(10); // 构造函数，注意这种创建形式\n\n// 方法2\n// 直接通过数组赋值的形式创建\nvar buf2 = new Buffer([1,2,3,4,5]);\n\n// 方法3\n// 通过字符串来创建\nvar buf3 = new Buffer('ifyour','utf-8');// utf-8 默认编码，可以省略\n```\n从代码我们可以看出这个 Buffer 类是一个构造函数，通过实例化一个 Buffer 对象，让它具有一些 Buffer 类的方法，总得来说常用的方法有下面三种。\n#### 写入缓冲区\n```js\n// 语法：  buf.write(string[, offset[, length]][, encoding])\n// 实例：\n\nvar b4 = new Buffer(14);\nlen = b4.write('this is buffer');\nconsole.log('Buffer 写入了 ' + len + ' 字节，内容为：' + b4.toString());\n// Buffer 写入了 14字节，内容为：this is buffer\n```\n#### 缓冲区读取\n```js\n// 语法： buf.toString([encoding[, start[, end]]])\n// 实例：\nbuf = new Buffer(26);\nfor (var i = 0 ; i < 26 ; i++) {\n  buf[i] = i + 97;\n}\n\nconsole.log( buf.toString('ascii'));       // 输出: abcdefghijklmnopqrstuvwxyz\nconsole.log( buf.toString('ascii',0,5));   // 输出: abcde\nconsole.log( buf.toString('utf8',0,5));    // 输出: abcde\nconsole.log( buf.toString(undefined,0,5)); // 使用 'utf8' 编码, 并输出: abcde\n```\n\n#### 缓冲区拷贝\n```js\n//语法： buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]])\n//实例：\nvar b5 = new Buffer([1,2,3,4,5]);\nvar b6 = new  Buffer(5);\n\nb5.copy(b6,1,0,2);// 把 b5 中的索引 0-2 （不包括2） 的值复制给 b6 的第 1 位置\nconsole.log(b6);\n```\n### 文件系统 (fs)\nNode.js 文件系统（fs 模块）模块中的方法均有异步和同步版本，例如读取文件内容的函数有异步的 `fs.readFile()` 和同步的 `fs.readFileSync()`。异步的方法函数最后一个参数为回调函数，回调函数的第一个参数包含了错误信息 (error)。相比同步，异步效率更高，性能更好，没有阻塞，但是在实际使用中，一定要处理好先后顺序。\n\n#### 文件读写方式\n文件读取方式，举个简单例子，好比先把整个数据源完整拿出来放到内存中，再使用 `writeFile` 方法或 `writeFileSync` 方法写入文件内容。显然，如果数据源非常大（10GB）使用这种方式，效率就很低了。说不定就死机了。:) 这时候，就需要下一节讲到的 ***流读取***。\n\n```Text\n// data.txt\nHello,Node.js!\n```\n```js\nvar fs = require(\"fs\");\n\n// 异步读取\nfs.readFile('data.txt', function (err, data) {\n   if (err) {\n       return console.error(err);\n   }\n   console.log(\"异步读取: \" + data.toString());\n});\n\n// 同步读取\nvar data = fs.readFileSync('data.txt');\nconsole.log(\"同步读取: \" + data.toString());\n\nconsole.log(\"程序执行完毕。\");\n```\n\n```Text\n同步读取: Hello,Node.js!\n程序执行完毕。\n\n异步读取: Hello,Node.js!\n```\n\n<div class=\"tip\">\nNode.js 中，先执行同步代码，后执行异步代码，异步代码会将回调函数放入调用 ***队列***，以 ***先进先出*** 的形式依次调用。\n</div>\n\n```js\nvar fs = require('fs');\n// 异步写入\nfs.writeFile('./data/d2.txt','我是一条数据',function (err) {\n    if (!err){\n        console.log('文件写入成功');\n    }else {\n        console.log('写入失败');\n    }\n});\n\n// 同步写入\nfs.writeFileSync('./data/d3','我是一条数据');\n\nvar data = fs.readFileSync('./data/d3');\n\nconsole.log(data.toString());// 我是一条数据\n```\n\n\n#### 流读写方式\n应用程序中，流是一组有序的、有起点和终点的 ***字节数据的传输方式***。在应用程序中各种对象之间交换与传输数据的时候，总是先将该对象中所包含的数据转换为各种形式的流数据（即字节数据），再通过流的传输，到达目的对象后再将流数据转换为该对象中可以使用的数据。\n\n```js\nvar fs = require('fs');\nvar data = '';\n// 流读取\nvar stream = fs.createReadStream('./data/d1.txt','utf-8');\nstream.on('data',function (result) {\n    data += result;\n});\n// data end 事件表示连贯的行为，字节流需要起点和终点。\nstream.on('end',function () {\n    console.log(data);\n});\n\nstream.on('error',function (err) {\n    console.log(err.stack);\n});\n\n// 流写入\nvar stream = fs.createWriteStream('./data/123.txt','utf-8');\nstream.write('hello','utf-8');\n\nstream.end();\n\nstream.on('finish',function () {// finish 事件触发，必须等 end 事件结束才可以\n   console.log('写入完成！');\n});\n\nstream.on('error', function(err){\n    console.log(err.stack);\n});\n```\n<div class=\"tip\">\n流读取会依次触发事件： data -> end -> error ,每个事件发生会有对应的回调函数处理。\n流写入会依次触发事件： end -> finish -> error ,每个事件发生会有对应的回调函数处理。\n</div>\n\n#### 管道流读写\n管道(pipe) 提供了一个输出流到输入流的机制。通常我们用于从一个流中获取数据并将数据传递到另外一个流中。通过管道，我们就可以实现大文件流入另外一个文件的复制过程。\n```js\nvar fs = require('fs');\n\nvar readStream = fs.createReadStream('./data/d1.txt');\n\nvar writeStrem = fs.createWriteStream('./data/d3.txt');\n\nreadStream.pipe(writeStrem);// 实现了 d1.txt 到 d3.txt 的传输过程\n```\n\n#### 链式流读写\n链式是通过连接输出流到另外一个流并创建多个对个流操作链的机制。链式流一般用于管道操作。接下来我们就是用管道和链式来压缩和解压文件。\n```js\n// compress.js\nvar fs = require('fs');\nvar zlib = require('zlib'); // 引入压缩模块\n\nfs.createReadStream('./data/123.txt')\n    .pipe(zlib.createGzip())\n    .pipe(fs.createWriteStream('./data/123.txt.gz'));// 链式操作\nconsole.log('文件压缩完成');\n```\n#### 文件、文件夹删除\n```js\nvar fs = require(\"fs\");\n// 文件目录读取，返回一个数组，包含文件及文件夹\nfs.readdir(\"./testdir\",function(err,files){\n    if (!err){\n        console.log(files);// [ 'index.html', 'main.css', 'subdir' ]\n    }else {\n        console.log(err);\n    }\n});\n\n// 文件删除\nconsole.log(\"准备删除文件！\");\nfs.unlink('./data/123.txt.gz', function(err) {\n    if (err) {\n        return err;\n    }\n    console.log(\"文件删除成功！\");\n});\n\n// 空文件夹删除\nfs.rmdir('./data',function (err) {\n    if (!err){\n        console.log('删除成功！');\n    }else {\n        console.log(err);\n    }\n});\n\n```\n一个递归删除的小练习，把前面的综合运用一下。\n```js\ndelDir('./testdir');\n\n// 传入一个文件夹路径，删除掉该文件夹所有内容\n// @param pathStr string 传入一个路径\nfunction delDir(pathStr) {\n    var fs = require('fs');\n    if (fs.existsSync(pathStr)){\n        var files = fs.readdirSync(pathStr);\n        for (var i = 0; i < files.length; i++) {\n            var curPath = pathStr + '/' + files[i];\n            var stats = fs.statSync(curPath);\n            if (stats.isFile()){\n                fs.unlink(curPath);\n            }else if(stats.isDirectory()){\n                delDir(curPath);// 递归调用，最终删除掉所有文件，只剩空目录\n            }\n        }\n        fs.rmdirSync(pathStr);// 收尾，删掉空目录\n    }else {\n        console.log('文件夹不存在');\n    }\n}\n```\n<div class=\"tip\">\n文件、文件夹的操作，都有同步和异步的代码，比如 `fs.unlink()` 和 `fs.unlinkSync()`,默认都是异步代码，异步代码会调用回调函数进行操作，同步代码会返回一个对象，进行后续的操作，可以认真观察上面代码的区别。使用异步代码的时候，一定注意执行顺序。\n</div>\n\n\n### 路径 (path)\npath 模块包含一套用于 ***处理和转换文件路径*** 的工具集，用于处理目录的对象，提高开发效率。用 Node.js 的 path 命令，与使用 Linux 下的 shell 脚本命令相似。几乎所有的方法仅对字符串进行转换，文件系统是不会检查路径是否真实有效。\n```js\n// 引入path对象\nvar path = require('path');\n\n/*\n* 格式化路径  path.normalize(p)\n* 特点：将不符合规范的路径格式化，简化开发人员中处理各种复杂的路径判断\n* */\npath.normalize('/foo/bar//baz/asdf/quux/..');\n// returns\n'/foo/bar/baz/asdf'\n\n/*\n* 路径联合 path.join([path1], [path2], [...])\n* 特点：将所有名称用path.seq串联起来，然后用normailze格式化\n* */\npath.join('///foo', 'bar', '//baz/asdf', 'quux', '..');\n// returns\n'/foo/bar/baz/asdf'\n\n/*\n* 路径寻航 path.resolve([from ...], to)\n* 特点：相当于不断的调用系统的cd命令\n* */\npath.resolve('foo/bar', '/tmp/file/', '..', 'a/../subfile');\n// 相当于终端命令：\n// cd foo/bar\n// cd /tmp/file/\n// cd ..\n// cd a/../subfile\n// pwd\n\n/*\n* 相对路径 path.relative(from, to)\n* 特点：返回某个路径下相对于另一个路径的相对位置串，\n* 相当于：path.resolve(from, path.relative(from, to)) == path.resolve(to)\n* */\n//简单理解： 地址一执行怎样的 shell 命令，到达地址二\npath.relative('/data/orandea/test/aaa', '/data/orandea/impl/bbb')\n// returns\n'../../impl/bbb'\n\n/*\n* 文件夹名称 path.dirname(p)\n* 特点：返回路径的上级路径\n* */\npath.dirname('/foo/bar/baz/asdf/quux')\n// returns\n'/foo/bar/baz/asdf'\n\n/*\n* 文件名称 path.basename(p, [ext])\n* 特点：返回指定的文件名，返回结果可去掉[ext]后缀字符串\n* */\npath.basename('/foo/bar/baz/asdf/quux.html')\n// returns\n'quux.html'\n\npath.basename('/foo/bar/baz/asdf/quux.html', '.html')\n// returns\n'quux'\n\n/*\n* 扩展名称 path.extname(p)\n* 特点：返回指定文件名的扩展名称\n* */\npath.extname('index.html')\n// returns\n'.html'\n\npath.extname('index.')\n// returns\n'.'\n\npath.extname('index')\n// returns\n''\n\n/*\n* 路径分隔符 path.sep\n* 特点：获取文件路径的分隔符，主要是与操作系统相关\n* 注意调用方式\n* */\n'foo/bar/baz'.split(path.sep)\n// returns\n['foo', 'bar', 'baz']\n```\n","slug":"Node.JS-学习笔记-[03]----Buffer-fs-path","published":1,"updated":"2018-12-26T16:01:04.000Z","layout":"post","photos":[],"link":"","_id":"ck3v60jtf000er9q99ta0j9h9","content":"<p>今天学习了 Node.js 的缓冲区（Buffer）、文件系统（fs）、路径（path）模块，感受了一下 Node.js 作为 JavaScript 的扩展在后台方面的一些功能。给我最多的感受是，大量的异步代码和回调函数，让 Node.js 性能非常出色。来总结下今天学习的内容吧。<br><a id=\"more\"></a></p>\n<h3 id=\"缓冲区-Buffer\"><a href=\"#缓冲区-Buffer\" class=\"headerlink\" title=\"缓冲区 (Buffer)\"></a>缓冲区 (Buffer)</h3><p>JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。但在处理像 TCP 流或文件流时，必须使用到二进制数据。因此在 Node.js 中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。按照我的理解，Buffer 类很像我们的整数数组。有对应的索引，存储方式也和数组类似。来看看 Buffer 类是如何创建的。</p>\n<h4 id=\"创建-Buffer-类\"><a href=\"#创建-Buffer-类\" class=\"headerlink\" title=\"创建 Buffer 类\"></a>创建 Buffer 类</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法1</span></span><br><span class=\"line\"><span class=\"comment\">// 创建长度为10字节的 Buffer 类</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> buf = <span class=\"keyword\">new</span> Buffer(<span class=\"number\">10</span>); <span class=\"comment\">// 构造函数，注意这种创建形式</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法2</span></span><br><span class=\"line\"><span class=\"comment\">// 直接通过数组赋值的形式创建</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> buf2 = <span class=\"keyword\">new</span> Buffer([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法3</span></span><br><span class=\"line\"><span class=\"comment\">// 通过字符串来创建</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> buf3 = <span class=\"keyword\">new</span> Buffer(<span class=\"string\">'ifyour'</span>,<span class=\"string\">'utf-8'</span>);<span class=\"comment\">// utf-8 默认编码，可以省略</span></span><br></pre></td></tr></table></figure>\n<p>从代码我们可以看出这个 Buffer 类是一个构造函数，通过实例化一个 Buffer 对象，让它具有一些 Buffer 类的方法，总得来说常用的方法有下面三种。</p>\n<h4 id=\"写入缓冲区\"><a href=\"#写入缓冲区\" class=\"headerlink\" title=\"写入缓冲区\"></a>写入缓冲区</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 语法：  buf.write(string[, offset[, length]][, encoding])</span></span><br><span class=\"line\"><span class=\"comment\">// 实例：</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b4 = <span class=\"keyword\">new</span> Buffer(<span class=\"number\">14</span>);</span><br><span class=\"line\">len = b4.write(<span class=\"string\">'this is buffer'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Buffer 写入了 '</span> + len + <span class=\"string\">' 字节，内容为：'</span> + b4.toString());</span><br><span class=\"line\"><span class=\"comment\">// Buffer 写入了 14字节，内容为：this is buffer</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"缓冲区读取\"><a href=\"#缓冲区读取\" class=\"headerlink\" title=\"缓冲区读取\"></a>缓冲区读取</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 语法： buf.toString([encoding[, start[, end]]])</span></span><br><span class=\"line\"><span class=\"comment\">// 实例：</span></span><br><span class=\"line\">buf = <span class=\"keyword\">new</span> Buffer(<span class=\"number\">26</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">26</span> ; i++) &#123;</span><br><span class=\"line\">  buf[i] = i + <span class=\"number\">97</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( buf.toString(<span class=\"string\">'ascii'</span>));       <span class=\"comment\">// 输出: abcdefghijklmnopqrstuvwxyz</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( buf.toString(<span class=\"string\">'ascii'</span>,<span class=\"number\">0</span>,<span class=\"number\">5</span>));   <span class=\"comment\">// 输出: abcde</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( buf.toString(<span class=\"string\">'utf8'</span>,<span class=\"number\">0</span>,<span class=\"number\">5</span>));    <span class=\"comment\">// 输出: abcde</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( buf.toString(<span class=\"literal\">undefined</span>,<span class=\"number\">0</span>,<span class=\"number\">5</span>)); <span class=\"comment\">// 使用 'utf8' 编码, 并输出: abcde</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"缓冲区拷贝\"><a href=\"#缓冲区拷贝\" class=\"headerlink\" title=\"缓冲区拷贝\"></a>缓冲区拷贝</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//语法： buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]])</span></span><br><span class=\"line\"><span class=\"comment\">//实例：</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b5 = <span class=\"keyword\">new</span> Buffer([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>]);</span><br><span class=\"line\"><span class=\"keyword\">var</span> b6 = <span class=\"keyword\">new</span>  Buffer(<span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">b5.copy(b6,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">2</span>);<span class=\"comment\">// 把 b5 中的索引 0-2 （不包括2） 的值复制给 b6 的第 1 位置</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b6);</span><br></pre></td></tr></table></figure>\n<h3 id=\"文件系统-fs\"><a href=\"#文件系统-fs\" class=\"headerlink\" title=\"文件系统 (fs)\"></a>文件系统 (fs)</h3><p>Node.js 文件系统（fs 模块）模块中的方法均有异步和同步版本，例如读取文件内容的函数有异步的 <code>fs.readFile()</code> 和同步的 <code>fs.readFileSync()</code>。异步的方法函数最后一个参数为回调函数，回调函数的第一个参数包含了错误信息 (error)。相比同步，异步效率更高，性能更好，没有阻塞，但是在实际使用中，一定要处理好先后顺序。</p>\n<h4 id=\"文件读写方式\"><a href=\"#文件读写方式\" class=\"headerlink\" title=\"文件读写方式\"></a>文件读写方式</h4><p>文件读取方式，举个简单例子，好比先把整个数据源完整拿出来放到内存中，再使用 <code>writeFile</code> 方法或 <code>writeFileSync</code> 方法写入文件内容。显然，如果数据源非常大（10GB）使用这种方式，效率就很低了。说不定就死机了。:) 这时候，就需要下一节讲到的 <strong><em>流读取</em></strong>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// data.txt</span><br><span class=\"line\">Hello,Node.js!</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">\"fs\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 异步读取</span></span><br><span class=\"line\">fs.readFile(<span class=\"string\">'data.txt'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, data</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"built_in\">console</span>.error(err);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(<span class=\"string\">\"异步读取: \"</span> + data.toString());</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 同步读取</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> data = fs.readFileSync(<span class=\"string\">'data.txt'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"同步读取: \"</span> + data.toString());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"程序执行完毕。\"</span>);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">同步读取: Hello,Node.js!</span><br><span class=\"line\">程序执行完毕。</span><br><span class=\"line\"></span><br><span class=\"line\">异步读取: Hello,Node.js!</span><br></pre></td></tr></table></figure>\n<div class=\"tip\"><br>Node.js 中，先执行同步代码，后执行异步代码，异步代码会将回调函数放入调用 <strong><em>队列</em></strong>，以 <strong><em>先进先出</em></strong> 的形式依次调用。<br></div>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 异步写入</span></span><br><span class=\"line\">fs.writeFile(<span class=\"string\">'./data/d2.txt'</span>,<span class=\"string\">'我是一条数据'</span>,<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!err)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'文件写入成功'</span>);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'写入失败'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 同步写入</span></span><br><span class=\"line\">fs.writeFileSync(<span class=\"string\">'./data/d3'</span>,<span class=\"string\">'我是一条数据'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> data = fs.readFileSync(<span class=\"string\">'./data/d3'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(data.toString());<span class=\"comment\">// 我是一条数据</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"流读写方式\"><a href=\"#流读写方式\" class=\"headerlink\" title=\"流读写方式\"></a>流读写方式</h4><p>应用程序中，流是一组有序的、有起点和终点的 <strong><em>字节数据的传输方式</em></strong>。在应用程序中各种对象之间交换与传输数据的时候，总是先将该对象中所包含的数据转换为各种形式的流数据（即字节数据），再通过流的传输，到达目的对象后再将流数据转换为该对象中可以使用的数据。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> data = <span class=\"string\">''</span>;</span><br><span class=\"line\"><span class=\"comment\">// 流读取</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> stream = fs.createReadStream(<span class=\"string\">'./data/d1.txt'</span>,<span class=\"string\">'utf-8'</span>);</span><br><span class=\"line\">stream.on(<span class=\"string\">'data'</span>,<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">result</span>) </span>&#123;</span><br><span class=\"line\">    data += result;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// data end 事件表示连贯的行为，字节流需要起点和终点。</span></span><br><span class=\"line\">stream.on(<span class=\"string\">'end'</span>,<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">stream.on(<span class=\"string\">'error'</span>,<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err.stack);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 流写入</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> stream = fs.createWriteStream(<span class=\"string\">'./data/123.txt'</span>,<span class=\"string\">'utf-8'</span>);</span><br><span class=\"line\">stream.write(<span class=\"string\">'hello'</span>,<span class=\"string\">'utf-8'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">stream.end();</span><br><span class=\"line\"></span><br><span class=\"line\">stream.on(<span class=\"string\">'finish'</span>,<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;<span class=\"comment\">// finish 事件触发，必须等 end 事件结束才可以</span></span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(<span class=\"string\">'写入完成！'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">stream.on(<span class=\"string\">'error'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err.stack);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<div class=\"tip\"><br>流读取会依次触发事件： data -&gt; end -&gt; error ,每个事件发生会有对应的回调函数处理。<br>流写入会依次触发事件： end -&gt; finish -&gt; error ,每个事件发生会有对应的回调函数处理。<br></div>\n\n<h4 id=\"管道流读写\"><a href=\"#管道流读写\" class=\"headerlink\" title=\"管道流读写\"></a>管道流读写</h4><p>管道(pipe) 提供了一个输出流到输入流的机制。通常我们用于从一个流中获取数据并将数据传递到另外一个流中。通过管道，我们就可以实现大文件流入另外一个文件的复制过程。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> readStream = fs.createReadStream(<span class=\"string\">'./data/d1.txt'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> writeStrem = fs.createWriteStream(<span class=\"string\">'./data/d3.txt'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">readStream.pipe(writeStrem);<span class=\"comment\">// 实现了 d1.txt 到 d3.txt 的传输过程</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"链式流读写\"><a href=\"#链式流读写\" class=\"headerlink\" title=\"链式流读写\"></a>链式流读写</h4><p>链式是通过连接输出流到另外一个流并创建多个对个流操作链的机制。链式流一般用于管道操作。接下来我们就是用管道和链式来压缩和解压文件。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// compress.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> zlib = <span class=\"built_in\">require</span>(<span class=\"string\">'zlib'</span>); <span class=\"comment\">// 引入压缩模块</span></span><br><span class=\"line\"></span><br><span class=\"line\">fs.createReadStream(<span class=\"string\">'./data/123.txt'</span>)</span><br><span class=\"line\">    .pipe(zlib.createGzip())</span><br><span class=\"line\">    .pipe(fs.createWriteStream(<span class=\"string\">'./data/123.txt.gz'</span>));<span class=\"comment\">// 链式操作</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'文件压缩完成'</span>);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"文件、文件夹删除\"><a href=\"#文件、文件夹删除\" class=\"headerlink\" title=\"文件、文件夹删除\"></a>文件、文件夹删除</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">\"fs\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// 文件目录读取，返回一个数组，包含文件及文件夹</span></span><br><span class=\"line\">fs.readdir(<span class=\"string\">\"./testdir\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err,files</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!err)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(files);<span class=\"comment\">// [ 'index.html', 'main.css', 'subdir' ]</span></span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 文件删除</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"准备删除文件！\"</span>);</span><br><span class=\"line\">fs.unlink(<span class=\"string\">'./data/123.txt.gz'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> err;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"文件删除成功！\"</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 空文件夹删除</span></span><br><span class=\"line\">fs.rmdir(<span class=\"string\">'./data'</span>,<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!err)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'删除成功！'</span>);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>一个递归删除的小练习，把前面的综合运用一下。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">delDir(<span class=\"string\">'./testdir'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 传入一个文件夹路径，删除掉该文件夹所有内容</span></span><br><span class=\"line\"><span class=\"comment\">// @param pathStr string 传入一个路径</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">delDir</span>(<span class=\"params\">pathStr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fs.existsSync(pathStr))&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> files = fs.readdirSync(pathStr);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; files.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> curPath = pathStr + <span class=\"string\">'/'</span> + files[i];</span><br><span class=\"line\">            <span class=\"keyword\">var</span> stats = fs.statSync(curPath);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (stats.isFile())&#123;</span><br><span class=\"line\">                fs.unlink(curPath);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(stats.isDirectory())&#123;</span><br><span class=\"line\">                delDir(curPath);<span class=\"comment\">// 递归调用，最终删除掉所有文件，只剩空目录</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        fs.rmdirSync(pathStr);<span class=\"comment\">// 收尾，删掉空目录</span></span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'文件夹不存在'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<div class=\"tip\"><br>文件、文件夹的操作，都有同步和异步的代码，比如 <code>fs.unlink()</code> 和 <code>fs.unlinkSync()</code>,默认都是异步代码，异步代码会调用回调函数进行操作，同步代码会返回一个对象，进行后续的操作，可以认真观察上面代码的区别。使用异步代码的时候，一定注意执行顺序。<br></div>\n\n\n<h3 id=\"路径-path\"><a href=\"#路径-path\" class=\"headerlink\" title=\"路径 (path)\"></a>路径 (path)</h3><p>path 模块包含一套用于 <strong><em>处理和转换文件路径</em></strong> 的工具集，用于处理目录的对象，提高开发效率。用 Node.js 的 path 命令，与使用 Linux 下的 shell 脚本命令相似。几乎所有的方法仅对字符串进行转换，文件系统是不会检查路径是否真实有效。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引入path对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 格式化路径  path.normalize(p)</span></span><br><span class=\"line\"><span class=\"comment\">* 特点：将不符合规范的路径格式化，简化开发人员中处理各种复杂的路径判断</span></span><br><span class=\"line\"><span class=\"comment\">* */</span></span><br><span class=\"line\">path.normalize(<span class=\"string\">'/foo/bar//baz/asdf/quux/..'</span>);</span><br><span class=\"line\"><span class=\"comment\">// returns</span></span><br><span class=\"line\"><span class=\"string\">'/foo/bar/baz/asdf'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 路径联合 path.join([path1], [path2], [...])</span></span><br><span class=\"line\"><span class=\"comment\">* 特点：将所有名称用path.seq串联起来，然后用normailze格式化</span></span><br><span class=\"line\"><span class=\"comment\">* */</span></span><br><span class=\"line\">path.join(<span class=\"string\">'///foo'</span>, <span class=\"string\">'bar'</span>, <span class=\"string\">'//baz/asdf'</span>, <span class=\"string\">'quux'</span>, <span class=\"string\">'..'</span>);</span><br><span class=\"line\"><span class=\"comment\">// returns</span></span><br><span class=\"line\"><span class=\"string\">'/foo/bar/baz/asdf'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 路径寻航 path.resolve([from ...], to)</span></span><br><span class=\"line\"><span class=\"comment\">* 特点：相当于不断的调用系统的cd命令</span></span><br><span class=\"line\"><span class=\"comment\">* */</span></span><br><span class=\"line\">path.resolve(<span class=\"string\">'foo/bar'</span>, <span class=\"string\">'/tmp/file/'</span>, <span class=\"string\">'..'</span>, <span class=\"string\">'a/../subfile'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 相当于终端命令：</span></span><br><span class=\"line\"><span class=\"comment\">// cd foo/bar</span></span><br><span class=\"line\"><span class=\"comment\">// cd /tmp/file/</span></span><br><span class=\"line\"><span class=\"comment\">// cd ..</span></span><br><span class=\"line\"><span class=\"comment\">// cd a/../subfile</span></span><br><span class=\"line\"><span class=\"comment\">// pwd</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 相对路径 path.relative(from, to)</span></span><br><span class=\"line\"><span class=\"comment\">* 特点：返回某个路径下相对于另一个路径的相对位置串，</span></span><br><span class=\"line\"><span class=\"comment\">* 相当于：path.resolve(from, path.relative(from, to)) == path.resolve(to)</span></span><br><span class=\"line\"><span class=\"comment\">* */</span></span><br><span class=\"line\"><span class=\"comment\">//简单理解： 地址一执行怎样的 shell 命令，到达地址二</span></span><br><span class=\"line\">path.relative(<span class=\"string\">'/data/orandea/test/aaa'</span>, <span class=\"string\">'/data/orandea/impl/bbb'</span>)</span><br><span class=\"line\"><span class=\"comment\">// returns</span></span><br><span class=\"line\"><span class=\"string\">'../../impl/bbb'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 文件夹名称 path.dirname(p)</span></span><br><span class=\"line\"><span class=\"comment\">* 特点：返回路径的上级路径</span></span><br><span class=\"line\"><span class=\"comment\">* */</span></span><br><span class=\"line\">path.dirname(<span class=\"string\">'/foo/bar/baz/asdf/quux'</span>)</span><br><span class=\"line\"><span class=\"comment\">// returns</span></span><br><span class=\"line\"><span class=\"string\">'/foo/bar/baz/asdf'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 文件名称 path.basename(p, [ext])</span></span><br><span class=\"line\"><span class=\"comment\">* 特点：返回指定的文件名，返回结果可去掉[ext]后缀字符串</span></span><br><span class=\"line\"><span class=\"comment\">* */</span></span><br><span class=\"line\">path.basename(<span class=\"string\">'/foo/bar/baz/asdf/quux.html'</span>)</span><br><span class=\"line\"><span class=\"comment\">// returns</span></span><br><span class=\"line\"><span class=\"string\">'quux.html'</span></span><br><span class=\"line\"></span><br><span class=\"line\">path.basename(<span class=\"string\">'/foo/bar/baz/asdf/quux.html'</span>, <span class=\"string\">'.html'</span>)</span><br><span class=\"line\"><span class=\"comment\">// returns</span></span><br><span class=\"line\"><span class=\"string\">'quux'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 扩展名称 path.extname(p)</span></span><br><span class=\"line\"><span class=\"comment\">* 特点：返回指定文件名的扩展名称</span></span><br><span class=\"line\"><span class=\"comment\">* */</span></span><br><span class=\"line\">path.extname(<span class=\"string\">'index.html'</span>)</span><br><span class=\"line\"><span class=\"comment\">// returns</span></span><br><span class=\"line\"><span class=\"string\">'.html'</span></span><br><span class=\"line\"></span><br><span class=\"line\">path.extname(<span class=\"string\">'index.'</span>)</span><br><span class=\"line\"><span class=\"comment\">// returns</span></span><br><span class=\"line\"><span class=\"string\">'.'</span></span><br><span class=\"line\"></span><br><span class=\"line\">path.extname(<span class=\"string\">'index'</span>)</span><br><span class=\"line\"><span class=\"comment\">// returns</span></span><br><span class=\"line\"><span class=\"string\">''</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 路径分隔符 path.sep</span></span><br><span class=\"line\"><span class=\"comment\">* 特点：获取文件路径的分隔符，主要是与操作系统相关</span></span><br><span class=\"line\"><span class=\"comment\">* 注意调用方式</span></span><br><span class=\"line\"><span class=\"comment\">* */</span></span><br><span class=\"line\"><span class=\"string\">'foo/bar/baz'</span>.split(path.sep)</span><br><span class=\"line\"><span class=\"comment\">// returns</span></span><br><span class=\"line\">[<span class=\"string\">'foo'</span>, <span class=\"string\">'bar'</span>, <span class=\"string\">'baz'</span>]</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>今天学习了 Node.js 的缓冲区（Buffer）、文件系统（fs）、路径（path）模块，感受了一下 Node.js 作为 JavaScript 的扩展在后台方面的一些功能。给我最多的感受是，大量的异步代码和回调函数，让 Node.js 性能非常出色。来总结下今天学习的内容吧。<br>","more":"</p>\n<h3 id=\"缓冲区-Buffer\"><a href=\"#缓冲区-Buffer\" class=\"headerlink\" title=\"缓冲区 (Buffer)\"></a>缓冲区 (Buffer)</h3><p>JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。但在处理像 TCP 流或文件流时，必须使用到二进制数据。因此在 Node.js 中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。按照我的理解，Buffer 类很像我们的整数数组。有对应的索引，存储方式也和数组类似。来看看 Buffer 类是如何创建的。</p>\n<h4 id=\"创建-Buffer-类\"><a href=\"#创建-Buffer-类\" class=\"headerlink\" title=\"创建 Buffer 类\"></a>创建 Buffer 类</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法1</span></span><br><span class=\"line\"><span class=\"comment\">// 创建长度为10字节的 Buffer 类</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> buf = <span class=\"keyword\">new</span> Buffer(<span class=\"number\">10</span>); <span class=\"comment\">// 构造函数，注意这种创建形式</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法2</span></span><br><span class=\"line\"><span class=\"comment\">// 直接通过数组赋值的形式创建</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> buf2 = <span class=\"keyword\">new</span> Buffer([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法3</span></span><br><span class=\"line\"><span class=\"comment\">// 通过字符串来创建</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> buf3 = <span class=\"keyword\">new</span> Buffer(<span class=\"string\">'ifyour'</span>,<span class=\"string\">'utf-8'</span>);<span class=\"comment\">// utf-8 默认编码，可以省略</span></span><br></pre></td></tr></table></figure>\n<p>从代码我们可以看出这个 Buffer 类是一个构造函数，通过实例化一个 Buffer 对象，让它具有一些 Buffer 类的方法，总得来说常用的方法有下面三种。</p>\n<h4 id=\"写入缓冲区\"><a href=\"#写入缓冲区\" class=\"headerlink\" title=\"写入缓冲区\"></a>写入缓冲区</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 语法：  buf.write(string[, offset[, length]][, encoding])</span></span><br><span class=\"line\"><span class=\"comment\">// 实例：</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b4 = <span class=\"keyword\">new</span> Buffer(<span class=\"number\">14</span>);</span><br><span class=\"line\">len = b4.write(<span class=\"string\">'this is buffer'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Buffer 写入了 '</span> + len + <span class=\"string\">' 字节，内容为：'</span> + b4.toString());</span><br><span class=\"line\"><span class=\"comment\">// Buffer 写入了 14字节，内容为：this is buffer</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"缓冲区读取\"><a href=\"#缓冲区读取\" class=\"headerlink\" title=\"缓冲区读取\"></a>缓冲区读取</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 语法： buf.toString([encoding[, start[, end]]])</span></span><br><span class=\"line\"><span class=\"comment\">// 实例：</span></span><br><span class=\"line\">buf = <span class=\"keyword\">new</span> Buffer(<span class=\"number\">26</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">26</span> ; i++) &#123;</span><br><span class=\"line\">  buf[i] = i + <span class=\"number\">97</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( buf.toString(<span class=\"string\">'ascii'</span>));       <span class=\"comment\">// 输出: abcdefghijklmnopqrstuvwxyz</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( buf.toString(<span class=\"string\">'ascii'</span>,<span class=\"number\">0</span>,<span class=\"number\">5</span>));   <span class=\"comment\">// 输出: abcde</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( buf.toString(<span class=\"string\">'utf8'</span>,<span class=\"number\">0</span>,<span class=\"number\">5</span>));    <span class=\"comment\">// 输出: abcde</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( buf.toString(<span class=\"literal\">undefined</span>,<span class=\"number\">0</span>,<span class=\"number\">5</span>)); <span class=\"comment\">// 使用 'utf8' 编码, 并输出: abcde</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"缓冲区拷贝\"><a href=\"#缓冲区拷贝\" class=\"headerlink\" title=\"缓冲区拷贝\"></a>缓冲区拷贝</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//语法： buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]])</span></span><br><span class=\"line\"><span class=\"comment\">//实例：</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b5 = <span class=\"keyword\">new</span> Buffer([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>]);</span><br><span class=\"line\"><span class=\"keyword\">var</span> b6 = <span class=\"keyword\">new</span>  Buffer(<span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">b5.copy(b6,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">2</span>);<span class=\"comment\">// 把 b5 中的索引 0-2 （不包括2） 的值复制给 b6 的第 1 位置</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b6);</span><br></pre></td></tr></table></figure>\n<h3 id=\"文件系统-fs\"><a href=\"#文件系统-fs\" class=\"headerlink\" title=\"文件系统 (fs)\"></a>文件系统 (fs)</h3><p>Node.js 文件系统（fs 模块）模块中的方法均有异步和同步版本，例如读取文件内容的函数有异步的 <code>fs.readFile()</code> 和同步的 <code>fs.readFileSync()</code>。异步的方法函数最后一个参数为回调函数，回调函数的第一个参数包含了错误信息 (error)。相比同步，异步效率更高，性能更好，没有阻塞，但是在实际使用中，一定要处理好先后顺序。</p>\n<h4 id=\"文件读写方式\"><a href=\"#文件读写方式\" class=\"headerlink\" title=\"文件读写方式\"></a>文件读写方式</h4><p>文件读取方式，举个简单例子，好比先把整个数据源完整拿出来放到内存中，再使用 <code>writeFile</code> 方法或 <code>writeFileSync</code> 方法写入文件内容。显然，如果数据源非常大（10GB）使用这种方式，效率就很低了。说不定就死机了。:) 这时候，就需要下一节讲到的 <strong><em>流读取</em></strong>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// data.txt</span><br><span class=\"line\">Hello,Node.js!</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">\"fs\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 异步读取</span></span><br><span class=\"line\">fs.readFile(<span class=\"string\">'data.txt'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, data</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"built_in\">console</span>.error(err);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(<span class=\"string\">\"异步读取: \"</span> + data.toString());</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 同步读取</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> data = fs.readFileSync(<span class=\"string\">'data.txt'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"同步读取: \"</span> + data.toString());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"程序执行完毕。\"</span>);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">同步读取: Hello,Node.js!</span><br><span class=\"line\">程序执行完毕。</span><br><span class=\"line\"></span><br><span class=\"line\">异步读取: Hello,Node.js!</span><br></pre></td></tr></table></figure>\n<div class=\"tip\"><br>Node.js 中，先执行同步代码，后执行异步代码，异步代码会将回调函数放入调用 <strong><em>队列</em></strong>，以 <strong><em>先进先出</em></strong> 的形式依次调用。<br></div>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 异步写入</span></span><br><span class=\"line\">fs.writeFile(<span class=\"string\">'./data/d2.txt'</span>,<span class=\"string\">'我是一条数据'</span>,<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!err)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'文件写入成功'</span>);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'写入失败'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 同步写入</span></span><br><span class=\"line\">fs.writeFileSync(<span class=\"string\">'./data/d3'</span>,<span class=\"string\">'我是一条数据'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> data = fs.readFileSync(<span class=\"string\">'./data/d3'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(data.toString());<span class=\"comment\">// 我是一条数据</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"流读写方式\"><a href=\"#流读写方式\" class=\"headerlink\" title=\"流读写方式\"></a>流读写方式</h4><p>应用程序中，流是一组有序的、有起点和终点的 <strong><em>字节数据的传输方式</em></strong>。在应用程序中各种对象之间交换与传输数据的时候，总是先将该对象中所包含的数据转换为各种形式的流数据（即字节数据），再通过流的传输，到达目的对象后再将流数据转换为该对象中可以使用的数据。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> data = <span class=\"string\">''</span>;</span><br><span class=\"line\"><span class=\"comment\">// 流读取</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> stream = fs.createReadStream(<span class=\"string\">'./data/d1.txt'</span>,<span class=\"string\">'utf-8'</span>);</span><br><span class=\"line\">stream.on(<span class=\"string\">'data'</span>,<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">result</span>) </span>&#123;</span><br><span class=\"line\">    data += result;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// data end 事件表示连贯的行为，字节流需要起点和终点。</span></span><br><span class=\"line\">stream.on(<span class=\"string\">'end'</span>,<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">stream.on(<span class=\"string\">'error'</span>,<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err.stack);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 流写入</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> stream = fs.createWriteStream(<span class=\"string\">'./data/123.txt'</span>,<span class=\"string\">'utf-8'</span>);</span><br><span class=\"line\">stream.write(<span class=\"string\">'hello'</span>,<span class=\"string\">'utf-8'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">stream.end();</span><br><span class=\"line\"></span><br><span class=\"line\">stream.on(<span class=\"string\">'finish'</span>,<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;<span class=\"comment\">// finish 事件触发，必须等 end 事件结束才可以</span></span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(<span class=\"string\">'写入完成！'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">stream.on(<span class=\"string\">'error'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err.stack);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<div class=\"tip\"><br>流读取会依次触发事件： data -&gt; end -&gt; error ,每个事件发生会有对应的回调函数处理。<br>流写入会依次触发事件： end -&gt; finish -&gt; error ,每个事件发生会有对应的回调函数处理。<br></div>\n\n<h4 id=\"管道流读写\"><a href=\"#管道流读写\" class=\"headerlink\" title=\"管道流读写\"></a>管道流读写</h4><p>管道(pipe) 提供了一个输出流到输入流的机制。通常我们用于从一个流中获取数据并将数据传递到另外一个流中。通过管道，我们就可以实现大文件流入另外一个文件的复制过程。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> readStream = fs.createReadStream(<span class=\"string\">'./data/d1.txt'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> writeStrem = fs.createWriteStream(<span class=\"string\">'./data/d3.txt'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">readStream.pipe(writeStrem);<span class=\"comment\">// 实现了 d1.txt 到 d3.txt 的传输过程</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"链式流读写\"><a href=\"#链式流读写\" class=\"headerlink\" title=\"链式流读写\"></a>链式流读写</h4><p>链式是通过连接输出流到另外一个流并创建多个对个流操作链的机制。链式流一般用于管道操作。接下来我们就是用管道和链式来压缩和解压文件。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// compress.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> zlib = <span class=\"built_in\">require</span>(<span class=\"string\">'zlib'</span>); <span class=\"comment\">// 引入压缩模块</span></span><br><span class=\"line\"></span><br><span class=\"line\">fs.createReadStream(<span class=\"string\">'./data/123.txt'</span>)</span><br><span class=\"line\">    .pipe(zlib.createGzip())</span><br><span class=\"line\">    .pipe(fs.createWriteStream(<span class=\"string\">'./data/123.txt.gz'</span>));<span class=\"comment\">// 链式操作</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'文件压缩完成'</span>);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"文件、文件夹删除\"><a href=\"#文件、文件夹删除\" class=\"headerlink\" title=\"文件、文件夹删除\"></a>文件、文件夹删除</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">\"fs\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// 文件目录读取，返回一个数组，包含文件及文件夹</span></span><br><span class=\"line\">fs.readdir(<span class=\"string\">\"./testdir\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err,files</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!err)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(files);<span class=\"comment\">// [ 'index.html', 'main.css', 'subdir' ]</span></span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 文件删除</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"准备删除文件！\"</span>);</span><br><span class=\"line\">fs.unlink(<span class=\"string\">'./data/123.txt.gz'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> err;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"文件删除成功！\"</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 空文件夹删除</span></span><br><span class=\"line\">fs.rmdir(<span class=\"string\">'./data'</span>,<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!err)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'删除成功！'</span>);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>一个递归删除的小练习，把前面的综合运用一下。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">delDir(<span class=\"string\">'./testdir'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 传入一个文件夹路径，删除掉该文件夹所有内容</span></span><br><span class=\"line\"><span class=\"comment\">// @param pathStr string 传入一个路径</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">delDir</span>(<span class=\"params\">pathStr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fs.existsSync(pathStr))&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> files = fs.readdirSync(pathStr);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; files.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> curPath = pathStr + <span class=\"string\">'/'</span> + files[i];</span><br><span class=\"line\">            <span class=\"keyword\">var</span> stats = fs.statSync(curPath);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (stats.isFile())&#123;</span><br><span class=\"line\">                fs.unlink(curPath);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(stats.isDirectory())&#123;</span><br><span class=\"line\">                delDir(curPath);<span class=\"comment\">// 递归调用，最终删除掉所有文件，只剩空目录</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        fs.rmdirSync(pathStr);<span class=\"comment\">// 收尾，删掉空目录</span></span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'文件夹不存在'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<div class=\"tip\"><br>文件、文件夹的操作，都有同步和异步的代码，比如 <code>fs.unlink()</code> 和 <code>fs.unlinkSync()</code>,默认都是异步代码，异步代码会调用回调函数进行操作，同步代码会返回一个对象，进行后续的操作，可以认真观察上面代码的区别。使用异步代码的时候，一定注意执行顺序。<br></div>\n\n\n<h3 id=\"路径-path\"><a href=\"#路径-path\" class=\"headerlink\" title=\"路径 (path)\"></a>路径 (path)</h3><p>path 模块包含一套用于 <strong><em>处理和转换文件路径</em></strong> 的工具集，用于处理目录的对象，提高开发效率。用 Node.js 的 path 命令，与使用 Linux 下的 shell 脚本命令相似。几乎所有的方法仅对字符串进行转换，文件系统是不会检查路径是否真实有效。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引入path对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 格式化路径  path.normalize(p)</span></span><br><span class=\"line\"><span class=\"comment\">* 特点：将不符合规范的路径格式化，简化开发人员中处理各种复杂的路径判断</span></span><br><span class=\"line\"><span class=\"comment\">* */</span></span><br><span class=\"line\">path.normalize(<span class=\"string\">'/foo/bar//baz/asdf/quux/..'</span>);</span><br><span class=\"line\"><span class=\"comment\">// returns</span></span><br><span class=\"line\"><span class=\"string\">'/foo/bar/baz/asdf'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 路径联合 path.join([path1], [path2], [...])</span></span><br><span class=\"line\"><span class=\"comment\">* 特点：将所有名称用path.seq串联起来，然后用normailze格式化</span></span><br><span class=\"line\"><span class=\"comment\">* */</span></span><br><span class=\"line\">path.join(<span class=\"string\">'///foo'</span>, <span class=\"string\">'bar'</span>, <span class=\"string\">'//baz/asdf'</span>, <span class=\"string\">'quux'</span>, <span class=\"string\">'..'</span>);</span><br><span class=\"line\"><span class=\"comment\">// returns</span></span><br><span class=\"line\"><span class=\"string\">'/foo/bar/baz/asdf'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 路径寻航 path.resolve([from ...], to)</span></span><br><span class=\"line\"><span class=\"comment\">* 特点：相当于不断的调用系统的cd命令</span></span><br><span class=\"line\"><span class=\"comment\">* */</span></span><br><span class=\"line\">path.resolve(<span class=\"string\">'foo/bar'</span>, <span class=\"string\">'/tmp/file/'</span>, <span class=\"string\">'..'</span>, <span class=\"string\">'a/../subfile'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 相当于终端命令：</span></span><br><span class=\"line\"><span class=\"comment\">// cd foo/bar</span></span><br><span class=\"line\"><span class=\"comment\">// cd /tmp/file/</span></span><br><span class=\"line\"><span class=\"comment\">// cd ..</span></span><br><span class=\"line\"><span class=\"comment\">// cd a/../subfile</span></span><br><span class=\"line\"><span class=\"comment\">// pwd</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 相对路径 path.relative(from, to)</span></span><br><span class=\"line\"><span class=\"comment\">* 特点：返回某个路径下相对于另一个路径的相对位置串，</span></span><br><span class=\"line\"><span class=\"comment\">* 相当于：path.resolve(from, path.relative(from, to)) == path.resolve(to)</span></span><br><span class=\"line\"><span class=\"comment\">* */</span></span><br><span class=\"line\"><span class=\"comment\">//简单理解： 地址一执行怎样的 shell 命令，到达地址二</span></span><br><span class=\"line\">path.relative(<span class=\"string\">'/data/orandea/test/aaa'</span>, <span class=\"string\">'/data/orandea/impl/bbb'</span>)</span><br><span class=\"line\"><span class=\"comment\">// returns</span></span><br><span class=\"line\"><span class=\"string\">'../../impl/bbb'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 文件夹名称 path.dirname(p)</span></span><br><span class=\"line\"><span class=\"comment\">* 特点：返回路径的上级路径</span></span><br><span class=\"line\"><span class=\"comment\">* */</span></span><br><span class=\"line\">path.dirname(<span class=\"string\">'/foo/bar/baz/asdf/quux'</span>)</span><br><span class=\"line\"><span class=\"comment\">// returns</span></span><br><span class=\"line\"><span class=\"string\">'/foo/bar/baz/asdf'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 文件名称 path.basename(p, [ext])</span></span><br><span class=\"line\"><span class=\"comment\">* 特点：返回指定的文件名，返回结果可去掉[ext]后缀字符串</span></span><br><span class=\"line\"><span class=\"comment\">* */</span></span><br><span class=\"line\">path.basename(<span class=\"string\">'/foo/bar/baz/asdf/quux.html'</span>)</span><br><span class=\"line\"><span class=\"comment\">// returns</span></span><br><span class=\"line\"><span class=\"string\">'quux.html'</span></span><br><span class=\"line\"></span><br><span class=\"line\">path.basename(<span class=\"string\">'/foo/bar/baz/asdf/quux.html'</span>, <span class=\"string\">'.html'</span>)</span><br><span class=\"line\"><span class=\"comment\">// returns</span></span><br><span class=\"line\"><span class=\"string\">'quux'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 扩展名称 path.extname(p)</span></span><br><span class=\"line\"><span class=\"comment\">* 特点：返回指定文件名的扩展名称</span></span><br><span class=\"line\"><span class=\"comment\">* */</span></span><br><span class=\"line\">path.extname(<span class=\"string\">'index.html'</span>)</span><br><span class=\"line\"><span class=\"comment\">// returns</span></span><br><span class=\"line\"><span class=\"string\">'.html'</span></span><br><span class=\"line\"></span><br><span class=\"line\">path.extname(<span class=\"string\">'index.'</span>)</span><br><span class=\"line\"><span class=\"comment\">// returns</span></span><br><span class=\"line\"><span class=\"string\">'.'</span></span><br><span class=\"line\"></span><br><span class=\"line\">path.extname(<span class=\"string\">'index'</span>)</span><br><span class=\"line\"><span class=\"comment\">// returns</span></span><br><span class=\"line\"><span class=\"string\">''</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 路径分隔符 path.sep</span></span><br><span class=\"line\"><span class=\"comment\">* 特点：获取文件路径的分隔符，主要是与操作系统相关</span></span><br><span class=\"line\"><span class=\"comment\">* 注意调用方式</span></span><br><span class=\"line\"><span class=\"comment\">* */</span></span><br><span class=\"line\"><span class=\"string\">'foo/bar/baz'</span>.split(path.sep)</span><br><span class=\"line\"><span class=\"comment\">// returns</span></span><br><span class=\"line\">[<span class=\"string\">'foo'</span>, <span class=\"string\">'bar'</span>, <span class=\"string\">'baz'</span>]</span><br></pre></td></tr></table></figure></p>"},{"title":"Node.JS 学习笔记 [05] -- Express","date":"2015-01-06T13:24:40.000Z","comments":0,"_content":"\n***Express*** 是一个基于 Node.js 平台的极简、灵活的 Web 应用开发框架，它提供一系列强大的特性，帮助你创建各种 Web 和移动设备应用。Express 的核心特性可以概括以下三点。\n<!-- more -->\n\n- 可以设置中间件来响应 HTTP 请求。\n- 定义了路由表用于执行不同的 HTTP 请求动作。\n- 可以通过向模板传递参数来动态渲染 HTML 页面。\n\n下面学习的知识点，都会围绕这几个特性展开。\n\n### Express 安装\n#### 在项目中引入 Express\n```bash\ncd projectName              # 进入新建的 Node.js 项目\nnpm init                    # 初始化项目配置文件\nnpm install express --save  # 安装 Express 模块到项目配置文件中\n```\n通过上门的命令，就可以完成 Express 的安装，下面在 `app.js` 中使用 Express 吧！\n```js\nvar express = require('express');\nvar app = express();\n\napp.get('/', function (req, res) {\n    res.send('Hello,Express!');\n});\n\napp.listen(8080, function () {\n    console.log('Express running at http://127.0.0.1:8080/');\n});\n```\n\n#### 使用 Express-generator\n为了方便开发者，更便捷的使用 Express 生成项目，官方提供的快速的生成工具 `Express-generator`，虽然生成非常快速方便，但是作为初学者，还是要弄清楚里面每条命令所代表的含义，最后再使用官方提供的工具快速生成。打开终端，因为我是 MacOS，所以安装的时候要加上 `sudo` 否则会报错提示权限不够。\n```bash\nsudo npm install express-generator -g  # 全局安装\nexpress mywebapp                       # 创建 mywebapp 项目\ncd mywebapp && npm install             # 安装依赖文件\nnpm start                              # 启动项目\n```\n启动项目后，就可以在浏览器中预览了，访问地址：http://127.0.0.1:3000/ 。\n\n<div class=\"tip\">\n启动前需要关闭其它已经启用的 Web 服务，否则可能会导致端口占用启动不成功。\n</div>\n\n### Express 路由\n> 路由是指如何定义应用的端点（URLs）以及如何响应客户端的请求。\n\n#### 基础用法\n简单理解，其实就是根据不同的请求，来响应与之对应的页面。比如，当用户访问 http://localhost/images/ 时，根据 URL 可以看出，请求的是 `/images` 这个目录，那么通过路由，找到这个页面并返回给请求的用户，这个过程就叫路由。来看一个简单的例子。\n```js\nvar express = require('express');\nvar app = express();\n\n// 当用户请求访问 / 时，响应一个 Hello,Express! 字符串，这就是一个简单路由\napp.get('/', function (req, res) {\n    res.send('Hello,Express!');\n});\n```\n这里需要注意 `app.all()` ,它是一个特殊的路由方法，没有任何 HTTP 方法与其对应，它的作用是对于一个路径上的所有请求加载中间件。 all 相当于既可以处理 `GET`，也可以处理 `POST` 。\n\n#### Router 方法\n通过 `express.Router` 类可以创建独立模块的路由模块，它是一个可以挂载的路由对象，把路由模块分离出项目，让整个项目结构清晰、方便管理，这里光说还是挺抽象，举个例子。\n```bash\n# 目录结构\n.\n├── index.js\n├── node_modules\n│   ├── body-parser\n│   └── express\n├── package.json\n├── router\n│   ├── admin.js\n│   └── home.js\n└── views\n    ├── admin\n    └── home\n```\n```js\n// index.js\nvar express = require('express');\nvar bodyparser = require('body-parser');\n// 引入外部路由模块\nvar home = require('./router/home');\nvar admin = require('./router/admin');\nvar app = express();\n\n// 使用中间件 bodyparser ，后面可以在 req.body 中分析出 POST 请求体的内容\napp.use(bodyparser.urlencoded({extended:false}));\n\n// 使用外部路由模块\napp.use('/',home);\napp.use('/admin',admin);\n\napp.listen(8080,function () {\n   console.log('visit http://127.0.0.1:8080/');\n});\n```\n\n```js\n// admin.js\nvar express = require('express');\nvar router = express.Router();// 用 Router 构造函数实例化 router 对象\nvar path = require('path');\n\nrouter.get('/login.html', function (req, res) {\n    res.sendFile(path.resolve(__dirname + '/../views/admin/' + 'login.html'));\n});\n\nrouter.get('/user.html', function (req, res) {\n    res.sendFile(path.resolve(__dirname + '/../views/admin/' + 'user.html'));\n});\n\nrouter.post('/login.html', function (req, res) {// /admin/login.html\n    res.sendFile(path.resolve(__dirname + '/../views/admin/' + 'login.html'));\n});\n\nmodule.exports = router;// 暴露给外部调用该路由\n```\n\n### Express 响应对象\n通过响应（Response）对象，服务器可以返回一个来自客户端（浏览器）的 `Request` ,最终返回给用户的其实就是一个经过业务逻辑层处理的 `res` 对象。来了解下 Express 的响应对象吧。\n\n#### send()\nExpress 已经封装过了原生 Node.js 的响应方法，在原生 Node.js 中，通过 `res.write()` 方法可以返回字符串和 Buffer。而 Express 中的 `send()` 可以返回任意数据类型，如流、数据、普通文本等，来看个例子。\n```js\nres.send(new Buffer('ifyour')); // Buffer\nres.send({\"name\": \"ifyour\"});   // JSON\nres.send('<p>some html</p>');   // HTML\nres.status(404).send('404 Not Find'); // 设置状态码并返回提示\n//...\n```\n\n#### json()\n通过 `json()` 方法可以返回一个 `JSON` 对象，用于 Ajax 等。\n```js\nres.json(null);\nres.json({\"user\": \"ifyour\"});\nres.status(500).json({\"error\": \"message\"});\n```\n\n#### render()\n`render` 用于渲染模板引擎，比如在使用 [ejs](https://github.com/tj/ejs) 模板引擎时，响应用户请求就可以使用 `res.render()` 返回给用户一个渲染好的页面。这个用的比较多，我来举个例子。\n```bash\n# 目录结构\n.\n├── index.js\n├── node_modules\n│   ├── ejs\n│   └── express\n├── package.json\n└── views\n    └── login.html\n```\n```html\n<!-- ejs 模板引擎，定义了 /login.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n<!-- 注意 ejs 模板中变量的写法 -->\n<h1>欢迎你，<%=name%></h1>\n</body>\n</html>\n```\n```js\n// index.js\nvar express = require('express');\nvar ejs = require('ejs'); // 引入 ejs 模板引擎\nvar path = require('path');\nvar app = express();\n\nvar viewsPath = path.join(__dirname, 'views');// views 是模板目录\n// 设置 express views 层，模板根路径\napp.set('views', viewsPath);\n\n// 设置 express 实例的模板语言\napp.set('view engine', 'html');\n\n// 把 express 实例的模板引擎和 ejs 模板引擎关联\napp.engine('html', ejs.__express);\n\napp.get('/login.html', function (req, res) {\n    res.render('login', {name: \"ifyour\"});// 替换到模板变量中的 name 为 ifyour\n});\n\napp.listen(8080, function () {\n    console.log('visit http://127.0.0.1:8080/');\n});\n```\n<div class=\"tip\">\n`__dirname` 是 Node.js 中定义的 `global` 全局变量，获取当前文件的绝对路径，返回 `string` 类型。\n</div>\n\n#### download()\n```js\nres.download('./123.doc'); // 下载当前目录下面的123.doc文件。\nres.download('./123.doc','books.doc'); // 下载当前目录下面的123.doc文件，重命名为 books.doc\n```\n#### redirect()\n```js\n// 重定向到指定的 URL 路径\nres.redirect('/404.html');\nres.redirect('https://www.google.com/');\n```\n\n更多响应对象的方法，参考 [Express 官方 API](http://www.expressjs.com.cn/4x/api.html#res)。\n### Express 请求对象\nExpress 中的 `Request` 对象，包含了一次请求中的所有数据，比如请求头、路径、Cookies 等，获取请求头中的信息，服务器根据这些信息处理业务逻辑层，最终将处理过后的数据返回给用户。这里总结了常用的请求对象方法。\n\n#### URL 中的参数\n```js\n// 方式一： req.query.参数名\n// e.g.  http://localhost:3000/user?name=ifyour\nconsole.log(req.query.name);\n// => ifyour\n\n// 方式二：req.params.参数名\n//e.g.  http://localhost/post/123123\nrouter.get('/post/:id', function (req, res) {\n    console.log(req.params.id);\n    // => 123123\n});\n```\n\n#### 表单中的参数\n```js\n// 方式一：语法：req.param.参数名  注意这里没加 s\n// e.g. <input type=\"text\" name=\"user\">\nconsole.log(req.param('user'));\n\n\n// 方式二：使用 body-parser 中间件\n// e.g. <input type=\"text\" name=\"user\">\nvar bodyparser = require('body-parser');\nconsole.console.log(req.boy.user);\n```\n\n### Express 中间件\nExpress 是一个自身功能极简，完全是由路由和中间件构成一个的 Web 开发框架：从本质上来说，一个 Express 应用就是在调用各种中间件。\n![](http://ww3.sinaimg.cn/large/6057861cgw1fbcrpk71zxj20sg03kaaa.jpg)\n如图，中间件（Middleware）位于客户端和路由之间，它好比是一个漏斗，经过这个漏斗的 `Request` 对象和 `Response` 对象以及循环流程中的 `Next` 会被处理，比如正确性校验、业务逻辑处理等。\n\n- 执行任何代码\n- 修改请求和响应对象\n- 终结请求-响应循环\n- 调用堆栈中的下一个中间件\n\n<div class=\"tip\">\n如果当前中间件没有终结请求-响应循环，则必须调用 next() 方法将控制权交给下一个中间件，否则请求就会挂起。\n</div>\n举个例子来说明一下，如何通过 `next()` 方法把控制权交给下一个中间件。\n```js\nvar app = express();\napp.use(function (req, res, next) {\n   var accessToken = req.query.accessToken;\n   //检查请求中是否含有“认证牌”，存在就继续执行。\n   if(accessToken){\n       next(); // 执行下一个中间件\n       }else{\n          res.send(“请求必须包含token”);\n        }\n});\n// ...\n```\n\n#### 应用级中间件\n应用级中间件就是绑定到用 `express()` 生成的对象 `app` 身上的，比如 `app.use()` 中的 `use` 方法，以及 `app.post()` 、`app.get()` 中的 `POST` 和 `GET` 方法等。\n#### 内置中间件\n```js\n// 设置公共静态目录，用于存放 css js image 等文件，项目目录里有 images 目录存放 1.png\n// 那么访问：http://localhost/images/1.png 获取\napp.use(express.static('public'));\n```\n#### 第三方中间件\n中间件可以说是整个 Express 的精华所在了，使用中间件可以几大的扩展项目的功能。使用方法都差不多，这里介绍几个常用的，具体使用方式需要看官方的文档了。\n- 解析客户端请求的 body 中的内容：body-parser\n- cookie 解析中间件：cookie-parser\n- 文件上传中间件：multer\n\n使用命令 `npm i 包名称 --save` 安装到项目中，然后引入项目使用即可。\n","source":"_posts/Node.JS-学习笔记-[05]----Express.md","raw":"---\ntitle: 'Node.JS 学习笔记 [05] -- Express'\ndate: 2015-01-06 21:24:40\ntags:\ncomments: false\n---\n\n***Express*** 是一个基于 Node.js 平台的极简、灵活的 Web 应用开发框架，它提供一系列强大的特性，帮助你创建各种 Web 和移动设备应用。Express 的核心特性可以概括以下三点。\n<!-- more -->\n\n- 可以设置中间件来响应 HTTP 请求。\n- 定义了路由表用于执行不同的 HTTP 请求动作。\n- 可以通过向模板传递参数来动态渲染 HTML 页面。\n\n下面学习的知识点，都会围绕这几个特性展开。\n\n### Express 安装\n#### 在项目中引入 Express\n```bash\ncd projectName              # 进入新建的 Node.js 项目\nnpm init                    # 初始化项目配置文件\nnpm install express --save  # 安装 Express 模块到项目配置文件中\n```\n通过上门的命令，就可以完成 Express 的安装，下面在 `app.js` 中使用 Express 吧！\n```js\nvar express = require('express');\nvar app = express();\n\napp.get('/', function (req, res) {\n    res.send('Hello,Express!');\n});\n\napp.listen(8080, function () {\n    console.log('Express running at http://127.0.0.1:8080/');\n});\n```\n\n#### 使用 Express-generator\n为了方便开发者，更便捷的使用 Express 生成项目，官方提供的快速的生成工具 `Express-generator`，虽然生成非常快速方便，但是作为初学者，还是要弄清楚里面每条命令所代表的含义，最后再使用官方提供的工具快速生成。打开终端，因为我是 MacOS，所以安装的时候要加上 `sudo` 否则会报错提示权限不够。\n```bash\nsudo npm install express-generator -g  # 全局安装\nexpress mywebapp                       # 创建 mywebapp 项目\ncd mywebapp && npm install             # 安装依赖文件\nnpm start                              # 启动项目\n```\n启动项目后，就可以在浏览器中预览了，访问地址：http://127.0.0.1:3000/ 。\n\n<div class=\"tip\">\n启动前需要关闭其它已经启用的 Web 服务，否则可能会导致端口占用启动不成功。\n</div>\n\n### Express 路由\n> 路由是指如何定义应用的端点（URLs）以及如何响应客户端的请求。\n\n#### 基础用法\n简单理解，其实就是根据不同的请求，来响应与之对应的页面。比如，当用户访问 http://localhost/images/ 时，根据 URL 可以看出，请求的是 `/images` 这个目录，那么通过路由，找到这个页面并返回给请求的用户，这个过程就叫路由。来看一个简单的例子。\n```js\nvar express = require('express');\nvar app = express();\n\n// 当用户请求访问 / 时，响应一个 Hello,Express! 字符串，这就是一个简单路由\napp.get('/', function (req, res) {\n    res.send('Hello,Express!');\n});\n```\n这里需要注意 `app.all()` ,它是一个特殊的路由方法，没有任何 HTTP 方法与其对应，它的作用是对于一个路径上的所有请求加载中间件。 all 相当于既可以处理 `GET`，也可以处理 `POST` 。\n\n#### Router 方法\n通过 `express.Router` 类可以创建独立模块的路由模块，它是一个可以挂载的路由对象，把路由模块分离出项目，让整个项目结构清晰、方便管理，这里光说还是挺抽象，举个例子。\n```bash\n# 目录结构\n.\n├── index.js\n├── node_modules\n│   ├── body-parser\n│   └── express\n├── package.json\n├── router\n│   ├── admin.js\n│   └── home.js\n└── views\n    ├── admin\n    └── home\n```\n```js\n// index.js\nvar express = require('express');\nvar bodyparser = require('body-parser');\n// 引入外部路由模块\nvar home = require('./router/home');\nvar admin = require('./router/admin');\nvar app = express();\n\n// 使用中间件 bodyparser ，后面可以在 req.body 中分析出 POST 请求体的内容\napp.use(bodyparser.urlencoded({extended:false}));\n\n// 使用外部路由模块\napp.use('/',home);\napp.use('/admin',admin);\n\napp.listen(8080,function () {\n   console.log('visit http://127.0.0.1:8080/');\n});\n```\n\n```js\n// admin.js\nvar express = require('express');\nvar router = express.Router();// 用 Router 构造函数实例化 router 对象\nvar path = require('path');\n\nrouter.get('/login.html', function (req, res) {\n    res.sendFile(path.resolve(__dirname + '/../views/admin/' + 'login.html'));\n});\n\nrouter.get('/user.html', function (req, res) {\n    res.sendFile(path.resolve(__dirname + '/../views/admin/' + 'user.html'));\n});\n\nrouter.post('/login.html', function (req, res) {// /admin/login.html\n    res.sendFile(path.resolve(__dirname + '/../views/admin/' + 'login.html'));\n});\n\nmodule.exports = router;// 暴露给外部调用该路由\n```\n\n### Express 响应对象\n通过响应（Response）对象，服务器可以返回一个来自客户端（浏览器）的 `Request` ,最终返回给用户的其实就是一个经过业务逻辑层处理的 `res` 对象。来了解下 Express 的响应对象吧。\n\n#### send()\nExpress 已经封装过了原生 Node.js 的响应方法，在原生 Node.js 中，通过 `res.write()` 方法可以返回字符串和 Buffer。而 Express 中的 `send()` 可以返回任意数据类型，如流、数据、普通文本等，来看个例子。\n```js\nres.send(new Buffer('ifyour')); // Buffer\nres.send({\"name\": \"ifyour\"});   // JSON\nres.send('<p>some html</p>');   // HTML\nres.status(404).send('404 Not Find'); // 设置状态码并返回提示\n//...\n```\n\n#### json()\n通过 `json()` 方法可以返回一个 `JSON` 对象，用于 Ajax 等。\n```js\nres.json(null);\nres.json({\"user\": \"ifyour\"});\nres.status(500).json({\"error\": \"message\"});\n```\n\n#### render()\n`render` 用于渲染模板引擎，比如在使用 [ejs](https://github.com/tj/ejs) 模板引擎时，响应用户请求就可以使用 `res.render()` 返回给用户一个渲染好的页面。这个用的比较多，我来举个例子。\n```bash\n# 目录结构\n.\n├── index.js\n├── node_modules\n│   ├── ejs\n│   └── express\n├── package.json\n└── views\n    └── login.html\n```\n```html\n<!-- ejs 模板引擎，定义了 /login.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n<!-- 注意 ejs 模板中变量的写法 -->\n<h1>欢迎你，<%=name%></h1>\n</body>\n</html>\n```\n```js\n// index.js\nvar express = require('express');\nvar ejs = require('ejs'); // 引入 ejs 模板引擎\nvar path = require('path');\nvar app = express();\n\nvar viewsPath = path.join(__dirname, 'views');// views 是模板目录\n// 设置 express views 层，模板根路径\napp.set('views', viewsPath);\n\n// 设置 express 实例的模板语言\napp.set('view engine', 'html');\n\n// 把 express 实例的模板引擎和 ejs 模板引擎关联\napp.engine('html', ejs.__express);\n\napp.get('/login.html', function (req, res) {\n    res.render('login', {name: \"ifyour\"});// 替换到模板变量中的 name 为 ifyour\n});\n\napp.listen(8080, function () {\n    console.log('visit http://127.0.0.1:8080/');\n});\n```\n<div class=\"tip\">\n`__dirname` 是 Node.js 中定义的 `global` 全局变量，获取当前文件的绝对路径，返回 `string` 类型。\n</div>\n\n#### download()\n```js\nres.download('./123.doc'); // 下载当前目录下面的123.doc文件。\nres.download('./123.doc','books.doc'); // 下载当前目录下面的123.doc文件，重命名为 books.doc\n```\n#### redirect()\n```js\n// 重定向到指定的 URL 路径\nres.redirect('/404.html');\nres.redirect('https://www.google.com/');\n```\n\n更多响应对象的方法，参考 [Express 官方 API](http://www.expressjs.com.cn/4x/api.html#res)。\n### Express 请求对象\nExpress 中的 `Request` 对象，包含了一次请求中的所有数据，比如请求头、路径、Cookies 等，获取请求头中的信息，服务器根据这些信息处理业务逻辑层，最终将处理过后的数据返回给用户。这里总结了常用的请求对象方法。\n\n#### URL 中的参数\n```js\n// 方式一： req.query.参数名\n// e.g.  http://localhost:3000/user?name=ifyour\nconsole.log(req.query.name);\n// => ifyour\n\n// 方式二：req.params.参数名\n//e.g.  http://localhost/post/123123\nrouter.get('/post/:id', function (req, res) {\n    console.log(req.params.id);\n    // => 123123\n});\n```\n\n#### 表单中的参数\n```js\n// 方式一：语法：req.param.参数名  注意这里没加 s\n// e.g. <input type=\"text\" name=\"user\">\nconsole.log(req.param('user'));\n\n\n// 方式二：使用 body-parser 中间件\n// e.g. <input type=\"text\" name=\"user\">\nvar bodyparser = require('body-parser');\nconsole.console.log(req.boy.user);\n```\n\n### Express 中间件\nExpress 是一个自身功能极简，完全是由路由和中间件构成一个的 Web 开发框架：从本质上来说，一个 Express 应用就是在调用各种中间件。\n![](http://ww3.sinaimg.cn/large/6057861cgw1fbcrpk71zxj20sg03kaaa.jpg)\n如图，中间件（Middleware）位于客户端和路由之间，它好比是一个漏斗，经过这个漏斗的 `Request` 对象和 `Response` 对象以及循环流程中的 `Next` 会被处理，比如正确性校验、业务逻辑处理等。\n\n- 执行任何代码\n- 修改请求和响应对象\n- 终结请求-响应循环\n- 调用堆栈中的下一个中间件\n\n<div class=\"tip\">\n如果当前中间件没有终结请求-响应循环，则必须调用 next() 方法将控制权交给下一个中间件，否则请求就会挂起。\n</div>\n举个例子来说明一下，如何通过 `next()` 方法把控制权交给下一个中间件。\n```js\nvar app = express();\napp.use(function (req, res, next) {\n   var accessToken = req.query.accessToken;\n   //检查请求中是否含有“认证牌”，存在就继续执行。\n   if(accessToken){\n       next(); // 执行下一个中间件\n       }else{\n          res.send(“请求必须包含token”);\n        }\n});\n// ...\n```\n\n#### 应用级中间件\n应用级中间件就是绑定到用 `express()` 生成的对象 `app` 身上的，比如 `app.use()` 中的 `use` 方法，以及 `app.post()` 、`app.get()` 中的 `POST` 和 `GET` 方法等。\n#### 内置中间件\n```js\n// 设置公共静态目录，用于存放 css js image 等文件，项目目录里有 images 目录存放 1.png\n// 那么访问：http://localhost/images/1.png 获取\napp.use(express.static('public'));\n```\n#### 第三方中间件\n中间件可以说是整个 Express 的精华所在了，使用中间件可以几大的扩展项目的功能。使用方法都差不多，这里介绍几个常用的，具体使用方式需要看官方的文档了。\n- 解析客户端请求的 body 中的内容：body-parser\n- cookie 解析中间件：cookie-parser\n- 文件上传中间件：multer\n\n使用命令 `npm i 包名称 --save` 安装到项目中，然后引入项目使用即可。\n","slug":"Node.JS-学习笔记-[05]----Express","published":1,"updated":"2019-12-07T04:59:34.226Z","layout":"post","photos":[],"link":"","_id":"ck3v60jtg000fr9q9o5bovpy9","content":"<p><strong><em>Express</em></strong> 是一个基于 Node.js 平台的极简、灵活的 Web 应用开发框架，它提供一系列强大的特性，帮助你创建各种 Web 和移动设备应用。Express 的核心特性可以概括以下三点。<br><a id=\"more\"></a></p>\n<ul>\n<li>可以设置中间件来响应 HTTP 请求。</li>\n<li>定义了路由表用于执行不同的 HTTP 请求动作。</li>\n<li>可以通过向模板传递参数来动态渲染 HTML 页面。</li>\n</ul>\n<p>下面学习的知识点，都会围绕这几个特性展开。</p>\n<h3 id=\"Express-安装\"><a href=\"#Express-安装\" class=\"headerlink\" title=\"Express 安装\"></a>Express 安装</h3><h4 id=\"在项目中引入-Express\"><a href=\"#在项目中引入-Express\" class=\"headerlink\" title=\"在项目中引入 Express\"></a>在项目中引入 Express</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> projectName              <span class=\"comment\"># 进入新建的 Node.js 项目</span></span><br><span class=\"line\">npm init                    <span class=\"comment\"># 初始化项目配置文件</span></span><br><span class=\"line\">npm install express --save  <span class=\"comment\"># 安装 Express 模块到项目配置文件中</span></span><br></pre></td></tr></table></figure>\n<p>通过上门的命令，就可以完成 Express 的安装，下面在 <code>app.js</code> 中使用 Express 吧！<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> app = express();</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(<span class=\"string\">'/'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">    res.send(<span class=\"string\">'Hello,Express!'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">8080</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Express running at http://127.0.0.1:8080/'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"使用-Express-generator\"><a href=\"#使用-Express-generator\" class=\"headerlink\" title=\"使用 Express-generator\"></a>使用 Express-generator</h4><p>为了方便开发者，更便捷的使用 Express 生成项目，官方提供的快速的生成工具 <code>Express-generator</code>，虽然生成非常快速方便，但是作为初学者，还是要弄清楚里面每条命令所代表的含义，最后再使用官方提供的工具快速生成。打开终端，因为我是 MacOS，所以安装的时候要加上 <code>sudo</code> 否则会报错提示权限不够。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo npm install express-generator -g  <span class=\"comment\"># 全局安装</span></span><br><span class=\"line\">express mywebapp                       <span class=\"comment\"># 创建 mywebapp 项目</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> mywebapp &amp;&amp; npm install             <span class=\"comment\"># 安装依赖文件</span></span><br><span class=\"line\">npm start                              <span class=\"comment\"># 启动项目</span></span><br></pre></td></tr></table></figure></p>\n<p>启动项目后，就可以在浏览器中预览了，访问地址：<a href=\"http://127.0.0.1:3000/\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:3000/</a> 。</p>\n<div class=\"tip\"><br>启动前需要关闭其它已经启用的 Web 服务，否则可能会导致端口占用启动不成功。<br></div>\n\n<h3 id=\"Express-路由\"><a href=\"#Express-路由\" class=\"headerlink\" title=\"Express 路由\"></a>Express 路由</h3><blockquote>\n<p>路由是指如何定义应用的端点（URLs）以及如何响应客户端的请求。</p>\n</blockquote>\n<h4 id=\"基础用法\"><a href=\"#基础用法\" class=\"headerlink\" title=\"基础用法\"></a>基础用法</h4><p>简单理解，其实就是根据不同的请求，来响应与之对应的页面。比如，当用户访问 <a href=\"http://localhost/images/\" target=\"_blank\" rel=\"noopener\">http://localhost/images/</a> 时，根据 URL 可以看出，请求的是 <code>/images</code> 这个目录，那么通过路由，找到这个页面并返回给请求的用户，这个过程就叫路由。来看一个简单的例子。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> app = express();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 当用户请求访问 / 时，响应一个 Hello,Express! 字符串，这就是一个简单路由</span></span><br><span class=\"line\">app.get(<span class=\"string\">'/'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">    res.send(<span class=\"string\">'Hello,Express!'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>这里需要注意 <code>app.all()</code> ,它是一个特殊的路由方法，没有任何 HTTP 方法与其对应，它的作用是对于一个路径上的所有请求加载中间件。 all 相当于既可以处理 <code>GET</code>，也可以处理 <code>POST</code> 。</p>\n<h4 id=\"Router-方法\"><a href=\"#Router-方法\" class=\"headerlink\" title=\"Router 方法\"></a>Router 方法</h4><p>通过 <code>express.Router</code> 类可以创建独立模块的路由模块，它是一个可以挂载的路由对象，把路由模块分离出项目，让整个项目结构清晰、方便管理，这里光说还是挺抽象，举个例子。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 目录结构</span></span><br><span class=\"line\">.</span><br><span class=\"line\">├── index.js</span><br><span class=\"line\">├── node_modules</span><br><span class=\"line\">│   ├── body-parser</span><br><span class=\"line\">│   └── express</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">├── router</span><br><span class=\"line\">│   ├── admin.js</span><br><span class=\"line\">│   └── home.js</span><br><span class=\"line\">└── views</span><br><span class=\"line\">    ├── admin</span><br><span class=\"line\">    └── home</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// index.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> bodyparser = <span class=\"built_in\">require</span>(<span class=\"string\">'body-parser'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 引入外部路由模块</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> home = <span class=\"built_in\">require</span>(<span class=\"string\">'./router/home'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> admin = <span class=\"built_in\">require</span>(<span class=\"string\">'./router/admin'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> app = express();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用中间件 bodyparser ，后面可以在 req.body 中分析出 POST 请求体的内容</span></span><br><span class=\"line\">app.use(bodyparser.urlencoded(&#123;<span class=\"attr\">extended</span>:<span class=\"literal\">false</span>&#125;));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用外部路由模块</span></span><br><span class=\"line\">app.use(<span class=\"string\">'/'</span>,home);</span><br><span class=\"line\">app.use(<span class=\"string\">'/admin'</span>,admin);</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">8080</span>,<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(<span class=\"string\">'visit http://127.0.0.1:8080/'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// admin.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> router = express.Router();<span class=\"comment\">// 用 Router 构造函数实例化 router 对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">router.get(<span class=\"string\">'/login.html'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">    res.sendFile(path.resolve(__dirname + <span class=\"string\">'/../views/admin/'</span> + <span class=\"string\">'login.html'</span>));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">router.get(<span class=\"string\">'/user.html'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">    res.sendFile(path.resolve(__dirname + <span class=\"string\">'/../views/admin/'</span> + <span class=\"string\">'user.html'</span>));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">router.post(<span class=\"string\">'/login.html'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;<span class=\"comment\">// /admin/login.html</span></span><br><span class=\"line\">    res.sendFile(path.resolve(__dirname + <span class=\"string\">'/../views/admin/'</span> + <span class=\"string\">'login.html'</span>));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = router;<span class=\"comment\">// 暴露给外部调用该路由</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Express-响应对象\"><a href=\"#Express-响应对象\" class=\"headerlink\" title=\"Express 响应对象\"></a>Express 响应对象</h3><p>通过响应（Response）对象，服务器可以返回一个来自客户端（浏览器）的 <code>Request</code> ,最终返回给用户的其实就是一个经过业务逻辑层处理的 <code>res</code> 对象。来了解下 Express 的响应对象吧。</p>\n<h4 id=\"send\"><a href=\"#send\" class=\"headerlink\" title=\"send()\"></a>send()</h4><p>Express 已经封装过了原生 Node.js 的响应方法，在原生 Node.js 中，通过 <code>res.write()</code> 方法可以返回字符串和 Buffer。而 Express 中的 <code>send()</code> 可以返回任意数据类型，如流、数据、普通文本等，来看个例子。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">res.send(<span class=\"keyword\">new</span> Buffer(<span class=\"string\">'ifyour'</span>)); <span class=\"comment\">// Buffer</span></span><br><span class=\"line\">res.send(&#123;<span class=\"string\">\"name\"</span>: <span class=\"string\">\"ifyour\"</span>&#125;);   <span class=\"comment\">// JSON</span></span><br><span class=\"line\">res.send(<span class=\"string\">'&lt;p&gt;some html&lt;/p&gt;'</span>);   <span class=\"comment\">// HTML</span></span><br><span class=\"line\">res.status(<span class=\"number\">404</span>).send(<span class=\"string\">'404 Not Find'</span>); <span class=\"comment\">// 设置状态码并返回提示</span></span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"json\"><a href=\"#json\" class=\"headerlink\" title=\"json()\"></a>json()</h4><p>通过 <code>json()</code> 方法可以返回一个 <code>JSON</code> 对象，用于 Ajax 等。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">res.json(<span class=\"literal\">null</span>);</span><br><span class=\"line\">res.json(&#123;<span class=\"string\">\"user\"</span>: <span class=\"string\">\"ifyour\"</span>&#125;);</span><br><span class=\"line\">res.status(<span class=\"number\">500</span>).json(&#123;<span class=\"string\">\"error\"</span>: <span class=\"string\">\"message\"</span>&#125;);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"render\"><a href=\"#render\" class=\"headerlink\" title=\"render()\"></a>render()</h4><p><code>render</code> 用于渲染模板引擎，比如在使用 <a href=\"https://github.com/tj/ejs\" target=\"_blank\" rel=\"noopener\">ejs</a> 模板引擎时，响应用户请求就可以使用 <code>res.render()</code> 返回给用户一个渲染好的页面。这个用的比较多，我来举个例子。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 目录结构</span></span><br><span class=\"line\">.</span><br><span class=\"line\">├── index.js</span><br><span class=\"line\">├── node_modules</span><br><span class=\"line\">│   ├── ejs</span><br><span class=\"line\">│   └── express</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">└── views</span><br><span class=\"line\">    └── login.html</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- ejs 模板引擎，定义了 /login.html --&gt;</span></span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Title<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 注意 ejs 模板中变量的写法 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>欢迎你，<span class=\"tag\">&lt;<span class=\"name\">%=name%</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// index.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> ejs = <span class=\"built_in\">require</span>(<span class=\"string\">'ejs'</span>); <span class=\"comment\">// 引入 ejs 模板引擎</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> app = express();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> viewsPath = path.join(__dirname, <span class=\"string\">'views'</span>);<span class=\"comment\">// views 是模板目录</span></span><br><span class=\"line\"><span class=\"comment\">// 设置 express views 层，模板根路径</span></span><br><span class=\"line\">app.set(<span class=\"string\">'views'</span>, viewsPath);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置 express 实例的模板语言</span></span><br><span class=\"line\">app.set(<span class=\"string\">'view engine'</span>, <span class=\"string\">'html'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 把 express 实例的模板引擎和 ejs 模板引擎关联</span></span><br><span class=\"line\">app.engine(<span class=\"string\">'html'</span>, ejs.__express);</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(<span class=\"string\">'/login.html'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">    res.render(<span class=\"string\">'login'</span>, &#123;<span class=\"attr\">name</span>: <span class=\"string\">\"ifyour\"</span>&#125;);<span class=\"comment\">// 替换到模板变量中的 name 为 ifyour</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">8080</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'visit http://127.0.0.1:8080/'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<div class=\"tip\"><br><code>__dirname</code> 是 Node.js 中定义的 <code>global</code> 全局变量，获取当前文件的绝对路径，返回 <code>string</code> 类型。<br></div>\n\n<h4 id=\"download\"><a href=\"#download\" class=\"headerlink\" title=\"download()\"></a>download()</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">res.download(<span class=\"string\">'./123.doc'</span>); <span class=\"comment\">// 下载当前目录下面的123.doc文件。</span></span><br><span class=\"line\">res.download(<span class=\"string\">'./123.doc'</span>,<span class=\"string\">'books.doc'</span>); <span class=\"comment\">// 下载当前目录下面的123.doc文件，重命名为 books.doc</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"redirect\"><a href=\"#redirect\" class=\"headerlink\" title=\"redirect()\"></a>redirect()</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 重定向到指定的 URL 路径</span></span><br><span class=\"line\">res.redirect(<span class=\"string\">'/404.html'</span>);</span><br><span class=\"line\">res.redirect(<span class=\"string\">'https://www.google.com/'</span>);</span><br></pre></td></tr></table></figure>\n<p>更多响应对象的方法，参考 <a href=\"http://www.expressjs.com.cn/4x/api.html#res\" target=\"_blank\" rel=\"noopener\">Express 官方 API</a>。</p>\n<h3 id=\"Express-请求对象\"><a href=\"#Express-请求对象\" class=\"headerlink\" title=\"Express 请求对象\"></a>Express 请求对象</h3><p>Express 中的 <code>Request</code> 对象，包含了一次请求中的所有数据，比如请求头、路径、Cookies 等，获取请求头中的信息，服务器根据这些信息处理业务逻辑层，最终将处理过后的数据返回给用户。这里总结了常用的请求对象方法。</p>\n<h4 id=\"URL-中的参数\"><a href=\"#URL-中的参数\" class=\"headerlink\" title=\"URL 中的参数\"></a>URL 中的参数</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方式一： req.query.参数名</span></span><br><span class=\"line\"><span class=\"comment\">// e.g.  http://localhost:3000/user?name=ifyour</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(req.query.name);</span><br><span class=\"line\"><span class=\"comment\">// =&gt; ifyour</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方式二：req.params.参数名</span></span><br><span class=\"line\"><span class=\"comment\">//e.g.  http://localhost/post/123123</span></span><br><span class=\"line\">router.get(<span class=\"string\">'/post/:id'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(req.params.id);</span><br><span class=\"line\">    <span class=\"comment\">// =&gt; 123123</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"表单中的参数\"><a href=\"#表单中的参数\" class=\"headerlink\" title=\"表单中的参数\"></a>表单中的参数</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方式一：语法：req.param.参数名  注意这里没加 s</span></span><br><span class=\"line\"><span class=\"comment\">// e.g. &lt;input type=\"text\" name=\"user\"&gt;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(req.param(<span class=\"string\">'user'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方式二：使用 body-parser 中间件</span></span><br><span class=\"line\"><span class=\"comment\">// e.g. &lt;input type=\"text\" name=\"user\"&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bodyparser = <span class=\"built_in\">require</span>(<span class=\"string\">'body-parser'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.console.log(req.boy.user);</span><br></pre></td></tr></table></figure>\n<h3 id=\"Express-中间件\"><a href=\"#Express-中间件\" class=\"headerlink\" title=\"Express 中间件\"></a>Express 中间件</h3><p>Express 是一个自身功能极简，完全是由路由和中间件构成一个的 Web 开发框架：从本质上来说，一个 Express 应用就是在调用各种中间件。<br><img src=\"http://ww3.sinaimg.cn/large/6057861cgw1fbcrpk71zxj20sg03kaaa.jpg\" alt=\"\"><br>如图，中间件（Middleware）位于客户端和路由之间，它好比是一个漏斗，经过这个漏斗的 <code>Request</code> 对象和 <code>Response</code> 对象以及循环流程中的 <code>Next</code> 会被处理，比如正确性校验、业务逻辑处理等。</p>\n<ul>\n<li>执行任何代码</li>\n<li>修改请求和响应对象</li>\n<li>终结请求-响应循环</li>\n<li>调用堆栈中的下一个中间件</li>\n</ul>\n<p><div class=\"tip\"><br>如果当前中间件没有终结请求-响应循环，则必须调用 next() 方法将控制权交给下一个中间件，否则请求就会挂起。<br></div><br>举个例子来说明一下，如何通过 <code>next()</code> 方法把控制权交给下一个中间件。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> app = express();</span><br><span class=\"line\">app.use(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res, next</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> accessToken = req.query.accessToken;</span><br><span class=\"line\">   <span class=\"comment\">//检查请求中是否含有“认证牌”，存在就继续执行。</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span>(accessToken)&#123;</span><br><span class=\"line\">       next(); <span class=\"comment\">// 执行下一个中间件</span></span><br><span class=\"line\">       &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">          res.send(“请求必须包含token”);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"应用级中间件\"><a href=\"#应用级中间件\" class=\"headerlink\" title=\"应用级中间件\"></a>应用级中间件</h4><p>应用级中间件就是绑定到用 <code>express()</code> 生成的对象 <code>app</code> 身上的，比如 <code>app.use()</code> 中的 <code>use</code> 方法，以及 <code>app.post()</code> 、<code>app.get()</code> 中的 <code>POST</code> 和 <code>GET</code> 方法等。</p>\n<h4 id=\"内置中间件\"><a href=\"#内置中间件\" class=\"headerlink\" title=\"内置中间件\"></a>内置中间件</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 设置公共静态目录，用于存放 css js image 等文件，项目目录里有 images 目录存放 1.png</span></span><br><span class=\"line\"><span class=\"comment\">// 那么访问：http://localhost/images/1.png 获取</span></span><br><span class=\"line\">app.use(express.static(<span class=\"string\">'public'</span>));</span><br></pre></td></tr></table></figure>\n<h4 id=\"第三方中间件\"><a href=\"#第三方中间件\" class=\"headerlink\" title=\"第三方中间件\"></a>第三方中间件</h4><p>中间件可以说是整个 Express 的精华所在了，使用中间件可以几大的扩展项目的功能。使用方法都差不多，这里介绍几个常用的，具体使用方式需要看官方的文档了。</p>\n<ul>\n<li>解析客户端请求的 body 中的内容：body-parser</li>\n<li>cookie 解析中间件：cookie-parser</li>\n<li>文件上传中间件：multer</li>\n</ul>\n<p>使用命令 <code>npm i 包名称 --save</code> 安装到项目中，然后引入项目使用即可。</p>\n","site":{"data":{}},"excerpt":"<p><strong><em>Express</em></strong> 是一个基于 Node.js 平台的极简、灵活的 Web 应用开发框架，它提供一系列强大的特性，帮助你创建各种 Web 和移动设备应用。Express 的核心特性可以概括以下三点。<br>","more":"</p>\n<ul>\n<li>可以设置中间件来响应 HTTP 请求。</li>\n<li>定义了路由表用于执行不同的 HTTP 请求动作。</li>\n<li>可以通过向模板传递参数来动态渲染 HTML 页面。</li>\n</ul>\n<p>下面学习的知识点，都会围绕这几个特性展开。</p>\n<h3 id=\"Express-安装\"><a href=\"#Express-安装\" class=\"headerlink\" title=\"Express 安装\"></a>Express 安装</h3><h4 id=\"在项目中引入-Express\"><a href=\"#在项目中引入-Express\" class=\"headerlink\" title=\"在项目中引入 Express\"></a>在项目中引入 Express</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> projectName              <span class=\"comment\"># 进入新建的 Node.js 项目</span></span><br><span class=\"line\">npm init                    <span class=\"comment\"># 初始化项目配置文件</span></span><br><span class=\"line\">npm install express --save  <span class=\"comment\"># 安装 Express 模块到项目配置文件中</span></span><br></pre></td></tr></table></figure>\n<p>通过上门的命令，就可以完成 Express 的安装，下面在 <code>app.js</code> 中使用 Express 吧！<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> app = express();</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(<span class=\"string\">'/'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">    res.send(<span class=\"string\">'Hello,Express!'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">8080</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Express running at http://127.0.0.1:8080/'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"使用-Express-generator\"><a href=\"#使用-Express-generator\" class=\"headerlink\" title=\"使用 Express-generator\"></a>使用 Express-generator</h4><p>为了方便开发者，更便捷的使用 Express 生成项目，官方提供的快速的生成工具 <code>Express-generator</code>，虽然生成非常快速方便，但是作为初学者，还是要弄清楚里面每条命令所代表的含义，最后再使用官方提供的工具快速生成。打开终端，因为我是 MacOS，所以安装的时候要加上 <code>sudo</code> 否则会报错提示权限不够。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo npm install express-generator -g  <span class=\"comment\"># 全局安装</span></span><br><span class=\"line\">express mywebapp                       <span class=\"comment\"># 创建 mywebapp 项目</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> mywebapp &amp;&amp; npm install             <span class=\"comment\"># 安装依赖文件</span></span><br><span class=\"line\">npm start                              <span class=\"comment\"># 启动项目</span></span><br></pre></td></tr></table></figure></p>\n<p>启动项目后，就可以在浏览器中预览了，访问地址：<a href=\"http://127.0.0.1:3000/\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:3000/</a> 。</p>\n<div class=\"tip\"><br>启动前需要关闭其它已经启用的 Web 服务，否则可能会导致端口占用启动不成功。<br></div>\n\n<h3 id=\"Express-路由\"><a href=\"#Express-路由\" class=\"headerlink\" title=\"Express 路由\"></a>Express 路由</h3><blockquote>\n<p>路由是指如何定义应用的端点（URLs）以及如何响应客户端的请求。</p>\n</blockquote>\n<h4 id=\"基础用法\"><a href=\"#基础用法\" class=\"headerlink\" title=\"基础用法\"></a>基础用法</h4><p>简单理解，其实就是根据不同的请求，来响应与之对应的页面。比如，当用户访问 <a href=\"http://localhost/images/\" target=\"_blank\" rel=\"noopener\">http://localhost/images/</a> 时，根据 URL 可以看出，请求的是 <code>/images</code> 这个目录，那么通过路由，找到这个页面并返回给请求的用户，这个过程就叫路由。来看一个简单的例子。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> app = express();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 当用户请求访问 / 时，响应一个 Hello,Express! 字符串，这就是一个简单路由</span></span><br><span class=\"line\">app.get(<span class=\"string\">'/'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">    res.send(<span class=\"string\">'Hello,Express!'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>这里需要注意 <code>app.all()</code> ,它是一个特殊的路由方法，没有任何 HTTP 方法与其对应，它的作用是对于一个路径上的所有请求加载中间件。 all 相当于既可以处理 <code>GET</code>，也可以处理 <code>POST</code> 。</p>\n<h4 id=\"Router-方法\"><a href=\"#Router-方法\" class=\"headerlink\" title=\"Router 方法\"></a>Router 方法</h4><p>通过 <code>express.Router</code> 类可以创建独立模块的路由模块，它是一个可以挂载的路由对象，把路由模块分离出项目，让整个项目结构清晰、方便管理，这里光说还是挺抽象，举个例子。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 目录结构</span></span><br><span class=\"line\">.</span><br><span class=\"line\">├── index.js</span><br><span class=\"line\">├── node_modules</span><br><span class=\"line\">│   ├── body-parser</span><br><span class=\"line\">│   └── express</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">├── router</span><br><span class=\"line\">│   ├── admin.js</span><br><span class=\"line\">│   └── home.js</span><br><span class=\"line\">└── views</span><br><span class=\"line\">    ├── admin</span><br><span class=\"line\">    └── home</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// index.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> bodyparser = <span class=\"built_in\">require</span>(<span class=\"string\">'body-parser'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 引入外部路由模块</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> home = <span class=\"built_in\">require</span>(<span class=\"string\">'./router/home'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> admin = <span class=\"built_in\">require</span>(<span class=\"string\">'./router/admin'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> app = express();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用中间件 bodyparser ，后面可以在 req.body 中分析出 POST 请求体的内容</span></span><br><span class=\"line\">app.use(bodyparser.urlencoded(&#123;<span class=\"attr\">extended</span>:<span class=\"literal\">false</span>&#125;));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用外部路由模块</span></span><br><span class=\"line\">app.use(<span class=\"string\">'/'</span>,home);</span><br><span class=\"line\">app.use(<span class=\"string\">'/admin'</span>,admin);</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">8080</span>,<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(<span class=\"string\">'visit http://127.0.0.1:8080/'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// admin.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> router = express.Router();<span class=\"comment\">// 用 Router 构造函数实例化 router 对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">router.get(<span class=\"string\">'/login.html'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">    res.sendFile(path.resolve(__dirname + <span class=\"string\">'/../views/admin/'</span> + <span class=\"string\">'login.html'</span>));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">router.get(<span class=\"string\">'/user.html'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">    res.sendFile(path.resolve(__dirname + <span class=\"string\">'/../views/admin/'</span> + <span class=\"string\">'user.html'</span>));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">router.post(<span class=\"string\">'/login.html'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;<span class=\"comment\">// /admin/login.html</span></span><br><span class=\"line\">    res.sendFile(path.resolve(__dirname + <span class=\"string\">'/../views/admin/'</span> + <span class=\"string\">'login.html'</span>));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = router;<span class=\"comment\">// 暴露给外部调用该路由</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Express-响应对象\"><a href=\"#Express-响应对象\" class=\"headerlink\" title=\"Express 响应对象\"></a>Express 响应对象</h3><p>通过响应（Response）对象，服务器可以返回一个来自客户端（浏览器）的 <code>Request</code> ,最终返回给用户的其实就是一个经过业务逻辑层处理的 <code>res</code> 对象。来了解下 Express 的响应对象吧。</p>\n<h4 id=\"send\"><a href=\"#send\" class=\"headerlink\" title=\"send()\"></a>send()</h4><p>Express 已经封装过了原生 Node.js 的响应方法，在原生 Node.js 中，通过 <code>res.write()</code> 方法可以返回字符串和 Buffer。而 Express 中的 <code>send()</code> 可以返回任意数据类型，如流、数据、普通文本等，来看个例子。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">res.send(<span class=\"keyword\">new</span> Buffer(<span class=\"string\">'ifyour'</span>)); <span class=\"comment\">// Buffer</span></span><br><span class=\"line\">res.send(&#123;<span class=\"string\">\"name\"</span>: <span class=\"string\">\"ifyour\"</span>&#125;);   <span class=\"comment\">// JSON</span></span><br><span class=\"line\">res.send(<span class=\"string\">'&lt;p&gt;some html&lt;/p&gt;'</span>);   <span class=\"comment\">// HTML</span></span><br><span class=\"line\">res.status(<span class=\"number\">404</span>).send(<span class=\"string\">'404 Not Find'</span>); <span class=\"comment\">// 设置状态码并返回提示</span></span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"json\"><a href=\"#json\" class=\"headerlink\" title=\"json()\"></a>json()</h4><p>通过 <code>json()</code> 方法可以返回一个 <code>JSON</code> 对象，用于 Ajax 等。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">res.json(<span class=\"literal\">null</span>);</span><br><span class=\"line\">res.json(&#123;<span class=\"string\">\"user\"</span>: <span class=\"string\">\"ifyour\"</span>&#125;);</span><br><span class=\"line\">res.status(<span class=\"number\">500</span>).json(&#123;<span class=\"string\">\"error\"</span>: <span class=\"string\">\"message\"</span>&#125;);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"render\"><a href=\"#render\" class=\"headerlink\" title=\"render()\"></a>render()</h4><p><code>render</code> 用于渲染模板引擎，比如在使用 <a href=\"https://github.com/tj/ejs\" target=\"_blank\" rel=\"noopener\">ejs</a> 模板引擎时，响应用户请求就可以使用 <code>res.render()</code> 返回给用户一个渲染好的页面。这个用的比较多，我来举个例子。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 目录结构</span></span><br><span class=\"line\">.</span><br><span class=\"line\">├── index.js</span><br><span class=\"line\">├── node_modules</span><br><span class=\"line\">│   ├── ejs</span><br><span class=\"line\">│   └── express</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">└── views</span><br><span class=\"line\">    └── login.html</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- ejs 模板引擎，定义了 /login.html --&gt;</span></span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Title<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 注意 ejs 模板中变量的写法 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>欢迎你，<span class=\"tag\">&lt;<span class=\"name\">%=name%</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// index.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> ejs = <span class=\"built_in\">require</span>(<span class=\"string\">'ejs'</span>); <span class=\"comment\">// 引入 ejs 模板引擎</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> app = express();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> viewsPath = path.join(__dirname, <span class=\"string\">'views'</span>);<span class=\"comment\">// views 是模板目录</span></span><br><span class=\"line\"><span class=\"comment\">// 设置 express views 层，模板根路径</span></span><br><span class=\"line\">app.set(<span class=\"string\">'views'</span>, viewsPath);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置 express 实例的模板语言</span></span><br><span class=\"line\">app.set(<span class=\"string\">'view engine'</span>, <span class=\"string\">'html'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 把 express 实例的模板引擎和 ejs 模板引擎关联</span></span><br><span class=\"line\">app.engine(<span class=\"string\">'html'</span>, ejs.__express);</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(<span class=\"string\">'/login.html'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">    res.render(<span class=\"string\">'login'</span>, &#123;<span class=\"attr\">name</span>: <span class=\"string\">\"ifyour\"</span>&#125;);<span class=\"comment\">// 替换到模板变量中的 name 为 ifyour</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">8080</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'visit http://127.0.0.1:8080/'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<div class=\"tip\"><br><code>__dirname</code> 是 Node.js 中定义的 <code>global</code> 全局变量，获取当前文件的绝对路径，返回 <code>string</code> 类型。<br></div>\n\n<h4 id=\"download\"><a href=\"#download\" class=\"headerlink\" title=\"download()\"></a>download()</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">res.download(<span class=\"string\">'./123.doc'</span>); <span class=\"comment\">// 下载当前目录下面的123.doc文件。</span></span><br><span class=\"line\">res.download(<span class=\"string\">'./123.doc'</span>,<span class=\"string\">'books.doc'</span>); <span class=\"comment\">// 下载当前目录下面的123.doc文件，重命名为 books.doc</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"redirect\"><a href=\"#redirect\" class=\"headerlink\" title=\"redirect()\"></a>redirect()</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 重定向到指定的 URL 路径</span></span><br><span class=\"line\">res.redirect(<span class=\"string\">'/404.html'</span>);</span><br><span class=\"line\">res.redirect(<span class=\"string\">'https://www.google.com/'</span>);</span><br></pre></td></tr></table></figure>\n<p>更多响应对象的方法，参考 <a href=\"http://www.expressjs.com.cn/4x/api.html#res\" target=\"_blank\" rel=\"noopener\">Express 官方 API</a>。</p>\n<h3 id=\"Express-请求对象\"><a href=\"#Express-请求对象\" class=\"headerlink\" title=\"Express 请求对象\"></a>Express 请求对象</h3><p>Express 中的 <code>Request</code> 对象，包含了一次请求中的所有数据，比如请求头、路径、Cookies 等，获取请求头中的信息，服务器根据这些信息处理业务逻辑层，最终将处理过后的数据返回给用户。这里总结了常用的请求对象方法。</p>\n<h4 id=\"URL-中的参数\"><a href=\"#URL-中的参数\" class=\"headerlink\" title=\"URL 中的参数\"></a>URL 中的参数</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方式一： req.query.参数名</span></span><br><span class=\"line\"><span class=\"comment\">// e.g.  http://localhost:3000/user?name=ifyour</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(req.query.name);</span><br><span class=\"line\"><span class=\"comment\">// =&gt; ifyour</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方式二：req.params.参数名</span></span><br><span class=\"line\"><span class=\"comment\">//e.g.  http://localhost/post/123123</span></span><br><span class=\"line\">router.get(<span class=\"string\">'/post/:id'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(req.params.id);</span><br><span class=\"line\">    <span class=\"comment\">// =&gt; 123123</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"表单中的参数\"><a href=\"#表单中的参数\" class=\"headerlink\" title=\"表单中的参数\"></a>表单中的参数</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方式一：语法：req.param.参数名  注意这里没加 s</span></span><br><span class=\"line\"><span class=\"comment\">// e.g. &lt;input type=\"text\" name=\"user\"&gt;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(req.param(<span class=\"string\">'user'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方式二：使用 body-parser 中间件</span></span><br><span class=\"line\"><span class=\"comment\">// e.g. &lt;input type=\"text\" name=\"user\"&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bodyparser = <span class=\"built_in\">require</span>(<span class=\"string\">'body-parser'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.console.log(req.boy.user);</span><br></pre></td></tr></table></figure>\n<h3 id=\"Express-中间件\"><a href=\"#Express-中间件\" class=\"headerlink\" title=\"Express 中间件\"></a>Express 中间件</h3><p>Express 是一个自身功能极简，完全是由路由和中间件构成一个的 Web 开发框架：从本质上来说，一个 Express 应用就是在调用各种中间件。<br><img src=\"http://ww3.sinaimg.cn/large/6057861cgw1fbcrpk71zxj20sg03kaaa.jpg\" alt=\"\"><br>如图，中间件（Middleware）位于客户端和路由之间，它好比是一个漏斗，经过这个漏斗的 <code>Request</code> 对象和 <code>Response</code> 对象以及循环流程中的 <code>Next</code> 会被处理，比如正确性校验、业务逻辑处理等。</p>\n<ul>\n<li>执行任何代码</li>\n<li>修改请求和响应对象</li>\n<li>终结请求-响应循环</li>\n<li>调用堆栈中的下一个中间件</li>\n</ul>\n<p><div class=\"tip\"><br>如果当前中间件没有终结请求-响应循环，则必须调用 next() 方法将控制权交给下一个中间件，否则请求就会挂起。<br></div><br>举个例子来说明一下，如何通过 <code>next()</code> 方法把控制权交给下一个中间件。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> app = express();</span><br><span class=\"line\">app.use(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res, next</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> accessToken = req.query.accessToken;</span><br><span class=\"line\">   <span class=\"comment\">//检查请求中是否含有“认证牌”，存在就继续执行。</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span>(accessToken)&#123;</span><br><span class=\"line\">       next(); <span class=\"comment\">// 执行下一个中间件</span></span><br><span class=\"line\">       &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">          res.send(“请求必须包含token”);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"应用级中间件\"><a href=\"#应用级中间件\" class=\"headerlink\" title=\"应用级中间件\"></a>应用级中间件</h4><p>应用级中间件就是绑定到用 <code>express()</code> 生成的对象 <code>app</code> 身上的，比如 <code>app.use()</code> 中的 <code>use</code> 方法，以及 <code>app.post()</code> 、<code>app.get()</code> 中的 <code>POST</code> 和 <code>GET</code> 方法等。</p>\n<h4 id=\"内置中间件\"><a href=\"#内置中间件\" class=\"headerlink\" title=\"内置中间件\"></a>内置中间件</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 设置公共静态目录，用于存放 css js image 等文件，项目目录里有 images 目录存放 1.png</span></span><br><span class=\"line\"><span class=\"comment\">// 那么访问：http://localhost/images/1.png 获取</span></span><br><span class=\"line\">app.use(express.static(<span class=\"string\">'public'</span>));</span><br></pre></td></tr></table></figure>\n<h4 id=\"第三方中间件\"><a href=\"#第三方中间件\" class=\"headerlink\" title=\"第三方中间件\"></a>第三方中间件</h4><p>中间件可以说是整个 Express 的精华所在了，使用中间件可以几大的扩展项目的功能。使用方法都差不多，这里介绍几个常用的，具体使用方式需要看官方的文档了。</p>\n<ul>\n<li>解析客户端请求的 body 中的内容：body-parser</li>\n<li>cookie 解析中间件：cookie-parser</li>\n<li>文件上传中间件：multer</li>\n</ul>\n<p>使用命令 <code>npm i 包名称 --save</code> 安装到项目中，然后引入项目使用即可。</p>"},{"title":"ProxyChains-NG + ShadowSocks 实现终端代理","date":"2016-03-23T00:25:31.000Z","comments":0,"_content":"\n经常在终端下执行一些网络命令，例如 `wget` 、`git`、`ssh` 等命令，速度慢的不行，说白了，有些是因为 GFW 的原因，有些则是访问国外的服务器本来速度就很慢，而我们的 ShadowSocks 提供的是 `socks5` 代理，终端无法享用。这个时候 **ProxyChains-NG** 应势而生。\n<!-- more -->\n### 安装\n使用 [brew](http://brew.sh/index_zh-cn.html) 快速安装 ProxyChains-NG，想详细了解 ProxyChains-NG 可以去他们[项目主页](https://github.com/rofl0r/proxychains-ng)。\n```bash\nbrew install proxychains-ng\n```\n\n配置\n```bash\nvi /usr/local/etc/proxychains.conf\n```\n\n添加代理\n```bash\nsocks5  127.0.0.1 1080\n```\n\n### 使用\n到此为止，整个命令安装完成，用法 `proxychains4 需要执行的命令`。举个例子：执行下面的命令后，可以看到是 ss 的 IP 了。\n```bash\nproxychains4 curl ip.cn\n```\n\n\n### 优化\n这个命令太长了，我想换一个！我使用的是 zsh，来给 `proxychains4` 配置一个别名吧！:P\n编辑 zsh 配置文件\n```bash\nvi ~/.zshrc\n```\n\n添加别名\n```bash\nalias myss='proxychains4'\n```\n\n让配置生效\n```bash\nsource ~/.zshrc\n```\n\n再执行之前查看 ip 的命令\n```bash\nmyss curl ip.cn\n```\n\nHave done! :)\n\n### 测速\n使用 speedtest 的命令行工具，来测上行宽带和下行宽度。\n```bash\n# 下载 speedtest-cli\nwget -O speedtest-cli https://raw.githubusercontent.com/sivel/speedtest-cli/master/speedtest.py\n\n# 给执行权限\nchmod +x speedtest-cli\n\n# 运行\n./speedtest-cli\n\n# 测试下代理的速度\nmyss ./speedtest-cli\n```\n\n#### 附：brew 常用命令\n\n|命令          |含义                       |\n|:------------|:--------------------------|\n|安装包        |brew install `<PackageName>`|\n|搜索包        |brew search `<PackageName>` |\n|查询包信息    |brew info `<PackageName>`   |\n|升级指定包    |brew upgrade `<PackageName>`|\n|更新自己      |brew update                |\n|检查过时包    |brew outdated              |\n|升级所有包    |brew upgrade               |\n|清理缓存      |brew cleanup               |\n","source":"_posts/ProxyChains-NG-ShadowSocks-实现终端代理.md","raw":"---\ntitle: ProxyChains-NG + ShadowSocks 实现终端代理\ndate: 2016-03-23 08:25:31\ntags:\ncomments: false\n---\n\n经常在终端下执行一些网络命令，例如 `wget` 、`git`、`ssh` 等命令，速度慢的不行，说白了，有些是因为 GFW 的原因，有些则是访问国外的服务器本来速度就很慢，而我们的 ShadowSocks 提供的是 `socks5` 代理，终端无法享用。这个时候 **ProxyChains-NG** 应势而生。\n<!-- more -->\n### 安装\n使用 [brew](http://brew.sh/index_zh-cn.html) 快速安装 ProxyChains-NG，想详细了解 ProxyChains-NG 可以去他们[项目主页](https://github.com/rofl0r/proxychains-ng)。\n```bash\nbrew install proxychains-ng\n```\n\n配置\n```bash\nvi /usr/local/etc/proxychains.conf\n```\n\n添加代理\n```bash\nsocks5  127.0.0.1 1080\n```\n\n### 使用\n到此为止，整个命令安装完成，用法 `proxychains4 需要执行的命令`。举个例子：执行下面的命令后，可以看到是 ss 的 IP 了。\n```bash\nproxychains4 curl ip.cn\n```\n\n\n### 优化\n这个命令太长了，我想换一个！我使用的是 zsh，来给 `proxychains4` 配置一个别名吧！:P\n编辑 zsh 配置文件\n```bash\nvi ~/.zshrc\n```\n\n添加别名\n```bash\nalias myss='proxychains4'\n```\n\n让配置生效\n```bash\nsource ~/.zshrc\n```\n\n再执行之前查看 ip 的命令\n```bash\nmyss curl ip.cn\n```\n\nHave done! :)\n\n### 测速\n使用 speedtest 的命令行工具，来测上行宽带和下行宽度。\n```bash\n# 下载 speedtest-cli\nwget -O speedtest-cli https://raw.githubusercontent.com/sivel/speedtest-cli/master/speedtest.py\n\n# 给执行权限\nchmod +x speedtest-cli\n\n# 运行\n./speedtest-cli\n\n# 测试下代理的速度\nmyss ./speedtest-cli\n```\n\n#### 附：brew 常用命令\n\n|命令          |含义                       |\n|:------------|:--------------------------|\n|安装包        |brew install `<PackageName>`|\n|搜索包        |brew search `<PackageName>` |\n|查询包信息    |brew info `<PackageName>`   |\n|升级指定包    |brew upgrade `<PackageName>`|\n|更新自己      |brew update                |\n|检查过时包    |brew outdated              |\n|升级所有包    |brew upgrade               |\n|清理缓存      |brew cleanup               |\n","slug":"ProxyChains-NG-ShadowSocks-实现终端代理","published":1,"updated":"2019-12-07T05:22:37.267Z","layout":"post","photos":[],"link":"","_id":"ck3v60jth000gr9q9nomcyr0c","content":"<p>经常在终端下执行一些网络命令，例如 <code>wget</code> 、<code>git</code>、<code>ssh</code> 等命令，速度慢的不行，说白了，有些是因为 GFW 的原因，有些则是访问国外的服务器本来速度就很慢，而我们的 ShadowSocks 提供的是 <code>socks5</code> 代理，终端无法享用。这个时候 <strong>ProxyChains-NG</strong> 应势而生。<br><a id=\"more\"></a></p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>使用 <a href=\"http://brew.sh/index_zh-cn.html\" target=\"_blank\" rel=\"noopener\">brew</a> 快速安装 ProxyChains-NG，想详细了解 ProxyChains-NG 可以去他们<a href=\"https://github.com/rofl0r/proxychains-ng\" target=\"_blank\" rel=\"noopener\">项目主页</a>。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install proxychains-ng</span><br></pre></td></tr></table></figure></p>\n<p>配置<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi /usr/<span class=\"built_in\">local</span>/etc/proxychains.conf</span><br></pre></td></tr></table></figure></p>\n<p>添加代理<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">socks5  127.0.0.1 1080</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>到此为止，整个命令安装完成，用法 <code>proxychains4 需要执行的命令</code>。举个例子：执行下面的命令后，可以看到是 ss 的 IP 了。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">proxychains4 curl ip.cn</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h3><p>这个命令太长了，我想换一个！我使用的是 zsh，来给 <code>proxychains4</code> 配置一个别名吧！:P<br>编辑 zsh 配置文件<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi ~/.zshrc</span><br></pre></td></tr></table></figure></p>\n<p>添加别名<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">alias</span> myss=<span class=\"string\">'proxychains4'</span></span><br></pre></td></tr></table></figure></p>\n<p>让配置生效<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure></p>\n<p>再执行之前查看 ip 的命令<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myss curl ip.cn</span><br></pre></td></tr></table></figure></p>\n<p>Have done! :)</p>\n<h3 id=\"测速\"><a href=\"#测速\" class=\"headerlink\" title=\"测速\"></a>测速</h3><p>使用 speedtest 的命令行工具，来测上行宽带和下行宽度。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 下载 speedtest-cli</span></span><br><span class=\"line\">wget -O speedtest-cli https://raw.githubusercontent.com/sivel/speedtest-cli/master/speedtest.py</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 给执行权限</span></span><br><span class=\"line\">chmod +x speedtest-cli</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 运行</span></span><br><span class=\"line\">./speedtest-cli</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 测试下代理的速度</span></span><br><span class=\"line\">myss ./speedtest-cli</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"附：brew-常用命令\"><a href=\"#附：brew-常用命令\" class=\"headerlink\" title=\"附：brew 常用命令\"></a>附：brew 常用命令</h4><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">命令</th>\n<th style=\"text-align:left\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">安装包</td>\n<td style=\"text-align:left\">brew install <code>&lt;PackageName&gt;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">搜索包</td>\n<td style=\"text-align:left\">brew search <code>&lt;PackageName&gt;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">查询包信息</td>\n<td style=\"text-align:left\">brew info <code>&lt;PackageName&gt;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">升级指定包</td>\n<td style=\"text-align:left\">brew upgrade <code>&lt;PackageName&gt;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">更新自己</td>\n<td style=\"text-align:left\">brew update</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">检查过时包</td>\n<td style=\"text-align:left\">brew outdated</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">升级所有包</td>\n<td style=\"text-align:left\">brew upgrade</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">清理缓存</td>\n<td style=\"text-align:left\">brew cleanup</td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"<p>经常在终端下执行一些网络命令，例如 <code>wget</code> 、<code>git</code>、<code>ssh</code> 等命令，速度慢的不行，说白了，有些是因为 GFW 的原因，有些则是访问国外的服务器本来速度就很慢，而我们的 ShadowSocks 提供的是 <code>socks5</code> 代理，终端无法享用。这个时候 <strong>ProxyChains-NG</strong> 应势而生。<br>","more":"</p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>使用 <a href=\"http://brew.sh/index_zh-cn.html\" target=\"_blank\" rel=\"noopener\">brew</a> 快速安装 ProxyChains-NG，想详细了解 ProxyChains-NG 可以去他们<a href=\"https://github.com/rofl0r/proxychains-ng\" target=\"_blank\" rel=\"noopener\">项目主页</a>。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install proxychains-ng</span><br></pre></td></tr></table></figure></p>\n<p>配置<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi /usr/<span class=\"built_in\">local</span>/etc/proxychains.conf</span><br></pre></td></tr></table></figure></p>\n<p>添加代理<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">socks5  127.0.0.1 1080</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>到此为止，整个命令安装完成，用法 <code>proxychains4 需要执行的命令</code>。举个例子：执行下面的命令后，可以看到是 ss 的 IP 了。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">proxychains4 curl ip.cn</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h3><p>这个命令太长了，我想换一个！我使用的是 zsh，来给 <code>proxychains4</code> 配置一个别名吧！:P<br>编辑 zsh 配置文件<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi ~/.zshrc</span><br></pre></td></tr></table></figure></p>\n<p>添加别名<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">alias</span> myss=<span class=\"string\">'proxychains4'</span></span><br></pre></td></tr></table></figure></p>\n<p>让配置生效<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure></p>\n<p>再执行之前查看 ip 的命令<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myss curl ip.cn</span><br></pre></td></tr></table></figure></p>\n<p>Have done! :)</p>\n<h3 id=\"测速\"><a href=\"#测速\" class=\"headerlink\" title=\"测速\"></a>测速</h3><p>使用 speedtest 的命令行工具，来测上行宽带和下行宽度。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 下载 speedtest-cli</span></span><br><span class=\"line\">wget -O speedtest-cli https://raw.githubusercontent.com/sivel/speedtest-cli/master/speedtest.py</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 给执行权限</span></span><br><span class=\"line\">chmod +x speedtest-cli</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 运行</span></span><br><span class=\"line\">./speedtest-cli</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 测试下代理的速度</span></span><br><span class=\"line\">myss ./speedtest-cli</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"附：brew-常用命令\"><a href=\"#附：brew-常用命令\" class=\"headerlink\" title=\"附：brew 常用命令\"></a>附：brew 常用命令</h4><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">命令</th>\n<th style=\"text-align:left\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">安装包</td>\n<td style=\"text-align:left\">brew install <code>&lt;PackageName&gt;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">搜索包</td>\n<td style=\"text-align:left\">brew search <code>&lt;PackageName&gt;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">查询包信息</td>\n<td style=\"text-align:left\">brew info <code>&lt;PackageName&gt;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">升级指定包</td>\n<td style=\"text-align:left\">brew upgrade <code>&lt;PackageName&gt;</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">更新自己</td>\n<td style=\"text-align:left\">brew update</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">检查过时包</td>\n<td style=\"text-align:left\">brew outdated</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">升级所有包</td>\n<td style=\"text-align:left\">brew upgrade</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">清理缓存</td>\n<td style=\"text-align:left\">brew cleanup</td>\n</tr>\n</tbody>\n</table>"},{"title":"React 组件模式","comments":1,"date":"2018-05-14T16:33:40.000Z","from":"https://levelup.gitconnected.com/react-component-patterns-ab1f09be2c82","_content":"\n使用 React 已经有一段时间了， React 是 Facebook 公司开发的用于构建网页界面的 UI 库。本文试图总结实践中所学到的一些模式，同时希望能够帮助到即将迈入组件世界的开发者。\n\n<!-- more -->\n\n### 概要\n\n- 有状态组件 vs 无状态组件\n- 容器组件 vs 展示组件\n- 高阶组件 vs 回调渲染组件\n\n![image](https://user-images.githubusercontent.com/15377484/40128970-a333542c-5965-11e8-8505-d1284d2759b1.png)\n\n### 有状态组件 vs 无状态组件\n\n正如 WEB 服务有静态和动态之分，React 组件也有有状态和无状态的区分。\n\n- 有状态组件：在应用中组件可以拥有自身状态并操纵它；\n- 无状态组件：只接收属性进行效果呈现。\n\n一个简单的无状态组件，只受属性控制:\n\n```jsx\nconst Button = props => <button onClick={props.onClick}>{props.text}</button>;\n```\n\n一个具有计数功能的按钮组件 (复用上面 Button 组件)\n\n```jsx\nclass ButtonCounter extends React.Component {\n  constructor() {\n    super();\n    this.state = { clicks: 0 };\n    this.handleClick = this.handleClick.bind(this);\n  }\n\n  handleClick() {\n    this.setState({ clicks: this.state.clicks + 1 });\n  }\n\n  render() {\n    return (\n      <Button\n        onClick={this.handleClick}\n        text={`You've clicked me ${this.state.clicks} times!`}\n      />\n    );\n  }\n}\n```\n\n正如上面两个 Demo 所示，第二个组件的 `constructor` 具有状态的定义，第一个组件只是单纯地渲染属性文字。有状态组件和无状态组件的划分看起来非常简单，但是它对于组件复用具有重大意义。\n\n### 容器组件 vs 展示组件\n\n当组件需要获取外部数据时，我们又可以将组件划分为两种新的类型。容器组件负责获取数据，它常常是超出了 React 范畴的，如使用 Redux 或 Relay 进行了绑定。对比而言，展示型组件不依赖于程序其他部分，它只和自身状态或属性有关。下面我们实现一个用户列表的展示组件:\n\n```jsx\nconst UserList = props => (\n  <ul>\n    {props.users.map(u => (\n      <li>\n        {u.name} — {u.age} years old\n      </li>\n    ))}\n  </ul>\n);\n```\n\n容器组件可以用来更新用户列表的展示:\n\n```jsx\nclass UserListContainer extends React.Component {\n  constructor() {\n    super();\n    this.state = { users: [] };\n  }\n\n  componentDidMount() {\n    fetchUsers(users => this.setState({ users }));\n  }\n\n  render() {\n    return <UserList users={this.state.users} />;\n  }\n}\n```\n\n这种分类将数据获取和渲染的逻辑分开，进而使用户列表组件可以复用。\n\n如果你想了解更多该模式的信息，[这篇文章](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0)对它进行了详细的解释。\n\n### 高阶组件\n\n当你想复用组件逻辑时，高阶组件非常有用。高阶组件：是将组件作为参数并返回新组件的 JS 函数。\n\n假设你需要构建一个可扩展菜单组件，当用户点击时，它会显示隐藏子组件内容。因此，你可以使用高阶组件来实现:\n\n```jsx\nfunction makeToggleable(Clickable) {\n  return class extends React.Component {\n    constructor() {\n      super();\n      this.toggle = this.toggle.bind(this);\n      this.state = { show: false };\n    }\n\n    toggle() {\n      this.setState(prevState => ({ show: !prevState.show }));\n    }\n\n    render() {\n      return (\n        <div>\n          <Clickable {...this.props} onClick={this.toggle} />\n          {this.state.show && this.props.children}\n        </div>\n      );\n    }\n  };\n}\n```\n\n这种方法允许我们使用 ES7 装饰器语法将逻辑应用于 ToggleableMenu 组件:\n\n```jsx\n@makeToggleable\nclass ToggleableMenu extends React.Component {\n  render() {\n    return (\n      <div onClick={this.props.onClick}>\n        <h1>{this.props.title}</h1>\n      </div>\n    );\n  }\n}\n```\n\n现在，我们可以将任何子组件传递给 ToggleableMenu 组件:\n\n```jsx\nclass Menu extends React.Component {\n  render() {\n    return (\n      <div>\n        <ToggleableMenu title=\"First Menu\">\n          <p>Some content</p>\n        </ToggleableMenu>\n        <ToggleableMenu title=\"Second Menu\">\n          <p>Another content</p>\n        </ToggleableMenu>\n        <ToggleableMenu title=\"Third Menu\">\n          <p>More content</p>\n        </ToggleableMenu>\n      </div>\n    );\n  }\n}\n```\n\n如果你熟悉 Redux 的 connect 函数或者 React Router 的 withRouter 函数，那么你已经使用过高阶组件了。\n\n### 回调渲染组件\n\n另一个比较高端的复用组件逻辑的方法是将函数作为组件的 `props.children`，该方法也称为 **Function as Child Components**。我们将使用**渲染回调**来重新实现上面的可扩展 Menu:\n\n```jsx\nclass Toggleable extends React.Component {\n  constructor() {\n    super();\n    this.toggle = this.toggle.bind(this);\n    this.state = { show: false };\n  }\n\n  toggle() {\n    this.setState(prevState => ({ show: !prevState.show }));\n  }\n\n  render() {\n    return this.props.children(this.state.show, this.toggle);\n  }\n}\n```\n\n现在，我们可以将函数作为组件的子级进行传递:\n\n```jsx\n<Toggleable>\n  {(show, onClick) => (\n    <div>\n      <div onClick={onClick}>\n        <h1>{props.title}</h1>\n      </div>\n      {show && props.children}\n    </div>\n  )}\n</Toggleable>\n```\n\n上面的代码已经将一个函数作为**子组件**，但是，若我们想复用上述逻辑，我们需要创建一个转换逻辑的新组件：\n\n```jsx\nconst ToggleableMenu = props => (\n  <Toggleable>\n    {(show, onClick) => (\n      <div>\n        <div onClick={onClick}>\n          <h1>{props.title}</h1>\n        </div>\n        {show && props.children}\n      </div>\n    )}\n  </Toggleable>\n);\n```\n\n我们使用 Render Callbacks 实现的可扩展的 Menu 组件如下:\n\n```jsx\nclass Menu extends React.Component {\n  render() {\n    return (\n      <div>\n        <ToggleableMenu title=\"First Menu\">\n          <p>Some content</p>\n        </ToggleableMenu>\n        <ToggleableMenu title=\"Second Menu\">\n          <p>Another content</p>\n        </ToggleableMenu>\n        <ToggleableMenu title=\"Third Menu\">\n          <p>More content</p>\n        </ToggleableMenu>\n      </div>\n    );\n  }\n}\n```\n\n回调渲染组件 (Render Callbacks) 和高阶函数使我们的组件更加灵活，掌握和适应起来具有一定的难度，需要反复学习和消化。\n","source":"_posts/React-组件模式.md","raw":"---\ntitle: React 组件模式\ncomments: true\ndate: 2018-05-15 00:33:40\ntags:\nfrom: https://levelup.gitconnected.com/react-component-patterns-ab1f09be2c82\n---\n\n使用 React 已经有一段时间了， React 是 Facebook 公司开发的用于构建网页界面的 UI 库。本文试图总结实践中所学到的一些模式，同时希望能够帮助到即将迈入组件世界的开发者。\n\n<!-- more -->\n\n### 概要\n\n- 有状态组件 vs 无状态组件\n- 容器组件 vs 展示组件\n- 高阶组件 vs 回调渲染组件\n\n![image](https://user-images.githubusercontent.com/15377484/40128970-a333542c-5965-11e8-8505-d1284d2759b1.png)\n\n### 有状态组件 vs 无状态组件\n\n正如 WEB 服务有静态和动态之分，React 组件也有有状态和无状态的区分。\n\n- 有状态组件：在应用中组件可以拥有自身状态并操纵它；\n- 无状态组件：只接收属性进行效果呈现。\n\n一个简单的无状态组件，只受属性控制:\n\n```jsx\nconst Button = props => <button onClick={props.onClick}>{props.text}</button>;\n```\n\n一个具有计数功能的按钮组件 (复用上面 Button 组件)\n\n```jsx\nclass ButtonCounter extends React.Component {\n  constructor() {\n    super();\n    this.state = { clicks: 0 };\n    this.handleClick = this.handleClick.bind(this);\n  }\n\n  handleClick() {\n    this.setState({ clicks: this.state.clicks + 1 });\n  }\n\n  render() {\n    return (\n      <Button\n        onClick={this.handleClick}\n        text={`You've clicked me ${this.state.clicks} times!`}\n      />\n    );\n  }\n}\n```\n\n正如上面两个 Demo 所示，第二个组件的 `constructor` 具有状态的定义，第一个组件只是单纯地渲染属性文字。有状态组件和无状态组件的划分看起来非常简单，但是它对于组件复用具有重大意义。\n\n### 容器组件 vs 展示组件\n\n当组件需要获取外部数据时，我们又可以将组件划分为两种新的类型。容器组件负责获取数据，它常常是超出了 React 范畴的，如使用 Redux 或 Relay 进行了绑定。对比而言，展示型组件不依赖于程序其他部分，它只和自身状态或属性有关。下面我们实现一个用户列表的展示组件:\n\n```jsx\nconst UserList = props => (\n  <ul>\n    {props.users.map(u => (\n      <li>\n        {u.name} — {u.age} years old\n      </li>\n    ))}\n  </ul>\n);\n```\n\n容器组件可以用来更新用户列表的展示:\n\n```jsx\nclass UserListContainer extends React.Component {\n  constructor() {\n    super();\n    this.state = { users: [] };\n  }\n\n  componentDidMount() {\n    fetchUsers(users => this.setState({ users }));\n  }\n\n  render() {\n    return <UserList users={this.state.users} />;\n  }\n}\n```\n\n这种分类将数据获取和渲染的逻辑分开，进而使用户列表组件可以复用。\n\n如果你想了解更多该模式的信息，[这篇文章](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0)对它进行了详细的解释。\n\n### 高阶组件\n\n当你想复用组件逻辑时，高阶组件非常有用。高阶组件：是将组件作为参数并返回新组件的 JS 函数。\n\n假设你需要构建一个可扩展菜单组件，当用户点击时，它会显示隐藏子组件内容。因此，你可以使用高阶组件来实现:\n\n```jsx\nfunction makeToggleable(Clickable) {\n  return class extends React.Component {\n    constructor() {\n      super();\n      this.toggle = this.toggle.bind(this);\n      this.state = { show: false };\n    }\n\n    toggle() {\n      this.setState(prevState => ({ show: !prevState.show }));\n    }\n\n    render() {\n      return (\n        <div>\n          <Clickable {...this.props} onClick={this.toggle} />\n          {this.state.show && this.props.children}\n        </div>\n      );\n    }\n  };\n}\n```\n\n这种方法允许我们使用 ES7 装饰器语法将逻辑应用于 ToggleableMenu 组件:\n\n```jsx\n@makeToggleable\nclass ToggleableMenu extends React.Component {\n  render() {\n    return (\n      <div onClick={this.props.onClick}>\n        <h1>{this.props.title}</h1>\n      </div>\n    );\n  }\n}\n```\n\n现在，我们可以将任何子组件传递给 ToggleableMenu 组件:\n\n```jsx\nclass Menu extends React.Component {\n  render() {\n    return (\n      <div>\n        <ToggleableMenu title=\"First Menu\">\n          <p>Some content</p>\n        </ToggleableMenu>\n        <ToggleableMenu title=\"Second Menu\">\n          <p>Another content</p>\n        </ToggleableMenu>\n        <ToggleableMenu title=\"Third Menu\">\n          <p>More content</p>\n        </ToggleableMenu>\n      </div>\n    );\n  }\n}\n```\n\n如果你熟悉 Redux 的 connect 函数或者 React Router 的 withRouter 函数，那么你已经使用过高阶组件了。\n\n### 回调渲染组件\n\n另一个比较高端的复用组件逻辑的方法是将函数作为组件的 `props.children`，该方法也称为 **Function as Child Components**。我们将使用**渲染回调**来重新实现上面的可扩展 Menu:\n\n```jsx\nclass Toggleable extends React.Component {\n  constructor() {\n    super();\n    this.toggle = this.toggle.bind(this);\n    this.state = { show: false };\n  }\n\n  toggle() {\n    this.setState(prevState => ({ show: !prevState.show }));\n  }\n\n  render() {\n    return this.props.children(this.state.show, this.toggle);\n  }\n}\n```\n\n现在，我们可以将函数作为组件的子级进行传递:\n\n```jsx\n<Toggleable>\n  {(show, onClick) => (\n    <div>\n      <div onClick={onClick}>\n        <h1>{props.title}</h1>\n      </div>\n      {show && props.children}\n    </div>\n  )}\n</Toggleable>\n```\n\n上面的代码已经将一个函数作为**子组件**，但是，若我们想复用上述逻辑，我们需要创建一个转换逻辑的新组件：\n\n```jsx\nconst ToggleableMenu = props => (\n  <Toggleable>\n    {(show, onClick) => (\n      <div>\n        <div onClick={onClick}>\n          <h1>{props.title}</h1>\n        </div>\n        {show && props.children}\n      </div>\n    )}\n  </Toggleable>\n);\n```\n\n我们使用 Render Callbacks 实现的可扩展的 Menu 组件如下:\n\n```jsx\nclass Menu extends React.Component {\n  render() {\n    return (\n      <div>\n        <ToggleableMenu title=\"First Menu\">\n          <p>Some content</p>\n        </ToggleableMenu>\n        <ToggleableMenu title=\"Second Menu\">\n          <p>Another content</p>\n        </ToggleableMenu>\n        <ToggleableMenu title=\"Third Menu\">\n          <p>More content</p>\n        </ToggleableMenu>\n      </div>\n    );\n  }\n}\n```\n\n回调渲染组件 (Render Callbacks) 和高阶函数使我们的组件更加灵活，掌握和适应起来具有一定的难度，需要反复学习和消化。\n","slug":"React-组件模式","published":1,"updated":"2019-12-07T04:59:34.371Z","layout":"post","photos":[],"link":"","_id":"ck3v60jti000hr9q9bu4g0xyd","content":"<p>使用 React 已经有一段时间了， React 是 Facebook 公司开发的用于构建网页界面的 UI 库。本文试图总结实践中所学到的一些模式，同时希望能够帮助到即将迈入组件世界的开发者。</p>\n<a id=\"more\"></a>\n<h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><ul>\n<li>有状态组件 vs 无状态组件</li>\n<li>容器组件 vs 展示组件</li>\n<li>高阶组件 vs 回调渲染组件</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/15377484/40128970-a333542c-5965-11e8-8505-d1284d2759b1.png\" alt=\"image\"></p>\n<h3 id=\"有状态组件-vs-无状态组件\"><a href=\"#有状态组件-vs-无状态组件\" class=\"headerlink\" title=\"有状态组件 vs 无状态组件\"></a>有状态组件 vs 无状态组件</h3><p>正如 WEB 服务有静态和动态之分，React 组件也有有状态和无状态的区分。</p>\n<ul>\n<li>有状态组件：在应用中组件可以拥有自身状态并操纵它；</li>\n<li>无状态组件：只接收属性进行效果呈现。</li>\n</ul>\n<p>一个简单的无状态组件，只受属性控制:</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Button = <span class=\"function\"><span class=\"params\">props</span> =&gt;</span> &lt;button onClick=&#123;props.onClick&#125;&gt;&#123;props.text&#125;&lt;<span class=\"regexp\">/button&gt;;</span></span><br></pre></td></tr></table></figure>\n<p>一个具有计数功能的按钮组件 (复用上面 Button 组件)</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ButtonCounter</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123; <span class=\"attr\">clicks</span>: <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.handleClick = <span class=\"keyword\">this</span>.handleClick.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  handleClick() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123; <span class=\"attr\">clicks</span>: <span class=\"keyword\">this</span>.state.clicks + <span class=\"number\">1</span> &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;Button</span><br><span class=\"line\">        onClick=&#123;<span class=\"keyword\">this</span>.handleClick&#125;</span><br><span class=\"line\">        text=&#123;<span class=\"string\">`You've clicked me <span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.state.clicks&#125;</span> times!`</span>&#125;</span><br><span class=\"line\">      /&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>正如上面两个 Demo 所示，第二个组件的 <code>constructor</code> 具有状态的定义，第一个组件只是单纯地渲染属性文字。有状态组件和无状态组件的划分看起来非常简单，但是它对于组件复用具有重大意义。</p>\n<h3 id=\"容器组件-vs-展示组件\"><a href=\"#容器组件-vs-展示组件\" class=\"headerlink\" title=\"容器组件 vs 展示组件\"></a>容器组件 vs 展示组件</h3><p>当组件需要获取外部数据时，我们又可以将组件划分为两种新的类型。容器组件负责获取数据，它常常是超出了 React 范畴的，如使用 Redux 或 Relay 进行了绑定。对比而言，展示型组件不依赖于程序其他部分，它只和自身状态或属性有关。下面我们实现一个用户列表的展示组件:</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> UserList = <span class=\"function\"><span class=\"params\">props</span> =&gt;</span> (</span><br><span class=\"line\">  &lt;ul&gt;</span><br><span class=\"line\">    &#123;props.users.map(<span class=\"function\"><span class=\"params\">u</span> =&gt;</span> (</span><br><span class=\"line\">      &lt;li&gt;</span><br><span class=\"line\">        &#123;u.name&#125; — &#123;u.age&#125; years old</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/li&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    ))&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;/u</span>l&gt;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>容器组件可以用来更新用户列表的展示:</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserListContainer</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123; <span class=\"attr\">users</span>: [] &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  componentDidMount() &#123;</span><br><span class=\"line\">    fetchUsers(<span class=\"function\"><span class=\"params\">users</span> =&gt;</span> <span class=\"keyword\">this</span>.setState(&#123; users &#125;));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">UserList</span> <span class=\"attr\">users</span>=<span class=\"string\">&#123;this.state.users&#125;</span> /&gt;</span>;</span></span><br><span class=\"line\"><span class=\"xml\">  &#125;</span></span><br><span class=\"line\"><span class=\"xml\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>这种分类将数据获取和渲染的逻辑分开，进而使用户列表组件可以复用。</p>\n<p>如果你想了解更多该模式的信息，<a href=\"https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0\" target=\"_blank\" rel=\"noopener\">这篇文章</a>对它进行了详细的解释。</p>\n<h3 id=\"高阶组件\"><a href=\"#高阶组件\" class=\"headerlink\" title=\"高阶组件\"></a>高阶组件</h3><p>当你想复用组件逻辑时，高阶组件非常有用。高阶组件：是将组件作为参数并返回新组件的 JS 函数。</p>\n<p>假设你需要构建一个可扩展菜单组件，当用户点击时，它会显示隐藏子组件内容。因此，你可以使用高阶组件来实现:</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">makeToggleable</span>(<span class=\"params\">Clickable</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>();</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.toggle = <span class=\"keyword\">this</span>.toggle.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.state = &#123; <span class=\"attr\">show</span>: <span class=\"literal\">false</span> &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    toggle() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.setState(<span class=\"function\"><span class=\"params\">prevState</span> =&gt;</span> (&#123; <span class=\"attr\">show</span>: !prevState.show &#125;));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">          &lt;Clickable &#123;...this.props&#125; onClick=&#123;<span class=\"keyword\">this</span>.toggle&#125; /&gt;</span><br><span class=\"line\">          &#123;<span class=\"keyword\">this</span>.state.show &amp;&amp; <span class=\"keyword\">this</span>.props.children&#125;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      );</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>这种方法允许我们使用 ES7 装饰器语法将逻辑应用于 ToggleableMenu 组件:</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@makeToggleable</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ToggleableMenu</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div onClick=&#123;<span class=\"keyword\">this</span>.props.onClick&#125;&gt;</span><br><span class=\"line\">        &lt;h1&gt;&#123;<span class=\"keyword\">this</span>.props.title&#125;&lt;<span class=\"regexp\">/h1&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在，我们可以将任何子组件传递给 ToggleableMenu 组件:</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Menu</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;ToggleableMenu title=<span class=\"string\">\"First Menu\"</span>&gt;</span><br><span class=\"line\">          &lt;p&gt;Some content&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>ToggleableMenu&gt;</span><br><span class=\"line\">        &lt;ToggleableMenu title=<span class=\"string\">\"Second Menu\"</span>&gt;</span><br><span class=\"line\">          &lt;p&gt;Another content&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>ToggleableMenu&gt;</span><br><span class=\"line\">        &lt;ToggleableMenu title=<span class=\"string\">\"Third Menu\"</span>&gt;</span><br><span class=\"line\">          &lt;p&gt;More content&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>ToggleableMenu&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>如果你熟悉 Redux 的 connect 函数或者 React Router 的 withRouter 函数，那么你已经使用过高阶组件了。</p>\n<h3 id=\"回调渲染组件\"><a href=\"#回调渲染组件\" class=\"headerlink\" title=\"回调渲染组件\"></a>回调渲染组件</h3><p>另一个比较高端的复用组件逻辑的方法是将函数作为组件的 <code>props.children</code>，该方法也称为 <strong>Function as Child Components</strong>。我们将使用<strong>渲染回调</strong>来重新实现上面的可扩展 Menu:</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Toggleable</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.toggle = <span class=\"keyword\">this</span>.toggle.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123; <span class=\"attr\">show</span>: <span class=\"literal\">false</span> &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  toggle() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(<span class=\"function\"><span class=\"params\">prevState</span> =&gt;</span> (&#123; <span class=\"attr\">show</span>: !prevState.show &#125;));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.props.children(<span class=\"keyword\">this</span>.state.show, <span class=\"keyword\">this</span>.toggle);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在，我们可以将函数作为组件的子级进行传递:</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Toggleable&gt;</span><br><span class=\"line\">  &#123;(show, onClick) =&gt; (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;div onClick=&#123;onClick&#125;&gt;</span><br><span class=\"line\">        &lt;h1&gt;&#123;props.title&#125;&lt;<span class=\"regexp\">/h1&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">      &#123;show &amp;&amp; props.children&#125;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  )&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/</span>Toggleable&gt;</span><br></pre></td></tr></table></figure>\n<p>上面的代码已经将一个函数作为<strong>子组件</strong>，但是，若我们想复用上述逻辑，我们需要创建一个转换逻辑的新组件：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ToggleableMenu = <span class=\"function\"><span class=\"params\">props</span> =&gt;</span> (</span><br><span class=\"line\">  &lt;Toggleable&gt;</span><br><span class=\"line\">    &#123;(show, onClick) =&gt; (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;div onClick=&#123;onClick&#125;&gt;</span><br><span class=\"line\">          &lt;h1&gt;&#123;props.title&#125;&lt;<span class=\"regexp\">/h1&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>div&gt;</span><br><span class=\"line\">        &#123;show &amp;&amp; props.children&#125;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    )&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;/</span>Toggleable&gt;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>我们使用 Render Callbacks 实现的可扩展的 Menu 组件如下:</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Menu</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;ToggleableMenu title=<span class=\"string\">\"First Menu\"</span>&gt;</span><br><span class=\"line\">          &lt;p&gt;Some content&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>ToggleableMenu&gt;</span><br><span class=\"line\">        &lt;ToggleableMenu title=<span class=\"string\">\"Second Menu\"</span>&gt;</span><br><span class=\"line\">          &lt;p&gt;Another content&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>ToggleableMenu&gt;</span><br><span class=\"line\">        &lt;ToggleableMenu title=<span class=\"string\">\"Third Menu\"</span>&gt;</span><br><span class=\"line\">          &lt;p&gt;More content&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>ToggleableMenu&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>回调渲染组件 (Render Callbacks) 和高阶函数使我们的组件更加灵活，掌握和适应起来具有一定的难度，需要反复学习和消化。</p>\n","site":{"data":{}},"excerpt":"<p>使用 React 已经有一段时间了， React 是 Facebook 公司开发的用于构建网页界面的 UI 库。本文试图总结实践中所学到的一些模式，同时希望能够帮助到即将迈入组件世界的开发者。</p>","more":"<h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><ul>\n<li>有状态组件 vs 无状态组件</li>\n<li>容器组件 vs 展示组件</li>\n<li>高阶组件 vs 回调渲染组件</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/15377484/40128970-a333542c-5965-11e8-8505-d1284d2759b1.png\" alt=\"image\"></p>\n<h3 id=\"有状态组件-vs-无状态组件\"><a href=\"#有状态组件-vs-无状态组件\" class=\"headerlink\" title=\"有状态组件 vs 无状态组件\"></a>有状态组件 vs 无状态组件</h3><p>正如 WEB 服务有静态和动态之分，React 组件也有有状态和无状态的区分。</p>\n<ul>\n<li>有状态组件：在应用中组件可以拥有自身状态并操纵它；</li>\n<li>无状态组件：只接收属性进行效果呈现。</li>\n</ul>\n<p>一个简单的无状态组件，只受属性控制:</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Button = <span class=\"function\"><span class=\"params\">props</span> =&gt;</span> &lt;button onClick=&#123;props.onClick&#125;&gt;&#123;props.text&#125;&lt;<span class=\"regexp\">/button&gt;;</span></span><br></pre></td></tr></table></figure>\n<p>一个具有计数功能的按钮组件 (复用上面 Button 组件)</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ButtonCounter</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123; <span class=\"attr\">clicks</span>: <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.handleClick = <span class=\"keyword\">this</span>.handleClick.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  handleClick() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123; <span class=\"attr\">clicks</span>: <span class=\"keyword\">this</span>.state.clicks + <span class=\"number\">1</span> &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;Button</span><br><span class=\"line\">        onClick=&#123;<span class=\"keyword\">this</span>.handleClick&#125;</span><br><span class=\"line\">        text=&#123;<span class=\"string\">`You've clicked me <span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.state.clicks&#125;</span> times!`</span>&#125;</span><br><span class=\"line\">      /&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>正如上面两个 Demo 所示，第二个组件的 <code>constructor</code> 具有状态的定义，第一个组件只是单纯地渲染属性文字。有状态组件和无状态组件的划分看起来非常简单，但是它对于组件复用具有重大意义。</p>\n<h3 id=\"容器组件-vs-展示组件\"><a href=\"#容器组件-vs-展示组件\" class=\"headerlink\" title=\"容器组件 vs 展示组件\"></a>容器组件 vs 展示组件</h3><p>当组件需要获取外部数据时，我们又可以将组件划分为两种新的类型。容器组件负责获取数据，它常常是超出了 React 范畴的，如使用 Redux 或 Relay 进行了绑定。对比而言，展示型组件不依赖于程序其他部分，它只和自身状态或属性有关。下面我们实现一个用户列表的展示组件:</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> UserList = <span class=\"function\"><span class=\"params\">props</span> =&gt;</span> (</span><br><span class=\"line\">  &lt;ul&gt;</span><br><span class=\"line\">    &#123;props.users.map(<span class=\"function\"><span class=\"params\">u</span> =&gt;</span> (</span><br><span class=\"line\">      &lt;li&gt;</span><br><span class=\"line\">        &#123;u.name&#125; — &#123;u.age&#125; years old</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/li&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    ))&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;/u</span>l&gt;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>容器组件可以用来更新用户列表的展示:</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserListContainer</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123; <span class=\"attr\">users</span>: [] &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  componentDidMount() &#123;</span><br><span class=\"line\">    fetchUsers(<span class=\"function\"><span class=\"params\">users</span> =&gt;</span> <span class=\"keyword\">this</span>.setState(&#123; users &#125;));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">UserList</span> <span class=\"attr\">users</span>=<span class=\"string\">&#123;this.state.users&#125;</span> /&gt;</span>;</span></span><br><span class=\"line\"><span class=\"xml\">  &#125;</span></span><br><span class=\"line\"><span class=\"xml\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>这种分类将数据获取和渲染的逻辑分开，进而使用户列表组件可以复用。</p>\n<p>如果你想了解更多该模式的信息，<a href=\"https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0\" target=\"_blank\" rel=\"noopener\">这篇文章</a>对它进行了详细的解释。</p>\n<h3 id=\"高阶组件\"><a href=\"#高阶组件\" class=\"headerlink\" title=\"高阶组件\"></a>高阶组件</h3><p>当你想复用组件逻辑时，高阶组件非常有用。高阶组件：是将组件作为参数并返回新组件的 JS 函数。</p>\n<p>假设你需要构建一个可扩展菜单组件，当用户点击时，它会显示隐藏子组件内容。因此，你可以使用高阶组件来实现:</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">makeToggleable</span>(<span class=\"params\">Clickable</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>();</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.toggle = <span class=\"keyword\">this</span>.toggle.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.state = &#123; <span class=\"attr\">show</span>: <span class=\"literal\">false</span> &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    toggle() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.setState(<span class=\"function\"><span class=\"params\">prevState</span> =&gt;</span> (&#123; <span class=\"attr\">show</span>: !prevState.show &#125;));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">          &lt;Clickable &#123;...this.props&#125; onClick=&#123;<span class=\"keyword\">this</span>.toggle&#125; /&gt;</span><br><span class=\"line\">          &#123;<span class=\"keyword\">this</span>.state.show &amp;&amp; <span class=\"keyword\">this</span>.props.children&#125;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      );</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>这种方法允许我们使用 ES7 装饰器语法将逻辑应用于 ToggleableMenu 组件:</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@makeToggleable</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ToggleableMenu</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div onClick=&#123;<span class=\"keyword\">this</span>.props.onClick&#125;&gt;</span><br><span class=\"line\">        &lt;h1&gt;&#123;<span class=\"keyword\">this</span>.props.title&#125;&lt;<span class=\"regexp\">/h1&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在，我们可以将任何子组件传递给 ToggleableMenu 组件:</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Menu</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;ToggleableMenu title=<span class=\"string\">\"First Menu\"</span>&gt;</span><br><span class=\"line\">          &lt;p&gt;Some content&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>ToggleableMenu&gt;</span><br><span class=\"line\">        &lt;ToggleableMenu title=<span class=\"string\">\"Second Menu\"</span>&gt;</span><br><span class=\"line\">          &lt;p&gt;Another content&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>ToggleableMenu&gt;</span><br><span class=\"line\">        &lt;ToggleableMenu title=<span class=\"string\">\"Third Menu\"</span>&gt;</span><br><span class=\"line\">          &lt;p&gt;More content&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>ToggleableMenu&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>如果你熟悉 Redux 的 connect 函数或者 React Router 的 withRouter 函数，那么你已经使用过高阶组件了。</p>\n<h3 id=\"回调渲染组件\"><a href=\"#回调渲染组件\" class=\"headerlink\" title=\"回调渲染组件\"></a>回调渲染组件</h3><p>另一个比较高端的复用组件逻辑的方法是将函数作为组件的 <code>props.children</code>，该方法也称为 <strong>Function as Child Components</strong>。我们将使用<strong>渲染回调</strong>来重新实现上面的可扩展 Menu:</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Toggleable</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.toggle = <span class=\"keyword\">this</span>.toggle.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123; <span class=\"attr\">show</span>: <span class=\"literal\">false</span> &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  toggle() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(<span class=\"function\"><span class=\"params\">prevState</span> =&gt;</span> (&#123; <span class=\"attr\">show</span>: !prevState.show &#125;));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.props.children(<span class=\"keyword\">this</span>.state.show, <span class=\"keyword\">this</span>.toggle);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在，我们可以将函数作为组件的子级进行传递:</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Toggleable&gt;</span><br><span class=\"line\">  &#123;(show, onClick) =&gt; (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;div onClick=&#123;onClick&#125;&gt;</span><br><span class=\"line\">        &lt;h1&gt;&#123;props.title&#125;&lt;<span class=\"regexp\">/h1&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">      &#123;show &amp;&amp; props.children&#125;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  )&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/</span>Toggleable&gt;</span><br></pre></td></tr></table></figure>\n<p>上面的代码已经将一个函数作为<strong>子组件</strong>，但是，若我们想复用上述逻辑，我们需要创建一个转换逻辑的新组件：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ToggleableMenu = <span class=\"function\"><span class=\"params\">props</span> =&gt;</span> (</span><br><span class=\"line\">  &lt;Toggleable&gt;</span><br><span class=\"line\">    &#123;(show, onClick) =&gt; (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;div onClick=&#123;onClick&#125;&gt;</span><br><span class=\"line\">          &lt;h1&gt;&#123;props.title&#125;&lt;<span class=\"regexp\">/h1&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>div&gt;</span><br><span class=\"line\">        &#123;show &amp;&amp; props.children&#125;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    )&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;/</span>Toggleable&gt;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>我们使用 Render Callbacks 实现的可扩展的 Menu 组件如下:</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Menu</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;ToggleableMenu title=<span class=\"string\">\"First Menu\"</span>&gt;</span><br><span class=\"line\">          &lt;p&gt;Some content&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>ToggleableMenu&gt;</span><br><span class=\"line\">        &lt;ToggleableMenu title=<span class=\"string\">\"Second Menu\"</span>&gt;</span><br><span class=\"line\">          &lt;p&gt;Another content&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>ToggleableMenu&gt;</span><br><span class=\"line\">        &lt;ToggleableMenu title=<span class=\"string\">\"Third Menu\"</span>&gt;</span><br><span class=\"line\">          &lt;p&gt;More content&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>ToggleableMenu&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>回调渲染组件 (Render Callbacks) 和高阶函数使我们的组件更加灵活，掌握和适应起来具有一定的难度，需要反复学习和消化。</p>"},{"title":"Why Immutable Data?","date":"2018-05-05T13:14:23.000Z","comments":1,"_content":"什么是不可变数据, 如何理解不可变数据, 不可变数据在项目中的实践. 弄清楚了这些问题, 你才能更好的处理项目中一些调优问题. 比如 React 性能优化等. 一起来学习下吧! 👨🏼‍💻\n\n<!-- more -->\n## What\n\n> ***Immutable Data*** 是指一旦被创造后就不可以被改变的数据, 通过使用 Immutable Data, 可以让我们更容易的去处理缓存、回退、数据变化检测等问题, 简化我们的开发.\n\n\n![image](https://user-images.githubusercontent.com/15377484/39663322-c4bb61ae-50a3-11e8-8267-4c2a80c00af7.png)\n\n\n## Why\n在原生 JS 中, 存在两种数据类型:\n\n- 静态数据类型\n- 引用数据类型\n\n引用类型数据结构非常灵活, 节约内存, 能给开发带来不少便利. 但与此同时也产生了一些副作用:\n\n#### Case 1\n```js\nlet obj = { count: 1 };\nlet copyObj = obj;\ncopyObj.count = 2;\n\nconsole.log(copyObj.count); // => 2\nconsole.log(obj.count); // => 2, 这并不是我们期望的\n```\n#### Case 2\n```js\nlet obj2 = { count: 1 };\n\n// 团队协作, 大家都在用这个 obj2\nunKnowFunction(obj2);\nconsole.log(obj2.count); // 能保证这个结果一定是1吗?\n```\n\n针对以上引用类型产生的副作用, 有人提出了 ***深度拷贝*** (Deep Clone)的方法, 实现代码如下:\n```js\nfunction isObject(obj) {\n  return typeof obj === 'object';\n}\n\nfunction isArray(arr) {\n  return Array.isArray(arr);\n}\n\nfunction deepClone(obj) {\n  if (!isObject(obj))  return obj;\n  var cloneObj = isArray(obj) ? [] : {};\n\n  for(var key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      var value = obj[key];\n      var copy = value;\n\n      if (isObject(value)) {\n        // 这里使用了递归\n        cloneObj[key] = deepClone(value);\n      } else {\n        cloneObj[key] = value;\n      }\n    }\n  }\n  return cloneObj;\n}\n```\n\n现在我们可以使用 `deepClone` 这个方法来解决文章一开头的问题了:\n```js\nlet obj = {\n  age: 5,\n  list: [1, 2, 3]\n}\n\n// 深拷贝一个新的对象, 两者互相独立, 不存在引用关系\nlet trueCopyObj = deepClone(obj);\nconsole.log(obj.list === trueCopyObj.list); // => false, 这是我们期望的\n\n// 但是又有一个问题, 我只是想拷贝一个新的对象, 改一下 `age`\nlet obj2 = deepClone(obj);\nobj2.age = 6;\n// 难不成剩下的一堆引用类型的属性都要递归做一次深拷贝?\n// 所以这明显是多余的, 并且存在严重的性能问题\n```\n\n在原生 JavaScript 中实现数据不可变, 有 2 个办法:\n\n- ES6: `const`\n- ES5: `Object.freeze`\n\n但是这两种都是浅处理, 遇到深层次的数据结构, 就需要递归处理, 又会存在性能上的问题.\n\n### How\n\n针对以上一系列需求, 我们完全可以使用不可变数据结构来处理, 对应的实现库有:\n- [facebook/immutable-js](https://github.com/facebook/immutable-js)\n- [rtfeldman/seamless-immutable](https://github.com/rtfeldman/seamless-immutable)\n\nImmutable.js 主要特点:\n- 稳定数据结构 (Persistent Data Structure), 每次返回新的对象, 不存在引用\n- 结构共享 (Structural Sharing), 基于哈希映射树, 可以实现部分结构共享\n- 支持延迟操作 (Support Lazy Operation)\n- 强大的 API (Power API)\n\n针对以上特点, 我们用一些代码实例来说明一下:\n```js\n// 稳定数据结构\nlet obj = {count: 1};\nlet map = Immutable.fromJS(obj);\nlet map2 = map.set('count', 2);\n\nconsole.log(map.get('count')); // => 1\nconsole.log(map2.get('count')); // => 2\n```\n\n```js\n// 结构共享\n\nlet obj = {\n  count: 1,\n  list: [1, 2, 3, 4, 5]\n}\nlet map1 = Immutable.fromJS(obj);\nlet map2 = map1.set('count', 2);\n\nconsole.log(map1.list === map2.list); // true\n```\n\n<div style=\"width: 300px; \">![image](https://user-images.githubusercontent.com/15377484/39665040-d92a0764-50bf-11e8-84e3-ad83cf758acd.gif)</div>\n\n这张 GIF 很形象的解释了 `结构共享` 👍\n\n```js\n// 强大的 API\n\nlet obj = {\n  a: {\n    b: {\n      list: [1, 2, 3]\n    }\n  }\n};\nlet map = Immutable.fromJS(obj);\nlet map2 = Immutable.updateIn(['a', 'b', 'list'], (list) => {\n  return list.push(4);\n});\n\nconsole.log(map2.getIn(['a', 'b', 'list'])); // => List [ 1, 2, 3, 4 ]\n```\n\n还有一个特点就不举例子了, 超纲! 😁\n\n### 参考\n- [Immutable 详解及 React 中实践](https://github.com/camsong/blog/issues/3)\n- [浅合并 (shallow merge) 例子](https://stackoverflow.com/questions/27936772/how-to-deep-merge-instead-of-shallow-merge/28248548)\n- [Lodash merge 方法](https://lodash.com/docs/4.17.10#merge)\n","source":"_posts/Why-Immutable-Data.md","raw":"---\ntitle: Why Immutable Data?\ndate: 2018-05-05 21:14:23\ntags:\ncomments: true\n---\n什么是不可变数据, 如何理解不可变数据, 不可变数据在项目中的实践. 弄清楚了这些问题, 你才能更好的处理项目中一些调优问题. 比如 React 性能优化等. 一起来学习下吧! 👨🏼‍💻\n\n<!-- more -->\n## What\n\n> ***Immutable Data*** 是指一旦被创造后就不可以被改变的数据, 通过使用 Immutable Data, 可以让我们更容易的去处理缓存、回退、数据变化检测等问题, 简化我们的开发.\n\n\n![image](https://user-images.githubusercontent.com/15377484/39663322-c4bb61ae-50a3-11e8-8267-4c2a80c00af7.png)\n\n\n## Why\n在原生 JS 中, 存在两种数据类型:\n\n- 静态数据类型\n- 引用数据类型\n\n引用类型数据结构非常灵活, 节约内存, 能给开发带来不少便利. 但与此同时也产生了一些副作用:\n\n#### Case 1\n```js\nlet obj = { count: 1 };\nlet copyObj = obj;\ncopyObj.count = 2;\n\nconsole.log(copyObj.count); // => 2\nconsole.log(obj.count); // => 2, 这并不是我们期望的\n```\n#### Case 2\n```js\nlet obj2 = { count: 1 };\n\n// 团队协作, 大家都在用这个 obj2\nunKnowFunction(obj2);\nconsole.log(obj2.count); // 能保证这个结果一定是1吗?\n```\n\n针对以上引用类型产生的副作用, 有人提出了 ***深度拷贝*** (Deep Clone)的方法, 实现代码如下:\n```js\nfunction isObject(obj) {\n  return typeof obj === 'object';\n}\n\nfunction isArray(arr) {\n  return Array.isArray(arr);\n}\n\nfunction deepClone(obj) {\n  if (!isObject(obj))  return obj;\n  var cloneObj = isArray(obj) ? [] : {};\n\n  for(var key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      var value = obj[key];\n      var copy = value;\n\n      if (isObject(value)) {\n        // 这里使用了递归\n        cloneObj[key] = deepClone(value);\n      } else {\n        cloneObj[key] = value;\n      }\n    }\n  }\n  return cloneObj;\n}\n```\n\n现在我们可以使用 `deepClone` 这个方法来解决文章一开头的问题了:\n```js\nlet obj = {\n  age: 5,\n  list: [1, 2, 3]\n}\n\n// 深拷贝一个新的对象, 两者互相独立, 不存在引用关系\nlet trueCopyObj = deepClone(obj);\nconsole.log(obj.list === trueCopyObj.list); // => false, 这是我们期望的\n\n// 但是又有一个问题, 我只是想拷贝一个新的对象, 改一下 `age`\nlet obj2 = deepClone(obj);\nobj2.age = 6;\n// 难不成剩下的一堆引用类型的属性都要递归做一次深拷贝?\n// 所以这明显是多余的, 并且存在严重的性能问题\n```\n\n在原生 JavaScript 中实现数据不可变, 有 2 个办法:\n\n- ES6: `const`\n- ES5: `Object.freeze`\n\n但是这两种都是浅处理, 遇到深层次的数据结构, 就需要递归处理, 又会存在性能上的问题.\n\n### How\n\n针对以上一系列需求, 我们完全可以使用不可变数据结构来处理, 对应的实现库有:\n- [facebook/immutable-js](https://github.com/facebook/immutable-js)\n- [rtfeldman/seamless-immutable](https://github.com/rtfeldman/seamless-immutable)\n\nImmutable.js 主要特点:\n- 稳定数据结构 (Persistent Data Structure), 每次返回新的对象, 不存在引用\n- 结构共享 (Structural Sharing), 基于哈希映射树, 可以实现部分结构共享\n- 支持延迟操作 (Support Lazy Operation)\n- 强大的 API (Power API)\n\n针对以上特点, 我们用一些代码实例来说明一下:\n```js\n// 稳定数据结构\nlet obj = {count: 1};\nlet map = Immutable.fromJS(obj);\nlet map2 = map.set('count', 2);\n\nconsole.log(map.get('count')); // => 1\nconsole.log(map2.get('count')); // => 2\n```\n\n```js\n// 结构共享\n\nlet obj = {\n  count: 1,\n  list: [1, 2, 3, 4, 5]\n}\nlet map1 = Immutable.fromJS(obj);\nlet map2 = map1.set('count', 2);\n\nconsole.log(map1.list === map2.list); // true\n```\n\n<div style=\"width: 300px; \">![image](https://user-images.githubusercontent.com/15377484/39665040-d92a0764-50bf-11e8-84e3-ad83cf758acd.gif)</div>\n\n这张 GIF 很形象的解释了 `结构共享` 👍\n\n```js\n// 强大的 API\n\nlet obj = {\n  a: {\n    b: {\n      list: [1, 2, 3]\n    }\n  }\n};\nlet map = Immutable.fromJS(obj);\nlet map2 = Immutable.updateIn(['a', 'b', 'list'], (list) => {\n  return list.push(4);\n});\n\nconsole.log(map2.getIn(['a', 'b', 'list'])); // => List [ 1, 2, 3, 4 ]\n```\n\n还有一个特点就不举例子了, 超纲! 😁\n\n### 参考\n- [Immutable 详解及 React 中实践](https://github.com/camsong/blog/issues/3)\n- [浅合并 (shallow merge) 例子](https://stackoverflow.com/questions/27936772/how-to-deep-merge-instead-of-shallow-merge/28248548)\n- [Lodash merge 方法](https://lodash.com/docs/4.17.10#merge)\n","slug":"Why-Immutable-Data","published":1,"updated":"2019-12-07T05:45:26.498Z","layout":"post","photos":[],"link":"","_id":"ck3v60jti000ir9q9h2tsgqct","content":"<p>什么是不可变数据, 如何理解不可变数据, 不可变数据在项目中的实践. 弄清楚了这些问题, 你才能更好的处理项目中一些调优问题. 比如 React 性能优化等. 一起来学习下吧! 👨🏼‍💻</p>\n<a id=\"more\"></a>\n<h2 id=\"What\"><a href=\"#What\" class=\"headerlink\" title=\"What\"></a>What</h2><blockquote>\n<p><strong><em>Immutable Data</em></strong> 是指一旦被创造后就不可以被改变的数据, 通过使用 Immutable Data, 可以让我们更容易的去处理缓存、回退、数据变化检测等问题, 简化我们的开发.</p>\n</blockquote>\n<p><img src=\"https://user-images.githubusercontent.com/15377484/39663322-c4bb61ae-50a3-11e8-8267-4c2a80c00af7.png\" alt=\"image\"></p>\n<h2 id=\"Why\"><a href=\"#Why\" class=\"headerlink\" title=\"Why\"></a>Why</h2><p>在原生 JS 中, 存在两种数据类型:</p>\n<ul>\n<li>静态数据类型</li>\n<li>引用数据类型</li>\n</ul>\n<p>引用类型数据结构非常灵活, 节约内存, 能给开发带来不少便利. 但与此同时也产生了一些副作用:</p>\n<h4 id=\"Case-1\"><a href=\"#Case-1\" class=\"headerlink\" title=\"Case 1\"></a>Case 1</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123; <span class=\"attr\">count</span>: <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> copyObj = obj;</span><br><span class=\"line\">copyObj.count = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(copyObj.count); <span class=\"comment\">// =&gt; 2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.count); <span class=\"comment\">// =&gt; 2, 这并不是我们期望的</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"Case-2\"><a href=\"#Case-2\" class=\"headerlink\" title=\"Case 2\"></a>Case 2</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj2 = &#123; <span class=\"attr\">count</span>: <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 团队协作, 大家都在用这个 obj2</span></span><br><span class=\"line\">unKnowFunction(obj2);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj2.count); <span class=\"comment\">// 能保证这个结果一定是1吗?</span></span><br></pre></td></tr></table></figure>\n<p>针对以上引用类型产生的副作用, 有人提出了 <strong><em>深度拷贝</em></strong> (Deep Clone)的方法, 实现代码如下:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isObject</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> obj === <span class=\"string\">'object'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isArray</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.isArray(arr);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deepClone</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!isObject(obj))  <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> cloneObj = isArray(obj) ? [] : &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> obj) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> value = obj[key];</span><br><span class=\"line\">      <span class=\"keyword\">var</span> copy = value;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (isObject(value)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里使用了递归</span></span><br><span class=\"line\">        cloneObj[key] = deepClone(value);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        cloneObj[key] = value;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> cloneObj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>现在我们可以使用 <code>deepClone</code> 这个方法来解决文章一开头的问题了:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">  age: <span class=\"number\">5</span>,</span><br><span class=\"line\">  list: [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 深拷贝一个新的对象, 两者互相独立, 不存在引用关系</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> trueCopyObj = deepClone(obj);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.list === trueCopyObj.list); <span class=\"comment\">// =&gt; false, 这是我们期望的</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 但是又有一个问题, 我只是想拷贝一个新的对象, 改一下 `age`</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj2 = deepClone(obj);</span><br><span class=\"line\">obj2.age = <span class=\"number\">6</span>;</span><br><span class=\"line\"><span class=\"comment\">// 难不成剩下的一堆引用类型的属性都要递归做一次深拷贝?</span></span><br><span class=\"line\"><span class=\"comment\">// 所以这明显是多余的, 并且存在严重的性能问题</span></span><br></pre></td></tr></table></figure></p>\n<p>在原生 JavaScript 中实现数据不可变, 有 2 个办法:</p>\n<ul>\n<li>ES6: <code>const</code></li>\n<li>ES5: <code>Object.freeze</code></li>\n</ul>\n<p>但是这两种都是浅处理, 遇到深层次的数据结构, 就需要递归处理, 又会存在性能上的问题.</p>\n<h3 id=\"How\"><a href=\"#How\" class=\"headerlink\" title=\"How\"></a>How</h3><p>针对以上一系列需求, 我们完全可以使用不可变数据结构来处理, 对应的实现库有:</p>\n<ul>\n<li><a href=\"https://github.com/facebook/immutable-js\" target=\"_blank\" rel=\"noopener\">facebook/immutable-js</a></li>\n<li><a href=\"https://github.com/rtfeldman/seamless-immutable\" target=\"_blank\" rel=\"noopener\">rtfeldman/seamless-immutable</a></li>\n</ul>\n<p>Immutable.js 主要特点:</p>\n<ul>\n<li>稳定数据结构 (Persistent Data Structure), 每次返回新的对象, 不存在引用</li>\n<li>结构共享 (Structural Sharing), 基于哈希映射树, 可以实现部分结构共享</li>\n<li>支持延迟操作 (Support Lazy Operation)</li>\n<li>强大的 API (Power API)</li>\n</ul>\n<p>针对以上特点, 我们用一些代码实例来说明一下:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 稳定数据结构</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;<span class=\"attr\">count</span>: <span class=\"number\">1</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> map = Immutable.fromJS(obj);</span><br><span class=\"line\"><span class=\"keyword\">let</span> map2 = map.set(<span class=\"string\">'count'</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map.get(<span class=\"string\">'count'</span>)); <span class=\"comment\">// =&gt; 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map2.get(<span class=\"string\">'count'</span>)); <span class=\"comment\">// =&gt; 2</span></span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 结构共享</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">  count: <span class=\"number\">1</span>,</span><br><span class=\"line\">  list: [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> map1 = Immutable.fromJS(obj);</span><br><span class=\"line\"><span class=\"keyword\">let</span> map2 = map1.set(<span class=\"string\">'count'</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map1.list === map2.list); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<div style=\"width: 300px; \"><img src=\"https://user-images.githubusercontent.com/15377484/39665040-d92a0764-50bf-11e8-84e3-ad83cf758acd.gif\" alt=\"image\"></div>\n\n<p>这张 GIF 很形象的解释了 <code>结构共享</code> 👍</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 强大的 API</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">  a: &#123;</span><br><span class=\"line\">    b: &#123;</span><br><span class=\"line\">      list: [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> map = Immutable.fromJS(obj);</span><br><span class=\"line\"><span class=\"keyword\">let</span> map2 = Immutable.updateIn([<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'list'</span>], (list) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> list.push(<span class=\"number\">4</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map2.getIn([<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'list'</span>])); <span class=\"comment\">// =&gt; List [ 1, 2, 3, 4 ]</span></span><br></pre></td></tr></table></figure>\n<p>还有一个特点就不举例子了, 超纲! 😁</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><a href=\"https://github.com/camsong/blog/issues/3\" target=\"_blank\" rel=\"noopener\">Immutable 详解及 React 中实践</a></li>\n<li><a href=\"https://stackoverflow.com/questions/27936772/how-to-deep-merge-instead-of-shallow-merge/28248548\" target=\"_blank\" rel=\"noopener\">浅合并 (shallow merge) 例子</a></li>\n<li><a href=\"https://lodash.com/docs/4.17.10#merge\" target=\"_blank\" rel=\"noopener\">Lodash merge 方法</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>什么是不可变数据, 如何理解不可变数据, 不可变数据在项目中的实践. 弄清楚了这些问题, 你才能更好的处理项目中一些调优问题. 比如 React 性能优化等. 一起来学习下吧! 👨🏼‍💻</p>","more":"<h2 id=\"What\"><a href=\"#What\" class=\"headerlink\" title=\"What\"></a>What</h2><blockquote>\n<p><strong><em>Immutable Data</em></strong> 是指一旦被创造后就不可以被改变的数据, 通过使用 Immutable Data, 可以让我们更容易的去处理缓存、回退、数据变化检测等问题, 简化我们的开发.</p>\n</blockquote>\n<p><img src=\"https://user-images.githubusercontent.com/15377484/39663322-c4bb61ae-50a3-11e8-8267-4c2a80c00af7.png\" alt=\"image\"></p>\n<h2 id=\"Why\"><a href=\"#Why\" class=\"headerlink\" title=\"Why\"></a>Why</h2><p>在原生 JS 中, 存在两种数据类型:</p>\n<ul>\n<li>静态数据类型</li>\n<li>引用数据类型</li>\n</ul>\n<p>引用类型数据结构非常灵活, 节约内存, 能给开发带来不少便利. 但与此同时也产生了一些副作用:</p>\n<h4 id=\"Case-1\"><a href=\"#Case-1\" class=\"headerlink\" title=\"Case 1\"></a>Case 1</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123; <span class=\"attr\">count</span>: <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> copyObj = obj;</span><br><span class=\"line\">copyObj.count = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(copyObj.count); <span class=\"comment\">// =&gt; 2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.count); <span class=\"comment\">// =&gt; 2, 这并不是我们期望的</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"Case-2\"><a href=\"#Case-2\" class=\"headerlink\" title=\"Case 2\"></a>Case 2</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj2 = &#123; <span class=\"attr\">count</span>: <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 团队协作, 大家都在用这个 obj2</span></span><br><span class=\"line\">unKnowFunction(obj2);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj2.count); <span class=\"comment\">// 能保证这个结果一定是1吗?</span></span><br></pre></td></tr></table></figure>\n<p>针对以上引用类型产生的副作用, 有人提出了 <strong><em>深度拷贝</em></strong> (Deep Clone)的方法, 实现代码如下:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isObject</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> obj === <span class=\"string\">'object'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isArray</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.isArray(arr);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deepClone</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!isObject(obj))  <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> cloneObj = isArray(obj) ? [] : &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> obj) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> value = obj[key];</span><br><span class=\"line\">      <span class=\"keyword\">var</span> copy = value;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (isObject(value)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里使用了递归</span></span><br><span class=\"line\">        cloneObj[key] = deepClone(value);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        cloneObj[key] = value;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> cloneObj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>现在我们可以使用 <code>deepClone</code> 这个方法来解决文章一开头的问题了:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">  age: <span class=\"number\">5</span>,</span><br><span class=\"line\">  list: [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 深拷贝一个新的对象, 两者互相独立, 不存在引用关系</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> trueCopyObj = deepClone(obj);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.list === trueCopyObj.list); <span class=\"comment\">// =&gt; false, 这是我们期望的</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 但是又有一个问题, 我只是想拷贝一个新的对象, 改一下 `age`</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj2 = deepClone(obj);</span><br><span class=\"line\">obj2.age = <span class=\"number\">6</span>;</span><br><span class=\"line\"><span class=\"comment\">// 难不成剩下的一堆引用类型的属性都要递归做一次深拷贝?</span></span><br><span class=\"line\"><span class=\"comment\">// 所以这明显是多余的, 并且存在严重的性能问题</span></span><br></pre></td></tr></table></figure></p>\n<p>在原生 JavaScript 中实现数据不可变, 有 2 个办法:</p>\n<ul>\n<li>ES6: <code>const</code></li>\n<li>ES5: <code>Object.freeze</code></li>\n</ul>\n<p>但是这两种都是浅处理, 遇到深层次的数据结构, 就需要递归处理, 又会存在性能上的问题.</p>\n<h3 id=\"How\"><a href=\"#How\" class=\"headerlink\" title=\"How\"></a>How</h3><p>针对以上一系列需求, 我们完全可以使用不可变数据结构来处理, 对应的实现库有:</p>\n<ul>\n<li><a href=\"https://github.com/facebook/immutable-js\" target=\"_blank\" rel=\"noopener\">facebook/immutable-js</a></li>\n<li><a href=\"https://github.com/rtfeldman/seamless-immutable\" target=\"_blank\" rel=\"noopener\">rtfeldman/seamless-immutable</a></li>\n</ul>\n<p>Immutable.js 主要特点:</p>\n<ul>\n<li>稳定数据结构 (Persistent Data Structure), 每次返回新的对象, 不存在引用</li>\n<li>结构共享 (Structural Sharing), 基于哈希映射树, 可以实现部分结构共享</li>\n<li>支持延迟操作 (Support Lazy Operation)</li>\n<li>强大的 API (Power API)</li>\n</ul>\n<p>针对以上特点, 我们用一些代码实例来说明一下:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 稳定数据结构</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;<span class=\"attr\">count</span>: <span class=\"number\">1</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> map = Immutable.fromJS(obj);</span><br><span class=\"line\"><span class=\"keyword\">let</span> map2 = map.set(<span class=\"string\">'count'</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map.get(<span class=\"string\">'count'</span>)); <span class=\"comment\">// =&gt; 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map2.get(<span class=\"string\">'count'</span>)); <span class=\"comment\">// =&gt; 2</span></span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 结构共享</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">  count: <span class=\"number\">1</span>,</span><br><span class=\"line\">  list: [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> map1 = Immutable.fromJS(obj);</span><br><span class=\"line\"><span class=\"keyword\">let</span> map2 = map1.set(<span class=\"string\">'count'</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map1.list === map2.list); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<div style=\"width: 300px; \"><img src=\"https://user-images.githubusercontent.com/15377484/39665040-d92a0764-50bf-11e8-84e3-ad83cf758acd.gif\" alt=\"image\"></div>\n\n<p>这张 GIF 很形象的解释了 <code>结构共享</code> 👍</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 强大的 API</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">  a: &#123;</span><br><span class=\"line\">    b: &#123;</span><br><span class=\"line\">      list: [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> map = Immutable.fromJS(obj);</span><br><span class=\"line\"><span class=\"keyword\">let</span> map2 = Immutable.updateIn([<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'list'</span>], (list) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> list.push(<span class=\"number\">4</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map2.getIn([<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'list'</span>])); <span class=\"comment\">// =&gt; List [ 1, 2, 3, 4 ]</span></span><br></pre></td></tr></table></figure>\n<p>还有一个特点就不举例子了, 超纲! 😁</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><a href=\"https://github.com/camsong/blog/issues/3\" target=\"_blank\" rel=\"noopener\">Immutable 详解及 React 中实践</a></li>\n<li><a href=\"https://stackoverflow.com/questions/27936772/how-to-deep-merge-instead-of-shallow-merge/28248548\" target=\"_blank\" rel=\"noopener\">浅合并 (shallow merge) 例子</a></li>\n<li><a href=\"https://lodash.com/docs/4.17.10#merge\" target=\"_blank\" rel=\"noopener\">Lodash merge 方法</a></li>\n</ul>"},{"title":"call、apply、bind 的区别及应用","date":"2016-03-26T10:14:16.000Z","comments":0,"_content":"\n在面向对象的编程中，经常会处理 `this` 的指向问题，改变 this 的指向就不得不谈谈今天的主角—— `call`、`apply`、`bind`。个人感觉 `this` 的问题初学者不同容易一下理解透彻，今天再来好好捋一捋加深理解。\n<!-- more -->\n### 作用\n`call`、`apply`、`bind` 的作用就是改变函数执行时的上下文，即改变 `this` 指向。\n\n`this` 的指向其实也就[不外乎这四种情况](https://ifyour.github.io/2016/02/19/JavaScript-%E4%B8%AD%E7%9A%84-this-%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/)，其实理解起来还是很容易的，理解不了也没关系，先记住，后面在工作中大量编码应用，写多了就知道为啥要这样用了。先来一个简单的例子。\n```js\n// 定义人类构造函数，属性是姓名，方法是输出自己的姓名\nfunction Person(name) {\n    this.name = name;\n}\n\nPerson.prototype = {\n    constructor: Person,\n    showName: function() {\n        console.log(this.name);\n    }\n};\n\nvar p1 = new Person('ifyour');\np1.showName(); // => ifyour\n\n// 定义一个动物对象，它有个一姓名属性\nvar animal = {\n    name: 'cat'\n};\n\n```\n人类实例 `p1` 想要打印自己的姓名，只要调用自身的 `showName` 方法即可，但是动物呢？我也想要动物实例 `animal` 打印自己的名字，如何做呢？当然改变 this 咯，把人类的 `showName` 方法借给动物用。\n\n```js\n// 可以直接去原型上借用\nPerson.prototype.showName.call(animal);//=>cat\n\n// 也可以从人类上生成的实例 p1 去借用\np1.showName.call(animal);//  => cat\np1.showName.apply(animal);// => cat\np1.showName.bind(animal)();//=> cat\n```\n\n### 区别\n#### call、apply 与 bind\n- `call`、`apply` 改变 `this` 指向后会 ***立即执行***\n- `bind` 并不会执行\n\n在上面的例子我们也看到了，`bind` 方法改变 this 时，还需要加一个 `()` 才能执行输出 `cat`。\n\n#### call 与 apply\n\n- `call` 把参数按顺序传入，即：`fn.call(obj, arg1, arg2, arg3...);`\n- `apply` 把参数打包成 `Array` 后传入，即： `fn.apply(obj, [arg1, arg2, arg3...]);`\n\n\n它们俩之间的差别在于 ***参数***，`call` 和 `aplly` 的第一个参数都是要改变上下文的对象，而 `call` 从第二个参数开始以参数列表的形式展现，`apply` 则是把除了改变上下文对象的参数放在一个数组里面作为它的第二个参数。\n\n### 应用\n知道了怎么使用和它们之间的区别，接下来我们来了解一下使用 `call`、`apply`、`bind` 的常见应用场景。\n\n#### 求数组中的最大、最小值\n```js\nvar arr = [34,5,3,6,54,6,-67,5,7,6,-8,687];\n\nMath.max.call(Math, 34,5,3,6,54,6,-67,5,7,6,-8,687);\nMath.max.apply(Math, arr);\n\nMath.min.call(Math, 34,5,3,6,54,6,-67,5,7,6,-8,687);\nMath.min.apply(Math, arr);\n```\n#### 将伪数组转化为数组\nJavaScript 中的伪数组(例如通过 `document.getElementsByTagName` 获取的元素)具有 `length` 属性，并且可以通过 0、1、2……下标来访问其中的元素，但是没有 `Array` 中的 `push`、`pop` 等方法。我们可以利用 `call`、`apply` 来将其转化为真正的数组这样便可以方便地使用数组方法了。\n\n```js\n// 这是一个伪数组\nvar arrayLike = {\n    0: 'aaaa',\n    1: 'bbbb',\n    2: 'cccc',\n    length: 3\n}\n// 通过这个方法转换\nvar arr = Array.prototype.slice.call(arrayLike);\n```\n<div class='tip'>上面 `arr` 便是一个包含 `arrayLike` 元素的真正的数组啦( 注意数据结构必须是以数字为下标而且一定要有 `length` 属性 )\n</div>\n\n#### 数组追加\n```js\nvar arr1 = [1,2,3];\nvar arr2 = [4,5,6];\n[].push.apply(arr1, arr2);\n\nconsole.log(arr1);// => [1, 2, 3, 4, 5, 6]\nconsole.log(arr2);// => [1, 2, 3]\n```\n\n#### 变量类型判断\n```js\nfunction isArray(obj){\n    return Object.prototype.toString.call(obj) == '[object Array]'\n}\nvar arr1 = [1,2,3];\nvar arr2 = '[1,2,3]';\n\nisArray(arr1);//   => true\nisArray(arr2);//   => false\n```\n\n#### 继承\n```js\n// 基础类\nvar Person = function (name, age) {\n  this.name = name;\n  this.age = age;\n};\n\n// 女孩类继承基础人类\nvar Girl = function (name) {\n  Person.call(this, name);\n};\n// 男孩类继承基础人类\nvar Boy = function (name, age) {\n  Person.apply(this, arguments);\n};\n\nvar g1 = new Girl ('Jilly');\nvar b1 = new Boy('ifyour', 18);\n```\n","source":"_posts/call、apply、bind-的区别及应用.md","raw":"---\ntitle: call、apply、bind 的区别及应用\ndate: 2016-03-26 18:14:16\ntags:\ncomments: false\n---\n\n在面向对象的编程中，经常会处理 `this` 的指向问题，改变 this 的指向就不得不谈谈今天的主角—— `call`、`apply`、`bind`。个人感觉 `this` 的问题初学者不同容易一下理解透彻，今天再来好好捋一捋加深理解。\n<!-- more -->\n### 作用\n`call`、`apply`、`bind` 的作用就是改变函数执行时的上下文，即改变 `this` 指向。\n\n`this` 的指向其实也就[不外乎这四种情况](https://ifyour.github.io/2016/02/19/JavaScript-%E4%B8%AD%E7%9A%84-this-%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/)，其实理解起来还是很容易的，理解不了也没关系，先记住，后面在工作中大量编码应用，写多了就知道为啥要这样用了。先来一个简单的例子。\n```js\n// 定义人类构造函数，属性是姓名，方法是输出自己的姓名\nfunction Person(name) {\n    this.name = name;\n}\n\nPerson.prototype = {\n    constructor: Person,\n    showName: function() {\n        console.log(this.name);\n    }\n};\n\nvar p1 = new Person('ifyour');\np1.showName(); // => ifyour\n\n// 定义一个动物对象，它有个一姓名属性\nvar animal = {\n    name: 'cat'\n};\n\n```\n人类实例 `p1` 想要打印自己的姓名，只要调用自身的 `showName` 方法即可，但是动物呢？我也想要动物实例 `animal` 打印自己的名字，如何做呢？当然改变 this 咯，把人类的 `showName` 方法借给动物用。\n\n```js\n// 可以直接去原型上借用\nPerson.prototype.showName.call(animal);//=>cat\n\n// 也可以从人类上生成的实例 p1 去借用\np1.showName.call(animal);//  => cat\np1.showName.apply(animal);// => cat\np1.showName.bind(animal)();//=> cat\n```\n\n### 区别\n#### call、apply 与 bind\n- `call`、`apply` 改变 `this` 指向后会 ***立即执行***\n- `bind` 并不会执行\n\n在上面的例子我们也看到了，`bind` 方法改变 this 时，还需要加一个 `()` 才能执行输出 `cat`。\n\n#### call 与 apply\n\n- `call` 把参数按顺序传入，即：`fn.call(obj, arg1, arg2, arg3...);`\n- `apply` 把参数打包成 `Array` 后传入，即： `fn.apply(obj, [arg1, arg2, arg3...]);`\n\n\n它们俩之间的差别在于 ***参数***，`call` 和 `aplly` 的第一个参数都是要改变上下文的对象，而 `call` 从第二个参数开始以参数列表的形式展现，`apply` 则是把除了改变上下文对象的参数放在一个数组里面作为它的第二个参数。\n\n### 应用\n知道了怎么使用和它们之间的区别，接下来我们来了解一下使用 `call`、`apply`、`bind` 的常见应用场景。\n\n#### 求数组中的最大、最小值\n```js\nvar arr = [34,5,3,6,54,6,-67,5,7,6,-8,687];\n\nMath.max.call(Math, 34,5,3,6,54,6,-67,5,7,6,-8,687);\nMath.max.apply(Math, arr);\n\nMath.min.call(Math, 34,5,3,6,54,6,-67,5,7,6,-8,687);\nMath.min.apply(Math, arr);\n```\n#### 将伪数组转化为数组\nJavaScript 中的伪数组(例如通过 `document.getElementsByTagName` 获取的元素)具有 `length` 属性，并且可以通过 0、1、2……下标来访问其中的元素，但是没有 `Array` 中的 `push`、`pop` 等方法。我们可以利用 `call`、`apply` 来将其转化为真正的数组这样便可以方便地使用数组方法了。\n\n```js\n// 这是一个伪数组\nvar arrayLike = {\n    0: 'aaaa',\n    1: 'bbbb',\n    2: 'cccc',\n    length: 3\n}\n// 通过这个方法转换\nvar arr = Array.prototype.slice.call(arrayLike);\n```\n<div class='tip'>上面 `arr` 便是一个包含 `arrayLike` 元素的真正的数组啦( 注意数据结构必须是以数字为下标而且一定要有 `length` 属性 )\n</div>\n\n#### 数组追加\n```js\nvar arr1 = [1,2,3];\nvar arr2 = [4,5,6];\n[].push.apply(arr1, arr2);\n\nconsole.log(arr1);// => [1, 2, 3, 4, 5, 6]\nconsole.log(arr2);// => [1, 2, 3]\n```\n\n#### 变量类型判断\n```js\nfunction isArray(obj){\n    return Object.prototype.toString.call(obj) == '[object Array]'\n}\nvar arr1 = [1,2,3];\nvar arr2 = '[1,2,3]';\n\nisArray(arr1);//   => true\nisArray(arr2);//   => false\n```\n\n#### 继承\n```js\n// 基础类\nvar Person = function (name, age) {\n  this.name = name;\n  this.age = age;\n};\n\n// 女孩类继承基础人类\nvar Girl = function (name) {\n  Person.call(this, name);\n};\n// 男孩类继承基础人类\nvar Boy = function (name, age) {\n  Person.apply(this, arguments);\n};\n\nvar g1 = new Girl ('Jilly');\nvar b1 = new Boy('ifyour', 18);\n```\n","slug":"call、apply、bind-的区别及应用","published":1,"updated":"2019-12-07T04:59:33.620Z","layout":"post","photos":[],"link":"","_id":"ck3v60jtj000jr9q9cc1xqsg9","content":"<p>在面向对象的编程中，经常会处理 <code>this</code> 的指向问题，改变 this 的指向就不得不谈谈今天的主角—— <code>call</code>、<code>apply</code>、<code>bind</code>。个人感觉 <code>this</code> 的问题初学者不同容易一下理解透彻，今天再来好好捋一捋加深理解。<br><a id=\"more\"></a></p>\n<h3 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h3><p><code>call</code>、<code>apply</code>、<code>bind</code> 的作用就是改变函数执行时的上下文，即改变 <code>this</code> 指向。</p>\n<p><code>this</code> 的指向其实也就<a href=\"https://ifyour.github.io/2016/02/19/JavaScript-%E4%B8%AD%E7%9A%84-this-%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/\">不外乎这四种情况</a>，其实理解起来还是很容易的，理解不了也没关系，先记住，后面在工作中大量编码应用，写多了就知道为啥要这样用了。先来一个简单的例子。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义人类构造函数，属性是姓名，方法是输出自己的姓名</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>: Person,</span><br><span class=\"line\">    showName: function() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p1 = <span class=\"keyword\">new</span> Person(<span class=\"string\">'ifyour'</span>);</span><br><span class=\"line\">p1.showName(); <span class=\"comment\">// =&gt; ifyour</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义一个动物对象，它有个一姓名属性</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> animal = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'cat'</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>人类实例 <code>p1</code> 想要打印自己的姓名，只要调用自身的 <code>showName</code> 方法即可，但是动物呢？我也想要动物实例 <code>animal</code> 打印自己的名字，如何做呢？当然改变 this 咯，把人类的 <code>showName</code> 方法借给动物用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 可以直接去原型上借用</span></span><br><span class=\"line\">Person.prototype.showName.call(animal);<span class=\"comment\">//=&gt;cat</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 也可以从人类上生成的实例 p1 去借用</span></span><br><span class=\"line\">p1.showName.call(animal);<span class=\"comment\">//  =&gt; cat</span></span><br><span class=\"line\">p1.showName.apply(animal);<span class=\"comment\">// =&gt; cat</span></span><br><span class=\"line\">p1.showName.bind(animal)();<span class=\"comment\">//=&gt; cat</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h3><h4 id=\"call、apply-与-bind\"><a href=\"#call、apply-与-bind\" class=\"headerlink\" title=\"call、apply 与 bind\"></a>call、apply 与 bind</h4><ul>\n<li><code>call</code>、<code>apply</code> 改变 <code>this</code> 指向后会 <strong><em>立即执行</em></strong></li>\n<li><code>bind</code> 并不会执行</li>\n</ul>\n<p>在上面的例子我们也看到了，<code>bind</code> 方法改变 this 时，还需要加一个 <code>()</code> 才能执行输出 <code>cat</code>。</p>\n<h4 id=\"call-与-apply\"><a href=\"#call-与-apply\" class=\"headerlink\" title=\"call 与 apply\"></a>call 与 apply</h4><ul>\n<li><code>call</code> 把参数按顺序传入，即：<code>fn.call(obj, arg1, arg2, arg3...);</code></li>\n<li><code>apply</code> 把参数打包成 <code>Array</code> 后传入，即： <code>fn.apply(obj, [arg1, arg2, arg3...]);</code></li>\n</ul>\n<p>它们俩之间的差别在于 <strong><em>参数</em></strong>，<code>call</code> 和 <code>aplly</code> 的第一个参数都是要改变上下文的对象，而 <code>call</code> 从第二个参数开始以参数列表的形式展现，<code>apply</code> 则是把除了改变上下文对象的参数放在一个数组里面作为它的第二个参数。</p>\n<h3 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h3><p>知道了怎么使用和它们之间的区别，接下来我们来了解一下使用 <code>call</code>、<code>apply</code>、<code>bind</code> 的常见应用场景。</p>\n<h4 id=\"求数组中的最大、最小值\"><a href=\"#求数组中的最大、最小值\" class=\"headerlink\" title=\"求数组中的最大、最小值\"></a>求数组中的最大、最小值</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">34</span>,<span class=\"number\">5</span>,<span class=\"number\">3</span>,<span class=\"number\">6</span>,<span class=\"number\">54</span>,<span class=\"number\">6</span>,<span class=\"number\">-67</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">6</span>,<span class=\"number\">-8</span>,<span class=\"number\">687</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.max.call(<span class=\"built_in\">Math</span>, <span class=\"number\">34</span>,<span class=\"number\">5</span>,<span class=\"number\">3</span>,<span class=\"number\">6</span>,<span class=\"number\">54</span>,<span class=\"number\">6</span>,<span class=\"number\">-67</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">6</span>,<span class=\"number\">-8</span>,<span class=\"number\">687</span>);</span><br><span class=\"line\"><span class=\"built_in\">Math</span>.max.apply(<span class=\"built_in\">Math</span>, arr);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.min.call(<span class=\"built_in\">Math</span>, <span class=\"number\">34</span>,<span class=\"number\">5</span>,<span class=\"number\">3</span>,<span class=\"number\">6</span>,<span class=\"number\">54</span>,<span class=\"number\">6</span>,<span class=\"number\">-67</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">6</span>,<span class=\"number\">-8</span>,<span class=\"number\">687</span>);</span><br><span class=\"line\"><span class=\"built_in\">Math</span>.min.apply(<span class=\"built_in\">Math</span>, arr);</span><br></pre></td></tr></table></figure>\n<h4 id=\"将伪数组转化为数组\"><a href=\"#将伪数组转化为数组\" class=\"headerlink\" title=\"将伪数组转化为数组\"></a>将伪数组转化为数组</h4><p>JavaScript 中的伪数组(例如通过 <code>document.getElementsByTagName</code> 获取的元素)具有 <code>length</code> 属性，并且可以通过 0、1、2……下标来访问其中的元素，但是没有 <code>Array</code> 中的 <code>push</code>、<code>pop</code> 等方法。我们可以利用 <code>call</code>、<code>apply</code> 来将其转化为真正的数组这样便可以方便地使用数组方法了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这是一个伪数组</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arrayLike = &#123;</span><br><span class=\"line\">    <span class=\"number\">0</span>: <span class=\"string\">'aaaa'</span>,</span><br><span class=\"line\">    <span class=\"number\">1</span>: <span class=\"string\">'bbbb'</span>,</span><br><span class=\"line\">    <span class=\"number\">2</span>: <span class=\"string\">'cccc'</span>,</span><br><span class=\"line\">    length: <span class=\"number\">3</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 通过这个方法转换</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = <span class=\"built_in\">Array</span>.prototype.slice.call(arrayLike);</span><br></pre></td></tr></table></figure>\n<div class=\"tip\">上面 <code>arr</code> 便是一个包含 <code>arrayLike</code> 元素的真正的数组啦( 注意数据结构必须是以数字为下标而且一定要有 <code>length</code> 属性 )<br></div>\n\n<h4 id=\"数组追加\"><a href=\"#数组追加\" class=\"headerlink\" title=\"数组追加\"></a>数组追加</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr1 = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = [<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>];</span><br><span class=\"line\">[].push.apply(arr1, arr2);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr1);<span class=\"comment\">// =&gt; [1, 2, 3, 4, 5, 6]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2);<span class=\"comment\">// =&gt; [1, 2, 3]</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"变量类型判断\"><a href=\"#变量类型判断\" class=\"headerlink\" title=\"变量类型判断\"></a>变量类型判断</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isArray</span>(<span class=\"params\">obj</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(obj) == <span class=\"string\">'[object Array]'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr1 = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = <span class=\"string\">'[1,2,3]'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">isArray(arr1);<span class=\"comment\">//   =&gt; true</span></span><br><span class=\"line\">isArray(arr2);<span class=\"comment\">//   =&gt; false</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 基础类</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Person = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 女孩类继承基础人类</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Girl = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  Person.call(<span class=\"keyword\">this</span>, name);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 男孩类继承基础人类</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Boy = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">  Person.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> g1 = <span class=\"keyword\">new</span> Girl (<span class=\"string\">'Jilly'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> b1 = <span class=\"keyword\">new</span> Boy(<span class=\"string\">'ifyour'</span>, <span class=\"number\">18</span>);</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>在面向对象的编程中，经常会处理 <code>this</code> 的指向问题，改变 this 的指向就不得不谈谈今天的主角—— <code>call</code>、<code>apply</code>、<code>bind</code>。个人感觉 <code>this</code> 的问题初学者不同容易一下理解透彻，今天再来好好捋一捋加深理解。<br>","more":"</p>\n<h3 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h3><p><code>call</code>、<code>apply</code>、<code>bind</code> 的作用就是改变函数执行时的上下文，即改变 <code>this</code> 指向。</p>\n<p><code>this</code> 的指向其实也就<a href=\"https://ifyour.github.io/2016/02/19/JavaScript-%E4%B8%AD%E7%9A%84-this-%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/\">不外乎这四种情况</a>，其实理解起来还是很容易的，理解不了也没关系，先记住，后面在工作中大量编码应用，写多了就知道为啥要这样用了。先来一个简单的例子。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义人类构造函数，属性是姓名，方法是输出自己的姓名</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>: Person,</span><br><span class=\"line\">    showName: function() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p1 = <span class=\"keyword\">new</span> Person(<span class=\"string\">'ifyour'</span>);</span><br><span class=\"line\">p1.showName(); <span class=\"comment\">// =&gt; ifyour</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义一个动物对象，它有个一姓名属性</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> animal = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'cat'</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>人类实例 <code>p1</code> 想要打印自己的姓名，只要调用自身的 <code>showName</code> 方法即可，但是动物呢？我也想要动物实例 <code>animal</code> 打印自己的名字，如何做呢？当然改变 this 咯，把人类的 <code>showName</code> 方法借给动物用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 可以直接去原型上借用</span></span><br><span class=\"line\">Person.prototype.showName.call(animal);<span class=\"comment\">//=&gt;cat</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 也可以从人类上生成的实例 p1 去借用</span></span><br><span class=\"line\">p1.showName.call(animal);<span class=\"comment\">//  =&gt; cat</span></span><br><span class=\"line\">p1.showName.apply(animal);<span class=\"comment\">// =&gt; cat</span></span><br><span class=\"line\">p1.showName.bind(animal)();<span class=\"comment\">//=&gt; cat</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h3><h4 id=\"call、apply-与-bind\"><a href=\"#call、apply-与-bind\" class=\"headerlink\" title=\"call、apply 与 bind\"></a>call、apply 与 bind</h4><ul>\n<li><code>call</code>、<code>apply</code> 改变 <code>this</code> 指向后会 <strong><em>立即执行</em></strong></li>\n<li><code>bind</code> 并不会执行</li>\n</ul>\n<p>在上面的例子我们也看到了，<code>bind</code> 方法改变 this 时，还需要加一个 <code>()</code> 才能执行输出 <code>cat</code>。</p>\n<h4 id=\"call-与-apply\"><a href=\"#call-与-apply\" class=\"headerlink\" title=\"call 与 apply\"></a>call 与 apply</h4><ul>\n<li><code>call</code> 把参数按顺序传入，即：<code>fn.call(obj, arg1, arg2, arg3...);</code></li>\n<li><code>apply</code> 把参数打包成 <code>Array</code> 后传入，即： <code>fn.apply(obj, [arg1, arg2, arg3...]);</code></li>\n</ul>\n<p>它们俩之间的差别在于 <strong><em>参数</em></strong>，<code>call</code> 和 <code>aplly</code> 的第一个参数都是要改变上下文的对象，而 <code>call</code> 从第二个参数开始以参数列表的形式展现，<code>apply</code> 则是把除了改变上下文对象的参数放在一个数组里面作为它的第二个参数。</p>\n<h3 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h3><p>知道了怎么使用和它们之间的区别，接下来我们来了解一下使用 <code>call</code>、<code>apply</code>、<code>bind</code> 的常见应用场景。</p>\n<h4 id=\"求数组中的最大、最小值\"><a href=\"#求数组中的最大、最小值\" class=\"headerlink\" title=\"求数组中的最大、最小值\"></a>求数组中的最大、最小值</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">34</span>,<span class=\"number\">5</span>,<span class=\"number\">3</span>,<span class=\"number\">6</span>,<span class=\"number\">54</span>,<span class=\"number\">6</span>,<span class=\"number\">-67</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">6</span>,<span class=\"number\">-8</span>,<span class=\"number\">687</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.max.call(<span class=\"built_in\">Math</span>, <span class=\"number\">34</span>,<span class=\"number\">5</span>,<span class=\"number\">3</span>,<span class=\"number\">6</span>,<span class=\"number\">54</span>,<span class=\"number\">6</span>,<span class=\"number\">-67</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">6</span>,<span class=\"number\">-8</span>,<span class=\"number\">687</span>);</span><br><span class=\"line\"><span class=\"built_in\">Math</span>.max.apply(<span class=\"built_in\">Math</span>, arr);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.min.call(<span class=\"built_in\">Math</span>, <span class=\"number\">34</span>,<span class=\"number\">5</span>,<span class=\"number\">3</span>,<span class=\"number\">6</span>,<span class=\"number\">54</span>,<span class=\"number\">6</span>,<span class=\"number\">-67</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">6</span>,<span class=\"number\">-8</span>,<span class=\"number\">687</span>);</span><br><span class=\"line\"><span class=\"built_in\">Math</span>.min.apply(<span class=\"built_in\">Math</span>, arr);</span><br></pre></td></tr></table></figure>\n<h4 id=\"将伪数组转化为数组\"><a href=\"#将伪数组转化为数组\" class=\"headerlink\" title=\"将伪数组转化为数组\"></a>将伪数组转化为数组</h4><p>JavaScript 中的伪数组(例如通过 <code>document.getElementsByTagName</code> 获取的元素)具有 <code>length</code> 属性，并且可以通过 0、1、2……下标来访问其中的元素，但是没有 <code>Array</code> 中的 <code>push</code>、<code>pop</code> 等方法。我们可以利用 <code>call</code>、<code>apply</code> 来将其转化为真正的数组这样便可以方便地使用数组方法了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这是一个伪数组</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arrayLike = &#123;</span><br><span class=\"line\">    <span class=\"number\">0</span>: <span class=\"string\">'aaaa'</span>,</span><br><span class=\"line\">    <span class=\"number\">1</span>: <span class=\"string\">'bbbb'</span>,</span><br><span class=\"line\">    <span class=\"number\">2</span>: <span class=\"string\">'cccc'</span>,</span><br><span class=\"line\">    length: <span class=\"number\">3</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 通过这个方法转换</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = <span class=\"built_in\">Array</span>.prototype.slice.call(arrayLike);</span><br></pre></td></tr></table></figure>\n<div class=\"tip\">上面 <code>arr</code> 便是一个包含 <code>arrayLike</code> 元素的真正的数组啦( 注意数据结构必须是以数字为下标而且一定要有 <code>length</code> 属性 )<br></div>\n\n<h4 id=\"数组追加\"><a href=\"#数组追加\" class=\"headerlink\" title=\"数组追加\"></a>数组追加</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr1 = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = [<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>];</span><br><span class=\"line\">[].push.apply(arr1, arr2);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr1);<span class=\"comment\">// =&gt; [1, 2, 3, 4, 5, 6]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2);<span class=\"comment\">// =&gt; [1, 2, 3]</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"变量类型判断\"><a href=\"#变量类型判断\" class=\"headerlink\" title=\"变量类型判断\"></a>变量类型判断</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isArray</span>(<span class=\"params\">obj</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(obj) == <span class=\"string\">'[object Array]'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr1 = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = <span class=\"string\">'[1,2,3]'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">isArray(arr1);<span class=\"comment\">//   =&gt; true</span></span><br><span class=\"line\">isArray(arr2);<span class=\"comment\">//   =&gt; false</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 基础类</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Person = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 女孩类继承基础人类</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Girl = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  Person.call(<span class=\"keyword\">this</span>, name);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 男孩类继承基础人类</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Boy = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">  Person.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> g1 = <span class=\"keyword\">new</span> Girl (<span class=\"string\">'Jilly'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> b1 = <span class=\"keyword\">new</span> Boy(<span class=\"string\">'ifyour'</span>, <span class=\"number\">18</span>);</span><br></pre></td></tr></table></figure>"},{"title":"Git 操作详细总结","date":"2018-05-11T15:25:56.000Z","from":null,"comments":1,"_content":"\nGit 操作详细总结，以便回顾和查询。理解这些指令，觉得最重要的是理解 Git 的内部原理，比如 Git 的分布式版本控制，分清楚工作区、暂存区、版本库，还有就是理解 Git 跟踪并管理的是修改，而非文件。\n\n<!-- more -->\n\n![image](https://user-images.githubusercontent.com/15377484/39952532-4c0c156e-55cb-11e8-8052-e62c448325fe.png)\n\n## 设置\n\n```bash\ngit config --global user.name \"Your Name\"\ngit config --global user.email \"email@example.com\"\n```\n\n## 提交\n\nGit 追踪的是修改，而不是文件。\n\n![image](https://user-images.githubusercontent.com/15377484/39952534-5c10f236-55cb-11e8-81bf-c4d369d07054.png)\n\n```bash\n# 将 “当前修改” 移动到暂存区 (stage)\ngit add filename.txt\n\n# 将暂存区修改提交\ngit commit -m \"Add filename.txt.\"\n```\n\n## 状态\n\n```bash\ngit status\ngit diff\n```\n\n## 回退\n\n```bash\n# 放弃工作区修改\ngit checkout -- file.name\ngit checkout -- .\n\n# 取消 commit(比如需要重写 commit 信息)\ngit reset --soft HEAD\n\n# 取消 commit、add(重新提交代码和 commit)\ngit reset HEAD\ngit reset --mixed HEAD\n\n# 取消 commit、add、工作区修改 (需要完全重置)\ngit reset --hard HEAD\n```\n\n## 记录\n\n```bash\ngit reflog\ngit log\n```\n\n## 删除\n\n```bash\nrm file.name\ngit rm file.name\ngit commit -m \"Del\"\n```\n\n## 远程操作\n\n```bash\ngit remote add origin git@github.com:ifyour/ifyour.github.io.git\n\n# 第一次推送，-u(--set-upstream) 指定默认上游\ngit push -u origin master\ngit push origin master\n```\n\n## 克隆\n\n```bash\ngit clone https://github.com/ifyour/ifyour.github.io.git path\ngit clone git@github.com:ifyour/ifyour.github.io.git path\n```\n\n## 分支操作\n\n![image](https://user-images.githubusercontent.com/15377484/39952537-6b679758-55cb-11e8-9ff7-87440fcbb4d0.png)\n\n```bash\n# 查看当前分支\ngit branch\n\n# 创建分支\ngit branch dev\n\n# 切换分支\ngit checkout dev\n\n# 创建并 checkout 分支\ngit checkout -b dev\n\n# 合并分支\ngit merge dev\n\n# 删除分支\ngit branch -d dev\n```\n\n## 标签\n\n```bash\ngit tag 0.1.1\ngit push origin --tags\n```\n\n## More\n\n- [Git - 简易指南](http://www.bootcss.com/p/git-guide/)\n","source":"_posts/Git-操作详细总结.md","raw":"---\ntitle: Git 操作详细总结\ndate: 2018-05-11 23:25:56\ntags:\nfrom:\ncomments: true\n---\n\nGit 操作详细总结，以便回顾和查询。理解这些指令，觉得最重要的是理解 Git 的内部原理，比如 Git 的分布式版本控制，分清楚工作区、暂存区、版本库，还有就是理解 Git 跟踪并管理的是修改，而非文件。\n\n<!-- more -->\n\n![image](https://user-images.githubusercontent.com/15377484/39952532-4c0c156e-55cb-11e8-8052-e62c448325fe.png)\n\n## 设置\n\n```bash\ngit config --global user.name \"Your Name\"\ngit config --global user.email \"email@example.com\"\n```\n\n## 提交\n\nGit 追踪的是修改，而不是文件。\n\n![image](https://user-images.githubusercontent.com/15377484/39952534-5c10f236-55cb-11e8-81bf-c4d369d07054.png)\n\n```bash\n# 将 “当前修改” 移动到暂存区 (stage)\ngit add filename.txt\n\n# 将暂存区修改提交\ngit commit -m \"Add filename.txt.\"\n```\n\n## 状态\n\n```bash\ngit status\ngit diff\n```\n\n## 回退\n\n```bash\n# 放弃工作区修改\ngit checkout -- file.name\ngit checkout -- .\n\n# 取消 commit(比如需要重写 commit 信息)\ngit reset --soft HEAD\n\n# 取消 commit、add(重新提交代码和 commit)\ngit reset HEAD\ngit reset --mixed HEAD\n\n# 取消 commit、add、工作区修改 (需要完全重置)\ngit reset --hard HEAD\n```\n\n## 记录\n\n```bash\ngit reflog\ngit log\n```\n\n## 删除\n\n```bash\nrm file.name\ngit rm file.name\ngit commit -m \"Del\"\n```\n\n## 远程操作\n\n```bash\ngit remote add origin git@github.com:ifyour/ifyour.github.io.git\n\n# 第一次推送，-u(--set-upstream) 指定默认上游\ngit push -u origin master\ngit push origin master\n```\n\n## 克隆\n\n```bash\ngit clone https://github.com/ifyour/ifyour.github.io.git path\ngit clone git@github.com:ifyour/ifyour.github.io.git path\n```\n\n## 分支操作\n\n![image](https://user-images.githubusercontent.com/15377484/39952537-6b679758-55cb-11e8-9ff7-87440fcbb4d0.png)\n\n```bash\n# 查看当前分支\ngit branch\n\n# 创建分支\ngit branch dev\n\n# 切换分支\ngit checkout dev\n\n# 创建并 checkout 分支\ngit checkout -b dev\n\n# 合并分支\ngit merge dev\n\n# 删除分支\ngit branch -d dev\n```\n\n## 标签\n\n```bash\ngit tag 0.1.1\ngit push origin --tags\n```\n\n## More\n\n- [Git - 简易指南](http://www.bootcss.com/p/git-guide/)\n","slug":"Git-操作详细总结","published":1,"updated":"2018-12-26T16:01:04.000Z","layout":"post","photos":[],"link":"","_id":"ck3v60jtk000kr9q9tydvk7vq","content":"<p>Git 操作详细总结，以便回顾和查询。理解这些指令，觉得最重要的是理解 Git 的内部原理，比如 Git 的分布式版本控制，分清楚工作区、暂存区、版本库，还有就是理解 Git 跟踪并管理的是修改，而非文件。</p>\n<a id=\"more\"></a>\n<p><img src=\"https://user-images.githubusercontent.com/15377484/39952532-4c0c156e-55cb-11e8-8052-e62c448325fe.png\" alt=\"image\"></p>\n<h2 id=\"设置\"><a href=\"#设置\" class=\"headerlink\" title=\"设置\"></a>设置</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global user.name <span class=\"string\">\"Your Name\"</span></span><br><span class=\"line\">git config --global user.email <span class=\"string\">\"email@example.com\"</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"提交\"><a href=\"#提交\" class=\"headerlink\" title=\"提交\"></a>提交</h2><p>Git 追踪的是修改，而不是文件。</p>\n<p><img src=\"https://user-images.githubusercontent.com/15377484/39952534-5c10f236-55cb-11e8-81bf-c4d369d07054.png\" alt=\"image\"></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将 “当前修改” 移动到暂存区 (stage)</span></span><br><span class=\"line\">git add filename.txt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将暂存区修改提交</span></span><br><span class=\"line\">git commit -m <span class=\"string\">\"Add filename.txt.\"</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"状态\"><a href=\"#状态\" class=\"headerlink\" title=\"状态\"></a>状态</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git status</span><br><span class=\"line\">git diff</span><br></pre></td></tr></table></figure>\n<h2 id=\"回退\"><a href=\"#回退\" class=\"headerlink\" title=\"回退\"></a>回退</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 放弃工作区修改</span></span><br><span class=\"line\">git checkout -- file.name</span><br><span class=\"line\">git checkout -- .</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 取消 commit(比如需要重写 commit 信息)</span></span><br><span class=\"line\">git reset --soft HEAD</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 取消 commit、add(重新提交代码和 commit)</span></span><br><span class=\"line\">git reset HEAD</span><br><span class=\"line\">git reset --mixed HEAD</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 取消 commit、add、工作区修改 (需要完全重置)</span></span><br><span class=\"line\">git reset --hard HEAD</span><br></pre></td></tr></table></figure>\n<h2 id=\"记录\"><a href=\"#记录\" class=\"headerlink\" title=\"记录\"></a>记录</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reflog</span><br><span class=\"line\">git <span class=\"built_in\">log</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm file.name</span><br><span class=\"line\">git rm file.name</span><br><span class=\"line\">git commit -m <span class=\"string\">\"Del\"</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"远程操作\"><a href=\"#远程操作\" class=\"headerlink\" title=\"远程操作\"></a>远程操作</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add origin git@github.com:ifyour/ifyour.github.io.git</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 第一次推送，-u(--set-upstream) 指定默认上游</span></span><br><span class=\"line\">git push -u origin master</span><br><span class=\"line\">git push origin master</span><br></pre></td></tr></table></figure>\n<h2 id=\"克隆\"><a href=\"#克隆\" class=\"headerlink\" title=\"克隆\"></a>克隆</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/ifyour/ifyour.github.io.git path</span><br><span class=\"line\">git <span class=\"built_in\">clone</span> git@github.com:ifyour/ifyour.github.io.git path</span><br></pre></td></tr></table></figure>\n<h2 id=\"分支操作\"><a href=\"#分支操作\" class=\"headerlink\" title=\"分支操作\"></a>分支操作</h2><p><img src=\"https://user-images.githubusercontent.com/15377484/39952537-6b679758-55cb-11e8-9ff7-87440fcbb4d0.png\" alt=\"image\"></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看当前分支</span></span><br><span class=\"line\">git branch</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建分支</span></span><br><span class=\"line\">git branch dev</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 切换分支</span></span><br><span class=\"line\">git checkout dev</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建并 checkout 分支</span></span><br><span class=\"line\">git checkout -b dev</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 合并分支</span></span><br><span class=\"line\">git merge dev</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除分支</span></span><br><span class=\"line\">git branch -d dev</span><br></pre></td></tr></table></figure>\n<h2 id=\"标签\"><a href=\"#标签\" class=\"headerlink\" title=\"标签\"></a>标签</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag 0.1.1</span><br><span class=\"line\">git push origin --tags</span><br></pre></td></tr></table></figure>\n<h2 id=\"More\"><a href=\"#More\" class=\"headerlink\" title=\"More\"></a>More</h2><ul>\n<li><a href=\"http://www.bootcss.com/p/git-guide/\" target=\"_blank\" rel=\"noopener\">Git - 简易指南</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>Git 操作详细总结，以便回顾和查询。理解这些指令，觉得最重要的是理解 Git 的内部原理，比如 Git 的分布式版本控制，分清楚工作区、暂存区、版本库，还有就是理解 Git 跟踪并管理的是修改，而非文件。</p>","more":"<p><img src=\"https://user-images.githubusercontent.com/15377484/39952532-4c0c156e-55cb-11e8-8052-e62c448325fe.png\" alt=\"image\"></p>\n<h2 id=\"设置\"><a href=\"#设置\" class=\"headerlink\" title=\"设置\"></a>设置</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global user.name <span class=\"string\">\"Your Name\"</span></span><br><span class=\"line\">git config --global user.email <span class=\"string\">\"email@example.com\"</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"提交\"><a href=\"#提交\" class=\"headerlink\" title=\"提交\"></a>提交</h2><p>Git 追踪的是修改，而不是文件。</p>\n<p><img src=\"https://user-images.githubusercontent.com/15377484/39952534-5c10f236-55cb-11e8-81bf-c4d369d07054.png\" alt=\"image\"></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将 “当前修改” 移动到暂存区 (stage)</span></span><br><span class=\"line\">git add filename.txt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将暂存区修改提交</span></span><br><span class=\"line\">git commit -m <span class=\"string\">\"Add filename.txt.\"</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"状态\"><a href=\"#状态\" class=\"headerlink\" title=\"状态\"></a>状态</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git status</span><br><span class=\"line\">git diff</span><br></pre></td></tr></table></figure>\n<h2 id=\"回退\"><a href=\"#回退\" class=\"headerlink\" title=\"回退\"></a>回退</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 放弃工作区修改</span></span><br><span class=\"line\">git checkout -- file.name</span><br><span class=\"line\">git checkout -- .</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 取消 commit(比如需要重写 commit 信息)</span></span><br><span class=\"line\">git reset --soft HEAD</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 取消 commit、add(重新提交代码和 commit)</span></span><br><span class=\"line\">git reset HEAD</span><br><span class=\"line\">git reset --mixed HEAD</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 取消 commit、add、工作区修改 (需要完全重置)</span></span><br><span class=\"line\">git reset --hard HEAD</span><br></pre></td></tr></table></figure>\n<h2 id=\"记录\"><a href=\"#记录\" class=\"headerlink\" title=\"记录\"></a>记录</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reflog</span><br><span class=\"line\">git <span class=\"built_in\">log</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm file.name</span><br><span class=\"line\">git rm file.name</span><br><span class=\"line\">git commit -m <span class=\"string\">\"Del\"</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"远程操作\"><a href=\"#远程操作\" class=\"headerlink\" title=\"远程操作\"></a>远程操作</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add origin git@github.com:ifyour/ifyour.github.io.git</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 第一次推送，-u(--set-upstream) 指定默认上游</span></span><br><span class=\"line\">git push -u origin master</span><br><span class=\"line\">git push origin master</span><br></pre></td></tr></table></figure>\n<h2 id=\"克隆\"><a href=\"#克隆\" class=\"headerlink\" title=\"克隆\"></a>克隆</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/ifyour/ifyour.github.io.git path</span><br><span class=\"line\">git <span class=\"built_in\">clone</span> git@github.com:ifyour/ifyour.github.io.git path</span><br></pre></td></tr></table></figure>\n<h2 id=\"分支操作\"><a href=\"#分支操作\" class=\"headerlink\" title=\"分支操作\"></a>分支操作</h2><p><img src=\"https://user-images.githubusercontent.com/15377484/39952537-6b679758-55cb-11e8-9ff7-87440fcbb4d0.png\" alt=\"image\"></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看当前分支</span></span><br><span class=\"line\">git branch</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建分支</span></span><br><span class=\"line\">git branch dev</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 切换分支</span></span><br><span class=\"line\">git checkout dev</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建并 checkout 分支</span></span><br><span class=\"line\">git checkout -b dev</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 合并分支</span></span><br><span class=\"line\">git merge dev</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除分支</span></span><br><span class=\"line\">git branch -d dev</span><br></pre></td></tr></table></figure>\n<h2 id=\"标签\"><a href=\"#标签\" class=\"headerlink\" title=\"标签\"></a>标签</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag 0.1.1</span><br><span class=\"line\">git push origin --tags</span><br></pre></td></tr></table></figure>\n<h2 id=\"More\"><a href=\"#More\" class=\"headerlink\" title=\"More\"></a>More</h2><ul>\n<li><a href=\"http://www.bootcss.com/p/git-guide/\" target=\"_blank\" rel=\"noopener\">Git - 简易指南</a></li>\n</ul>"},{"title":"代码洁癖养成指南","comments":1,"date":"2018-12-31T12:45:31.000Z","from":null,"_content":"\n这篇文章我从几个方面来介绍我是如何配置开发环境的，尽可能使代码编写风格统一。其实不光是代码，包括日常文字，都有很多规范。比如最常见的中英文之间添加空格，可能很多人并没有在意。但是看到别人的文章里出现这样的问题，肯定是要减印象分的。\n\n<!-- more -->\n\n因为我日常使用 **VSCode**，所以这里相关配置都以这个展开。\n\n### 扩展\n\n- [EditorConfig for VS Code](https://marketplace.visualstudio.com/items?itemName=EditorConfig.EditorConfig)\n- [ESLint](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint)\n- [Prettier - Code formatter](https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode)\n- [VSCode-Pangu](https://marketplace.visualstudio.com/items?itemName=baurine.vscode-pangu)\n- [Code Spell Checker](https://marketplace.visualstudio.com/items?itemName=streetsidesoftware.code-spell-checker)\n- [Indent-Rainbow](https://marketplace.visualstudio.com/items?itemName=oderwat.indent-rainbow)\n\n下面来我简单介绍一下每个插件的功能。\n\n- EditorConfig：生成 `.editorconfig` 配置文件，规定当前编辑器的一些设定。\n- ESLint：集成 Eslint 到 VSCode，具体看 Eslint 的官方文档。\n- Prettier：Eslint 侧重于静态校验，而 Prettier 则负责按照一些规则美化代码。\n- VSCode-Pangu：自动在中英文之间添加空格。\n- Code Spell Checker：单词拼写检查。\n- Indent-Rainbow：彩虹缩进，缩进不规范时会标红提示。\n\n### 偏好\n\n#### VSCode Settings\n\n安装插件：ESLint、Prettier 后，在 settings 配置下面的选项，即可实现保存时自动格式化：\n\n```js\n{\n  // ...\n\n  // 开启保存自动格式化，调用 Prettier 时自动 eslint -fix\n  \"editor.formatOnSave\": true,\n  // 不需要 fix 了，Prettier 会自动 fix\n  \"eslint.autoFixOnSave\": false,\n  // 告诉 Prettier 使用 `prettier-eslint` 来代替 Prettier\n  \"prettier.eslintIntegration\": true,\n\n  //...\n}\n```\n\n### Lint\n\n#### 使用 Prettier 按照 Eslint 美化代码\n\n- 安装 `prettier-eslint-cli`\n\n```bash\nnpm i prettier-eslint-cli --save-dev\n```\n\n- 配置 `prettier`，在 `package.json` 添加\n\n```json\n{\n  \"scripts\": {\n    \"lint\": \"eslint *.js\",\n    \"format\": \"prettier-eslint --write *.js\"\n  },\n  \"eslintConfig\": {\n    \"extends\": \"some-config\"\n  },\n  \"prettier\": {\n    \"singleQuote\": true,\n    \"semi\": false\n  }\n}\n```\n\n经过上面配置后，编辑器就可以在保存文件时，自动按照 Eslint 格式化。\n\n#### 使用 Standard 规范\n\n[Standard](https://github.com/standard) 其实并不是标准组织出的规范，但是行业内使用的比较多。看来看去，好像各种各样的约定都没有一个标准。我看了一下，目前来说 `standard` 还算有影响力。打算以后在个人项目中全部采用这种风格，然后把剩下的时间去做点有意义的事。配置一堆 `.eslintrc` `.jscsrc` `.jshintrc` 真的很头疼。\n\n☝️ **初始化新项目**\n\n- 安装依赖\n\n```bash\nnpm install eslint \\\n    eslint-config-standard \\\n    eslint-plugin-standard \\\n    eslint-plugin-promise \\\n    eslint-plugin-import \\\n    eslint-plugin-node \\\n    eslint-plugin-markdown \\\n    --save-dev\n```\n\n- 添加 `.eslintrc`\n\n```json\n{\n  \"extends\": \"standard\"\n}\n```\n\nOK，现在让 Eslint 按照 standard 的规则来约束了，还可以使用另外的规则来覆盖。\n\n☝️ **全局使用**\n\n```bash\n# 全局安装\n$ npm i standard -g\n\n# 校验目录下 *.js/*.jsx\n$ standard\n\n# 修复\n$ standard --fix\n```\n\n### 总结\n\n以后的新项目我会采用 Standard 作为约束规范，对于已有项目我使用 Prettier 自动按照 Eslint 规则自动美化，日常一些代码片段使用 Standard 全局命令，简单实用。\n\n参考以下文档。\n\n- [standard/standard @Github](https://github.com/standard/standard/blob/master/docs/README-zhcn.md)\n- [standard/eslint-config-standard @Github](https://github.com/standard/eslint-config-standard)\n- [Standard Style Demo @Github](https://github.com/expressjs/body-parser)\n- [ESLint @中文官网](https://cn.eslint.org/)\n- [用 ESLint 和 Prettier 写出高质量代码 @EGOIST](https://egoist.moe/2017/12/11/write-better-code-with-eslint-and-prettier/)\n\n### 附：Eslint 规则\n\n#### 关闭校验\n\n```js\n// 关闭当前文件\n/* eslint-disable */\n\n// 关闭当前行校验\nlet a = 1; // eslint-disable-line\n\n// 关闭下一行校验\n// eslint-disable-next-line\nlet b = 2;\n```\n\n#### 详细规则\n\n- 0：关闭\n- 1：警告，仅给出警告\n- 2：错误，停止执行\n\n```js\n{\n    // 环境定义了预定义的全局变量。\n    \"env\": {\n        // 环境定义了预定义的全局变量。更多在官网查看\n        \"browser\": true,\n        \"node\": true,\n        \"commonjs\": true,\n        \"amd\": true,\n        \"es6\": true,\n        \"mocha\": true\n    },\n    // JavaScript 语言选项\n    \"parserOptions\": {\n        // ECMAScript 版本\n        \"ecmaVersion\": 6,\n        \"sourceType\": \"module\", // 设置为 \"script\" (默认) 或 \"module\"（如果你的代码是 ECMAScript 模块)。\n        // 想使用的额外的语言特性:\n        \"ecmaFeatures\": {\n            // 允许在全局作用域下使用 return 语句\n            \"globalReturn\": true,\n            // impliedStric\n            \"impliedStrict\": true,\n            // 启用 JSX\n            \"jsx\": true,\n            \"modules\": true\n        }\n    },\n    // 让 eslint 支持 JSX start\n    \"plugins\": [\n        \"react\"\n    ],\n    \"extends\": [\n        \"eslint:recommended\",\n        \"plugin:react/recommended\"\n    ],\n    // 让 eslint 支持 JSX end\n\n    \"rules\": {\n\n        ////////////////\n        // 可能的错误 //\n        ////////////////\n\n        // 禁止条件表达式中出现赋值操作符\n        \"no-cond-assign\": 2,\n        // 禁用 console\n        \"no-console\": 0,\n        // 禁止在条件中使用常量表达式\n        // if (false) {\n        // doSomethingUnfinished();\n        // } //cuowu\n        \"no-constant-condition\": 2,\n        // 禁止在正则表达式中使用控制字符 ：new RegExp(\"\\x1f\")\n        \"no-control-regex\": 2,\n        // 数组和对象键值对最后一个逗号， never 参数：不能带末尾的逗号, always 参数：必须带末尾的逗号，\n        // always-multiline：多行模式必须带逗号，单行模式不能带逗号\n        \"comma-dangle\": [1, \"never\"],\n        // 禁用 debugger\n        \"no-debugger\": 2,\n        // 禁止 function 定义中出现重名参数\n        \"no-dupe-args\": 2,\n        // 禁止对象字面量中出现重复的 key\n        \"no-dupe-keys\": 2,\n        // 禁止重复的 case 标签\n        \"no-duplicate-case\": 2,\n        // 禁止空语句块\n        \"no-empty\": 2,\n        // 禁止在正则表达式中使用空字符集 (/^abc[]/)\n        \"no-empty-character-class\": 2,\n        // 禁止对 catch 子句的参数重新赋值\n        \"no-ex-assign\": 2,\n        // 禁止不必要的布尔转换\n        \"no-extra-boolean-cast\": 2,\n        // 禁止不必要的括号 //(a * b) + c;// 报错\n        \"no-extra-parens\": 0,\n        // 禁止不必要的分号\n        \"no-extra-semi\": 2,\n        // 禁止对 function 声明重新赋值\n        \"no-func-assign\": 2,\n        // 禁止在嵌套的块中出现 function 或 var 声明\n        \"no-inner-declarations\": [2, \"functions\"],\n        // 禁止 RegExp 构造函数中无效的正则表达式字符串\n        \"no-invalid-regexp\": 2,\n        // 禁止在字符串和注释之外不规则的空白\n        \"no-irregular-whitespace\": 2,\n        // 禁止在 in 表达式中出现否定的左操作数\n        \"no-negated-in-lhs\": 2,\n        // 禁止把全局对象 (Math 和 JSON) 作为函数调用 错误：var math = Math();\n        \"no-obj-calls\": 2,\n        // 禁止直接使用 Object.prototypes 的内置属性\n        \"no-prototype-builtins\": 0,\n        // 禁止正则表达式字面量中出现多个空格\n        \"no-regex-spaces\": 2,\n        // 禁用稀疏数组\n        \"no-sparse-arrays\": 2,\n        // 禁止出现令人困惑的多行表达式\n        \"no-unexpected-multiline\": 2,\n        // 禁止在 return、throw、continue 和 break 语句之后出现不可达代码\n        \"no-unreachable\": 2,\n        // 要求使用 isNaN() 检查 NaN\n        \"use-isnan\": 2,\n        // 强制使用有效的 JSDoc 注释\n        \"valid-jsdoc\": 1,\n        // 强制 typeof 表达式与有效的字符串进行比较\n        // typeof foo === \"undefimed\" 错误\n        \"valid-typeof\": 2,\n\n\n        //////////////\n        // 最佳实践 //\n        //////////////\n\n        // 定义对象的 set 存取器属性时，强制定义 get\n        \"accessor-pairs\": 2,\n        // 强制数组方法的回调函数中有 return 语句\n        \"array-callback-return\": 0,\n        // 强制把变量的使用限制在其定义的作用域范围内\n        \"block-scoped-var\": 0,\n        // 限制圈复杂度，也就是类似 if else 能连续接多少个\n        \"complexity\": [2, 9],\n        // 要求 return 语句要么总是指定返回的值，要么不指定\n        \"consistent-return\": 0,\n        // 强制所有控制语句使用一致的括号风格\n        \"curly\": [2, \"all\"],\n        // switch 语句强制 default 分支，也可添加 // no default 注释取消此次警告\n        \"default-case\": 2,\n        // 强制 object.key 中 . 的位置，参数:\n        // property，'.'号应与属性在同一行\n        // object, '.' 号应与对象名在同一行\n        \"dot-location\": [2, \"property\"],\n        // 强制使用. 号取属性\n        // 参数： allowKeywords：true 使用保留字做属性名时，只能使用. 方式取属性\n        // false 使用保留字做属性名时, 只能使用 [] 方式取属性 e.g [2, {\"allowKeywords\": false}]\n        // allowPattern: 当属性名匹配提供的正则表达式时，允许使用 [] 方式取值, 否则只能用. 号取值 e.g [2, {\"allowPattern\": \"^[a-z]+(_[a-z]+)+$\"}]\n        \"dot-notation\": [2, {\n            \"allowKeywords\": false\n        }],\n        // 使用 === 替代 == allow-null 允许 null 和 undefined==\n        \"eqeqeq\": [2, \"allow-null\"],\n        // 要求 for-in 循环中有一个 if 语句\n        \"guard-for-in\": 2,\n        // 禁用 alert、confirm 和 prompt\n        \"no-alert\": 0,\n        // 禁用 arguments.caller 或 arguments.callee\n        \"no-caller\": 2,\n        // 不允许在 case 子句中使用词法声明\n        \"no-case-declarations\": 2,\n        // 禁止除法操作符显式的出现在正则表达式开始的位置\n        \"no-div-regex\": 2,\n        // 禁止 if 语句中有 return 之后有 else\n        \"no-else-return\": 0,\n        // 禁止出现空函数. 如果一个函数包含了一条注释，它将不会被认为有问题。\n        \"no-empty-function\": 2,\n        // 禁止使用空解构模式 no-empty-pattern\n        \"no-empty-pattern\": 2,\n        // 禁止在没有类型检查操作符的情况下与 null 进行比较\n        \"no-eq-null\": 1,\n        // 禁用 eval()\n        \"no-eval\": 2,\n        // 禁止扩展原生类型\n        \"no-extend-native\": 2,\n        // 禁止不必要的 .bind() 调用\n        \"no-extra-bind\": 2,\n        // 禁用不必要的标签\n        \"no-extra-label:\": 0,\n        // 禁止 case 语句落空\n        \"no-fallthrough\": 2,\n        // 禁止数字字面量中使用前导和末尾小数点\n        \"no-floating-decimal\": 2,\n        // 禁止使用短符号进行类型转换 (!!fOO)\n        \"no-implicit-coercion\": 0,\n        // 禁止在全局范围内使用 var 和命名的 function 声明\n        \"no-implicit-globals\": 1,\n        // 禁止使用类似 eval() 的方法\n        \"no-implied-eval\": 2,\n        // 禁止 this 关键字出现在类和类对象之外\n        \"no-invalid-this\": 0,\n        // 禁用 __iterator__ 属性\n        \"no-iterator\": 2,\n        // 禁用标签语句\n        \"no-labels\": 2,\n        // 禁用不必要的嵌套块\n        \"no-lone-blocks\": 2,\n        // 禁止在循环中出现 function 声明和表达式\n        \"no-loop-func\": 1,\n        // 禁用魔术数字 (3.14 什么的用常量代替)\n        \"no-magic-numbers\": [1, {\n            \"ignore\": [0, -1, 1]\n        }],\n        // 禁止使用多个空格\n        \"no-multi-spaces\": 2,\n        // 禁止使用多行字符串，在 JavaScript 中，可以在新行之前使用斜线创建多行字符串\n        \"no-multi-str\": 2,\n        // 禁止对原生对象赋值\n        \"no-native-reassign\": 2,\n        // 禁止在非赋值或条件语句中使用 new 操作符\n        \"no-new\": 2,\n        // 禁止对 Function 对象使用 new 操作符\n        \"no-new-func\": 0,\n        // 禁止对 String，Number 和 Boolean 使用 new 操作符\n        \"no-new-wrappers\": 2,\n        // 禁用八进制字面量\n        \"no-octal\": 2,\n        // 禁止在字符串中使用八进制转义序列\n        \"no-octal-escape\": 2,\n        // 不允许对 function 的参数进行重新赋值\n        \"no-param-reassign\": 0,\n        // 禁用 __proto__ 属性\n        \"no-proto\": 2,\n        // 禁止使用 var 多次声明同一变量\n        \"no-redeclare\": 2,\n        // 禁用指定的通过 require 加载的模块\n        \"no-return-assign\": 0,\n        // 禁止使用 javascript: url\n        \"no-script-url\": 0,\n        // 禁止自我赋值\n        \"no-self-assign\": 2,\n        // 禁止自身比较\n        \"no-self-compare\": 2,\n        // 禁用逗号操作符\n        \"no-sequences\": 2,\n        // 禁止抛出非异常字面量\n        \"no-throw-literal\": 2,\n        // 禁用一成不变的循环条件\n        \"no-unmodified-loop-condition\": 2,\n        // 禁止出现未使用过的表达式\n        \"no-unused-expressions\": 0,\n        // 禁用未使用过的标签\n        \"no-unused-labels\": 2,\n        // 禁止不必要的 .call() 和 .apply()\n        \"no-useless-call\": 2,\n        // 禁止不必要的字符串字面量或模板字面量的连接\n        \"no-useless-concat\": 2,\n        // 禁用不必要的转义字符\n        \"no-useless-escape\": 0,\n        // 禁用 void 操作符\n        \"no-void\": 0,\n        // 禁止在注释中使用特定的警告术语\n        \"no-warning-comments\": 0,\n        // 禁用 with 语句\n        \"no-with\": 2,\n        // 强制在 parseInt() 使用基数参数\n        \"radix\": 2,\n        // 要求所有的 var 声明出现在它们所在的作用域顶部\n        \"vars-on-top\": 0,\n        // 要求 IIFE 使用括号括起来\n        \"wrap-iife\": [2, \"any\"],\n        // 要求或禁止 “Yoda” 条件\n        \"yoda\": [2, \"never\"],\n        // 要求或禁止使用严格模式指令\n        \"strict\": 0,\n\n\n        //////////////\n        // 变量声明 //\n        //////////////\n\n        // 要求或禁止 var 声明中的初始化 (初值)\n        \"init-declarations\": 0,\n        // 不允许 catch 子句的参数与外层作用域中的变量同名\n        \"no-catch-shadow\": 0,\n        // 禁止删除变量\n        \"no-delete-var\": 2,\n        // 不允许标签与变量同名\n        \"no-label-var\": 2,\n        // 禁用特定的全局变量\n        \"no-restricted-globals\": 0,\n        // 禁止 var 声明 与外层作用域的变量同名\n        \"no-shadow\": 0,\n        // 禁止覆盖受限制的标识符\n        \"no-shadow-restricted-names\": 2,\n        // 禁用未声明的变量，除非它们在 /*global */ 注释中被提到\n        \"no-undef\": 2,\n        // 禁止将变量初始化为 undefined\n        \"no-undef-init\": 2,\n        // 禁止将 undefined 作为标识符\n        \"no-undefined\": 0,\n        // 禁止出现未使用过的变量\n        \"no-unused-vars\": [2, {\n            \"vars\": \"all\",\n            \"args\": \"none\"\n        }],\n        // 不允许在变量定义之前使用它们\n        \"no-use-before-define\": 0,\n\n        //////////////////////////\n        // Node.js and CommonJS //\n        //////////////////////////\n\n        // require return statements after callbacks\n        \"callback-return\": 0,\n        // 要求 require() 出现在顶层模块作用域中\n        \"global-require\": 1,\n        // 要求回调函数中有容错处理\n        \"handle-callback-err\": [2, \"^(err|error)$\"],\n        // 禁止混合常规 var 声明和 require 调用\n        \"no-mixed-requires\": 0,\n        // 禁止调用 require 时使用 new 操作符\n        \"no-new-require\": 2,\n        // 禁止对 __dirname 和 __filename 进行字符串连接\n        \"no-path-concat\": 0,\n        // 禁用 process.env\n        \"no-process-env\": 0,\n        // 禁用 process.exit()\n        \"no-process-exit\": 0,\n        // 禁用同步方法\n        \"no-sync\": 0,\n\n        //////////////\n        // 风格指南 //\n        //////////////\n\n        // 指定数组的元素之间要以空格隔开 (, 后面)， never 参数：[ 之前和 ] 之后不能带空格，always 参数：[ 之前和 ] 之后必须带空格\n        \"array-bracket-spacing\": [2, \"never\"],\n        // 禁止或强制在单行代码块中使用空格 (禁用)\n        \"block-spacing\": [1, \"never\"],\n        // 强制使用一致的缩进 第二个参数为 \"tab\" 时，会使用 tab，\n        // if while function 后面的 {必须与 if 在同一行，java 风格。\n        \"brace-style\": [2, \"1tbs\", {\n            \"allowSingleLine\": true\n        }],\n        // 双峰驼命名格式\n        \"camelcase\": 2,\n        // 控制逗号前后的空格\n        \"comma-spacing\": [2, {\n            \"before\": false,\n            \"after\": true\n        }],\n        // 控制逗号在行尾出现还是在行首出现 (默认行尾)\n        // http://eslint.org/docs/rules/comma-style\n        \"comma-style\": [2, \"last\"],\n        //\"SwitchCase\" (默认：0) 强制 switch 语句中的 case 子句的缩进水平\n        // 以方括号取对象属性时，[后面和] 前面是否需要空格, 可选参数 never, always\n        \"computed-property-spacing\": [2, \"never\"],\n        // 用于指统一在回调函数中指向 this 的变量名，箭头函数中的 this 已经可以指向外层调用者，应该没卵用了\n        // e.g [0,\"that\"] 指定只能 var that = this. that 不能指向其他任何值，this 也不能赋值给 that 以外的其他值\n        \"consistent-this\": [1, \"that\"],\n        // 强制使用命名的 function 表达式\n        \"func-names\": 0,\n        // 文件末尾强制换行\n        \"eol-last\": 2,\n        \"indent\": [2, 4, {\n            \"SwitchCase\": 1\n        }],\n        // 强制在对象字面量的属性中键和值之间使用一致的间距\n        \"key-spacing\": [2, {\n            \"beforeColon\": false,\n            \"afterColon\": true\n        }],\n        // 强制使用一致的换行风格\n        \"linebreak-style\": [1, \"unix\"],\n        // 要求在注释周围有空行 (要求在块级注释之前有一空行)\n        \"lines-around-comment\": [1, {\n            \"beforeBlockComment\": true\n        }],\n        // 强制一致地使用函数声明或函数表达式，方法定义风格，参数：\n        // declaration: 强制使用方法声明的方式，function f(){} e.g [2, \"declaration\"]\n        // expression：强制使用方法表达式的方式，var f = function() {} e.g [2, \"expression\"]\n        // allowArrowFunctions: declaration 风格中允许箭头函数。 e.g [2, \"declaration\", { \"allowArrowFunctions\": true}]\n        \"func-style\": 0,\n        // 强制回调函数最大嵌套深度 5 层\n        \"max-nested-callbacks\": [1, 5],\n        // 禁止使用指定的标识符\n        \"id-blacklist\": 0,\n        // 强制标识符的最新和最大长度\n        \"id-length\": 0,\n        // 要求标识符匹配一个指定的正则表达式\n        \"id-match\": 0,\n        // 强制在 JSX 属性中一致地使用双引号或单引号\n        \"jsx-quotes\": 0,\n        // 强制在关键字前后使用一致的空格 (前后腰需要)\n        \"keyword-spacing\": 2,\n        // 强制一行的最大长度\n        \"max-len\": [1, 200],\n        // 强制最大行数\n        \"max-lines\": 0,\n        // 强制 function 定义中最多允许的参数数量\n        \"max-params\": [1, 7],\n        // 强制 function 块最多允许的的语句数量\n        \"max-statements\": [1, 200],\n        // 强制每一行中所允许的最大语句数量\n        \"max-statements-per-line\": 0,\n        // 要求构造函数首字母大写 （要求调用 new 操作符时有首字母大小的函数，允许调用首字母大写的函数时没有 new 操作符。）\n        \"new-cap\": [2, {\n            \"newIsCap\": true,\n            \"capIsNew\": false\n        }],\n        // 要求调用无参构造函数时有圆括号\n        \"new-parens\": 2,\n        // 要求或禁止 var 声明语句后有一行空行\n        \"newline-after-var\": 0,\n        // 禁止使用 Array 构造函数\n        \"no-array-constructor\": 2,\n        // 禁用按位运算符\n        \"no-bitwise\": 0,\n        // 要求 return 语句之前有一空行\n        \"newline-before-return\": 0,\n        // 要求方法链中每个调用都有一个换行符\n        \"newline-per-chained-call\": 1,\n        // 禁用 continue 语句\n        \"no-continue\": 0,\n        // 禁止在代码行后使用内联注释\n        \"no-inline-comments\": 0,\n        // 禁止 if 作为唯一的语句出现在 else 语句中\n        \"no-lonely-if\": 0,\n        // 禁止混合使用不同的操作符\n        \"no-mixed-operators\": 0,\n        // 不允许空格和 tab 混合缩进\n        \"no-mixed-spaces-and-tabs\": 2,\n        // 不允许多个空行\n        \"no-multiple-empty-lines\": [2, {\n            \"max\": 2\n        }],\n        // 不允许否定的表达式\n        \"no-negated-condition\": 0,\n        // 不允许使用嵌套的三元表达式\n        \"no-nested-ternary\": 0,\n        // 禁止使用 Object 的构造函数\n        \"no-new-object\": 2,\n        // 禁止使用一元操作符 ++ 和 --\n        \"no-plusplus\": 0,\n        // 禁止使用特定的语法\n        \"no-restricted-syntax\": 0,\n        // 禁止 function 标识符和括号之间出现空格\n        \"no-spaced-func\": 2,\n        // 不允许使用三元操作符\n        \"no-ternary\": 0,\n        // 禁用行尾空格\n        \"no-trailing-spaces\": 2,\n        // 禁止标识符中有悬空下划线_bar\n        \"no-underscore-dangle\": 0,\n        // 禁止可以在有更简单的可替代的表达式时使用三元操作符\n        \"no-unneeded-ternary\": 2,\n        // 禁止属性前有空白\n        \"no-whitespace-before-property\": 0,\n        // 强制花括号内换行符的一致性\n        \"object-curly-newline\": 0,\n        // 强制在花括号中使用一致的空格\n        \"object-curly-spacing\": 0,\n        // 强制将对象的属性放在不同的行上\n        \"object-property-newline\": 0,\n        // 强制函数中的变量要么一起声明要么分开声明\n        \"one-var\": [2, {\n            \"initialized\": \"never\"\n        }],\n        // 要求或禁止在 var 声明周围换行\n        \"one-var-declaration-per-line\": 0,\n        // 要求或禁止在可能的情况下要求使用简化的赋值操作符\n        \"operator-assignment\": 0,\n        // 强制操作符使用一致的换行符\n        \"operator-linebreak\": [2, \"after\", {\n            \"overrides\": {\n                \"?\": \"before\",\n                \":\": \"before\"\n            }\n        }],\n        // 要求或禁止块内填充\n        \"padded-blocks\": 0,\n        // 要求对象字面量属性名称用引号括起来\n        \"quote-props\": 0,\n        // 强制使用一致的反勾号、双引号或单引号\n        \"quotes\": [2, \"double\", \"avoid-escape\"],\n        // 要求使用 JSDoc 注释\n        \"require-jsdoc\": 1,\n        // 要求或禁止使用分号而不是 ASI（这个才是控制行尾部分号的，）\n        \"semi\": [2, \"always\"],\n        // 强制分号之前和之后使用一致的空格\n        \"semi-spacing\": 0,\n        // 要求同一个声明块中的变量按顺序排列\n        \"sort-vars\": 0,\n        // 强制在块之前使用一致的空格\n        \"space-before-blocks\": [2, \"always\"],\n        // 强制在 function 的左括号之前使用一致的空格\n        \"space-before-function-paren\": [0, \"always\"],\n        // 强制在圆括号内使用一致的空格\n        \"space-in-parens\": [2, \"never\"],\n        // 要求操作符周围有空格\n        \"space-infix-ops\": 2,\n        // 强制在一元操作符前后使用一致的空格\n        \"space-unary-ops\": [2, {\n            \"words\": true,\n            \"nonwords\": false\n        }],\n        // 强制在注释中 // 或 /* 使用一致的空格\n        \"spaced-comment\": [2, \"always\", {\n            \"markers\": [\"global\", \"globals\", \"eslint\", \"eslint-disable\", \"*package\", \"!\"]\n        }],\n        // 要求或禁止 Unicode BOM\n        \"unicode-bom\": 0,\n        // 要求正则表达式被括号括起来\n        \"wrap-regex\": 0,\n\n        //////////////\n        // ES6. 相关 //\n        //////////////\n\n        // 要求箭头函数体使用大括号\n        \"arrow-body-style\": 2,\n        // 要求箭头函数的参数使用圆括号\n        \"arrow-parens\": 2,\n        \"arrow-spacing\": [2, {\n            \"before\": true,\n            \"after\": true\n        }],\n        // 强制在子类构造函数中用 super() 调用父类构造函数，TypeScrip 的编译器也会提示\n        \"constructor-super\": 0,\n        // 强制 generator 函数中 * 号周围使用一致的空格\n        \"generator-star-spacing\": [2, {\n            \"before\": true,\n            \"after\": true\n        }],\n        // 禁止修改类声明的变量\n        \"no-class-assign\": 2,\n        // 不允许箭头功能，在那里他们可以混淆的比较\n        \"no-confusing-arrow\": 0,\n        // 禁止修改 const 声明的变量\n        \"no-const-assign\": 2,\n        // 禁止类成员中出现重复的名称\n        \"no-dupe-class-members\": 2,\n        // 不允许复制模块的进口\n        \"no-duplicate-imports\": 0,\n        // 禁止 Symbol 的构造函数\n        \"no-new-symbol\": 2,\n        // 允许指定模块加载时的进口\n        \"no-restricted-imports\": 0,\n        // 禁止在构造函数中，在调用 super() 之前使用 this 或 super\n        \"no-this-before-super\": 2,\n        // 禁止不必要的计算性能键对象的文字\n        \"no-useless-computed-key\": 0,\n        // 要求使用 let 或 const 而不是 var\n        \"no-var\": 0,\n        // 要求或禁止对象字面量中方法和属性使用简写语法\n        \"object-shorthand\": 0,\n        // 要求使用箭头函数作为回调\n        \"prefer-arrow-callback\": 0,\n        // 要求使用 const 声明那些声明后不再被修改的变量\n        \"prefer-const\": 0,\n        // 要求在合适的地方使用 Reflect 方法\n        \"prefer-reflect\": 0,\n        // 要求使用扩展运算符而非 .apply()\n        \"prefer-spread\": 0,\n        // 要求使用模板字面量而非字符串连接\n        \"prefer-template\": 0,\n        // Suggest using the rest parameters instead of arguments\n        \"prefer-rest-params\": 0,\n        // 要求 generator 函数内有 yield\n        \"require-yield\": 0,\n        // enforce spacing between rest and spread operators and their expressions\n        \"rest-spread-spacing\": 0,\n        // 强制模块内的 import 排序\n        \"sort-imports\": 0,\n        // 要求或禁止模板字符串中的嵌入表达式周围空格的使用\n        \"template-curly-spacing\": 1,\n        // 强制在 yield* 表达式中 * 周围使用空格\n        \"yield-star-spacing\": 2\n    }\n}\n```\n","source":"_posts/代码洁癖养成指南.md","raw":"---\ntitle: 代码洁癖养成指南\ncomments: true\ndate: 2018-12-31 20:45:31\ntags:\nfrom:\n---\n\n这篇文章我从几个方面来介绍我是如何配置开发环境的，尽可能使代码编写风格统一。其实不光是代码，包括日常文字，都有很多规范。比如最常见的中英文之间添加空格，可能很多人并没有在意。但是看到别人的文章里出现这样的问题，肯定是要减印象分的。\n\n<!-- more -->\n\n因为我日常使用 **VSCode**，所以这里相关配置都以这个展开。\n\n### 扩展\n\n- [EditorConfig for VS Code](https://marketplace.visualstudio.com/items?itemName=EditorConfig.EditorConfig)\n- [ESLint](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint)\n- [Prettier - Code formatter](https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode)\n- [VSCode-Pangu](https://marketplace.visualstudio.com/items?itemName=baurine.vscode-pangu)\n- [Code Spell Checker](https://marketplace.visualstudio.com/items?itemName=streetsidesoftware.code-spell-checker)\n- [Indent-Rainbow](https://marketplace.visualstudio.com/items?itemName=oderwat.indent-rainbow)\n\n下面来我简单介绍一下每个插件的功能。\n\n- EditorConfig：生成 `.editorconfig` 配置文件，规定当前编辑器的一些设定。\n- ESLint：集成 Eslint 到 VSCode，具体看 Eslint 的官方文档。\n- Prettier：Eslint 侧重于静态校验，而 Prettier 则负责按照一些规则美化代码。\n- VSCode-Pangu：自动在中英文之间添加空格。\n- Code Spell Checker：单词拼写检查。\n- Indent-Rainbow：彩虹缩进，缩进不规范时会标红提示。\n\n### 偏好\n\n#### VSCode Settings\n\n安装插件：ESLint、Prettier 后，在 settings 配置下面的选项，即可实现保存时自动格式化：\n\n```js\n{\n  // ...\n\n  // 开启保存自动格式化，调用 Prettier 时自动 eslint -fix\n  \"editor.formatOnSave\": true,\n  // 不需要 fix 了，Prettier 会自动 fix\n  \"eslint.autoFixOnSave\": false,\n  // 告诉 Prettier 使用 `prettier-eslint` 来代替 Prettier\n  \"prettier.eslintIntegration\": true,\n\n  //...\n}\n```\n\n### Lint\n\n#### 使用 Prettier 按照 Eslint 美化代码\n\n- 安装 `prettier-eslint-cli`\n\n```bash\nnpm i prettier-eslint-cli --save-dev\n```\n\n- 配置 `prettier`，在 `package.json` 添加\n\n```json\n{\n  \"scripts\": {\n    \"lint\": \"eslint *.js\",\n    \"format\": \"prettier-eslint --write *.js\"\n  },\n  \"eslintConfig\": {\n    \"extends\": \"some-config\"\n  },\n  \"prettier\": {\n    \"singleQuote\": true,\n    \"semi\": false\n  }\n}\n```\n\n经过上面配置后，编辑器就可以在保存文件时，自动按照 Eslint 格式化。\n\n#### 使用 Standard 规范\n\n[Standard](https://github.com/standard) 其实并不是标准组织出的规范，但是行业内使用的比较多。看来看去，好像各种各样的约定都没有一个标准。我看了一下，目前来说 `standard` 还算有影响力。打算以后在个人项目中全部采用这种风格，然后把剩下的时间去做点有意义的事。配置一堆 `.eslintrc` `.jscsrc` `.jshintrc` 真的很头疼。\n\n☝️ **初始化新项目**\n\n- 安装依赖\n\n```bash\nnpm install eslint \\\n    eslint-config-standard \\\n    eslint-plugin-standard \\\n    eslint-plugin-promise \\\n    eslint-plugin-import \\\n    eslint-plugin-node \\\n    eslint-plugin-markdown \\\n    --save-dev\n```\n\n- 添加 `.eslintrc`\n\n```json\n{\n  \"extends\": \"standard\"\n}\n```\n\nOK，现在让 Eslint 按照 standard 的规则来约束了，还可以使用另外的规则来覆盖。\n\n☝️ **全局使用**\n\n```bash\n# 全局安装\n$ npm i standard -g\n\n# 校验目录下 *.js/*.jsx\n$ standard\n\n# 修复\n$ standard --fix\n```\n\n### 总结\n\n以后的新项目我会采用 Standard 作为约束规范，对于已有项目我使用 Prettier 自动按照 Eslint 规则自动美化，日常一些代码片段使用 Standard 全局命令，简单实用。\n\n参考以下文档。\n\n- [standard/standard @Github](https://github.com/standard/standard/blob/master/docs/README-zhcn.md)\n- [standard/eslint-config-standard @Github](https://github.com/standard/eslint-config-standard)\n- [Standard Style Demo @Github](https://github.com/expressjs/body-parser)\n- [ESLint @中文官网](https://cn.eslint.org/)\n- [用 ESLint 和 Prettier 写出高质量代码 @EGOIST](https://egoist.moe/2017/12/11/write-better-code-with-eslint-and-prettier/)\n\n### 附：Eslint 规则\n\n#### 关闭校验\n\n```js\n// 关闭当前文件\n/* eslint-disable */\n\n// 关闭当前行校验\nlet a = 1; // eslint-disable-line\n\n// 关闭下一行校验\n// eslint-disable-next-line\nlet b = 2;\n```\n\n#### 详细规则\n\n- 0：关闭\n- 1：警告，仅给出警告\n- 2：错误，停止执行\n\n```js\n{\n    // 环境定义了预定义的全局变量。\n    \"env\": {\n        // 环境定义了预定义的全局变量。更多在官网查看\n        \"browser\": true,\n        \"node\": true,\n        \"commonjs\": true,\n        \"amd\": true,\n        \"es6\": true,\n        \"mocha\": true\n    },\n    // JavaScript 语言选项\n    \"parserOptions\": {\n        // ECMAScript 版本\n        \"ecmaVersion\": 6,\n        \"sourceType\": \"module\", // 设置为 \"script\" (默认) 或 \"module\"（如果你的代码是 ECMAScript 模块)。\n        // 想使用的额外的语言特性:\n        \"ecmaFeatures\": {\n            // 允许在全局作用域下使用 return 语句\n            \"globalReturn\": true,\n            // impliedStric\n            \"impliedStrict\": true,\n            // 启用 JSX\n            \"jsx\": true,\n            \"modules\": true\n        }\n    },\n    // 让 eslint 支持 JSX start\n    \"plugins\": [\n        \"react\"\n    ],\n    \"extends\": [\n        \"eslint:recommended\",\n        \"plugin:react/recommended\"\n    ],\n    // 让 eslint 支持 JSX end\n\n    \"rules\": {\n\n        ////////////////\n        // 可能的错误 //\n        ////////////////\n\n        // 禁止条件表达式中出现赋值操作符\n        \"no-cond-assign\": 2,\n        // 禁用 console\n        \"no-console\": 0,\n        // 禁止在条件中使用常量表达式\n        // if (false) {\n        // doSomethingUnfinished();\n        // } //cuowu\n        \"no-constant-condition\": 2,\n        // 禁止在正则表达式中使用控制字符 ：new RegExp(\"\\x1f\")\n        \"no-control-regex\": 2,\n        // 数组和对象键值对最后一个逗号， never 参数：不能带末尾的逗号, always 参数：必须带末尾的逗号，\n        // always-multiline：多行模式必须带逗号，单行模式不能带逗号\n        \"comma-dangle\": [1, \"never\"],\n        // 禁用 debugger\n        \"no-debugger\": 2,\n        // 禁止 function 定义中出现重名参数\n        \"no-dupe-args\": 2,\n        // 禁止对象字面量中出现重复的 key\n        \"no-dupe-keys\": 2,\n        // 禁止重复的 case 标签\n        \"no-duplicate-case\": 2,\n        // 禁止空语句块\n        \"no-empty\": 2,\n        // 禁止在正则表达式中使用空字符集 (/^abc[]/)\n        \"no-empty-character-class\": 2,\n        // 禁止对 catch 子句的参数重新赋值\n        \"no-ex-assign\": 2,\n        // 禁止不必要的布尔转换\n        \"no-extra-boolean-cast\": 2,\n        // 禁止不必要的括号 //(a * b) + c;// 报错\n        \"no-extra-parens\": 0,\n        // 禁止不必要的分号\n        \"no-extra-semi\": 2,\n        // 禁止对 function 声明重新赋值\n        \"no-func-assign\": 2,\n        // 禁止在嵌套的块中出现 function 或 var 声明\n        \"no-inner-declarations\": [2, \"functions\"],\n        // 禁止 RegExp 构造函数中无效的正则表达式字符串\n        \"no-invalid-regexp\": 2,\n        // 禁止在字符串和注释之外不规则的空白\n        \"no-irregular-whitespace\": 2,\n        // 禁止在 in 表达式中出现否定的左操作数\n        \"no-negated-in-lhs\": 2,\n        // 禁止把全局对象 (Math 和 JSON) 作为函数调用 错误：var math = Math();\n        \"no-obj-calls\": 2,\n        // 禁止直接使用 Object.prototypes 的内置属性\n        \"no-prototype-builtins\": 0,\n        // 禁止正则表达式字面量中出现多个空格\n        \"no-regex-spaces\": 2,\n        // 禁用稀疏数组\n        \"no-sparse-arrays\": 2,\n        // 禁止出现令人困惑的多行表达式\n        \"no-unexpected-multiline\": 2,\n        // 禁止在 return、throw、continue 和 break 语句之后出现不可达代码\n        \"no-unreachable\": 2,\n        // 要求使用 isNaN() 检查 NaN\n        \"use-isnan\": 2,\n        // 强制使用有效的 JSDoc 注释\n        \"valid-jsdoc\": 1,\n        // 强制 typeof 表达式与有效的字符串进行比较\n        // typeof foo === \"undefimed\" 错误\n        \"valid-typeof\": 2,\n\n\n        //////////////\n        // 最佳实践 //\n        //////////////\n\n        // 定义对象的 set 存取器属性时，强制定义 get\n        \"accessor-pairs\": 2,\n        // 强制数组方法的回调函数中有 return 语句\n        \"array-callback-return\": 0,\n        // 强制把变量的使用限制在其定义的作用域范围内\n        \"block-scoped-var\": 0,\n        // 限制圈复杂度，也就是类似 if else 能连续接多少个\n        \"complexity\": [2, 9],\n        // 要求 return 语句要么总是指定返回的值，要么不指定\n        \"consistent-return\": 0,\n        // 强制所有控制语句使用一致的括号风格\n        \"curly\": [2, \"all\"],\n        // switch 语句强制 default 分支，也可添加 // no default 注释取消此次警告\n        \"default-case\": 2,\n        // 强制 object.key 中 . 的位置，参数:\n        // property，'.'号应与属性在同一行\n        // object, '.' 号应与对象名在同一行\n        \"dot-location\": [2, \"property\"],\n        // 强制使用. 号取属性\n        // 参数： allowKeywords：true 使用保留字做属性名时，只能使用. 方式取属性\n        // false 使用保留字做属性名时, 只能使用 [] 方式取属性 e.g [2, {\"allowKeywords\": false}]\n        // allowPattern: 当属性名匹配提供的正则表达式时，允许使用 [] 方式取值, 否则只能用. 号取值 e.g [2, {\"allowPattern\": \"^[a-z]+(_[a-z]+)+$\"}]\n        \"dot-notation\": [2, {\n            \"allowKeywords\": false\n        }],\n        // 使用 === 替代 == allow-null 允许 null 和 undefined==\n        \"eqeqeq\": [2, \"allow-null\"],\n        // 要求 for-in 循环中有一个 if 语句\n        \"guard-for-in\": 2,\n        // 禁用 alert、confirm 和 prompt\n        \"no-alert\": 0,\n        // 禁用 arguments.caller 或 arguments.callee\n        \"no-caller\": 2,\n        // 不允许在 case 子句中使用词法声明\n        \"no-case-declarations\": 2,\n        // 禁止除法操作符显式的出现在正则表达式开始的位置\n        \"no-div-regex\": 2,\n        // 禁止 if 语句中有 return 之后有 else\n        \"no-else-return\": 0,\n        // 禁止出现空函数. 如果一个函数包含了一条注释，它将不会被认为有问题。\n        \"no-empty-function\": 2,\n        // 禁止使用空解构模式 no-empty-pattern\n        \"no-empty-pattern\": 2,\n        // 禁止在没有类型检查操作符的情况下与 null 进行比较\n        \"no-eq-null\": 1,\n        // 禁用 eval()\n        \"no-eval\": 2,\n        // 禁止扩展原生类型\n        \"no-extend-native\": 2,\n        // 禁止不必要的 .bind() 调用\n        \"no-extra-bind\": 2,\n        // 禁用不必要的标签\n        \"no-extra-label:\": 0,\n        // 禁止 case 语句落空\n        \"no-fallthrough\": 2,\n        // 禁止数字字面量中使用前导和末尾小数点\n        \"no-floating-decimal\": 2,\n        // 禁止使用短符号进行类型转换 (!!fOO)\n        \"no-implicit-coercion\": 0,\n        // 禁止在全局范围内使用 var 和命名的 function 声明\n        \"no-implicit-globals\": 1,\n        // 禁止使用类似 eval() 的方法\n        \"no-implied-eval\": 2,\n        // 禁止 this 关键字出现在类和类对象之外\n        \"no-invalid-this\": 0,\n        // 禁用 __iterator__ 属性\n        \"no-iterator\": 2,\n        // 禁用标签语句\n        \"no-labels\": 2,\n        // 禁用不必要的嵌套块\n        \"no-lone-blocks\": 2,\n        // 禁止在循环中出现 function 声明和表达式\n        \"no-loop-func\": 1,\n        // 禁用魔术数字 (3.14 什么的用常量代替)\n        \"no-magic-numbers\": [1, {\n            \"ignore\": [0, -1, 1]\n        }],\n        // 禁止使用多个空格\n        \"no-multi-spaces\": 2,\n        // 禁止使用多行字符串，在 JavaScript 中，可以在新行之前使用斜线创建多行字符串\n        \"no-multi-str\": 2,\n        // 禁止对原生对象赋值\n        \"no-native-reassign\": 2,\n        // 禁止在非赋值或条件语句中使用 new 操作符\n        \"no-new\": 2,\n        // 禁止对 Function 对象使用 new 操作符\n        \"no-new-func\": 0,\n        // 禁止对 String，Number 和 Boolean 使用 new 操作符\n        \"no-new-wrappers\": 2,\n        // 禁用八进制字面量\n        \"no-octal\": 2,\n        // 禁止在字符串中使用八进制转义序列\n        \"no-octal-escape\": 2,\n        // 不允许对 function 的参数进行重新赋值\n        \"no-param-reassign\": 0,\n        // 禁用 __proto__ 属性\n        \"no-proto\": 2,\n        // 禁止使用 var 多次声明同一变量\n        \"no-redeclare\": 2,\n        // 禁用指定的通过 require 加载的模块\n        \"no-return-assign\": 0,\n        // 禁止使用 javascript: url\n        \"no-script-url\": 0,\n        // 禁止自我赋值\n        \"no-self-assign\": 2,\n        // 禁止自身比较\n        \"no-self-compare\": 2,\n        // 禁用逗号操作符\n        \"no-sequences\": 2,\n        // 禁止抛出非异常字面量\n        \"no-throw-literal\": 2,\n        // 禁用一成不变的循环条件\n        \"no-unmodified-loop-condition\": 2,\n        // 禁止出现未使用过的表达式\n        \"no-unused-expressions\": 0,\n        // 禁用未使用过的标签\n        \"no-unused-labels\": 2,\n        // 禁止不必要的 .call() 和 .apply()\n        \"no-useless-call\": 2,\n        // 禁止不必要的字符串字面量或模板字面量的连接\n        \"no-useless-concat\": 2,\n        // 禁用不必要的转义字符\n        \"no-useless-escape\": 0,\n        // 禁用 void 操作符\n        \"no-void\": 0,\n        // 禁止在注释中使用特定的警告术语\n        \"no-warning-comments\": 0,\n        // 禁用 with 语句\n        \"no-with\": 2,\n        // 强制在 parseInt() 使用基数参数\n        \"radix\": 2,\n        // 要求所有的 var 声明出现在它们所在的作用域顶部\n        \"vars-on-top\": 0,\n        // 要求 IIFE 使用括号括起来\n        \"wrap-iife\": [2, \"any\"],\n        // 要求或禁止 “Yoda” 条件\n        \"yoda\": [2, \"never\"],\n        // 要求或禁止使用严格模式指令\n        \"strict\": 0,\n\n\n        //////////////\n        // 变量声明 //\n        //////////////\n\n        // 要求或禁止 var 声明中的初始化 (初值)\n        \"init-declarations\": 0,\n        // 不允许 catch 子句的参数与外层作用域中的变量同名\n        \"no-catch-shadow\": 0,\n        // 禁止删除变量\n        \"no-delete-var\": 2,\n        // 不允许标签与变量同名\n        \"no-label-var\": 2,\n        // 禁用特定的全局变量\n        \"no-restricted-globals\": 0,\n        // 禁止 var 声明 与外层作用域的变量同名\n        \"no-shadow\": 0,\n        // 禁止覆盖受限制的标识符\n        \"no-shadow-restricted-names\": 2,\n        // 禁用未声明的变量，除非它们在 /*global */ 注释中被提到\n        \"no-undef\": 2,\n        // 禁止将变量初始化为 undefined\n        \"no-undef-init\": 2,\n        // 禁止将 undefined 作为标识符\n        \"no-undefined\": 0,\n        // 禁止出现未使用过的变量\n        \"no-unused-vars\": [2, {\n            \"vars\": \"all\",\n            \"args\": \"none\"\n        }],\n        // 不允许在变量定义之前使用它们\n        \"no-use-before-define\": 0,\n\n        //////////////////////////\n        // Node.js and CommonJS //\n        //////////////////////////\n\n        // require return statements after callbacks\n        \"callback-return\": 0,\n        // 要求 require() 出现在顶层模块作用域中\n        \"global-require\": 1,\n        // 要求回调函数中有容错处理\n        \"handle-callback-err\": [2, \"^(err|error)$\"],\n        // 禁止混合常规 var 声明和 require 调用\n        \"no-mixed-requires\": 0,\n        // 禁止调用 require 时使用 new 操作符\n        \"no-new-require\": 2,\n        // 禁止对 __dirname 和 __filename 进行字符串连接\n        \"no-path-concat\": 0,\n        // 禁用 process.env\n        \"no-process-env\": 0,\n        // 禁用 process.exit()\n        \"no-process-exit\": 0,\n        // 禁用同步方法\n        \"no-sync\": 0,\n\n        //////////////\n        // 风格指南 //\n        //////////////\n\n        // 指定数组的元素之间要以空格隔开 (, 后面)， never 参数：[ 之前和 ] 之后不能带空格，always 参数：[ 之前和 ] 之后必须带空格\n        \"array-bracket-spacing\": [2, \"never\"],\n        // 禁止或强制在单行代码块中使用空格 (禁用)\n        \"block-spacing\": [1, \"never\"],\n        // 强制使用一致的缩进 第二个参数为 \"tab\" 时，会使用 tab，\n        // if while function 后面的 {必须与 if 在同一行，java 风格。\n        \"brace-style\": [2, \"1tbs\", {\n            \"allowSingleLine\": true\n        }],\n        // 双峰驼命名格式\n        \"camelcase\": 2,\n        // 控制逗号前后的空格\n        \"comma-spacing\": [2, {\n            \"before\": false,\n            \"after\": true\n        }],\n        // 控制逗号在行尾出现还是在行首出现 (默认行尾)\n        // http://eslint.org/docs/rules/comma-style\n        \"comma-style\": [2, \"last\"],\n        //\"SwitchCase\" (默认：0) 强制 switch 语句中的 case 子句的缩进水平\n        // 以方括号取对象属性时，[后面和] 前面是否需要空格, 可选参数 never, always\n        \"computed-property-spacing\": [2, \"never\"],\n        // 用于指统一在回调函数中指向 this 的变量名，箭头函数中的 this 已经可以指向外层调用者，应该没卵用了\n        // e.g [0,\"that\"] 指定只能 var that = this. that 不能指向其他任何值，this 也不能赋值给 that 以外的其他值\n        \"consistent-this\": [1, \"that\"],\n        // 强制使用命名的 function 表达式\n        \"func-names\": 0,\n        // 文件末尾强制换行\n        \"eol-last\": 2,\n        \"indent\": [2, 4, {\n            \"SwitchCase\": 1\n        }],\n        // 强制在对象字面量的属性中键和值之间使用一致的间距\n        \"key-spacing\": [2, {\n            \"beforeColon\": false,\n            \"afterColon\": true\n        }],\n        // 强制使用一致的换行风格\n        \"linebreak-style\": [1, \"unix\"],\n        // 要求在注释周围有空行 (要求在块级注释之前有一空行)\n        \"lines-around-comment\": [1, {\n            \"beforeBlockComment\": true\n        }],\n        // 强制一致地使用函数声明或函数表达式，方法定义风格，参数：\n        // declaration: 强制使用方法声明的方式，function f(){} e.g [2, \"declaration\"]\n        // expression：强制使用方法表达式的方式，var f = function() {} e.g [2, \"expression\"]\n        // allowArrowFunctions: declaration 风格中允许箭头函数。 e.g [2, \"declaration\", { \"allowArrowFunctions\": true}]\n        \"func-style\": 0,\n        // 强制回调函数最大嵌套深度 5 层\n        \"max-nested-callbacks\": [1, 5],\n        // 禁止使用指定的标识符\n        \"id-blacklist\": 0,\n        // 强制标识符的最新和最大长度\n        \"id-length\": 0,\n        // 要求标识符匹配一个指定的正则表达式\n        \"id-match\": 0,\n        // 强制在 JSX 属性中一致地使用双引号或单引号\n        \"jsx-quotes\": 0,\n        // 强制在关键字前后使用一致的空格 (前后腰需要)\n        \"keyword-spacing\": 2,\n        // 强制一行的最大长度\n        \"max-len\": [1, 200],\n        // 强制最大行数\n        \"max-lines\": 0,\n        // 强制 function 定义中最多允许的参数数量\n        \"max-params\": [1, 7],\n        // 强制 function 块最多允许的的语句数量\n        \"max-statements\": [1, 200],\n        // 强制每一行中所允许的最大语句数量\n        \"max-statements-per-line\": 0,\n        // 要求构造函数首字母大写 （要求调用 new 操作符时有首字母大小的函数，允许调用首字母大写的函数时没有 new 操作符。）\n        \"new-cap\": [2, {\n            \"newIsCap\": true,\n            \"capIsNew\": false\n        }],\n        // 要求调用无参构造函数时有圆括号\n        \"new-parens\": 2,\n        // 要求或禁止 var 声明语句后有一行空行\n        \"newline-after-var\": 0,\n        // 禁止使用 Array 构造函数\n        \"no-array-constructor\": 2,\n        // 禁用按位运算符\n        \"no-bitwise\": 0,\n        // 要求 return 语句之前有一空行\n        \"newline-before-return\": 0,\n        // 要求方法链中每个调用都有一个换行符\n        \"newline-per-chained-call\": 1,\n        // 禁用 continue 语句\n        \"no-continue\": 0,\n        // 禁止在代码行后使用内联注释\n        \"no-inline-comments\": 0,\n        // 禁止 if 作为唯一的语句出现在 else 语句中\n        \"no-lonely-if\": 0,\n        // 禁止混合使用不同的操作符\n        \"no-mixed-operators\": 0,\n        // 不允许空格和 tab 混合缩进\n        \"no-mixed-spaces-and-tabs\": 2,\n        // 不允许多个空行\n        \"no-multiple-empty-lines\": [2, {\n            \"max\": 2\n        }],\n        // 不允许否定的表达式\n        \"no-negated-condition\": 0,\n        // 不允许使用嵌套的三元表达式\n        \"no-nested-ternary\": 0,\n        // 禁止使用 Object 的构造函数\n        \"no-new-object\": 2,\n        // 禁止使用一元操作符 ++ 和 --\n        \"no-plusplus\": 0,\n        // 禁止使用特定的语法\n        \"no-restricted-syntax\": 0,\n        // 禁止 function 标识符和括号之间出现空格\n        \"no-spaced-func\": 2,\n        // 不允许使用三元操作符\n        \"no-ternary\": 0,\n        // 禁用行尾空格\n        \"no-trailing-spaces\": 2,\n        // 禁止标识符中有悬空下划线_bar\n        \"no-underscore-dangle\": 0,\n        // 禁止可以在有更简单的可替代的表达式时使用三元操作符\n        \"no-unneeded-ternary\": 2,\n        // 禁止属性前有空白\n        \"no-whitespace-before-property\": 0,\n        // 强制花括号内换行符的一致性\n        \"object-curly-newline\": 0,\n        // 强制在花括号中使用一致的空格\n        \"object-curly-spacing\": 0,\n        // 强制将对象的属性放在不同的行上\n        \"object-property-newline\": 0,\n        // 强制函数中的变量要么一起声明要么分开声明\n        \"one-var\": [2, {\n            \"initialized\": \"never\"\n        }],\n        // 要求或禁止在 var 声明周围换行\n        \"one-var-declaration-per-line\": 0,\n        // 要求或禁止在可能的情况下要求使用简化的赋值操作符\n        \"operator-assignment\": 0,\n        // 强制操作符使用一致的换行符\n        \"operator-linebreak\": [2, \"after\", {\n            \"overrides\": {\n                \"?\": \"before\",\n                \":\": \"before\"\n            }\n        }],\n        // 要求或禁止块内填充\n        \"padded-blocks\": 0,\n        // 要求对象字面量属性名称用引号括起来\n        \"quote-props\": 0,\n        // 强制使用一致的反勾号、双引号或单引号\n        \"quotes\": [2, \"double\", \"avoid-escape\"],\n        // 要求使用 JSDoc 注释\n        \"require-jsdoc\": 1,\n        // 要求或禁止使用分号而不是 ASI（这个才是控制行尾部分号的，）\n        \"semi\": [2, \"always\"],\n        // 强制分号之前和之后使用一致的空格\n        \"semi-spacing\": 0,\n        // 要求同一个声明块中的变量按顺序排列\n        \"sort-vars\": 0,\n        // 强制在块之前使用一致的空格\n        \"space-before-blocks\": [2, \"always\"],\n        // 强制在 function 的左括号之前使用一致的空格\n        \"space-before-function-paren\": [0, \"always\"],\n        // 强制在圆括号内使用一致的空格\n        \"space-in-parens\": [2, \"never\"],\n        // 要求操作符周围有空格\n        \"space-infix-ops\": 2,\n        // 强制在一元操作符前后使用一致的空格\n        \"space-unary-ops\": [2, {\n            \"words\": true,\n            \"nonwords\": false\n        }],\n        // 强制在注释中 // 或 /* 使用一致的空格\n        \"spaced-comment\": [2, \"always\", {\n            \"markers\": [\"global\", \"globals\", \"eslint\", \"eslint-disable\", \"*package\", \"!\"]\n        }],\n        // 要求或禁止 Unicode BOM\n        \"unicode-bom\": 0,\n        // 要求正则表达式被括号括起来\n        \"wrap-regex\": 0,\n\n        //////////////\n        // ES6. 相关 //\n        //////////////\n\n        // 要求箭头函数体使用大括号\n        \"arrow-body-style\": 2,\n        // 要求箭头函数的参数使用圆括号\n        \"arrow-parens\": 2,\n        \"arrow-spacing\": [2, {\n            \"before\": true,\n            \"after\": true\n        }],\n        // 强制在子类构造函数中用 super() 调用父类构造函数，TypeScrip 的编译器也会提示\n        \"constructor-super\": 0,\n        // 强制 generator 函数中 * 号周围使用一致的空格\n        \"generator-star-spacing\": [2, {\n            \"before\": true,\n            \"after\": true\n        }],\n        // 禁止修改类声明的变量\n        \"no-class-assign\": 2,\n        // 不允许箭头功能，在那里他们可以混淆的比较\n        \"no-confusing-arrow\": 0,\n        // 禁止修改 const 声明的变量\n        \"no-const-assign\": 2,\n        // 禁止类成员中出现重复的名称\n        \"no-dupe-class-members\": 2,\n        // 不允许复制模块的进口\n        \"no-duplicate-imports\": 0,\n        // 禁止 Symbol 的构造函数\n        \"no-new-symbol\": 2,\n        // 允许指定模块加载时的进口\n        \"no-restricted-imports\": 0,\n        // 禁止在构造函数中，在调用 super() 之前使用 this 或 super\n        \"no-this-before-super\": 2,\n        // 禁止不必要的计算性能键对象的文字\n        \"no-useless-computed-key\": 0,\n        // 要求使用 let 或 const 而不是 var\n        \"no-var\": 0,\n        // 要求或禁止对象字面量中方法和属性使用简写语法\n        \"object-shorthand\": 0,\n        // 要求使用箭头函数作为回调\n        \"prefer-arrow-callback\": 0,\n        // 要求使用 const 声明那些声明后不再被修改的变量\n        \"prefer-const\": 0,\n        // 要求在合适的地方使用 Reflect 方法\n        \"prefer-reflect\": 0,\n        // 要求使用扩展运算符而非 .apply()\n        \"prefer-spread\": 0,\n        // 要求使用模板字面量而非字符串连接\n        \"prefer-template\": 0,\n        // Suggest using the rest parameters instead of arguments\n        \"prefer-rest-params\": 0,\n        // 要求 generator 函数内有 yield\n        \"require-yield\": 0,\n        // enforce spacing between rest and spread operators and their expressions\n        \"rest-spread-spacing\": 0,\n        // 强制模块内的 import 排序\n        \"sort-imports\": 0,\n        // 要求或禁止模板字符串中的嵌入表达式周围空格的使用\n        \"template-curly-spacing\": 1,\n        // 强制在 yield* 表达式中 * 周围使用空格\n        \"yield-star-spacing\": 2\n    }\n}\n```\n","slug":"代码洁癖养成指南","published":1,"updated":"2019-12-07T04:53:18.094Z","layout":"post","photos":[],"link":"","_id":"ck3v60jtk000lr9q9t83gmtne","content":"<p>这篇文章我从几个方面来介绍我是如何配置开发环境的，尽可能使代码编写风格统一。其实不光是代码，包括日常文字，都有很多规范。比如最常见的中英文之间添加空格，可能很多人并没有在意。但是看到别人的文章里出现这样的问题，肯定是要减印象分的。</p>\n<a id=\"more\"></a>\n<p>因为我日常使用 <strong>VSCode</strong>，所以这里相关配置都以这个展开。</p>\n<h3 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h3><ul>\n<li><a href=\"https://marketplace.visualstudio.com/items?itemName=EditorConfig.EditorConfig\" target=\"_blank\" rel=\"noopener\">EditorConfig for VS Code</a></li>\n<li><a href=\"https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint\" target=\"_blank\" rel=\"noopener\">ESLint</a></li>\n<li><a href=\"https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode\" target=\"_blank\" rel=\"noopener\">Prettier - Code formatter</a></li>\n<li><a href=\"https://marketplace.visualstudio.com/items?itemName=baurine.vscode-pangu\" target=\"_blank\" rel=\"noopener\">VSCode-Pangu</a></li>\n<li><a href=\"https://marketplace.visualstudio.com/items?itemName=streetsidesoftware.code-spell-checker\" target=\"_blank\" rel=\"noopener\">Code Spell Checker</a></li>\n<li><a href=\"https://marketplace.visualstudio.com/items?itemName=oderwat.indent-rainbow\" target=\"_blank\" rel=\"noopener\">Indent-Rainbow</a></li>\n</ul>\n<p>下面来我简单介绍一下每个插件的功能。</p>\n<ul>\n<li>EditorConfig：生成 <code>.editorconfig</code> 配置文件，规定当前编辑器的一些设定。</li>\n<li>ESLint：集成 Eslint 到 VSCode，具体看 Eslint 的官方文档。</li>\n<li>Prettier：Eslint 侧重于静态校验，而 Prettier 则负责按照一些规则美化代码。</li>\n<li>VSCode-Pangu：自动在中英文之间添加空格。</li>\n<li>Code Spell Checker：单词拼写检查。</li>\n<li>Indent-Rainbow：彩虹缩进，缩进不规范时会标红提示。</li>\n</ul>\n<h3 id=\"偏好\"><a href=\"#偏好\" class=\"headerlink\" title=\"偏好\"></a>偏好</h3><h4 id=\"VSCode-Settings\"><a href=\"#VSCode-Settings\" class=\"headerlink\" title=\"VSCode Settings\"></a>VSCode Settings</h4><p>安装插件：ESLint、Prettier 后，在 settings 配置下面的选项，即可实现保存时自动格式化：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 开启保存自动格式化，调用 Prettier 时自动 eslint -fix</span></span><br><span class=\"line\">  <span class=\"string\">\"editor.formatOnSave\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  <span class=\"comment\">// 不需要 fix 了，Prettier 会自动 fix</span></span><br><span class=\"line\">  <span class=\"string\">\"eslint.autoFixOnSave\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  <span class=\"comment\">// 告诉 Prettier 使用 `prettier-eslint` 来代替 Prettier</span></span><br><span class=\"line\">  <span class=\"string\">\"prettier.eslintIntegration\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Lint\"><a href=\"#Lint\" class=\"headerlink\" title=\"Lint\"></a>Lint</h3><h4 id=\"使用-Prettier-按照-Eslint-美化代码\"><a href=\"#使用-Prettier-按照-Eslint-美化代码\" class=\"headerlink\" title=\"使用 Prettier 按照 Eslint 美化代码\"></a>使用 Prettier 按照 Eslint 美化代码</h4><ul>\n<li>安装 <code>prettier-eslint-cli</code></li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i prettier-eslint-cli --save-dev</span><br></pre></td></tr></table></figure>\n<ul>\n<li>配置 <code>prettier</code>，在 <code>package.json</code> 添加</li>\n</ul>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"lint\"</span>: <span class=\"string\">\"eslint *.js\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"format\"</span>: <span class=\"string\">\"prettier-eslint --write *.js\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">\"eslintConfig\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"extends\"</span>: <span class=\"string\">\"some-config\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">\"prettier\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"singleQuote\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"semi\"</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>经过上面配置后，编辑器就可以在保存文件时，自动按照 Eslint 格式化。</p>\n<h4 id=\"使用-Standard-规范\"><a href=\"#使用-Standard-规范\" class=\"headerlink\" title=\"使用 Standard 规范\"></a>使用 Standard 规范</h4><p><a href=\"https://github.com/standard\" target=\"_blank\" rel=\"noopener\">Standard</a> 其实并不是标准组织出的规范，但是行业内使用的比较多。看来看去，好像各种各样的约定都没有一个标准。我看了一下，目前来说 <code>standard</code> 还算有影响力。打算以后在个人项目中全部采用这种风格，然后把剩下的时间去做点有意义的事。配置一堆 <code>.eslintrc</code> <code>.jscsrc</code> <code>.jshintrc</code> 真的很头疼。</p>\n<p>☝️ <strong>初始化新项目</strong></p>\n<ul>\n<li>安装依赖</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install eslint \\</span><br><span class=\"line\">    eslint-config-standard \\</span><br><span class=\"line\">    eslint-plugin-standard \\</span><br><span class=\"line\">    eslint-plugin-promise \\</span><br><span class=\"line\">    eslint-plugin-import \\</span><br><span class=\"line\">    eslint-plugin-node \\</span><br><span class=\"line\">    eslint-plugin-markdown \\</span><br><span class=\"line\">    --save-dev</span><br></pre></td></tr></table></figure>\n<ul>\n<li>添加 <code>.eslintrc</code></li>\n</ul>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"extends\"</span>: <span class=\"string\">\"standard\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>OK，现在让 Eslint 按照 standard 的规则来约束了，还可以使用另外的规则来覆盖。</p>\n<p>☝️ <strong>全局使用</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 全局安装</span></span><br><span class=\"line\">$ npm i standard -g</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 校验目录下 *.js/*.jsx</span></span><br><span class=\"line\">$ standard</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 修复</span></span><br><span class=\"line\">$ standard --fix</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>以后的新项目我会采用 Standard 作为约束规范，对于已有项目我使用 Prettier 自动按照 Eslint 规则自动美化，日常一些代码片段使用 Standard 全局命令，简单实用。</p>\n<p>参考以下文档。</p>\n<ul>\n<li><a href=\"https://github.com/standard/standard/blob/master/docs/README-zhcn.md\" target=\"_blank\" rel=\"noopener\">standard/standard @Github</a></li>\n<li><a href=\"https://github.com/standard/eslint-config-standard\" target=\"_blank\" rel=\"noopener\">standard/eslint-config-standard @Github</a></li>\n<li><a href=\"https://github.com/expressjs/body-parser\" target=\"_blank\" rel=\"noopener\">Standard Style Demo @Github</a></li>\n<li><a href=\"https://cn.eslint.org/\" target=\"_blank\" rel=\"noopener\">ESLint @中文官网</a></li>\n<li><a href=\"https://egoist.moe/2017/12/11/write-better-code-with-eslint-and-prettier/\" target=\"_blank\" rel=\"noopener\">用 ESLint 和 Prettier 写出高质量代码 @EGOIST</a></li>\n</ul>\n<h3 id=\"附：Eslint-规则\"><a href=\"#附：Eslint-规则\" class=\"headerlink\" title=\"附：Eslint 规则\"></a>附：Eslint 规则</h3><h4 id=\"关闭校验\"><a href=\"#关闭校验\" class=\"headerlink\" title=\"关闭校验\"></a>关闭校验</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 关闭当前文件</span></span><br><span class=\"line\"><span class=\"comment\">/* eslint-disable */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 关闭当前行校验</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">1</span>; <span class=\"comment\">// eslint-disable-line</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 关闭下一行校验</span></span><br><span class=\"line\"><span class=\"comment\">// eslint-disable-next-line</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"详细规则\"><a href=\"#详细规则\" class=\"headerlink\" title=\"详细规则\"></a>详细规则</h4><ul>\n<li>0：关闭</li>\n<li>1：警告，仅给出警告</li>\n<li>2：错误，停止执行</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br><span class=\"line\">322</span><br><span class=\"line\">323</span><br><span class=\"line\">324</span><br><span class=\"line\">325</span><br><span class=\"line\">326</span><br><span class=\"line\">327</span><br><span class=\"line\">328</span><br><span class=\"line\">329</span><br><span class=\"line\">330</span><br><span class=\"line\">331</span><br><span class=\"line\">332</span><br><span class=\"line\">333</span><br><span class=\"line\">334</span><br><span class=\"line\">335</span><br><span class=\"line\">336</span><br><span class=\"line\">337</span><br><span class=\"line\">338</span><br><span class=\"line\">339</span><br><span class=\"line\">340</span><br><span class=\"line\">341</span><br><span class=\"line\">342</span><br><span class=\"line\">343</span><br><span class=\"line\">344</span><br><span class=\"line\">345</span><br><span class=\"line\">346</span><br><span class=\"line\">347</span><br><span class=\"line\">348</span><br><span class=\"line\">349</span><br><span class=\"line\">350</span><br><span class=\"line\">351</span><br><span class=\"line\">352</span><br><span class=\"line\">353</span><br><span class=\"line\">354</span><br><span class=\"line\">355</span><br><span class=\"line\">356</span><br><span class=\"line\">357</span><br><span class=\"line\">358</span><br><span class=\"line\">359</span><br><span class=\"line\">360</span><br><span class=\"line\">361</span><br><span class=\"line\">362</span><br><span class=\"line\">363</span><br><span class=\"line\">364</span><br><span class=\"line\">365</span><br><span class=\"line\">366</span><br><span class=\"line\">367</span><br><span class=\"line\">368</span><br><span class=\"line\">369</span><br><span class=\"line\">370</span><br><span class=\"line\">371</span><br><span class=\"line\">372</span><br><span class=\"line\">373</span><br><span class=\"line\">374</span><br><span class=\"line\">375</span><br><span class=\"line\">376</span><br><span class=\"line\">377</span><br><span class=\"line\">378</span><br><span class=\"line\">379</span><br><span class=\"line\">380</span><br><span class=\"line\">381</span><br><span class=\"line\">382</span><br><span class=\"line\">383</span><br><span class=\"line\">384</span><br><span class=\"line\">385</span><br><span class=\"line\">386</span><br><span class=\"line\">387</span><br><span class=\"line\">388</span><br><span class=\"line\">389</span><br><span class=\"line\">390</span><br><span class=\"line\">391</span><br><span class=\"line\">392</span><br><span class=\"line\">393</span><br><span class=\"line\">394</span><br><span class=\"line\">395</span><br><span class=\"line\">396</span><br><span class=\"line\">397</span><br><span class=\"line\">398</span><br><span class=\"line\">399</span><br><span class=\"line\">400</span><br><span class=\"line\">401</span><br><span class=\"line\">402</span><br><span class=\"line\">403</span><br><span class=\"line\">404</span><br><span class=\"line\">405</span><br><span class=\"line\">406</span><br><span class=\"line\">407</span><br><span class=\"line\">408</span><br><span class=\"line\">409</span><br><span class=\"line\">410</span><br><span class=\"line\">411</span><br><span class=\"line\">412</span><br><span class=\"line\">413</span><br><span class=\"line\">414</span><br><span class=\"line\">415</span><br><span class=\"line\">416</span><br><span class=\"line\">417</span><br><span class=\"line\">418</span><br><span class=\"line\">419</span><br><span class=\"line\">420</span><br><span class=\"line\">421</span><br><span class=\"line\">422</span><br><span class=\"line\">423</span><br><span class=\"line\">424</span><br><span class=\"line\">425</span><br><span class=\"line\">426</span><br><span class=\"line\">427</span><br><span class=\"line\">428</span><br><span class=\"line\">429</span><br><span class=\"line\">430</span><br><span class=\"line\">431</span><br><span class=\"line\">432</span><br><span class=\"line\">433</span><br><span class=\"line\">434</span><br><span class=\"line\">435</span><br><span class=\"line\">436</span><br><span class=\"line\">437</span><br><span class=\"line\">438</span><br><span class=\"line\">439</span><br><span class=\"line\">440</span><br><span class=\"line\">441</span><br><span class=\"line\">442</span><br><span class=\"line\">443</span><br><span class=\"line\">444</span><br><span class=\"line\">445</span><br><span class=\"line\">446</span><br><span class=\"line\">447</span><br><span class=\"line\">448</span><br><span class=\"line\">449</span><br><span class=\"line\">450</span><br><span class=\"line\">451</span><br><span class=\"line\">452</span><br><span class=\"line\">453</span><br><span class=\"line\">454</span><br><span class=\"line\">455</span><br><span class=\"line\">456</span><br><span class=\"line\">457</span><br><span class=\"line\">458</span><br><span class=\"line\">459</span><br><span class=\"line\">460</span><br><span class=\"line\">461</span><br><span class=\"line\">462</span><br><span class=\"line\">463</span><br><span class=\"line\">464</span><br><span class=\"line\">465</span><br><span class=\"line\">466</span><br><span class=\"line\">467</span><br><span class=\"line\">468</span><br><span class=\"line\">469</span><br><span class=\"line\">470</span><br><span class=\"line\">471</span><br><span class=\"line\">472</span><br><span class=\"line\">473</span><br><span class=\"line\">474</span><br><span class=\"line\">475</span><br><span class=\"line\">476</span><br><span class=\"line\">477</span><br><span class=\"line\">478</span><br><span class=\"line\">479</span><br><span class=\"line\">480</span><br><span class=\"line\">481</span><br><span class=\"line\">482</span><br><span class=\"line\">483</span><br><span class=\"line\">484</span><br><span class=\"line\">485</span><br><span class=\"line\">486</span><br><span class=\"line\">487</span><br><span class=\"line\">488</span><br><span class=\"line\">489</span><br><span class=\"line\">490</span><br><span class=\"line\">491</span><br><span class=\"line\">492</span><br><span class=\"line\">493</span><br><span class=\"line\">494</span><br><span class=\"line\">495</span><br><span class=\"line\">496</span><br><span class=\"line\">497</span><br><span class=\"line\">498</span><br><span class=\"line\">499</span><br><span class=\"line\">500</span><br><span class=\"line\">501</span><br><span class=\"line\">502</span><br><span class=\"line\">503</span><br><span class=\"line\">504</span><br><span class=\"line\">505</span><br><span class=\"line\">506</span><br><span class=\"line\">507</span><br><span class=\"line\">508</span><br><span class=\"line\">509</span><br><span class=\"line\">510</span><br><span class=\"line\">511</span><br><span class=\"line\">512</span><br><span class=\"line\">513</span><br><span class=\"line\">514</span><br><span class=\"line\">515</span><br><span class=\"line\">516</span><br><span class=\"line\">517</span><br><span class=\"line\">518</span><br><span class=\"line\">519</span><br><span class=\"line\">520</span><br><span class=\"line\">521</span><br><span class=\"line\">522</span><br><span class=\"line\">523</span><br><span class=\"line\">524</span><br><span class=\"line\">525</span><br><span class=\"line\">526</span><br><span class=\"line\">527</span><br><span class=\"line\">528</span><br><span class=\"line\">529</span><br><span class=\"line\">530</span><br><span class=\"line\">531</span><br><span class=\"line\">532</span><br><span class=\"line\">533</span><br><span class=\"line\">534</span><br><span class=\"line\">535</span><br><span class=\"line\">536</span><br><span class=\"line\">537</span><br><span class=\"line\">538</span><br><span class=\"line\">539</span><br><span class=\"line\">540</span><br><span class=\"line\">541</span><br><span class=\"line\">542</span><br><span class=\"line\">543</span><br><span class=\"line\">544</span><br><span class=\"line\">545</span><br><span class=\"line\">546</span><br><span class=\"line\">547</span><br><span class=\"line\">548</span><br><span class=\"line\">549</span><br><span class=\"line\">550</span><br><span class=\"line\">551</span><br><span class=\"line\">552</span><br><span class=\"line\">553</span><br><span class=\"line\">554</span><br><span class=\"line\">555</span><br><span class=\"line\">556</span><br><span class=\"line\">557</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 环境定义了预定义的全局变量。</span></span><br><span class=\"line\">    <span class=\"string\">\"env\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 环境定义了预定义的全局变量。更多在官网查看</span></span><br><span class=\"line\">        <span class=\"string\">\"browser\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"string\">\"node\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"string\">\"commonjs\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"string\">\"amd\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"string\">\"es6\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"string\">\"mocha\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// JavaScript 语言选项</span></span><br><span class=\"line\">    <span class=\"string\">\"parserOptions\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ECMAScript 版本</span></span><br><span class=\"line\">        <span class=\"string\">\"ecmaVersion\"</span>: <span class=\"number\">6</span>,</span><br><span class=\"line\">        <span class=\"string\">\"sourceType\"</span>: <span class=\"string\">\"module\"</span>, <span class=\"comment\">// 设置为 \"script\" (默认) 或 \"module\"（如果你的代码是 ECMAScript 模块)。</span></span><br><span class=\"line\">        <span class=\"comment\">// 想使用的额外的语言特性:</span></span><br><span class=\"line\">        <span class=\"string\">\"ecmaFeatures\"</span>: &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 允许在全局作用域下使用 return 语句</span></span><br><span class=\"line\">            <span class=\"string\">\"globalReturn\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            <span class=\"comment\">// impliedStric</span></span><br><span class=\"line\">            <span class=\"string\">\"impliedStrict\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            <span class=\"comment\">// 启用 JSX</span></span><br><span class=\"line\">            <span class=\"string\">\"jsx\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            <span class=\"string\">\"modules\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 让 eslint 支持 JSX start</span></span><br><span class=\"line\">    <span class=\"string\">\"plugins\"</span>: [</span><br><span class=\"line\">        <span class=\"string\">\"react\"</span></span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"string\">\"extends\"</span>: [</span><br><span class=\"line\">        <span class=\"string\">\"eslint:recommended\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"plugin:react/recommended\"</span></span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"comment\">// 让 eslint 支持 JSX end</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">\"rules\"</span>: &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">////////////////</span></span><br><span class=\"line\">        <span class=\"comment\">// 可能的错误 //</span></span><br><span class=\"line\">        <span class=\"comment\">////////////////</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 禁止条件表达式中出现赋值操作符</span></span><br><span class=\"line\">        <span class=\"string\">\"no-cond-assign\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁用 console</span></span><br><span class=\"line\">        <span class=\"string\">\"no-console\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止在条件中使用常量表达式</span></span><br><span class=\"line\">        <span class=\"comment\">// if (false) &#123;</span></span><br><span class=\"line\">        <span class=\"comment\">// doSomethingUnfinished();</span></span><br><span class=\"line\">        <span class=\"comment\">// &#125; //cuowu</span></span><br><span class=\"line\">        <span class=\"string\">\"no-constant-condition\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止在正则表达式中使用控制字符 ：new RegExp(\"\\x1f\")</span></span><br><span class=\"line\">        <span class=\"string\">\"no-control-regex\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 数组和对象键值对最后一个逗号， never 参数：不能带末尾的逗号, always 参数：必须带末尾的逗号，</span></span><br><span class=\"line\">        <span class=\"comment\">// always-multiline：多行模式必须带逗号，单行模式不能带逗号</span></span><br><span class=\"line\">        <span class=\"string\">\"comma-dangle\"</span>: [<span class=\"number\">1</span>, <span class=\"string\">\"never\"</span>],</span><br><span class=\"line\">        <span class=\"comment\">// 禁用 debugger</span></span><br><span class=\"line\">        <span class=\"string\">\"no-debugger\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止 function 定义中出现重名参数</span></span><br><span class=\"line\">        <span class=\"string\">\"no-dupe-args\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止对象字面量中出现重复的 key</span></span><br><span class=\"line\">        <span class=\"string\">\"no-dupe-keys\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止重复的 case 标签</span></span><br><span class=\"line\">        <span class=\"string\">\"no-duplicate-case\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止空语句块</span></span><br><span class=\"line\">        <span class=\"string\">\"no-empty\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止在正则表达式中使用空字符集 (/^abc[]/)</span></span><br><span class=\"line\">        <span class=\"string\">\"no-empty-character-class\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止对 catch 子句的参数重新赋值</span></span><br><span class=\"line\">        <span class=\"string\">\"no-ex-assign\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止不必要的布尔转换</span></span><br><span class=\"line\">        <span class=\"string\">\"no-extra-boolean-cast\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止不必要的括号 //(a * b) + c;// 报错</span></span><br><span class=\"line\">        <span class=\"string\">\"no-extra-parens\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止不必要的分号</span></span><br><span class=\"line\">        <span class=\"string\">\"no-extra-semi\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止对 function 声明重新赋值</span></span><br><span class=\"line\">        <span class=\"string\">\"no-func-assign\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止在嵌套的块中出现 function 或 var 声明</span></span><br><span class=\"line\">        <span class=\"string\">\"no-inner-declarations\"</span>: [<span class=\"number\">2</span>, <span class=\"string\">\"functions\"</span>],</span><br><span class=\"line\">        <span class=\"comment\">// 禁止 RegExp 构造函数中无效的正则表达式字符串</span></span><br><span class=\"line\">        <span class=\"string\">\"no-invalid-regexp\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止在字符串和注释之外不规则的空白</span></span><br><span class=\"line\">        <span class=\"string\">\"no-irregular-whitespace\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止在 in 表达式中出现否定的左操作数</span></span><br><span class=\"line\">        <span class=\"string\">\"no-negated-in-lhs\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止把全局对象 (Math 和 JSON) 作为函数调用 错误：var math = Math();</span></span><br><span class=\"line\">        <span class=\"string\">\"no-obj-calls\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止直接使用 Object.prototypes 的内置属性</span></span><br><span class=\"line\">        <span class=\"string\">\"no-prototype-builtins\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止正则表达式字面量中出现多个空格</span></span><br><span class=\"line\">        <span class=\"string\">\"no-regex-spaces\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁用稀疏数组</span></span><br><span class=\"line\">        <span class=\"string\">\"no-sparse-arrays\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止出现令人困惑的多行表达式</span></span><br><span class=\"line\">        <span class=\"string\">\"no-unexpected-multiline\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止在 return、throw、continue 和 break 语句之后出现不可达代码</span></span><br><span class=\"line\">        <span class=\"string\">\"no-unreachable\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 要求使用 isNaN() 检查 NaN</span></span><br><span class=\"line\">        <span class=\"string\">\"use-isnan\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 强制使用有效的 JSDoc 注释</span></span><br><span class=\"line\">        <span class=\"string\">\"valid-jsdoc\"</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 强制 typeof 表达式与有效的字符串进行比较</span></span><br><span class=\"line\">        <span class=\"comment\">// typeof foo === \"undefimed\" 错误</span></span><br><span class=\"line\">        <span class=\"string\">\"valid-typeof\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//////////////</span></span><br><span class=\"line\">        <span class=\"comment\">// 最佳实践 //</span></span><br><span class=\"line\">        <span class=\"comment\">//////////////</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 定义对象的 set 存取器属性时，强制定义 get</span></span><br><span class=\"line\">        <span class=\"string\">\"accessor-pairs\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 强制数组方法的回调函数中有 return 语句</span></span><br><span class=\"line\">        <span class=\"string\">\"array-callback-return\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 强制把变量的使用限制在其定义的作用域范围内</span></span><br><span class=\"line\">        <span class=\"string\">\"block-scoped-var\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 限制圈复杂度，也就是类似 if else 能连续接多少个</span></span><br><span class=\"line\">        <span class=\"string\">\"complexity\"</span>: [<span class=\"number\">2</span>, <span class=\"number\">9</span>],</span><br><span class=\"line\">        <span class=\"comment\">// 要求 return 语句要么总是指定返回的值，要么不指定</span></span><br><span class=\"line\">        <span class=\"string\">\"consistent-return\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 强制所有控制语句使用一致的括号风格</span></span><br><span class=\"line\">        <span class=\"string\">\"curly\"</span>: [<span class=\"number\">2</span>, <span class=\"string\">\"all\"</span>],</span><br><span class=\"line\">        <span class=\"comment\">// switch 语句强制 default 分支，也可添加 // no default 注释取消此次警告</span></span><br><span class=\"line\">        <span class=\"string\">\"default-case\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 强制 object.key 中 . 的位置，参数:</span></span><br><span class=\"line\">        <span class=\"comment\">// property，'.'号应与属性在同一行</span></span><br><span class=\"line\">        <span class=\"comment\">// object, '.' 号应与对象名在同一行</span></span><br><span class=\"line\">        <span class=\"string\">\"dot-location\"</span>: [<span class=\"number\">2</span>, <span class=\"string\">\"property\"</span>],</span><br><span class=\"line\">        <span class=\"comment\">// 强制使用. 号取属性</span></span><br><span class=\"line\">        <span class=\"comment\">// 参数： allowKeywords：true 使用保留字做属性名时，只能使用. 方式取属性</span></span><br><span class=\"line\">        <span class=\"comment\">// false 使用保留字做属性名时, 只能使用 [] 方式取属性 e.g [2, &#123;\"allowKeywords\": false&#125;]</span></span><br><span class=\"line\">        <span class=\"comment\">// allowPattern: 当属性名匹配提供的正则表达式时，允许使用 [] 方式取值, 否则只能用. 号取值 e.g [2, &#123;\"allowPattern\": \"^[a-z]+(_[a-z]+)+$\"&#125;]</span></span><br><span class=\"line\">        <span class=\"string\">\"dot-notation\"</span>: [<span class=\"number\">2</span>, &#123;</span><br><span class=\"line\">            <span class=\"string\">\"allowKeywords\"</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;],</span><br><span class=\"line\">        <span class=\"comment\">// 使用 === 替代 == allow-null 允许 null 和 undefined==</span></span><br><span class=\"line\">        <span class=\"string\">\"eqeqeq\"</span>: [<span class=\"number\">2</span>, <span class=\"string\">\"allow-null\"</span>],</span><br><span class=\"line\">        <span class=\"comment\">// 要求 for-in 循环中有一个 if 语句</span></span><br><span class=\"line\">        <span class=\"string\">\"guard-for-in\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁用 alert、confirm 和 prompt</span></span><br><span class=\"line\">        <span class=\"string\">\"no-alert\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁用 arguments.caller 或 arguments.callee</span></span><br><span class=\"line\">        <span class=\"string\">\"no-caller\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 不允许在 case 子句中使用词法声明</span></span><br><span class=\"line\">        <span class=\"string\">\"no-case-declarations\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止除法操作符显式的出现在正则表达式开始的位置</span></span><br><span class=\"line\">        <span class=\"string\">\"no-div-regex\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止 if 语句中有 return 之后有 else</span></span><br><span class=\"line\">        <span class=\"string\">\"no-else-return\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止出现空函数. 如果一个函数包含了一条注释，它将不会被认为有问题。</span></span><br><span class=\"line\">        <span class=\"string\">\"no-empty-function\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止使用空解构模式 no-empty-pattern</span></span><br><span class=\"line\">        <span class=\"string\">\"no-empty-pattern\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止在没有类型检查操作符的情况下与 null 进行比较</span></span><br><span class=\"line\">        <span class=\"string\">\"no-eq-null\"</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁用 eval()</span></span><br><span class=\"line\">        <span class=\"string\">\"no-eval\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止扩展原生类型</span></span><br><span class=\"line\">        <span class=\"string\">\"no-extend-native\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止不必要的 .bind() 调用</span></span><br><span class=\"line\">        <span class=\"string\">\"no-extra-bind\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁用不必要的标签</span></span><br><span class=\"line\">        <span class=\"string\">\"no-extra-label:\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止 case 语句落空</span></span><br><span class=\"line\">        <span class=\"string\">\"no-fallthrough\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止数字字面量中使用前导和末尾小数点</span></span><br><span class=\"line\">        <span class=\"string\">\"no-floating-decimal\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止使用短符号进行类型转换 (!!fOO)</span></span><br><span class=\"line\">        <span class=\"string\">\"no-implicit-coercion\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止在全局范围内使用 var 和命名的 function 声明</span></span><br><span class=\"line\">        <span class=\"string\">\"no-implicit-globals\"</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止使用类似 eval() 的方法</span></span><br><span class=\"line\">        <span class=\"string\">\"no-implied-eval\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止 this 关键字出现在类和类对象之外</span></span><br><span class=\"line\">        <span class=\"string\">\"no-invalid-this\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁用 __iterator__ 属性</span></span><br><span class=\"line\">        <span class=\"string\">\"no-iterator\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁用标签语句</span></span><br><span class=\"line\">        <span class=\"string\">\"no-labels\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁用不必要的嵌套块</span></span><br><span class=\"line\">        <span class=\"string\">\"no-lone-blocks\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止在循环中出现 function 声明和表达式</span></span><br><span class=\"line\">        <span class=\"string\">\"no-loop-func\"</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁用魔术数字 (3.14 什么的用常量代替)</span></span><br><span class=\"line\">        <span class=\"string\">\"no-magic-numbers\"</span>: [<span class=\"number\">1</span>, &#123;</span><br><span class=\"line\">            <span class=\"string\">\"ignore\"</span>: [<span class=\"number\">0</span>, <span class=\"number\">-1</span>, <span class=\"number\">1</span>]</span><br><span class=\"line\">        &#125;],</span><br><span class=\"line\">        <span class=\"comment\">// 禁止使用多个空格</span></span><br><span class=\"line\">        <span class=\"string\">\"no-multi-spaces\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止使用多行字符串，在 JavaScript 中，可以在新行之前使用斜线创建多行字符串</span></span><br><span class=\"line\">        <span class=\"string\">\"no-multi-str\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止对原生对象赋值</span></span><br><span class=\"line\">        <span class=\"string\">\"no-native-reassign\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止在非赋值或条件语句中使用 new 操作符</span></span><br><span class=\"line\">        <span class=\"string\">\"no-new\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止对 Function 对象使用 new 操作符</span></span><br><span class=\"line\">        <span class=\"string\">\"no-new-func\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止对 String，Number 和 Boolean 使用 new 操作符</span></span><br><span class=\"line\">        <span class=\"string\">\"no-new-wrappers\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁用八进制字面量</span></span><br><span class=\"line\">        <span class=\"string\">\"no-octal\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止在字符串中使用八进制转义序列</span></span><br><span class=\"line\">        <span class=\"string\">\"no-octal-escape\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 不允许对 function 的参数进行重新赋值</span></span><br><span class=\"line\">        <span class=\"string\">\"no-param-reassign\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁用 __proto__ 属性</span></span><br><span class=\"line\">        <span class=\"string\">\"no-proto\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止使用 var 多次声明同一变量</span></span><br><span class=\"line\">        <span class=\"string\">\"no-redeclare\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁用指定的通过 require 加载的模块</span></span><br><span class=\"line\">        <span class=\"string\">\"no-return-assign\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止使用 javascript: url</span></span><br><span class=\"line\">        <span class=\"string\">\"no-script-url\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止自我赋值</span></span><br><span class=\"line\">        <span class=\"string\">\"no-self-assign\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止自身比较</span></span><br><span class=\"line\">        <span class=\"string\">\"no-self-compare\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁用逗号操作符</span></span><br><span class=\"line\">        <span class=\"string\">\"no-sequences\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止抛出非异常字面量</span></span><br><span class=\"line\">        <span class=\"string\">\"no-throw-literal\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁用一成不变的循环条件</span></span><br><span class=\"line\">        <span class=\"string\">\"no-unmodified-loop-condition\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止出现未使用过的表达式</span></span><br><span class=\"line\">        <span class=\"string\">\"no-unused-expressions\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁用未使用过的标签</span></span><br><span class=\"line\">        <span class=\"string\">\"no-unused-labels\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止不必要的 .call() 和 .apply()</span></span><br><span class=\"line\">        <span class=\"string\">\"no-useless-call\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止不必要的字符串字面量或模板字面量的连接</span></span><br><span class=\"line\">        <span class=\"string\">\"no-useless-concat\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁用不必要的转义字符</span></span><br><span class=\"line\">        <span class=\"string\">\"no-useless-escape\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁用 void 操作符</span></span><br><span class=\"line\">        <span class=\"string\">\"no-void\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止在注释中使用特定的警告术语</span></span><br><span class=\"line\">        <span class=\"string\">\"no-warning-comments\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁用 with 语句</span></span><br><span class=\"line\">        <span class=\"string\">\"no-with\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 强制在 parseInt() 使用基数参数</span></span><br><span class=\"line\">        <span class=\"string\">\"radix\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 要求所有的 var 声明出现在它们所在的作用域顶部</span></span><br><span class=\"line\">        <span class=\"string\">\"vars-on-top\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 要求 IIFE 使用括号括起来</span></span><br><span class=\"line\">        <span class=\"string\">\"wrap-iife\"</span>: [<span class=\"number\">2</span>, <span class=\"string\">\"any\"</span>],</span><br><span class=\"line\">        <span class=\"comment\">// 要求或禁止 “Yoda” 条件</span></span><br><span class=\"line\">        <span class=\"string\">\"yoda\"</span>: [<span class=\"number\">2</span>, <span class=\"string\">\"never\"</span>],</span><br><span class=\"line\">        <span class=\"comment\">// 要求或禁止使用严格模式指令</span></span><br><span class=\"line\">        <span class=\"string\">\"strict\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//////////////</span></span><br><span class=\"line\">        <span class=\"comment\">// 变量声明 //</span></span><br><span class=\"line\">        <span class=\"comment\">//////////////</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 要求或禁止 var 声明中的初始化 (初值)</span></span><br><span class=\"line\">        <span class=\"string\">\"init-declarations\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 不允许 catch 子句的参数与外层作用域中的变量同名</span></span><br><span class=\"line\">        <span class=\"string\">\"no-catch-shadow\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止删除变量</span></span><br><span class=\"line\">        <span class=\"string\">\"no-delete-var\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 不允许标签与变量同名</span></span><br><span class=\"line\">        <span class=\"string\">\"no-label-var\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁用特定的全局变量</span></span><br><span class=\"line\">        <span class=\"string\">\"no-restricted-globals\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止 var 声明 与外层作用域的变量同名</span></span><br><span class=\"line\">        <span class=\"string\">\"no-shadow\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止覆盖受限制的标识符</span></span><br><span class=\"line\">        <span class=\"string\">\"no-shadow-restricted-names\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁用未声明的变量，除非它们在 /*global */ 注释中被提到</span></span><br><span class=\"line\">        <span class=\"string\">\"no-undef\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止将变量初始化为 undefined</span></span><br><span class=\"line\">        <span class=\"string\">\"no-undef-init\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止将 undefined 作为标识符</span></span><br><span class=\"line\">        <span class=\"string\">\"no-undefined\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止出现未使用过的变量</span></span><br><span class=\"line\">        <span class=\"string\">\"no-unused-vars\"</span>: [<span class=\"number\">2</span>, &#123;</span><br><span class=\"line\">            <span class=\"string\">\"vars\"</span>: <span class=\"string\">\"all\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"args\"</span>: <span class=\"string\">\"none\"</span></span><br><span class=\"line\">        &#125;],</span><br><span class=\"line\">        <span class=\"comment\">// 不允许在变量定义之前使用它们</span></span><br><span class=\"line\">        <span class=\"string\">\"no-use-before-define\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//////////////////////////</span></span><br><span class=\"line\">        <span class=\"comment\">// Node.js and CommonJS //</span></span><br><span class=\"line\">        <span class=\"comment\">//////////////////////////</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// require return statements after callbacks</span></span><br><span class=\"line\">        <span class=\"string\">\"callback-return\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 要求 require() 出现在顶层模块作用域中</span></span><br><span class=\"line\">        <span class=\"string\">\"global-require\"</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 要求回调函数中有容错处理</span></span><br><span class=\"line\">        <span class=\"string\">\"handle-callback-err\"</span>: [<span class=\"number\">2</span>, <span class=\"string\">\"^(err|error)$\"</span>],</span><br><span class=\"line\">        <span class=\"comment\">// 禁止混合常规 var 声明和 require 调用</span></span><br><span class=\"line\">        <span class=\"string\">\"no-mixed-requires\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止调用 require 时使用 new 操作符</span></span><br><span class=\"line\">        <span class=\"string\">\"no-new-require\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止对 __dirname 和 __filename 进行字符串连接</span></span><br><span class=\"line\">        <span class=\"string\">\"no-path-concat\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁用 process.env</span></span><br><span class=\"line\">        <span class=\"string\">\"no-process-env\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁用 process.exit()</span></span><br><span class=\"line\">        <span class=\"string\">\"no-process-exit\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁用同步方法</span></span><br><span class=\"line\">        <span class=\"string\">\"no-sync\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//////////////</span></span><br><span class=\"line\">        <span class=\"comment\">// 风格指南 //</span></span><br><span class=\"line\">        <span class=\"comment\">//////////////</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 指定数组的元素之间要以空格隔开 (, 后面)， never 参数：[ 之前和 ] 之后不能带空格，always 参数：[ 之前和 ] 之后必须带空格</span></span><br><span class=\"line\">        <span class=\"string\">\"array-bracket-spacing\"</span>: [<span class=\"number\">2</span>, <span class=\"string\">\"never\"</span>],</span><br><span class=\"line\">        <span class=\"comment\">// 禁止或强制在单行代码块中使用空格 (禁用)</span></span><br><span class=\"line\">        <span class=\"string\">\"block-spacing\"</span>: [<span class=\"number\">1</span>, <span class=\"string\">\"never\"</span>],</span><br><span class=\"line\">        <span class=\"comment\">// 强制使用一致的缩进 第二个参数为 \"tab\" 时，会使用 tab，</span></span><br><span class=\"line\">        <span class=\"comment\">// if while function 后面的 &#123;必须与 if 在同一行，java 风格。</span></span><br><span class=\"line\">        <span class=\"string\">\"brace-style\"</span>: [<span class=\"number\">2</span>, <span class=\"string\">\"1tbs\"</span>, &#123;</span><br><span class=\"line\">            <span class=\"string\">\"allowSingleLine\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;],</span><br><span class=\"line\">        <span class=\"comment\">// 双峰驼命名格式</span></span><br><span class=\"line\">        <span class=\"string\">\"camelcase\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 控制逗号前后的空格</span></span><br><span class=\"line\">        <span class=\"string\">\"comma-spacing\"</span>: [<span class=\"number\">2</span>, &#123;</span><br><span class=\"line\">            <span class=\"string\">\"before\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">            <span class=\"string\">\"after\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;],</span><br><span class=\"line\">        <span class=\"comment\">// 控制逗号在行尾出现还是在行首出现 (默认行尾)</span></span><br><span class=\"line\">        <span class=\"comment\">// http://eslint.org/docs/rules/comma-style</span></span><br><span class=\"line\">        <span class=\"string\">\"comma-style\"</span>: [<span class=\"number\">2</span>, <span class=\"string\">\"last\"</span>],</span><br><span class=\"line\">        <span class=\"comment\">//\"SwitchCase\" (默认：0) 强制 switch 语句中的 case 子句的缩进水平</span></span><br><span class=\"line\">        <span class=\"comment\">// 以方括号取对象属性时，[后面和] 前面是否需要空格, 可选参数 never, always</span></span><br><span class=\"line\">        <span class=\"string\">\"computed-property-spacing\"</span>: [<span class=\"number\">2</span>, <span class=\"string\">\"never\"</span>],</span><br><span class=\"line\">        <span class=\"comment\">// 用于指统一在回调函数中指向 this 的变量名，箭头函数中的 this 已经可以指向外层调用者，应该没卵用了</span></span><br><span class=\"line\">        <span class=\"comment\">// e.g [0,\"that\"] 指定只能 var that = this. that 不能指向其他任何值，this 也不能赋值给 that 以外的其他值</span></span><br><span class=\"line\">        <span class=\"string\">\"consistent-this\"</span>: [<span class=\"number\">1</span>, <span class=\"string\">\"that\"</span>],</span><br><span class=\"line\">        <span class=\"comment\">// 强制使用命名的 function 表达式</span></span><br><span class=\"line\">        <span class=\"string\">\"func-names\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 文件末尾强制换行</span></span><br><span class=\"line\">        <span class=\"string\">\"eol-last\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"string\">\"indent\"</span>: [<span class=\"number\">2</span>, <span class=\"number\">4</span>, &#123;</span><br><span class=\"line\">            <span class=\"string\">\"SwitchCase\"</span>: <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;],</span><br><span class=\"line\">        <span class=\"comment\">// 强制在对象字面量的属性中键和值之间使用一致的间距</span></span><br><span class=\"line\">        <span class=\"string\">\"key-spacing\"</span>: [<span class=\"number\">2</span>, &#123;</span><br><span class=\"line\">            <span class=\"string\">\"beforeColon\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">            <span class=\"string\">\"afterColon\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;],</span><br><span class=\"line\">        <span class=\"comment\">// 强制使用一致的换行风格</span></span><br><span class=\"line\">        <span class=\"string\">\"linebreak-style\"</span>: [<span class=\"number\">1</span>, <span class=\"string\">\"unix\"</span>],</span><br><span class=\"line\">        <span class=\"comment\">// 要求在注释周围有空行 (要求在块级注释之前有一空行)</span></span><br><span class=\"line\">        <span class=\"string\">\"lines-around-comment\"</span>: [<span class=\"number\">1</span>, &#123;</span><br><span class=\"line\">            <span class=\"string\">\"beforeBlockComment\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;],</span><br><span class=\"line\">        <span class=\"comment\">// 强制一致地使用函数声明或函数表达式，方法定义风格，参数：</span></span><br><span class=\"line\">        <span class=\"comment\">// declaration: 强制使用方法声明的方式，function f()&#123;&#125; e.g [2, \"declaration\"]</span></span><br><span class=\"line\">        <span class=\"comment\">// expression：强制使用方法表达式的方式，var f = function() &#123;&#125; e.g [2, \"expression\"]</span></span><br><span class=\"line\">        <span class=\"comment\">// allowArrowFunctions: declaration 风格中允许箭头函数。 e.g [2, \"declaration\", &#123; \"allowArrowFunctions\": true&#125;]</span></span><br><span class=\"line\">        <span class=\"string\">\"func-style\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 强制回调函数最大嵌套深度 5 层</span></span><br><span class=\"line\">        <span class=\"string\">\"max-nested-callbacks\"</span>: [<span class=\"number\">1</span>, <span class=\"number\">5</span>],</span><br><span class=\"line\">        <span class=\"comment\">// 禁止使用指定的标识符</span></span><br><span class=\"line\">        <span class=\"string\">\"id-blacklist\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 强制标识符的最新和最大长度</span></span><br><span class=\"line\">        <span class=\"string\">\"id-length\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 要求标识符匹配一个指定的正则表达式</span></span><br><span class=\"line\">        <span class=\"string\">\"id-match\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 强制在 JSX 属性中一致地使用双引号或单引号</span></span><br><span class=\"line\">        <span class=\"string\">\"jsx-quotes\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 强制在关键字前后使用一致的空格 (前后腰需要)</span></span><br><span class=\"line\">        <span class=\"string\">\"keyword-spacing\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 强制一行的最大长度</span></span><br><span class=\"line\">        <span class=\"string\">\"max-len\"</span>: [<span class=\"number\">1</span>, <span class=\"number\">200</span>],</span><br><span class=\"line\">        <span class=\"comment\">// 强制最大行数</span></span><br><span class=\"line\">        <span class=\"string\">\"max-lines\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 强制 function 定义中最多允许的参数数量</span></span><br><span class=\"line\">        <span class=\"string\">\"max-params\"</span>: [<span class=\"number\">1</span>, <span class=\"number\">7</span>],</span><br><span class=\"line\">        <span class=\"comment\">// 强制 function 块最多允许的的语句数量</span></span><br><span class=\"line\">        <span class=\"string\">\"max-statements\"</span>: [<span class=\"number\">1</span>, <span class=\"number\">200</span>],</span><br><span class=\"line\">        <span class=\"comment\">// 强制每一行中所允许的最大语句数量</span></span><br><span class=\"line\">        <span class=\"string\">\"max-statements-per-line\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 要求构造函数首字母大写 （要求调用 new 操作符时有首字母大小的函数，允许调用首字母大写的函数时没有 new 操作符。）</span></span><br><span class=\"line\">        <span class=\"string\">\"new-cap\"</span>: [<span class=\"number\">2</span>, &#123;</span><br><span class=\"line\">            <span class=\"string\">\"newIsCap\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            <span class=\"string\">\"capIsNew\"</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;],</span><br><span class=\"line\">        <span class=\"comment\">// 要求调用无参构造函数时有圆括号</span></span><br><span class=\"line\">        <span class=\"string\">\"new-parens\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 要求或禁止 var 声明语句后有一行空行</span></span><br><span class=\"line\">        <span class=\"string\">\"newline-after-var\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止使用 Array 构造函数</span></span><br><span class=\"line\">        <span class=\"string\">\"no-array-constructor\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁用按位运算符</span></span><br><span class=\"line\">        <span class=\"string\">\"no-bitwise\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 要求 return 语句之前有一空行</span></span><br><span class=\"line\">        <span class=\"string\">\"newline-before-return\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 要求方法链中每个调用都有一个换行符</span></span><br><span class=\"line\">        <span class=\"string\">\"newline-per-chained-call\"</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁用 continue 语句</span></span><br><span class=\"line\">        <span class=\"string\">\"no-continue\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止在代码行后使用内联注释</span></span><br><span class=\"line\">        <span class=\"string\">\"no-inline-comments\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止 if 作为唯一的语句出现在 else 语句中</span></span><br><span class=\"line\">        <span class=\"string\">\"no-lonely-if\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止混合使用不同的操作符</span></span><br><span class=\"line\">        <span class=\"string\">\"no-mixed-operators\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 不允许空格和 tab 混合缩进</span></span><br><span class=\"line\">        <span class=\"string\">\"no-mixed-spaces-and-tabs\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 不允许多个空行</span></span><br><span class=\"line\">        <span class=\"string\">\"no-multiple-empty-lines\"</span>: [<span class=\"number\">2</span>, &#123;</span><br><span class=\"line\">            <span class=\"string\">\"max\"</span>: <span class=\"number\">2</span></span><br><span class=\"line\">        &#125;],</span><br><span class=\"line\">        <span class=\"comment\">// 不允许否定的表达式</span></span><br><span class=\"line\">        <span class=\"string\">\"no-negated-condition\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 不允许使用嵌套的三元表达式</span></span><br><span class=\"line\">        <span class=\"string\">\"no-nested-ternary\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止使用 Object 的构造函数</span></span><br><span class=\"line\">        <span class=\"string\">\"no-new-object\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止使用一元操作符 ++ 和 --</span></span><br><span class=\"line\">        <span class=\"string\">\"no-plusplus\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止使用特定的语法</span></span><br><span class=\"line\">        <span class=\"string\">\"no-restricted-syntax\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止 function 标识符和括号之间出现空格</span></span><br><span class=\"line\">        <span class=\"string\">\"no-spaced-func\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 不允许使用三元操作符</span></span><br><span class=\"line\">        <span class=\"string\">\"no-ternary\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁用行尾空格</span></span><br><span class=\"line\">        <span class=\"string\">\"no-trailing-spaces\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止标识符中有悬空下划线_bar</span></span><br><span class=\"line\">        <span class=\"string\">\"no-underscore-dangle\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止可以在有更简单的可替代的表达式时使用三元操作符</span></span><br><span class=\"line\">        <span class=\"string\">\"no-unneeded-ternary\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止属性前有空白</span></span><br><span class=\"line\">        <span class=\"string\">\"no-whitespace-before-property\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 强制花括号内换行符的一致性</span></span><br><span class=\"line\">        <span class=\"string\">\"object-curly-newline\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 强制在花括号中使用一致的空格</span></span><br><span class=\"line\">        <span class=\"string\">\"object-curly-spacing\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 强制将对象的属性放在不同的行上</span></span><br><span class=\"line\">        <span class=\"string\">\"object-property-newline\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 强制函数中的变量要么一起声明要么分开声明</span></span><br><span class=\"line\">        <span class=\"string\">\"one-var\"</span>: [<span class=\"number\">2</span>, &#123;</span><br><span class=\"line\">            <span class=\"string\">\"initialized\"</span>: <span class=\"string\">\"never\"</span></span><br><span class=\"line\">        &#125;],</span><br><span class=\"line\">        <span class=\"comment\">// 要求或禁止在 var 声明周围换行</span></span><br><span class=\"line\">        <span class=\"string\">\"one-var-declaration-per-line\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 要求或禁止在可能的情况下要求使用简化的赋值操作符</span></span><br><span class=\"line\">        <span class=\"string\">\"operator-assignment\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 强制操作符使用一致的换行符</span></span><br><span class=\"line\">        <span class=\"string\">\"operator-linebreak\"</span>: [<span class=\"number\">2</span>, <span class=\"string\">\"after\"</span>, &#123;</span><br><span class=\"line\">            <span class=\"string\">\"overrides\"</span>: &#123;</span><br><span class=\"line\">                <span class=\"string\">\"?\"</span>: <span class=\"string\">\"before\"</span>,</span><br><span class=\"line\">                <span class=\"string\">\":\"</span>: <span class=\"string\">\"before\"</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;],</span><br><span class=\"line\">        <span class=\"comment\">// 要求或禁止块内填充</span></span><br><span class=\"line\">        <span class=\"string\">\"padded-blocks\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 要求对象字面量属性名称用引号括起来</span></span><br><span class=\"line\">        <span class=\"string\">\"quote-props\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 强制使用一致的反勾号、双引号或单引号</span></span><br><span class=\"line\">        <span class=\"string\">\"quotes\"</span>: [<span class=\"number\">2</span>, <span class=\"string\">\"double\"</span>, <span class=\"string\">\"avoid-escape\"</span>],</span><br><span class=\"line\">        <span class=\"comment\">// 要求使用 JSDoc 注释</span></span><br><span class=\"line\">        <span class=\"string\">\"require-jsdoc\"</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 要求或禁止使用分号而不是 ASI（这个才是控制行尾部分号的，）</span></span><br><span class=\"line\">        <span class=\"string\">\"semi\"</span>: [<span class=\"number\">2</span>, <span class=\"string\">\"always\"</span>],</span><br><span class=\"line\">        <span class=\"comment\">// 强制分号之前和之后使用一致的空格</span></span><br><span class=\"line\">        <span class=\"string\">\"semi-spacing\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 要求同一个声明块中的变量按顺序排列</span></span><br><span class=\"line\">        <span class=\"string\">\"sort-vars\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 强制在块之前使用一致的空格</span></span><br><span class=\"line\">        <span class=\"string\">\"space-before-blocks\"</span>: [<span class=\"number\">2</span>, <span class=\"string\">\"always\"</span>],</span><br><span class=\"line\">        <span class=\"comment\">// 强制在 function 的左括号之前使用一致的空格</span></span><br><span class=\"line\">        <span class=\"string\">\"space-before-function-paren\"</span>: [<span class=\"number\">0</span>, <span class=\"string\">\"always\"</span>],</span><br><span class=\"line\">        <span class=\"comment\">// 强制在圆括号内使用一致的空格</span></span><br><span class=\"line\">        <span class=\"string\">\"space-in-parens\"</span>: [<span class=\"number\">2</span>, <span class=\"string\">\"never\"</span>],</span><br><span class=\"line\">        <span class=\"comment\">// 要求操作符周围有空格</span></span><br><span class=\"line\">        <span class=\"string\">\"space-infix-ops\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 强制在一元操作符前后使用一致的空格</span></span><br><span class=\"line\">        <span class=\"string\">\"space-unary-ops\"</span>: [<span class=\"number\">2</span>, &#123;</span><br><span class=\"line\">            <span class=\"string\">\"words\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            <span class=\"string\">\"nonwords\"</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;],</span><br><span class=\"line\">        <span class=\"comment\">// 强制在注释中 // 或 /* 使用一致的空格</span></span><br><span class=\"line\">        <span class=\"string\">\"spaced-comment\"</span>: [<span class=\"number\">2</span>, <span class=\"string\">\"always\"</span>, &#123;</span><br><span class=\"line\">            <span class=\"string\">\"markers\"</span>: [<span class=\"string\">\"global\"</span>, <span class=\"string\">\"globals\"</span>, <span class=\"string\">\"eslint\"</span>, <span class=\"string\">\"eslint-disable\"</span>, <span class=\"string\">\"*package\"</span>, <span class=\"string\">\"!\"</span>]</span><br><span class=\"line\">        &#125;],</span><br><span class=\"line\">        <span class=\"comment\">// 要求或禁止 Unicode BOM</span></span><br><span class=\"line\">        <span class=\"string\">\"unicode-bom\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 要求正则表达式被括号括起来</span></span><br><span class=\"line\">        <span class=\"string\">\"wrap-regex\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//////////////</span></span><br><span class=\"line\">        <span class=\"comment\">// ES6. 相关 //</span></span><br><span class=\"line\">        <span class=\"comment\">//////////////</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 要求箭头函数体使用大括号</span></span><br><span class=\"line\">        <span class=\"string\">\"arrow-body-style\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 要求箭头函数的参数使用圆括号</span></span><br><span class=\"line\">        <span class=\"string\">\"arrow-parens\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"string\">\"arrow-spacing\"</span>: [<span class=\"number\">2</span>, &#123;</span><br><span class=\"line\">            <span class=\"string\">\"before\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            <span class=\"string\">\"after\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;],</span><br><span class=\"line\">        <span class=\"comment\">// 强制在子类构造函数中用 super() 调用父类构造函数，TypeScrip 的编译器也会提示</span></span><br><span class=\"line\">        <span class=\"string\">\"constructor-super\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 强制 generator 函数中 * 号周围使用一致的空格</span></span><br><span class=\"line\">        <span class=\"string\">\"generator-star-spacing\"</span>: [<span class=\"number\">2</span>, &#123;</span><br><span class=\"line\">            <span class=\"string\">\"before\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            <span class=\"string\">\"after\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;],</span><br><span class=\"line\">        <span class=\"comment\">// 禁止修改类声明的变量</span></span><br><span class=\"line\">        <span class=\"string\">\"no-class-assign\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 不允许箭头功能，在那里他们可以混淆的比较</span></span><br><span class=\"line\">        <span class=\"string\">\"no-confusing-arrow\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止修改 const 声明的变量</span></span><br><span class=\"line\">        <span class=\"string\">\"no-const-assign\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止类成员中出现重复的名称</span></span><br><span class=\"line\">        <span class=\"string\">\"no-dupe-class-members\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 不允许复制模块的进口</span></span><br><span class=\"line\">        <span class=\"string\">\"no-duplicate-imports\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止 Symbol 的构造函数</span></span><br><span class=\"line\">        <span class=\"string\">\"no-new-symbol\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 允许指定模块加载时的进口</span></span><br><span class=\"line\">        <span class=\"string\">\"no-restricted-imports\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止在构造函数中，在调用 super() 之前使用 this 或 super</span></span><br><span class=\"line\">        <span class=\"string\">\"no-this-before-super\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止不必要的计算性能键对象的文字</span></span><br><span class=\"line\">        <span class=\"string\">\"no-useless-computed-key\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 要求使用 let 或 const 而不是 var</span></span><br><span class=\"line\">        <span class=\"string\">\"no-var\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 要求或禁止对象字面量中方法和属性使用简写语法</span></span><br><span class=\"line\">        <span class=\"string\">\"object-shorthand\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 要求使用箭头函数作为回调</span></span><br><span class=\"line\">        <span class=\"string\">\"prefer-arrow-callback\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 要求使用 const 声明那些声明后不再被修改的变量</span></span><br><span class=\"line\">        <span class=\"string\">\"prefer-const\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 要求在合适的地方使用 Reflect 方法</span></span><br><span class=\"line\">        <span class=\"string\">\"prefer-reflect\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 要求使用扩展运算符而非 .apply()</span></span><br><span class=\"line\">        <span class=\"string\">\"prefer-spread\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 要求使用模板字面量而非字符串连接</span></span><br><span class=\"line\">        <span class=\"string\">\"prefer-template\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// Suggest using the rest parameters instead of arguments</span></span><br><span class=\"line\">        <span class=\"string\">\"prefer-rest-params\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 要求 generator 函数内有 yield</span></span><br><span class=\"line\">        <span class=\"string\">\"require-yield\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// enforce spacing between rest and spread operators and their expressions</span></span><br><span class=\"line\">        <span class=\"string\">\"rest-spread-spacing\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 强制模块内的 import 排序</span></span><br><span class=\"line\">        <span class=\"string\">\"sort-imports\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 要求或禁止模板字符串中的嵌入表达式周围空格的使用</span></span><br><span class=\"line\">        <span class=\"string\">\"template-curly-spacing\"</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 强制在 yield* 表达式中 * 周围使用空格</span></span><br><span class=\"line\">        <span class=\"string\">\"yield-star-spacing\"</span>: <span class=\"number\">2</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>这篇文章我从几个方面来介绍我是如何配置开发环境的，尽可能使代码编写风格统一。其实不光是代码，包括日常文字，都有很多规范。比如最常见的中英文之间添加空格，可能很多人并没有在意。但是看到别人的文章里出现这样的问题，肯定是要减印象分的。</p>","more":"<p>因为我日常使用 <strong>VSCode</strong>，所以这里相关配置都以这个展开。</p>\n<h3 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h3><ul>\n<li><a href=\"https://marketplace.visualstudio.com/items?itemName=EditorConfig.EditorConfig\" target=\"_blank\" rel=\"noopener\">EditorConfig for VS Code</a></li>\n<li><a href=\"https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint\" target=\"_blank\" rel=\"noopener\">ESLint</a></li>\n<li><a href=\"https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode\" target=\"_blank\" rel=\"noopener\">Prettier - Code formatter</a></li>\n<li><a href=\"https://marketplace.visualstudio.com/items?itemName=baurine.vscode-pangu\" target=\"_blank\" rel=\"noopener\">VSCode-Pangu</a></li>\n<li><a href=\"https://marketplace.visualstudio.com/items?itemName=streetsidesoftware.code-spell-checker\" target=\"_blank\" rel=\"noopener\">Code Spell Checker</a></li>\n<li><a href=\"https://marketplace.visualstudio.com/items?itemName=oderwat.indent-rainbow\" target=\"_blank\" rel=\"noopener\">Indent-Rainbow</a></li>\n</ul>\n<p>下面来我简单介绍一下每个插件的功能。</p>\n<ul>\n<li>EditorConfig：生成 <code>.editorconfig</code> 配置文件，规定当前编辑器的一些设定。</li>\n<li>ESLint：集成 Eslint 到 VSCode，具体看 Eslint 的官方文档。</li>\n<li>Prettier：Eslint 侧重于静态校验，而 Prettier 则负责按照一些规则美化代码。</li>\n<li>VSCode-Pangu：自动在中英文之间添加空格。</li>\n<li>Code Spell Checker：单词拼写检查。</li>\n<li>Indent-Rainbow：彩虹缩进，缩进不规范时会标红提示。</li>\n</ul>\n<h3 id=\"偏好\"><a href=\"#偏好\" class=\"headerlink\" title=\"偏好\"></a>偏好</h3><h4 id=\"VSCode-Settings\"><a href=\"#VSCode-Settings\" class=\"headerlink\" title=\"VSCode Settings\"></a>VSCode Settings</h4><p>安装插件：ESLint、Prettier 后，在 settings 配置下面的选项，即可实现保存时自动格式化：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 开启保存自动格式化，调用 Prettier 时自动 eslint -fix</span></span><br><span class=\"line\">  <span class=\"string\">\"editor.formatOnSave\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  <span class=\"comment\">// 不需要 fix 了，Prettier 会自动 fix</span></span><br><span class=\"line\">  <span class=\"string\">\"eslint.autoFixOnSave\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  <span class=\"comment\">// 告诉 Prettier 使用 `prettier-eslint` 来代替 Prettier</span></span><br><span class=\"line\">  <span class=\"string\">\"prettier.eslintIntegration\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Lint\"><a href=\"#Lint\" class=\"headerlink\" title=\"Lint\"></a>Lint</h3><h4 id=\"使用-Prettier-按照-Eslint-美化代码\"><a href=\"#使用-Prettier-按照-Eslint-美化代码\" class=\"headerlink\" title=\"使用 Prettier 按照 Eslint 美化代码\"></a>使用 Prettier 按照 Eslint 美化代码</h4><ul>\n<li>安装 <code>prettier-eslint-cli</code></li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i prettier-eslint-cli --save-dev</span><br></pre></td></tr></table></figure>\n<ul>\n<li>配置 <code>prettier</code>，在 <code>package.json</code> 添加</li>\n</ul>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"lint\"</span>: <span class=\"string\">\"eslint *.js\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"format\"</span>: <span class=\"string\">\"prettier-eslint --write *.js\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">\"eslintConfig\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"extends\"</span>: <span class=\"string\">\"some-config\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">\"prettier\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"singleQuote\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"semi\"</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>经过上面配置后，编辑器就可以在保存文件时，自动按照 Eslint 格式化。</p>\n<h4 id=\"使用-Standard-规范\"><a href=\"#使用-Standard-规范\" class=\"headerlink\" title=\"使用 Standard 规范\"></a>使用 Standard 规范</h4><p><a href=\"https://github.com/standard\" target=\"_blank\" rel=\"noopener\">Standard</a> 其实并不是标准组织出的规范，但是行业内使用的比较多。看来看去，好像各种各样的约定都没有一个标准。我看了一下，目前来说 <code>standard</code> 还算有影响力。打算以后在个人项目中全部采用这种风格，然后把剩下的时间去做点有意义的事。配置一堆 <code>.eslintrc</code> <code>.jscsrc</code> <code>.jshintrc</code> 真的很头疼。</p>\n<p>☝️ <strong>初始化新项目</strong></p>\n<ul>\n<li>安装依赖</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install eslint \\</span><br><span class=\"line\">    eslint-config-standard \\</span><br><span class=\"line\">    eslint-plugin-standard \\</span><br><span class=\"line\">    eslint-plugin-promise \\</span><br><span class=\"line\">    eslint-plugin-import \\</span><br><span class=\"line\">    eslint-plugin-node \\</span><br><span class=\"line\">    eslint-plugin-markdown \\</span><br><span class=\"line\">    --save-dev</span><br></pre></td></tr></table></figure>\n<ul>\n<li>添加 <code>.eslintrc</code></li>\n</ul>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"extends\"</span>: <span class=\"string\">\"standard\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>OK，现在让 Eslint 按照 standard 的规则来约束了，还可以使用另外的规则来覆盖。</p>\n<p>☝️ <strong>全局使用</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 全局安装</span></span><br><span class=\"line\">$ npm i standard -g</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 校验目录下 *.js/*.jsx</span></span><br><span class=\"line\">$ standard</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 修复</span></span><br><span class=\"line\">$ standard --fix</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>以后的新项目我会采用 Standard 作为约束规范，对于已有项目我使用 Prettier 自动按照 Eslint 规则自动美化，日常一些代码片段使用 Standard 全局命令，简单实用。</p>\n<p>参考以下文档。</p>\n<ul>\n<li><a href=\"https://github.com/standard/standard/blob/master/docs/README-zhcn.md\" target=\"_blank\" rel=\"noopener\">standard/standard @Github</a></li>\n<li><a href=\"https://github.com/standard/eslint-config-standard\" target=\"_blank\" rel=\"noopener\">standard/eslint-config-standard @Github</a></li>\n<li><a href=\"https://github.com/expressjs/body-parser\" target=\"_blank\" rel=\"noopener\">Standard Style Demo @Github</a></li>\n<li><a href=\"https://cn.eslint.org/\" target=\"_blank\" rel=\"noopener\">ESLint @中文官网</a></li>\n<li><a href=\"https://egoist.moe/2017/12/11/write-better-code-with-eslint-and-prettier/\" target=\"_blank\" rel=\"noopener\">用 ESLint 和 Prettier 写出高质量代码 @EGOIST</a></li>\n</ul>\n<h3 id=\"附：Eslint-规则\"><a href=\"#附：Eslint-规则\" class=\"headerlink\" title=\"附：Eslint 规则\"></a>附：Eslint 规则</h3><h4 id=\"关闭校验\"><a href=\"#关闭校验\" class=\"headerlink\" title=\"关闭校验\"></a>关闭校验</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 关闭当前文件</span></span><br><span class=\"line\"><span class=\"comment\">/* eslint-disable */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 关闭当前行校验</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">1</span>; <span class=\"comment\">// eslint-disable-line</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 关闭下一行校验</span></span><br><span class=\"line\"><span class=\"comment\">// eslint-disable-next-line</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"详细规则\"><a href=\"#详细规则\" class=\"headerlink\" title=\"详细规则\"></a>详细规则</h4><ul>\n<li>0：关闭</li>\n<li>1：警告，仅给出警告</li>\n<li>2：错误，停止执行</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br><span class=\"line\">322</span><br><span class=\"line\">323</span><br><span class=\"line\">324</span><br><span class=\"line\">325</span><br><span class=\"line\">326</span><br><span class=\"line\">327</span><br><span class=\"line\">328</span><br><span class=\"line\">329</span><br><span class=\"line\">330</span><br><span class=\"line\">331</span><br><span class=\"line\">332</span><br><span class=\"line\">333</span><br><span class=\"line\">334</span><br><span class=\"line\">335</span><br><span class=\"line\">336</span><br><span class=\"line\">337</span><br><span class=\"line\">338</span><br><span class=\"line\">339</span><br><span class=\"line\">340</span><br><span class=\"line\">341</span><br><span class=\"line\">342</span><br><span class=\"line\">343</span><br><span class=\"line\">344</span><br><span class=\"line\">345</span><br><span class=\"line\">346</span><br><span class=\"line\">347</span><br><span class=\"line\">348</span><br><span class=\"line\">349</span><br><span class=\"line\">350</span><br><span class=\"line\">351</span><br><span class=\"line\">352</span><br><span class=\"line\">353</span><br><span class=\"line\">354</span><br><span class=\"line\">355</span><br><span class=\"line\">356</span><br><span class=\"line\">357</span><br><span class=\"line\">358</span><br><span class=\"line\">359</span><br><span class=\"line\">360</span><br><span class=\"line\">361</span><br><span class=\"line\">362</span><br><span class=\"line\">363</span><br><span class=\"line\">364</span><br><span class=\"line\">365</span><br><span class=\"line\">366</span><br><span class=\"line\">367</span><br><span class=\"line\">368</span><br><span class=\"line\">369</span><br><span class=\"line\">370</span><br><span class=\"line\">371</span><br><span class=\"line\">372</span><br><span class=\"line\">373</span><br><span class=\"line\">374</span><br><span class=\"line\">375</span><br><span class=\"line\">376</span><br><span class=\"line\">377</span><br><span class=\"line\">378</span><br><span class=\"line\">379</span><br><span class=\"line\">380</span><br><span class=\"line\">381</span><br><span class=\"line\">382</span><br><span class=\"line\">383</span><br><span class=\"line\">384</span><br><span class=\"line\">385</span><br><span class=\"line\">386</span><br><span class=\"line\">387</span><br><span class=\"line\">388</span><br><span class=\"line\">389</span><br><span class=\"line\">390</span><br><span class=\"line\">391</span><br><span class=\"line\">392</span><br><span class=\"line\">393</span><br><span class=\"line\">394</span><br><span class=\"line\">395</span><br><span class=\"line\">396</span><br><span class=\"line\">397</span><br><span class=\"line\">398</span><br><span class=\"line\">399</span><br><span class=\"line\">400</span><br><span class=\"line\">401</span><br><span class=\"line\">402</span><br><span class=\"line\">403</span><br><span class=\"line\">404</span><br><span class=\"line\">405</span><br><span class=\"line\">406</span><br><span class=\"line\">407</span><br><span class=\"line\">408</span><br><span class=\"line\">409</span><br><span class=\"line\">410</span><br><span class=\"line\">411</span><br><span class=\"line\">412</span><br><span class=\"line\">413</span><br><span class=\"line\">414</span><br><span class=\"line\">415</span><br><span class=\"line\">416</span><br><span class=\"line\">417</span><br><span class=\"line\">418</span><br><span class=\"line\">419</span><br><span class=\"line\">420</span><br><span class=\"line\">421</span><br><span class=\"line\">422</span><br><span class=\"line\">423</span><br><span class=\"line\">424</span><br><span class=\"line\">425</span><br><span class=\"line\">426</span><br><span class=\"line\">427</span><br><span class=\"line\">428</span><br><span class=\"line\">429</span><br><span class=\"line\">430</span><br><span class=\"line\">431</span><br><span class=\"line\">432</span><br><span class=\"line\">433</span><br><span class=\"line\">434</span><br><span class=\"line\">435</span><br><span class=\"line\">436</span><br><span class=\"line\">437</span><br><span class=\"line\">438</span><br><span class=\"line\">439</span><br><span class=\"line\">440</span><br><span class=\"line\">441</span><br><span class=\"line\">442</span><br><span class=\"line\">443</span><br><span class=\"line\">444</span><br><span class=\"line\">445</span><br><span class=\"line\">446</span><br><span class=\"line\">447</span><br><span class=\"line\">448</span><br><span class=\"line\">449</span><br><span class=\"line\">450</span><br><span class=\"line\">451</span><br><span class=\"line\">452</span><br><span class=\"line\">453</span><br><span class=\"line\">454</span><br><span class=\"line\">455</span><br><span class=\"line\">456</span><br><span class=\"line\">457</span><br><span class=\"line\">458</span><br><span class=\"line\">459</span><br><span class=\"line\">460</span><br><span class=\"line\">461</span><br><span class=\"line\">462</span><br><span class=\"line\">463</span><br><span class=\"line\">464</span><br><span class=\"line\">465</span><br><span class=\"line\">466</span><br><span class=\"line\">467</span><br><span class=\"line\">468</span><br><span class=\"line\">469</span><br><span class=\"line\">470</span><br><span class=\"line\">471</span><br><span class=\"line\">472</span><br><span class=\"line\">473</span><br><span class=\"line\">474</span><br><span class=\"line\">475</span><br><span class=\"line\">476</span><br><span class=\"line\">477</span><br><span class=\"line\">478</span><br><span class=\"line\">479</span><br><span class=\"line\">480</span><br><span class=\"line\">481</span><br><span class=\"line\">482</span><br><span class=\"line\">483</span><br><span class=\"line\">484</span><br><span class=\"line\">485</span><br><span class=\"line\">486</span><br><span class=\"line\">487</span><br><span class=\"line\">488</span><br><span class=\"line\">489</span><br><span class=\"line\">490</span><br><span class=\"line\">491</span><br><span class=\"line\">492</span><br><span class=\"line\">493</span><br><span class=\"line\">494</span><br><span class=\"line\">495</span><br><span class=\"line\">496</span><br><span class=\"line\">497</span><br><span class=\"line\">498</span><br><span class=\"line\">499</span><br><span class=\"line\">500</span><br><span class=\"line\">501</span><br><span class=\"line\">502</span><br><span class=\"line\">503</span><br><span class=\"line\">504</span><br><span class=\"line\">505</span><br><span class=\"line\">506</span><br><span class=\"line\">507</span><br><span class=\"line\">508</span><br><span class=\"line\">509</span><br><span class=\"line\">510</span><br><span class=\"line\">511</span><br><span class=\"line\">512</span><br><span class=\"line\">513</span><br><span class=\"line\">514</span><br><span class=\"line\">515</span><br><span class=\"line\">516</span><br><span class=\"line\">517</span><br><span class=\"line\">518</span><br><span class=\"line\">519</span><br><span class=\"line\">520</span><br><span class=\"line\">521</span><br><span class=\"line\">522</span><br><span class=\"line\">523</span><br><span class=\"line\">524</span><br><span class=\"line\">525</span><br><span class=\"line\">526</span><br><span class=\"line\">527</span><br><span class=\"line\">528</span><br><span class=\"line\">529</span><br><span class=\"line\">530</span><br><span class=\"line\">531</span><br><span class=\"line\">532</span><br><span class=\"line\">533</span><br><span class=\"line\">534</span><br><span class=\"line\">535</span><br><span class=\"line\">536</span><br><span class=\"line\">537</span><br><span class=\"line\">538</span><br><span class=\"line\">539</span><br><span class=\"line\">540</span><br><span class=\"line\">541</span><br><span class=\"line\">542</span><br><span class=\"line\">543</span><br><span class=\"line\">544</span><br><span class=\"line\">545</span><br><span class=\"line\">546</span><br><span class=\"line\">547</span><br><span class=\"line\">548</span><br><span class=\"line\">549</span><br><span class=\"line\">550</span><br><span class=\"line\">551</span><br><span class=\"line\">552</span><br><span class=\"line\">553</span><br><span class=\"line\">554</span><br><span class=\"line\">555</span><br><span class=\"line\">556</span><br><span class=\"line\">557</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 环境定义了预定义的全局变量。</span></span><br><span class=\"line\">    <span class=\"string\">\"env\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 环境定义了预定义的全局变量。更多在官网查看</span></span><br><span class=\"line\">        <span class=\"string\">\"browser\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"string\">\"node\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"string\">\"commonjs\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"string\">\"amd\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"string\">\"es6\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"string\">\"mocha\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// JavaScript 语言选项</span></span><br><span class=\"line\">    <span class=\"string\">\"parserOptions\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ECMAScript 版本</span></span><br><span class=\"line\">        <span class=\"string\">\"ecmaVersion\"</span>: <span class=\"number\">6</span>,</span><br><span class=\"line\">        <span class=\"string\">\"sourceType\"</span>: <span class=\"string\">\"module\"</span>, <span class=\"comment\">// 设置为 \"script\" (默认) 或 \"module\"（如果你的代码是 ECMAScript 模块)。</span></span><br><span class=\"line\">        <span class=\"comment\">// 想使用的额外的语言特性:</span></span><br><span class=\"line\">        <span class=\"string\">\"ecmaFeatures\"</span>: &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 允许在全局作用域下使用 return 语句</span></span><br><span class=\"line\">            <span class=\"string\">\"globalReturn\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            <span class=\"comment\">// impliedStric</span></span><br><span class=\"line\">            <span class=\"string\">\"impliedStrict\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            <span class=\"comment\">// 启用 JSX</span></span><br><span class=\"line\">            <span class=\"string\">\"jsx\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            <span class=\"string\">\"modules\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 让 eslint 支持 JSX start</span></span><br><span class=\"line\">    <span class=\"string\">\"plugins\"</span>: [</span><br><span class=\"line\">        <span class=\"string\">\"react\"</span></span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"string\">\"extends\"</span>: [</span><br><span class=\"line\">        <span class=\"string\">\"eslint:recommended\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"plugin:react/recommended\"</span></span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"comment\">// 让 eslint 支持 JSX end</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">\"rules\"</span>: &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">////////////////</span></span><br><span class=\"line\">        <span class=\"comment\">// 可能的错误 //</span></span><br><span class=\"line\">        <span class=\"comment\">////////////////</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 禁止条件表达式中出现赋值操作符</span></span><br><span class=\"line\">        <span class=\"string\">\"no-cond-assign\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁用 console</span></span><br><span class=\"line\">        <span class=\"string\">\"no-console\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止在条件中使用常量表达式</span></span><br><span class=\"line\">        <span class=\"comment\">// if (false) &#123;</span></span><br><span class=\"line\">        <span class=\"comment\">// doSomethingUnfinished();</span></span><br><span class=\"line\">        <span class=\"comment\">// &#125; //cuowu</span></span><br><span class=\"line\">        <span class=\"string\">\"no-constant-condition\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止在正则表达式中使用控制字符 ：new RegExp(\"\\x1f\")</span></span><br><span class=\"line\">        <span class=\"string\">\"no-control-regex\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 数组和对象键值对最后一个逗号， never 参数：不能带末尾的逗号, always 参数：必须带末尾的逗号，</span></span><br><span class=\"line\">        <span class=\"comment\">// always-multiline：多行模式必须带逗号，单行模式不能带逗号</span></span><br><span class=\"line\">        <span class=\"string\">\"comma-dangle\"</span>: [<span class=\"number\">1</span>, <span class=\"string\">\"never\"</span>],</span><br><span class=\"line\">        <span class=\"comment\">// 禁用 debugger</span></span><br><span class=\"line\">        <span class=\"string\">\"no-debugger\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止 function 定义中出现重名参数</span></span><br><span class=\"line\">        <span class=\"string\">\"no-dupe-args\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止对象字面量中出现重复的 key</span></span><br><span class=\"line\">        <span class=\"string\">\"no-dupe-keys\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止重复的 case 标签</span></span><br><span class=\"line\">        <span class=\"string\">\"no-duplicate-case\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止空语句块</span></span><br><span class=\"line\">        <span class=\"string\">\"no-empty\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止在正则表达式中使用空字符集 (/^abc[]/)</span></span><br><span class=\"line\">        <span class=\"string\">\"no-empty-character-class\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止对 catch 子句的参数重新赋值</span></span><br><span class=\"line\">        <span class=\"string\">\"no-ex-assign\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止不必要的布尔转换</span></span><br><span class=\"line\">        <span class=\"string\">\"no-extra-boolean-cast\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止不必要的括号 //(a * b) + c;// 报错</span></span><br><span class=\"line\">        <span class=\"string\">\"no-extra-parens\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止不必要的分号</span></span><br><span class=\"line\">        <span class=\"string\">\"no-extra-semi\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止对 function 声明重新赋值</span></span><br><span class=\"line\">        <span class=\"string\">\"no-func-assign\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止在嵌套的块中出现 function 或 var 声明</span></span><br><span class=\"line\">        <span class=\"string\">\"no-inner-declarations\"</span>: [<span class=\"number\">2</span>, <span class=\"string\">\"functions\"</span>],</span><br><span class=\"line\">        <span class=\"comment\">// 禁止 RegExp 构造函数中无效的正则表达式字符串</span></span><br><span class=\"line\">        <span class=\"string\">\"no-invalid-regexp\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止在字符串和注释之外不规则的空白</span></span><br><span class=\"line\">        <span class=\"string\">\"no-irregular-whitespace\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止在 in 表达式中出现否定的左操作数</span></span><br><span class=\"line\">        <span class=\"string\">\"no-negated-in-lhs\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止把全局对象 (Math 和 JSON) 作为函数调用 错误：var math = Math();</span></span><br><span class=\"line\">        <span class=\"string\">\"no-obj-calls\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止直接使用 Object.prototypes 的内置属性</span></span><br><span class=\"line\">        <span class=\"string\">\"no-prototype-builtins\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止正则表达式字面量中出现多个空格</span></span><br><span class=\"line\">        <span class=\"string\">\"no-regex-spaces\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁用稀疏数组</span></span><br><span class=\"line\">        <span class=\"string\">\"no-sparse-arrays\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止出现令人困惑的多行表达式</span></span><br><span class=\"line\">        <span class=\"string\">\"no-unexpected-multiline\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止在 return、throw、continue 和 break 语句之后出现不可达代码</span></span><br><span class=\"line\">        <span class=\"string\">\"no-unreachable\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 要求使用 isNaN() 检查 NaN</span></span><br><span class=\"line\">        <span class=\"string\">\"use-isnan\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 强制使用有效的 JSDoc 注释</span></span><br><span class=\"line\">        <span class=\"string\">\"valid-jsdoc\"</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 强制 typeof 表达式与有效的字符串进行比较</span></span><br><span class=\"line\">        <span class=\"comment\">// typeof foo === \"undefimed\" 错误</span></span><br><span class=\"line\">        <span class=\"string\">\"valid-typeof\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//////////////</span></span><br><span class=\"line\">        <span class=\"comment\">// 最佳实践 //</span></span><br><span class=\"line\">        <span class=\"comment\">//////////////</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 定义对象的 set 存取器属性时，强制定义 get</span></span><br><span class=\"line\">        <span class=\"string\">\"accessor-pairs\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 强制数组方法的回调函数中有 return 语句</span></span><br><span class=\"line\">        <span class=\"string\">\"array-callback-return\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 强制把变量的使用限制在其定义的作用域范围内</span></span><br><span class=\"line\">        <span class=\"string\">\"block-scoped-var\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 限制圈复杂度，也就是类似 if else 能连续接多少个</span></span><br><span class=\"line\">        <span class=\"string\">\"complexity\"</span>: [<span class=\"number\">2</span>, <span class=\"number\">9</span>],</span><br><span class=\"line\">        <span class=\"comment\">// 要求 return 语句要么总是指定返回的值，要么不指定</span></span><br><span class=\"line\">        <span class=\"string\">\"consistent-return\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 强制所有控制语句使用一致的括号风格</span></span><br><span class=\"line\">        <span class=\"string\">\"curly\"</span>: [<span class=\"number\">2</span>, <span class=\"string\">\"all\"</span>],</span><br><span class=\"line\">        <span class=\"comment\">// switch 语句强制 default 分支，也可添加 // no default 注释取消此次警告</span></span><br><span class=\"line\">        <span class=\"string\">\"default-case\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 强制 object.key 中 . 的位置，参数:</span></span><br><span class=\"line\">        <span class=\"comment\">// property，'.'号应与属性在同一行</span></span><br><span class=\"line\">        <span class=\"comment\">// object, '.' 号应与对象名在同一行</span></span><br><span class=\"line\">        <span class=\"string\">\"dot-location\"</span>: [<span class=\"number\">2</span>, <span class=\"string\">\"property\"</span>],</span><br><span class=\"line\">        <span class=\"comment\">// 强制使用. 号取属性</span></span><br><span class=\"line\">        <span class=\"comment\">// 参数： allowKeywords：true 使用保留字做属性名时，只能使用. 方式取属性</span></span><br><span class=\"line\">        <span class=\"comment\">// false 使用保留字做属性名时, 只能使用 [] 方式取属性 e.g [2, &#123;\"allowKeywords\": false&#125;]</span></span><br><span class=\"line\">        <span class=\"comment\">// allowPattern: 当属性名匹配提供的正则表达式时，允许使用 [] 方式取值, 否则只能用. 号取值 e.g [2, &#123;\"allowPattern\": \"^[a-z]+(_[a-z]+)+$\"&#125;]</span></span><br><span class=\"line\">        <span class=\"string\">\"dot-notation\"</span>: [<span class=\"number\">2</span>, &#123;</span><br><span class=\"line\">            <span class=\"string\">\"allowKeywords\"</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;],</span><br><span class=\"line\">        <span class=\"comment\">// 使用 === 替代 == allow-null 允许 null 和 undefined==</span></span><br><span class=\"line\">        <span class=\"string\">\"eqeqeq\"</span>: [<span class=\"number\">2</span>, <span class=\"string\">\"allow-null\"</span>],</span><br><span class=\"line\">        <span class=\"comment\">// 要求 for-in 循环中有一个 if 语句</span></span><br><span class=\"line\">        <span class=\"string\">\"guard-for-in\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁用 alert、confirm 和 prompt</span></span><br><span class=\"line\">        <span class=\"string\">\"no-alert\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁用 arguments.caller 或 arguments.callee</span></span><br><span class=\"line\">        <span class=\"string\">\"no-caller\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 不允许在 case 子句中使用词法声明</span></span><br><span class=\"line\">        <span class=\"string\">\"no-case-declarations\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止除法操作符显式的出现在正则表达式开始的位置</span></span><br><span class=\"line\">        <span class=\"string\">\"no-div-regex\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止 if 语句中有 return 之后有 else</span></span><br><span class=\"line\">        <span class=\"string\">\"no-else-return\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止出现空函数. 如果一个函数包含了一条注释，它将不会被认为有问题。</span></span><br><span class=\"line\">        <span class=\"string\">\"no-empty-function\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止使用空解构模式 no-empty-pattern</span></span><br><span class=\"line\">        <span class=\"string\">\"no-empty-pattern\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止在没有类型检查操作符的情况下与 null 进行比较</span></span><br><span class=\"line\">        <span class=\"string\">\"no-eq-null\"</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁用 eval()</span></span><br><span class=\"line\">        <span class=\"string\">\"no-eval\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止扩展原生类型</span></span><br><span class=\"line\">        <span class=\"string\">\"no-extend-native\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止不必要的 .bind() 调用</span></span><br><span class=\"line\">        <span class=\"string\">\"no-extra-bind\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁用不必要的标签</span></span><br><span class=\"line\">        <span class=\"string\">\"no-extra-label:\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止 case 语句落空</span></span><br><span class=\"line\">        <span class=\"string\">\"no-fallthrough\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止数字字面量中使用前导和末尾小数点</span></span><br><span class=\"line\">        <span class=\"string\">\"no-floating-decimal\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止使用短符号进行类型转换 (!!fOO)</span></span><br><span class=\"line\">        <span class=\"string\">\"no-implicit-coercion\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止在全局范围内使用 var 和命名的 function 声明</span></span><br><span class=\"line\">        <span class=\"string\">\"no-implicit-globals\"</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止使用类似 eval() 的方法</span></span><br><span class=\"line\">        <span class=\"string\">\"no-implied-eval\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止 this 关键字出现在类和类对象之外</span></span><br><span class=\"line\">        <span class=\"string\">\"no-invalid-this\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁用 __iterator__ 属性</span></span><br><span class=\"line\">        <span class=\"string\">\"no-iterator\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁用标签语句</span></span><br><span class=\"line\">        <span class=\"string\">\"no-labels\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁用不必要的嵌套块</span></span><br><span class=\"line\">        <span class=\"string\">\"no-lone-blocks\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止在循环中出现 function 声明和表达式</span></span><br><span class=\"line\">        <span class=\"string\">\"no-loop-func\"</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁用魔术数字 (3.14 什么的用常量代替)</span></span><br><span class=\"line\">        <span class=\"string\">\"no-magic-numbers\"</span>: [<span class=\"number\">1</span>, &#123;</span><br><span class=\"line\">            <span class=\"string\">\"ignore\"</span>: [<span class=\"number\">0</span>, <span class=\"number\">-1</span>, <span class=\"number\">1</span>]</span><br><span class=\"line\">        &#125;],</span><br><span class=\"line\">        <span class=\"comment\">// 禁止使用多个空格</span></span><br><span class=\"line\">        <span class=\"string\">\"no-multi-spaces\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止使用多行字符串，在 JavaScript 中，可以在新行之前使用斜线创建多行字符串</span></span><br><span class=\"line\">        <span class=\"string\">\"no-multi-str\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止对原生对象赋值</span></span><br><span class=\"line\">        <span class=\"string\">\"no-native-reassign\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止在非赋值或条件语句中使用 new 操作符</span></span><br><span class=\"line\">        <span class=\"string\">\"no-new\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止对 Function 对象使用 new 操作符</span></span><br><span class=\"line\">        <span class=\"string\">\"no-new-func\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止对 String，Number 和 Boolean 使用 new 操作符</span></span><br><span class=\"line\">        <span class=\"string\">\"no-new-wrappers\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁用八进制字面量</span></span><br><span class=\"line\">        <span class=\"string\">\"no-octal\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止在字符串中使用八进制转义序列</span></span><br><span class=\"line\">        <span class=\"string\">\"no-octal-escape\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 不允许对 function 的参数进行重新赋值</span></span><br><span class=\"line\">        <span class=\"string\">\"no-param-reassign\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁用 __proto__ 属性</span></span><br><span class=\"line\">        <span class=\"string\">\"no-proto\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止使用 var 多次声明同一变量</span></span><br><span class=\"line\">        <span class=\"string\">\"no-redeclare\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁用指定的通过 require 加载的模块</span></span><br><span class=\"line\">        <span class=\"string\">\"no-return-assign\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止使用 javascript: url</span></span><br><span class=\"line\">        <span class=\"string\">\"no-script-url\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止自我赋值</span></span><br><span class=\"line\">        <span class=\"string\">\"no-self-assign\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止自身比较</span></span><br><span class=\"line\">        <span class=\"string\">\"no-self-compare\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁用逗号操作符</span></span><br><span class=\"line\">        <span class=\"string\">\"no-sequences\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止抛出非异常字面量</span></span><br><span class=\"line\">        <span class=\"string\">\"no-throw-literal\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁用一成不变的循环条件</span></span><br><span class=\"line\">        <span class=\"string\">\"no-unmodified-loop-condition\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止出现未使用过的表达式</span></span><br><span class=\"line\">        <span class=\"string\">\"no-unused-expressions\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁用未使用过的标签</span></span><br><span class=\"line\">        <span class=\"string\">\"no-unused-labels\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止不必要的 .call() 和 .apply()</span></span><br><span class=\"line\">        <span class=\"string\">\"no-useless-call\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止不必要的字符串字面量或模板字面量的连接</span></span><br><span class=\"line\">        <span class=\"string\">\"no-useless-concat\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁用不必要的转义字符</span></span><br><span class=\"line\">        <span class=\"string\">\"no-useless-escape\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁用 void 操作符</span></span><br><span class=\"line\">        <span class=\"string\">\"no-void\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止在注释中使用特定的警告术语</span></span><br><span class=\"line\">        <span class=\"string\">\"no-warning-comments\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁用 with 语句</span></span><br><span class=\"line\">        <span class=\"string\">\"no-with\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 强制在 parseInt() 使用基数参数</span></span><br><span class=\"line\">        <span class=\"string\">\"radix\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 要求所有的 var 声明出现在它们所在的作用域顶部</span></span><br><span class=\"line\">        <span class=\"string\">\"vars-on-top\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 要求 IIFE 使用括号括起来</span></span><br><span class=\"line\">        <span class=\"string\">\"wrap-iife\"</span>: [<span class=\"number\">2</span>, <span class=\"string\">\"any\"</span>],</span><br><span class=\"line\">        <span class=\"comment\">// 要求或禁止 “Yoda” 条件</span></span><br><span class=\"line\">        <span class=\"string\">\"yoda\"</span>: [<span class=\"number\">2</span>, <span class=\"string\">\"never\"</span>],</span><br><span class=\"line\">        <span class=\"comment\">// 要求或禁止使用严格模式指令</span></span><br><span class=\"line\">        <span class=\"string\">\"strict\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//////////////</span></span><br><span class=\"line\">        <span class=\"comment\">// 变量声明 //</span></span><br><span class=\"line\">        <span class=\"comment\">//////////////</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 要求或禁止 var 声明中的初始化 (初值)</span></span><br><span class=\"line\">        <span class=\"string\">\"init-declarations\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 不允许 catch 子句的参数与外层作用域中的变量同名</span></span><br><span class=\"line\">        <span class=\"string\">\"no-catch-shadow\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止删除变量</span></span><br><span class=\"line\">        <span class=\"string\">\"no-delete-var\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 不允许标签与变量同名</span></span><br><span class=\"line\">        <span class=\"string\">\"no-label-var\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁用特定的全局变量</span></span><br><span class=\"line\">        <span class=\"string\">\"no-restricted-globals\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止 var 声明 与外层作用域的变量同名</span></span><br><span class=\"line\">        <span class=\"string\">\"no-shadow\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止覆盖受限制的标识符</span></span><br><span class=\"line\">        <span class=\"string\">\"no-shadow-restricted-names\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁用未声明的变量，除非它们在 /*global */ 注释中被提到</span></span><br><span class=\"line\">        <span class=\"string\">\"no-undef\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止将变量初始化为 undefined</span></span><br><span class=\"line\">        <span class=\"string\">\"no-undef-init\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止将 undefined 作为标识符</span></span><br><span class=\"line\">        <span class=\"string\">\"no-undefined\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止出现未使用过的变量</span></span><br><span class=\"line\">        <span class=\"string\">\"no-unused-vars\"</span>: [<span class=\"number\">2</span>, &#123;</span><br><span class=\"line\">            <span class=\"string\">\"vars\"</span>: <span class=\"string\">\"all\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"args\"</span>: <span class=\"string\">\"none\"</span></span><br><span class=\"line\">        &#125;],</span><br><span class=\"line\">        <span class=\"comment\">// 不允许在变量定义之前使用它们</span></span><br><span class=\"line\">        <span class=\"string\">\"no-use-before-define\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//////////////////////////</span></span><br><span class=\"line\">        <span class=\"comment\">// Node.js and CommonJS //</span></span><br><span class=\"line\">        <span class=\"comment\">//////////////////////////</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// require return statements after callbacks</span></span><br><span class=\"line\">        <span class=\"string\">\"callback-return\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 要求 require() 出现在顶层模块作用域中</span></span><br><span class=\"line\">        <span class=\"string\">\"global-require\"</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 要求回调函数中有容错处理</span></span><br><span class=\"line\">        <span class=\"string\">\"handle-callback-err\"</span>: [<span class=\"number\">2</span>, <span class=\"string\">\"^(err|error)$\"</span>],</span><br><span class=\"line\">        <span class=\"comment\">// 禁止混合常规 var 声明和 require 调用</span></span><br><span class=\"line\">        <span class=\"string\">\"no-mixed-requires\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止调用 require 时使用 new 操作符</span></span><br><span class=\"line\">        <span class=\"string\">\"no-new-require\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止对 __dirname 和 __filename 进行字符串连接</span></span><br><span class=\"line\">        <span class=\"string\">\"no-path-concat\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁用 process.env</span></span><br><span class=\"line\">        <span class=\"string\">\"no-process-env\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁用 process.exit()</span></span><br><span class=\"line\">        <span class=\"string\">\"no-process-exit\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁用同步方法</span></span><br><span class=\"line\">        <span class=\"string\">\"no-sync\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//////////////</span></span><br><span class=\"line\">        <span class=\"comment\">// 风格指南 //</span></span><br><span class=\"line\">        <span class=\"comment\">//////////////</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 指定数组的元素之间要以空格隔开 (, 后面)， never 参数：[ 之前和 ] 之后不能带空格，always 参数：[ 之前和 ] 之后必须带空格</span></span><br><span class=\"line\">        <span class=\"string\">\"array-bracket-spacing\"</span>: [<span class=\"number\">2</span>, <span class=\"string\">\"never\"</span>],</span><br><span class=\"line\">        <span class=\"comment\">// 禁止或强制在单行代码块中使用空格 (禁用)</span></span><br><span class=\"line\">        <span class=\"string\">\"block-spacing\"</span>: [<span class=\"number\">1</span>, <span class=\"string\">\"never\"</span>],</span><br><span class=\"line\">        <span class=\"comment\">// 强制使用一致的缩进 第二个参数为 \"tab\" 时，会使用 tab，</span></span><br><span class=\"line\">        <span class=\"comment\">// if while function 后面的 &#123;必须与 if 在同一行，java 风格。</span></span><br><span class=\"line\">        <span class=\"string\">\"brace-style\"</span>: [<span class=\"number\">2</span>, <span class=\"string\">\"1tbs\"</span>, &#123;</span><br><span class=\"line\">            <span class=\"string\">\"allowSingleLine\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;],</span><br><span class=\"line\">        <span class=\"comment\">// 双峰驼命名格式</span></span><br><span class=\"line\">        <span class=\"string\">\"camelcase\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 控制逗号前后的空格</span></span><br><span class=\"line\">        <span class=\"string\">\"comma-spacing\"</span>: [<span class=\"number\">2</span>, &#123;</span><br><span class=\"line\">            <span class=\"string\">\"before\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">            <span class=\"string\">\"after\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;],</span><br><span class=\"line\">        <span class=\"comment\">// 控制逗号在行尾出现还是在行首出现 (默认行尾)</span></span><br><span class=\"line\">        <span class=\"comment\">// http://eslint.org/docs/rules/comma-style</span></span><br><span class=\"line\">        <span class=\"string\">\"comma-style\"</span>: [<span class=\"number\">2</span>, <span class=\"string\">\"last\"</span>],</span><br><span class=\"line\">        <span class=\"comment\">//\"SwitchCase\" (默认：0) 强制 switch 语句中的 case 子句的缩进水平</span></span><br><span class=\"line\">        <span class=\"comment\">// 以方括号取对象属性时，[后面和] 前面是否需要空格, 可选参数 never, always</span></span><br><span class=\"line\">        <span class=\"string\">\"computed-property-spacing\"</span>: [<span class=\"number\">2</span>, <span class=\"string\">\"never\"</span>],</span><br><span class=\"line\">        <span class=\"comment\">// 用于指统一在回调函数中指向 this 的变量名，箭头函数中的 this 已经可以指向外层调用者，应该没卵用了</span></span><br><span class=\"line\">        <span class=\"comment\">// e.g [0,\"that\"] 指定只能 var that = this. that 不能指向其他任何值，this 也不能赋值给 that 以外的其他值</span></span><br><span class=\"line\">        <span class=\"string\">\"consistent-this\"</span>: [<span class=\"number\">1</span>, <span class=\"string\">\"that\"</span>],</span><br><span class=\"line\">        <span class=\"comment\">// 强制使用命名的 function 表达式</span></span><br><span class=\"line\">        <span class=\"string\">\"func-names\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 文件末尾强制换行</span></span><br><span class=\"line\">        <span class=\"string\">\"eol-last\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"string\">\"indent\"</span>: [<span class=\"number\">2</span>, <span class=\"number\">4</span>, &#123;</span><br><span class=\"line\">            <span class=\"string\">\"SwitchCase\"</span>: <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;],</span><br><span class=\"line\">        <span class=\"comment\">// 强制在对象字面量的属性中键和值之间使用一致的间距</span></span><br><span class=\"line\">        <span class=\"string\">\"key-spacing\"</span>: [<span class=\"number\">2</span>, &#123;</span><br><span class=\"line\">            <span class=\"string\">\"beforeColon\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">            <span class=\"string\">\"afterColon\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;],</span><br><span class=\"line\">        <span class=\"comment\">// 强制使用一致的换行风格</span></span><br><span class=\"line\">        <span class=\"string\">\"linebreak-style\"</span>: [<span class=\"number\">1</span>, <span class=\"string\">\"unix\"</span>],</span><br><span class=\"line\">        <span class=\"comment\">// 要求在注释周围有空行 (要求在块级注释之前有一空行)</span></span><br><span class=\"line\">        <span class=\"string\">\"lines-around-comment\"</span>: [<span class=\"number\">1</span>, &#123;</span><br><span class=\"line\">            <span class=\"string\">\"beforeBlockComment\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;],</span><br><span class=\"line\">        <span class=\"comment\">// 强制一致地使用函数声明或函数表达式，方法定义风格，参数：</span></span><br><span class=\"line\">        <span class=\"comment\">// declaration: 强制使用方法声明的方式，function f()&#123;&#125; e.g [2, \"declaration\"]</span></span><br><span class=\"line\">        <span class=\"comment\">// expression：强制使用方法表达式的方式，var f = function() &#123;&#125; e.g [2, \"expression\"]</span></span><br><span class=\"line\">        <span class=\"comment\">// allowArrowFunctions: declaration 风格中允许箭头函数。 e.g [2, \"declaration\", &#123; \"allowArrowFunctions\": true&#125;]</span></span><br><span class=\"line\">        <span class=\"string\">\"func-style\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 强制回调函数最大嵌套深度 5 层</span></span><br><span class=\"line\">        <span class=\"string\">\"max-nested-callbacks\"</span>: [<span class=\"number\">1</span>, <span class=\"number\">5</span>],</span><br><span class=\"line\">        <span class=\"comment\">// 禁止使用指定的标识符</span></span><br><span class=\"line\">        <span class=\"string\">\"id-blacklist\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 强制标识符的最新和最大长度</span></span><br><span class=\"line\">        <span class=\"string\">\"id-length\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 要求标识符匹配一个指定的正则表达式</span></span><br><span class=\"line\">        <span class=\"string\">\"id-match\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 强制在 JSX 属性中一致地使用双引号或单引号</span></span><br><span class=\"line\">        <span class=\"string\">\"jsx-quotes\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 强制在关键字前后使用一致的空格 (前后腰需要)</span></span><br><span class=\"line\">        <span class=\"string\">\"keyword-spacing\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 强制一行的最大长度</span></span><br><span class=\"line\">        <span class=\"string\">\"max-len\"</span>: [<span class=\"number\">1</span>, <span class=\"number\">200</span>],</span><br><span class=\"line\">        <span class=\"comment\">// 强制最大行数</span></span><br><span class=\"line\">        <span class=\"string\">\"max-lines\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 强制 function 定义中最多允许的参数数量</span></span><br><span class=\"line\">        <span class=\"string\">\"max-params\"</span>: [<span class=\"number\">1</span>, <span class=\"number\">7</span>],</span><br><span class=\"line\">        <span class=\"comment\">// 强制 function 块最多允许的的语句数量</span></span><br><span class=\"line\">        <span class=\"string\">\"max-statements\"</span>: [<span class=\"number\">1</span>, <span class=\"number\">200</span>],</span><br><span class=\"line\">        <span class=\"comment\">// 强制每一行中所允许的最大语句数量</span></span><br><span class=\"line\">        <span class=\"string\">\"max-statements-per-line\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 要求构造函数首字母大写 （要求调用 new 操作符时有首字母大小的函数，允许调用首字母大写的函数时没有 new 操作符。）</span></span><br><span class=\"line\">        <span class=\"string\">\"new-cap\"</span>: [<span class=\"number\">2</span>, &#123;</span><br><span class=\"line\">            <span class=\"string\">\"newIsCap\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            <span class=\"string\">\"capIsNew\"</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;],</span><br><span class=\"line\">        <span class=\"comment\">// 要求调用无参构造函数时有圆括号</span></span><br><span class=\"line\">        <span class=\"string\">\"new-parens\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 要求或禁止 var 声明语句后有一行空行</span></span><br><span class=\"line\">        <span class=\"string\">\"newline-after-var\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止使用 Array 构造函数</span></span><br><span class=\"line\">        <span class=\"string\">\"no-array-constructor\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁用按位运算符</span></span><br><span class=\"line\">        <span class=\"string\">\"no-bitwise\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 要求 return 语句之前有一空行</span></span><br><span class=\"line\">        <span class=\"string\">\"newline-before-return\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 要求方法链中每个调用都有一个换行符</span></span><br><span class=\"line\">        <span class=\"string\">\"newline-per-chained-call\"</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁用 continue 语句</span></span><br><span class=\"line\">        <span class=\"string\">\"no-continue\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止在代码行后使用内联注释</span></span><br><span class=\"line\">        <span class=\"string\">\"no-inline-comments\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止 if 作为唯一的语句出现在 else 语句中</span></span><br><span class=\"line\">        <span class=\"string\">\"no-lonely-if\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止混合使用不同的操作符</span></span><br><span class=\"line\">        <span class=\"string\">\"no-mixed-operators\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 不允许空格和 tab 混合缩进</span></span><br><span class=\"line\">        <span class=\"string\">\"no-mixed-spaces-and-tabs\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 不允许多个空行</span></span><br><span class=\"line\">        <span class=\"string\">\"no-multiple-empty-lines\"</span>: [<span class=\"number\">2</span>, &#123;</span><br><span class=\"line\">            <span class=\"string\">\"max\"</span>: <span class=\"number\">2</span></span><br><span class=\"line\">        &#125;],</span><br><span class=\"line\">        <span class=\"comment\">// 不允许否定的表达式</span></span><br><span class=\"line\">        <span class=\"string\">\"no-negated-condition\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 不允许使用嵌套的三元表达式</span></span><br><span class=\"line\">        <span class=\"string\">\"no-nested-ternary\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止使用 Object 的构造函数</span></span><br><span class=\"line\">        <span class=\"string\">\"no-new-object\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止使用一元操作符 ++ 和 --</span></span><br><span class=\"line\">        <span class=\"string\">\"no-plusplus\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止使用特定的语法</span></span><br><span class=\"line\">        <span class=\"string\">\"no-restricted-syntax\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止 function 标识符和括号之间出现空格</span></span><br><span class=\"line\">        <span class=\"string\">\"no-spaced-func\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 不允许使用三元操作符</span></span><br><span class=\"line\">        <span class=\"string\">\"no-ternary\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁用行尾空格</span></span><br><span class=\"line\">        <span class=\"string\">\"no-trailing-spaces\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止标识符中有悬空下划线_bar</span></span><br><span class=\"line\">        <span class=\"string\">\"no-underscore-dangle\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止可以在有更简单的可替代的表达式时使用三元操作符</span></span><br><span class=\"line\">        <span class=\"string\">\"no-unneeded-ternary\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止属性前有空白</span></span><br><span class=\"line\">        <span class=\"string\">\"no-whitespace-before-property\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 强制花括号内换行符的一致性</span></span><br><span class=\"line\">        <span class=\"string\">\"object-curly-newline\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 强制在花括号中使用一致的空格</span></span><br><span class=\"line\">        <span class=\"string\">\"object-curly-spacing\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 强制将对象的属性放在不同的行上</span></span><br><span class=\"line\">        <span class=\"string\">\"object-property-newline\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 强制函数中的变量要么一起声明要么分开声明</span></span><br><span class=\"line\">        <span class=\"string\">\"one-var\"</span>: [<span class=\"number\">2</span>, &#123;</span><br><span class=\"line\">            <span class=\"string\">\"initialized\"</span>: <span class=\"string\">\"never\"</span></span><br><span class=\"line\">        &#125;],</span><br><span class=\"line\">        <span class=\"comment\">// 要求或禁止在 var 声明周围换行</span></span><br><span class=\"line\">        <span class=\"string\">\"one-var-declaration-per-line\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 要求或禁止在可能的情况下要求使用简化的赋值操作符</span></span><br><span class=\"line\">        <span class=\"string\">\"operator-assignment\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 强制操作符使用一致的换行符</span></span><br><span class=\"line\">        <span class=\"string\">\"operator-linebreak\"</span>: [<span class=\"number\">2</span>, <span class=\"string\">\"after\"</span>, &#123;</span><br><span class=\"line\">            <span class=\"string\">\"overrides\"</span>: &#123;</span><br><span class=\"line\">                <span class=\"string\">\"?\"</span>: <span class=\"string\">\"before\"</span>,</span><br><span class=\"line\">                <span class=\"string\">\":\"</span>: <span class=\"string\">\"before\"</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;],</span><br><span class=\"line\">        <span class=\"comment\">// 要求或禁止块内填充</span></span><br><span class=\"line\">        <span class=\"string\">\"padded-blocks\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 要求对象字面量属性名称用引号括起来</span></span><br><span class=\"line\">        <span class=\"string\">\"quote-props\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 强制使用一致的反勾号、双引号或单引号</span></span><br><span class=\"line\">        <span class=\"string\">\"quotes\"</span>: [<span class=\"number\">2</span>, <span class=\"string\">\"double\"</span>, <span class=\"string\">\"avoid-escape\"</span>],</span><br><span class=\"line\">        <span class=\"comment\">// 要求使用 JSDoc 注释</span></span><br><span class=\"line\">        <span class=\"string\">\"require-jsdoc\"</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 要求或禁止使用分号而不是 ASI（这个才是控制行尾部分号的，）</span></span><br><span class=\"line\">        <span class=\"string\">\"semi\"</span>: [<span class=\"number\">2</span>, <span class=\"string\">\"always\"</span>],</span><br><span class=\"line\">        <span class=\"comment\">// 强制分号之前和之后使用一致的空格</span></span><br><span class=\"line\">        <span class=\"string\">\"semi-spacing\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 要求同一个声明块中的变量按顺序排列</span></span><br><span class=\"line\">        <span class=\"string\">\"sort-vars\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 强制在块之前使用一致的空格</span></span><br><span class=\"line\">        <span class=\"string\">\"space-before-blocks\"</span>: [<span class=\"number\">2</span>, <span class=\"string\">\"always\"</span>],</span><br><span class=\"line\">        <span class=\"comment\">// 强制在 function 的左括号之前使用一致的空格</span></span><br><span class=\"line\">        <span class=\"string\">\"space-before-function-paren\"</span>: [<span class=\"number\">0</span>, <span class=\"string\">\"always\"</span>],</span><br><span class=\"line\">        <span class=\"comment\">// 强制在圆括号内使用一致的空格</span></span><br><span class=\"line\">        <span class=\"string\">\"space-in-parens\"</span>: [<span class=\"number\">2</span>, <span class=\"string\">\"never\"</span>],</span><br><span class=\"line\">        <span class=\"comment\">// 要求操作符周围有空格</span></span><br><span class=\"line\">        <span class=\"string\">\"space-infix-ops\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 强制在一元操作符前后使用一致的空格</span></span><br><span class=\"line\">        <span class=\"string\">\"space-unary-ops\"</span>: [<span class=\"number\">2</span>, &#123;</span><br><span class=\"line\">            <span class=\"string\">\"words\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            <span class=\"string\">\"nonwords\"</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;],</span><br><span class=\"line\">        <span class=\"comment\">// 强制在注释中 // 或 /* 使用一致的空格</span></span><br><span class=\"line\">        <span class=\"string\">\"spaced-comment\"</span>: [<span class=\"number\">2</span>, <span class=\"string\">\"always\"</span>, &#123;</span><br><span class=\"line\">            <span class=\"string\">\"markers\"</span>: [<span class=\"string\">\"global\"</span>, <span class=\"string\">\"globals\"</span>, <span class=\"string\">\"eslint\"</span>, <span class=\"string\">\"eslint-disable\"</span>, <span class=\"string\">\"*package\"</span>, <span class=\"string\">\"!\"</span>]</span><br><span class=\"line\">        &#125;],</span><br><span class=\"line\">        <span class=\"comment\">// 要求或禁止 Unicode BOM</span></span><br><span class=\"line\">        <span class=\"string\">\"unicode-bom\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 要求正则表达式被括号括起来</span></span><br><span class=\"line\">        <span class=\"string\">\"wrap-regex\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//////////////</span></span><br><span class=\"line\">        <span class=\"comment\">// ES6. 相关 //</span></span><br><span class=\"line\">        <span class=\"comment\">//////////////</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 要求箭头函数体使用大括号</span></span><br><span class=\"line\">        <span class=\"string\">\"arrow-body-style\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 要求箭头函数的参数使用圆括号</span></span><br><span class=\"line\">        <span class=\"string\">\"arrow-parens\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"string\">\"arrow-spacing\"</span>: [<span class=\"number\">2</span>, &#123;</span><br><span class=\"line\">            <span class=\"string\">\"before\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            <span class=\"string\">\"after\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;],</span><br><span class=\"line\">        <span class=\"comment\">// 强制在子类构造函数中用 super() 调用父类构造函数，TypeScrip 的编译器也会提示</span></span><br><span class=\"line\">        <span class=\"string\">\"constructor-super\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 强制 generator 函数中 * 号周围使用一致的空格</span></span><br><span class=\"line\">        <span class=\"string\">\"generator-star-spacing\"</span>: [<span class=\"number\">2</span>, &#123;</span><br><span class=\"line\">            <span class=\"string\">\"before\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            <span class=\"string\">\"after\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;],</span><br><span class=\"line\">        <span class=\"comment\">// 禁止修改类声明的变量</span></span><br><span class=\"line\">        <span class=\"string\">\"no-class-assign\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 不允许箭头功能，在那里他们可以混淆的比较</span></span><br><span class=\"line\">        <span class=\"string\">\"no-confusing-arrow\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止修改 const 声明的变量</span></span><br><span class=\"line\">        <span class=\"string\">\"no-const-assign\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止类成员中出现重复的名称</span></span><br><span class=\"line\">        <span class=\"string\">\"no-dupe-class-members\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 不允许复制模块的进口</span></span><br><span class=\"line\">        <span class=\"string\">\"no-duplicate-imports\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止 Symbol 的构造函数</span></span><br><span class=\"line\">        <span class=\"string\">\"no-new-symbol\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 允许指定模块加载时的进口</span></span><br><span class=\"line\">        <span class=\"string\">\"no-restricted-imports\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止在构造函数中，在调用 super() 之前使用 this 或 super</span></span><br><span class=\"line\">        <span class=\"string\">\"no-this-before-super\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 禁止不必要的计算性能键对象的文字</span></span><br><span class=\"line\">        <span class=\"string\">\"no-useless-computed-key\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 要求使用 let 或 const 而不是 var</span></span><br><span class=\"line\">        <span class=\"string\">\"no-var\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 要求或禁止对象字面量中方法和属性使用简写语法</span></span><br><span class=\"line\">        <span class=\"string\">\"object-shorthand\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 要求使用箭头函数作为回调</span></span><br><span class=\"line\">        <span class=\"string\">\"prefer-arrow-callback\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 要求使用 const 声明那些声明后不再被修改的变量</span></span><br><span class=\"line\">        <span class=\"string\">\"prefer-const\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 要求在合适的地方使用 Reflect 方法</span></span><br><span class=\"line\">        <span class=\"string\">\"prefer-reflect\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 要求使用扩展运算符而非 .apply()</span></span><br><span class=\"line\">        <span class=\"string\">\"prefer-spread\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 要求使用模板字面量而非字符串连接</span></span><br><span class=\"line\">        <span class=\"string\">\"prefer-template\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// Suggest using the rest parameters instead of arguments</span></span><br><span class=\"line\">        <span class=\"string\">\"prefer-rest-params\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 要求 generator 函数内有 yield</span></span><br><span class=\"line\">        <span class=\"string\">\"require-yield\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// enforce spacing between rest and spread operators and their expressions</span></span><br><span class=\"line\">        <span class=\"string\">\"rest-spread-spacing\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 强制模块内的 import 排序</span></span><br><span class=\"line\">        <span class=\"string\">\"sort-imports\"</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 要求或禁止模板字符串中的嵌入表达式周围空格的使用</span></span><br><span class=\"line\">        <span class=\"string\">\"template-curly-spacing\"</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 强制在 yield* 表达式中 * 周围使用空格</span></span><br><span class=\"line\">        <span class=\"string\">\"yield-star-spacing\"</span>: <span class=\"number\">2</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"代码重构","comments":1,"date":"2018-06-16T14:46:36.000Z","from":null,"_content":"\n今天读了曾探的[《设计模式》](https://book.douban.com/subject/26382780/)中的代码重构这一章节, 知识点不多却非常实用, 在实际项目中除了使用设计模式重构代码外, 还有一些容易忽略的细节. 这些细节也是重构的重要手段. 写这篇文章总结一下.\n\n<!-- more -->\n\n> 代码是写给人看的, 顺便给机器运行. 优雅的代码应该是简单、易维护、可扩展的.\n\n### 提炼函数\n\n如果一个函数过长, 而且需要注释才清楚它是如何工作的, 那么需要考虑把它独立出来. 这样做的好处是:\n\n* 避免超大函数, 作用域过大变量不好维护\n* 抽离公共逻辑, 易于复用和覆写\n* 良好的命名起到了注释作用\n\n**例子:**\n\n```js\nconst getUserInfo = () => {\n  fetch('https://xxx.com/userInfo', (data) => {\n    console.log(`\n      userId: ${data.userId}\\n\n      userName: ${data.userName}\\n\n      nickName: ${data.NickName}\n    `);\n  });\n};\n```\n\n重构如下:\n\n```js\nconst printDetail = (data) => {\n    console.log(`\n    userId: ${data.userId}\\n\n    userName: ${data.userName}\\n\n    nickName: ${data.NickName}\n  `);\n}\n\nconst getUserInfo = () => {\n  fetch('https://xxx.com/userInfo', (data) => {\n    printDetail(data);\n  });\n};\n```\n\n[⤴️Go Top](#)\n\n### 合并重复的条件片段\n\n如果一个函数体内有一些条件分支, 而且这些条件分支内散布了一些重复的代码, 这个时候就有必要进行合并去重操作.\n\n**例子:**\n\n```js\nconst paging = (currPage) => {\n  if (currPage <= 0) {\n    currPage = 0;\n    jump(currPage); // 跳转\n  } else if (currPage >= totalPage) {\n    currPage = totalPage;\n    jump(currPage); // 跳转\n  } else {\n    jump(currPage); // 跳转\n  }\n};\n```\n\n可以看到上面的 `jump(currPage)` 重复了, 完全可以把它独立出来:\n\n```js\nconst paging = (currPage) => {\n  if (currPage <= 0) {\n    currPage = 0;\n  } else if (currPage >= totalPage) {\n    currPage = totalPage;\n  }\n  jump(currPage);\n}\n```\n\n[⤴️Go Top](#)\n\n### 把条件分支语句提炼成函数\n\n复杂的条件分支语句是导致程序难以阅读和理解的重要原因, 而且很容易导致一个庞大的函数. 这种情况下就需要把条件分支语句提炼出来.\n\n**例子:**\n\n```js\n// 需求: 如果当季是处于夏季, 那么所有的商品 8 折出售\n\nconst getPrice = (price) => {\n  const date = new Date();\n  if (date.getMonth() >= 6 && date.getMonth() <= 9) { // 夏季\n    return price * 0.8;\n  }\n  return price;\n};\n```\n\n观察这段代码:\n\n```js\nif (date.getMonth() >= 6 && date.getMonth() <= 9) { // 夏季\n  // ...\n}\n```\n\n我们需要让它更符合语义, 这样读代码的人能很轻松理解意图, 这里就可以提炼成一个单独函数.\n\n```js\nconst isSummer = () => {\n  const date = new Date();\n  return date.getMonth() >= 6 && date.getMonth() <= 9;\n};\n\nconst getPrice = (price) => {\n  const date = new Date();\n  if (isSummer()) {\n    return price * 0.8;\n  }\n  return price;\n};\n```\n\n[⤴️Go Top](#)\n\n### 合理的使用循环\n\n在函数体内, 如果一些代码只是完成一些重复的工作, 那么可以合理利用循环完成同样的功能, 这样可以保持代码量更少.\n\n**例子:**\n\n```js\n// 需求: IE9 以下创建一个 XHR 对象\n\nvar createXHR = function() {\n  var xhr;\n  try {\n    xhr = new ActiveXObject('MSXML2.XMLHttp.6.0');\n  } catch(e) {\n    try {\n      xhr = new ActiveXObject('MSXML2.XMLHttp.3.0')\n    } catch(e) {\n      xhr = new ActiveXObject('MSXML2.XMLHttp');\n    }\n  }\n  return xhr;\n};\n\nvar xhr = createXHR();\n```\n\n这个时候, 使用循环来优化上面的代码:\n\n```js\n// 这段代码就看着符合语义了, 而且好理解 🤡\n\nvar createXHR = function() {\n  var versions = ['MSXML2.XMLHttp.6.0', 'MSXML2.XMLHttp.3.0', 'MSXML2.XMLHttp'];\n  for (var i = 0, version; version = versions[i++];) {\n    try {\n      return new ActiveXObject(version);\n    } catch(e) {};\n  }\n};\n\nvar xhr = createXHR();\n```\n\n[⤴️Go Top](#)\n\n### 提前让函数退出代替嵌套条件分支\n\n很多程序员👨‍💻‍都有这种观念 \"每个函数只能有一个入口和一个出口\", 但是关于 \"函数只有一个出口\" 往往有一些不同的看法, 下面用代码来说明一下, 光讲概念有点晦涩.\n\n**例子:**\n\n```js\n// 下面是 \"函数只有一个出口\" 的典型代码\n\nconst del = (obj) => {\n  let ret;\n  if (!obj.isReadOnly) {\n    if (obj.isFolder) {\n      ret = delFolder(obj);\n    } else if (obj.isFile) {\n      ret = delFile(obj);\n    }\n  }\n  return ret;\n};\n```\n\n嵌套的条件分支绝对是代码维护者的噩梦, 多层嵌套的条件更加不容易理解, 有时候如果代码过长, 上一个 `if ()` 语句可能相隔很远. 严重影响了阅读体验啊. 重构的 `del` 函数如下:\n\n```js\nconst del = (obj) => {\n  if (obj.isReadOnly) { // 反转 if\n    return;\n  }\n  if (obj.isFolder) {\n    return delFolder(obj);\n  }\n  if (obj.isFile) {\n    return delFile(obj);\n  }\n};\n\n// 瞬间清爽 👌\n```\n\n[⤴️Go Top](#)\n\n### 传递对象参数代替过长的参数列表\n\n有时候一个函数可能接收多个参数, 而且参数越多, 就越难理解和使用. 最重要的一点需要注意参数的顺序, 如果不传的情况要使用占位符代替. 如果参数超过 3 个, 请使用对象吧.\n\n**例子:**\n\n```js\nconst setUserInfo = (id, name, address, sex, mobile, qq) => {\n  // ...\n}\n\n// 调用 ☹️:\nsetUserInfo(1, 'ifyour', undefined, 'male', undefined, '123456');\n\n\n// 重构 😁:\nsetUserInfo({\n  id: 1,\n  name: 'ifyour',\n  sex: 'male',\n  qq: '123456',\n})\n```\n\n[⤴️Go Top](#)\n\n### 尽量减少参数数量\n\n如果调用一个函数, 需要传递很多参数, 这样的函数用起来就要小心了, 必须搞清楚每个参数的含义, 所以, 如果能尽量少传参数就少传参数. 把复杂的逻辑封装到函数内部.\n\n**例子:**\n\n```js\n// 需求: 有一个画图函数 draw\n\nconst draw = (width, height, square) => {\n  // ...\n};\n\n// 优化如下:\nconst draw = (width, height) => {\n  const square = width * height;\n  // ...\n}\n```\n\n这里的 `square` 参数没必要, 可以通过 `width` 和 `height` 计算获得, 还有一种情况, 这个画图函数, 如果可以画多种图形呢? 所以需要在内部去处理, 什么时候需要 `square` 什么时候需要 `radius`, 然后可以使用 **策略模式** 让它支持画多种图形.\n\n[⤴️Go Top](#)\n\n### 少用三目运算\n\n三目运算能减少代码量, 但是不能滥用, 如果以牺牲代码可读性为代价, 那就得不偿失了.\n\n```js\nconst global = typeof window !== 'undefined' ? window : this;\n\n// 但是这种情况就完全没必要了, 老实写 if..else...\n\nif (!aup || !bup) {\n  return a === doc ? -1 :\n    b === doc ? 1 :\n    aup ? -1 :\n    bup ? 1 :\n    sortInput ?\n    (indexOf.call(sortInput, a) - indexOf.call(sortInput, b)) :\n    0;\n}\n\n// 😡 这是人看的吗\n```\n\n[⤴️Go Top](#)\n\n### 合理使用链式调用\n\njQuery 中的链式调用用起来还是很爽的, 它的实现也非常简单, 我们可以很容易的实现一个链式调用. 使用的前提就是链条的结构相对来说稳定, 不容易发生修改, 如果是经常发生修改的话, 还是建议使用普通的调用. 因为它调试的时候需要把这个链子拆开, 才知道是哪个环节有 Bug.\n\n**例子:**\n\n```js\n// ES5\n\nvar User = function() {\n  this.id = null;\n  this.name = null;\n};\n\nUser.prototype.setId = function (id) {\n  this.id = id;\n  return this; // 返回实例本身\n}\n\nUser.prototype.setName = function (name) {\n  this.name = name;\n  return this;\n}\n\n// 链式调用\nnew User()\n  .setId(1)\n  .setNmae('ifyour');\n```\n\n或者这样:\n\n```js\nvar User = {\n  id: null,\n  name: null,\n  setId: function(id) {\n    this.id = id;\n    return this;\n  },\n  setName: function(name) {\n    this.name = name;\n    return this;\n  }\n};\n\nUser.setId(1).setName('ifyour');\n```\n\n[⤴️Go Top](#)\n\n### 分解大型类\n\n从字面意思我们就能理解, 如果一个类里面有太多的方法, 我们要考虑把其中同一类型相关的方法抽离出来. 模块化的好处不言而喻, 把逻辑复杂的分离成小的单元, 这样更便于维护, 出现 bug 了也好定位问题. 来看一段代码.\n\n**例子:**\n\n```js\n// 英雄类\nvar Spirit = function() {\n  this.name = name;\n};\n\n// 原型上的攻击方法\nSpirit.prototype.attack = function (type) {\n  if (type === 'waveBoxing') {\n    console.log(this.name + ': 使用波动拳');\n  } else if (type === 'whirlKick') {\n    console.log(this.name + ': 使用旋风腿');\n  }\n  // ... 还有很多攻击方法\n}\n\nvar spirit = new Spirit('RYU');\nspirit.attack('waveBoxing'); // RYU: 使用波动拳\nspirit.attack('whirlKick'); // RYU: 使用旋风腿\n```\n\n面向对象的设计鼓励将 **行为** 分解到合理数量的更小的对象中:\n\n```js\nvar Attack = function (spirit) {\n  this.spirit = spirit;\n};\n\nAttack.prototype.start = function (type) {\n  return this.list[type].call(this);\n}\n\nAttack.prototype.list = {\n  waveBoxing: function () {\n    console.log(this.sprite.name + ': 使用波动拳')\n  },\n  whirlKick: function () {\n    console.log(this.sprite.name + ': 使用旋风腿')\n  }\n}\n```\n\n现在 Sprite 类精简了很多, 不再直接包含攻击相关的方法, 而是把方法委托给 Attack 类来执行. 这段代码也是 **策略模式** 的运用之一, 看代码:\n\n```js\nvar Spirit = function() {\n  this.name = name;\n  this.attackObj = new Attack(this);\n};\n\nSpirit.prototype.attack = function (type) {\n  this.attackObj.start(type);\n}\n\nvar spirit = new Spirit('RYU');\nspirit.attack('waveBoxing'); // RYU: 使用波动拳\nspirit.attack('whirlKick'); // RYU: 使用旋风腿\n```\n\n[⤴️Go Top](#)\n\n### 退出多重循环\n\n使用 `return` 退出多重循环. 一定程度上能简化代码, 使代码更容易理解.\n\n**例子:**\n\n```js\n// 需求: 假设在一个函数体内的多重循环内, 达到某个临界条件时退出循环\n\nvar func = function () {\n  var flag = false;\n  for (var i = 0; i < 10; i++) {\n    for (var j = 0; j < 10; j++) {\n      if (i * j > 30) {\n        flag = true;\n        break;\n      }\n    }\n  }\n};\n\n// 这种代码看着就头晕目眩, 重构如下:\n\nvar func = function () {\n  for (var i = 0; i < 10; i++) {\n    for (var j = 0; j < 10; j++) {\n      if (i * j > 30) {\n        return;\n      }\n    }\n  }\n};\n```\n\n直接使用 `return` 后, 后面的代码无法执行, 还是有点小问题的:\n\n```js\nvar func = function () {\n  for (var i = 0; i < 10; i++) {\n    for (var j = 0; j < 10; j++) {\n      if (i * j > 30) {\n        return;\n      }\n    }\n  }\n  console.log(i) // 无法执行\n};\n```\n\n为了解决这个问题, 我们可以把相关的代码放到 `return` 后面. 如果需要执行的代码较多, 可以提取成一个函数:\n\n```js\nvar print = function (i) {\n  console.log(i)\n};\n\nvar func = function () {\n  for (var i = 0; i < 10; i++) {\n    for (var j = 0; j < 10; j++) {\n      if (i * j > 30) {\n        return print(i); // 执行\n      }\n    }\n  }\n};\n```\n\n[⤴️Go Top](#)\n","source":"_posts/代码重构.md","raw":"---\ntitle: 代码重构\ncomments: true\ndate: 2018-06-16 22:46:36\ntags:\nfrom:\n---\n\n今天读了曾探的[《设计模式》](https://book.douban.com/subject/26382780/)中的代码重构这一章节, 知识点不多却非常实用, 在实际项目中除了使用设计模式重构代码外, 还有一些容易忽略的细节. 这些细节也是重构的重要手段. 写这篇文章总结一下.\n\n<!-- more -->\n\n> 代码是写给人看的, 顺便给机器运行. 优雅的代码应该是简单、易维护、可扩展的.\n\n### 提炼函数\n\n如果一个函数过长, 而且需要注释才清楚它是如何工作的, 那么需要考虑把它独立出来. 这样做的好处是:\n\n* 避免超大函数, 作用域过大变量不好维护\n* 抽离公共逻辑, 易于复用和覆写\n* 良好的命名起到了注释作用\n\n**例子:**\n\n```js\nconst getUserInfo = () => {\n  fetch('https://xxx.com/userInfo', (data) => {\n    console.log(`\n      userId: ${data.userId}\\n\n      userName: ${data.userName}\\n\n      nickName: ${data.NickName}\n    `);\n  });\n};\n```\n\n重构如下:\n\n```js\nconst printDetail = (data) => {\n    console.log(`\n    userId: ${data.userId}\\n\n    userName: ${data.userName}\\n\n    nickName: ${data.NickName}\n  `);\n}\n\nconst getUserInfo = () => {\n  fetch('https://xxx.com/userInfo', (data) => {\n    printDetail(data);\n  });\n};\n```\n\n[⤴️Go Top](#)\n\n### 合并重复的条件片段\n\n如果一个函数体内有一些条件分支, 而且这些条件分支内散布了一些重复的代码, 这个时候就有必要进行合并去重操作.\n\n**例子:**\n\n```js\nconst paging = (currPage) => {\n  if (currPage <= 0) {\n    currPage = 0;\n    jump(currPage); // 跳转\n  } else if (currPage >= totalPage) {\n    currPage = totalPage;\n    jump(currPage); // 跳转\n  } else {\n    jump(currPage); // 跳转\n  }\n};\n```\n\n可以看到上面的 `jump(currPage)` 重复了, 完全可以把它独立出来:\n\n```js\nconst paging = (currPage) => {\n  if (currPage <= 0) {\n    currPage = 0;\n  } else if (currPage >= totalPage) {\n    currPage = totalPage;\n  }\n  jump(currPage);\n}\n```\n\n[⤴️Go Top](#)\n\n### 把条件分支语句提炼成函数\n\n复杂的条件分支语句是导致程序难以阅读和理解的重要原因, 而且很容易导致一个庞大的函数. 这种情况下就需要把条件分支语句提炼出来.\n\n**例子:**\n\n```js\n// 需求: 如果当季是处于夏季, 那么所有的商品 8 折出售\n\nconst getPrice = (price) => {\n  const date = new Date();\n  if (date.getMonth() >= 6 && date.getMonth() <= 9) { // 夏季\n    return price * 0.8;\n  }\n  return price;\n};\n```\n\n观察这段代码:\n\n```js\nif (date.getMonth() >= 6 && date.getMonth() <= 9) { // 夏季\n  // ...\n}\n```\n\n我们需要让它更符合语义, 这样读代码的人能很轻松理解意图, 这里就可以提炼成一个单独函数.\n\n```js\nconst isSummer = () => {\n  const date = new Date();\n  return date.getMonth() >= 6 && date.getMonth() <= 9;\n};\n\nconst getPrice = (price) => {\n  const date = new Date();\n  if (isSummer()) {\n    return price * 0.8;\n  }\n  return price;\n};\n```\n\n[⤴️Go Top](#)\n\n### 合理的使用循环\n\n在函数体内, 如果一些代码只是完成一些重复的工作, 那么可以合理利用循环完成同样的功能, 这样可以保持代码量更少.\n\n**例子:**\n\n```js\n// 需求: IE9 以下创建一个 XHR 对象\n\nvar createXHR = function() {\n  var xhr;\n  try {\n    xhr = new ActiveXObject('MSXML2.XMLHttp.6.0');\n  } catch(e) {\n    try {\n      xhr = new ActiveXObject('MSXML2.XMLHttp.3.0')\n    } catch(e) {\n      xhr = new ActiveXObject('MSXML2.XMLHttp');\n    }\n  }\n  return xhr;\n};\n\nvar xhr = createXHR();\n```\n\n这个时候, 使用循环来优化上面的代码:\n\n```js\n// 这段代码就看着符合语义了, 而且好理解 🤡\n\nvar createXHR = function() {\n  var versions = ['MSXML2.XMLHttp.6.0', 'MSXML2.XMLHttp.3.0', 'MSXML2.XMLHttp'];\n  for (var i = 0, version; version = versions[i++];) {\n    try {\n      return new ActiveXObject(version);\n    } catch(e) {};\n  }\n};\n\nvar xhr = createXHR();\n```\n\n[⤴️Go Top](#)\n\n### 提前让函数退出代替嵌套条件分支\n\n很多程序员👨‍💻‍都有这种观念 \"每个函数只能有一个入口和一个出口\", 但是关于 \"函数只有一个出口\" 往往有一些不同的看法, 下面用代码来说明一下, 光讲概念有点晦涩.\n\n**例子:**\n\n```js\n// 下面是 \"函数只有一个出口\" 的典型代码\n\nconst del = (obj) => {\n  let ret;\n  if (!obj.isReadOnly) {\n    if (obj.isFolder) {\n      ret = delFolder(obj);\n    } else if (obj.isFile) {\n      ret = delFile(obj);\n    }\n  }\n  return ret;\n};\n```\n\n嵌套的条件分支绝对是代码维护者的噩梦, 多层嵌套的条件更加不容易理解, 有时候如果代码过长, 上一个 `if ()` 语句可能相隔很远. 严重影响了阅读体验啊. 重构的 `del` 函数如下:\n\n```js\nconst del = (obj) => {\n  if (obj.isReadOnly) { // 反转 if\n    return;\n  }\n  if (obj.isFolder) {\n    return delFolder(obj);\n  }\n  if (obj.isFile) {\n    return delFile(obj);\n  }\n};\n\n// 瞬间清爽 👌\n```\n\n[⤴️Go Top](#)\n\n### 传递对象参数代替过长的参数列表\n\n有时候一个函数可能接收多个参数, 而且参数越多, 就越难理解和使用. 最重要的一点需要注意参数的顺序, 如果不传的情况要使用占位符代替. 如果参数超过 3 个, 请使用对象吧.\n\n**例子:**\n\n```js\nconst setUserInfo = (id, name, address, sex, mobile, qq) => {\n  // ...\n}\n\n// 调用 ☹️:\nsetUserInfo(1, 'ifyour', undefined, 'male', undefined, '123456');\n\n\n// 重构 😁:\nsetUserInfo({\n  id: 1,\n  name: 'ifyour',\n  sex: 'male',\n  qq: '123456',\n})\n```\n\n[⤴️Go Top](#)\n\n### 尽量减少参数数量\n\n如果调用一个函数, 需要传递很多参数, 这样的函数用起来就要小心了, 必须搞清楚每个参数的含义, 所以, 如果能尽量少传参数就少传参数. 把复杂的逻辑封装到函数内部.\n\n**例子:**\n\n```js\n// 需求: 有一个画图函数 draw\n\nconst draw = (width, height, square) => {\n  // ...\n};\n\n// 优化如下:\nconst draw = (width, height) => {\n  const square = width * height;\n  // ...\n}\n```\n\n这里的 `square` 参数没必要, 可以通过 `width` 和 `height` 计算获得, 还有一种情况, 这个画图函数, 如果可以画多种图形呢? 所以需要在内部去处理, 什么时候需要 `square` 什么时候需要 `radius`, 然后可以使用 **策略模式** 让它支持画多种图形.\n\n[⤴️Go Top](#)\n\n### 少用三目运算\n\n三目运算能减少代码量, 但是不能滥用, 如果以牺牲代码可读性为代价, 那就得不偿失了.\n\n```js\nconst global = typeof window !== 'undefined' ? window : this;\n\n// 但是这种情况就完全没必要了, 老实写 if..else...\n\nif (!aup || !bup) {\n  return a === doc ? -1 :\n    b === doc ? 1 :\n    aup ? -1 :\n    bup ? 1 :\n    sortInput ?\n    (indexOf.call(sortInput, a) - indexOf.call(sortInput, b)) :\n    0;\n}\n\n// 😡 这是人看的吗\n```\n\n[⤴️Go Top](#)\n\n### 合理使用链式调用\n\njQuery 中的链式调用用起来还是很爽的, 它的实现也非常简单, 我们可以很容易的实现一个链式调用. 使用的前提就是链条的结构相对来说稳定, 不容易发生修改, 如果是经常发生修改的话, 还是建议使用普通的调用. 因为它调试的时候需要把这个链子拆开, 才知道是哪个环节有 Bug.\n\n**例子:**\n\n```js\n// ES5\n\nvar User = function() {\n  this.id = null;\n  this.name = null;\n};\n\nUser.prototype.setId = function (id) {\n  this.id = id;\n  return this; // 返回实例本身\n}\n\nUser.prototype.setName = function (name) {\n  this.name = name;\n  return this;\n}\n\n// 链式调用\nnew User()\n  .setId(1)\n  .setNmae('ifyour');\n```\n\n或者这样:\n\n```js\nvar User = {\n  id: null,\n  name: null,\n  setId: function(id) {\n    this.id = id;\n    return this;\n  },\n  setName: function(name) {\n    this.name = name;\n    return this;\n  }\n};\n\nUser.setId(1).setName('ifyour');\n```\n\n[⤴️Go Top](#)\n\n### 分解大型类\n\n从字面意思我们就能理解, 如果一个类里面有太多的方法, 我们要考虑把其中同一类型相关的方法抽离出来. 模块化的好处不言而喻, 把逻辑复杂的分离成小的单元, 这样更便于维护, 出现 bug 了也好定位问题. 来看一段代码.\n\n**例子:**\n\n```js\n// 英雄类\nvar Spirit = function() {\n  this.name = name;\n};\n\n// 原型上的攻击方法\nSpirit.prototype.attack = function (type) {\n  if (type === 'waveBoxing') {\n    console.log(this.name + ': 使用波动拳');\n  } else if (type === 'whirlKick') {\n    console.log(this.name + ': 使用旋风腿');\n  }\n  // ... 还有很多攻击方法\n}\n\nvar spirit = new Spirit('RYU');\nspirit.attack('waveBoxing'); // RYU: 使用波动拳\nspirit.attack('whirlKick'); // RYU: 使用旋风腿\n```\n\n面向对象的设计鼓励将 **行为** 分解到合理数量的更小的对象中:\n\n```js\nvar Attack = function (spirit) {\n  this.spirit = spirit;\n};\n\nAttack.prototype.start = function (type) {\n  return this.list[type].call(this);\n}\n\nAttack.prototype.list = {\n  waveBoxing: function () {\n    console.log(this.sprite.name + ': 使用波动拳')\n  },\n  whirlKick: function () {\n    console.log(this.sprite.name + ': 使用旋风腿')\n  }\n}\n```\n\n现在 Sprite 类精简了很多, 不再直接包含攻击相关的方法, 而是把方法委托给 Attack 类来执行. 这段代码也是 **策略模式** 的运用之一, 看代码:\n\n```js\nvar Spirit = function() {\n  this.name = name;\n  this.attackObj = new Attack(this);\n};\n\nSpirit.prototype.attack = function (type) {\n  this.attackObj.start(type);\n}\n\nvar spirit = new Spirit('RYU');\nspirit.attack('waveBoxing'); // RYU: 使用波动拳\nspirit.attack('whirlKick'); // RYU: 使用旋风腿\n```\n\n[⤴️Go Top](#)\n\n### 退出多重循环\n\n使用 `return` 退出多重循环. 一定程度上能简化代码, 使代码更容易理解.\n\n**例子:**\n\n```js\n// 需求: 假设在一个函数体内的多重循环内, 达到某个临界条件时退出循环\n\nvar func = function () {\n  var flag = false;\n  for (var i = 0; i < 10; i++) {\n    for (var j = 0; j < 10; j++) {\n      if (i * j > 30) {\n        flag = true;\n        break;\n      }\n    }\n  }\n};\n\n// 这种代码看着就头晕目眩, 重构如下:\n\nvar func = function () {\n  for (var i = 0; i < 10; i++) {\n    for (var j = 0; j < 10; j++) {\n      if (i * j > 30) {\n        return;\n      }\n    }\n  }\n};\n```\n\n直接使用 `return` 后, 后面的代码无法执行, 还是有点小问题的:\n\n```js\nvar func = function () {\n  for (var i = 0; i < 10; i++) {\n    for (var j = 0; j < 10; j++) {\n      if (i * j > 30) {\n        return;\n      }\n    }\n  }\n  console.log(i) // 无法执行\n};\n```\n\n为了解决这个问题, 我们可以把相关的代码放到 `return` 后面. 如果需要执行的代码较多, 可以提取成一个函数:\n\n```js\nvar print = function (i) {\n  console.log(i)\n};\n\nvar func = function () {\n  for (var i = 0; i < 10; i++) {\n    for (var j = 0; j < 10; j++) {\n      if (i * j > 30) {\n        return print(i); // 执行\n      }\n    }\n  }\n};\n```\n\n[⤴️Go Top](#)\n","slug":"代码重构","published":1,"updated":"2019-12-07T04:53:18.094Z","layout":"post","photos":[],"link":"","_id":"ck3v60jtl000mr9q9z7s5oot3","content":"<p>今天读了曾探的<a href=\"https://book.douban.com/subject/26382780/\" target=\"_blank\" rel=\"noopener\">《设计模式》</a>中的代码重构这一章节, 知识点不多却非常实用, 在实际项目中除了使用设计模式重构代码外, 还有一些容易忽略的细节. 这些细节也是重构的重要手段. 写这篇文章总结一下.</p>\n<a id=\"more\"></a>\n<blockquote>\n<p>代码是写给人看的, 顺便给机器运行. 优雅的代码应该是简单、易维护、可扩展的.</p>\n</blockquote>\n<h3 id=\"提炼函数\"><a href=\"#提炼函数\" class=\"headerlink\" title=\"提炼函数\"></a>提炼函数</h3><p>如果一个函数过长, 而且需要注释才清楚它是如何工作的, 那么需要考虑把它独立出来. 这样做的好处是:</p>\n<ul>\n<li>避免超大函数, 作用域过大变量不好维护</li>\n<li>抽离公共逻辑, 易于复用和覆写</li>\n<li>良好的命名起到了注释作用</li>\n</ul>\n<p><strong>例子:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> getUserInfo = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  fetch(<span class=\"string\">'https://xxx.com/userInfo'</span>, (data) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">      userId: <span class=\"subst\">$&#123;data.userId&#125;</span>\\n</span></span><br><span class=\"line\"><span class=\"string\">      userName: <span class=\"subst\">$&#123;data.userName&#125;</span>\\n</span></span><br><span class=\"line\"><span class=\"string\">      nickName: <span class=\"subst\">$&#123;data.NickName&#125;</span></span></span><br><span class=\"line\"><span class=\"string\">    `</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>重构如下:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> printDetail = <span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">    userId: <span class=\"subst\">$&#123;data.userId&#125;</span>\\n</span></span><br><span class=\"line\"><span class=\"string\">    userName: <span class=\"subst\">$&#123;data.userName&#125;</span>\\n</span></span><br><span class=\"line\"><span class=\"string\">    nickName: <span class=\"subst\">$&#123;data.NickName&#125;</span></span></span><br><span class=\"line\"><span class=\"string\">  `</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> getUserInfo = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  fetch(<span class=\"string\">'https://xxx.com/userInfo'</span>, (data) =&gt; &#123;</span><br><span class=\"line\">    printDetail(data);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><a href=\"#\">⤴️Go Top</a></p>\n<h3 id=\"合并重复的条件片段\"><a href=\"#合并重复的条件片段\" class=\"headerlink\" title=\"合并重复的条件片段\"></a>合并重复的条件片段</h3><p>如果一个函数体内有一些条件分支, 而且这些条件分支内散布了一些重复的代码, 这个时候就有必要进行合并去重操作.</p>\n<p><strong>例子:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> paging = <span class=\"function\">(<span class=\"params\">currPage</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (currPage &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    currPage = <span class=\"number\">0</span>;</span><br><span class=\"line\">    jump(currPage); <span class=\"comment\">// 跳转</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (currPage &gt;= totalPage) &#123;</span><br><span class=\"line\">    currPage = totalPage;</span><br><span class=\"line\">    jump(currPage); <span class=\"comment\">// 跳转</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    jump(currPage); <span class=\"comment\">// 跳转</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>可以看到上面的 <code>jump(currPage)</code> 重复了, 完全可以把它独立出来:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> paging = <span class=\"function\">(<span class=\"params\">currPage</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (currPage &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    currPage = <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (currPage &gt;= totalPage) &#123;</span><br><span class=\"line\">    currPage = totalPage;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  jump(currPage);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"#\">⤴️Go Top</a></p>\n<h3 id=\"把条件分支语句提炼成函数\"><a href=\"#把条件分支语句提炼成函数\" class=\"headerlink\" title=\"把条件分支语句提炼成函数\"></a>把条件分支语句提炼成函数</h3><p>复杂的条件分支语句是导致程序难以阅读和理解的重要原因, 而且很容易导致一个庞大的函数. 这种情况下就需要把条件分支语句提炼出来.</p>\n<p><strong>例子:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 需求: 如果当季是处于夏季, 那么所有的商品 8 折出售</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> getPrice = <span class=\"function\">(<span class=\"params\">price</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> date = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (date.getMonth() &gt;= <span class=\"number\">6</span> &amp;&amp; date.getMonth() &lt;= <span class=\"number\">9</span>) &#123; <span class=\"comment\">// 夏季</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> price * <span class=\"number\">0.8</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> price;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>观察这段代码:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (date.getMonth() &gt;= <span class=\"number\">6</span> &amp;&amp; date.getMonth() &lt;= <span class=\"number\">9</span>) &#123; <span class=\"comment\">// 夏季</span></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们需要让它更符合语义, 这样读代码的人能很轻松理解意图, 这里就可以提炼成一个单独函数.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> isSummer = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> date = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> date.getMonth() &gt;= <span class=\"number\">6</span> &amp;&amp; date.getMonth() &lt;= <span class=\"number\">9</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> getPrice = <span class=\"function\">(<span class=\"params\">price</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> date = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isSummer()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> price * <span class=\"number\">0.8</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> price;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><a href=\"#\">⤴️Go Top</a></p>\n<h3 id=\"合理的使用循环\"><a href=\"#合理的使用循环\" class=\"headerlink\" title=\"合理的使用循环\"></a>合理的使用循环</h3><p>在函数体内, 如果一些代码只是完成一些重复的工作, 那么可以合理利用循环完成同样的功能, 这样可以保持代码量更少.</p>\n<p><strong>例子:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 需求: IE9 以下创建一个 XHR 对象</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> createXHR = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> xhr;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    xhr = <span class=\"keyword\">new</span> ActiveXObject(<span class=\"string\">'MSXML2.XMLHttp.6.0'</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      xhr = <span class=\"keyword\">new</span> ActiveXObject(<span class=\"string\">'MSXML2.XMLHttp.3.0'</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">      xhr = <span class=\"keyword\">new</span> ActiveXObject(<span class=\"string\">'MSXML2.XMLHttp'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> xhr;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> xhr = createXHR();</span><br></pre></td></tr></table></figure>\n<p>这个时候, 使用循环来优化上面的代码:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这段代码就看着符合语义了, 而且好理解 🤡</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> createXHR = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> versions = [<span class=\"string\">'MSXML2.XMLHttp.6.0'</span>, <span class=\"string\">'MSXML2.XMLHttp.3.0'</span>, <span class=\"string\">'MSXML2.XMLHttp'</span>];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, version; version = versions[i++];) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ActiveXObject(version);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(e) &#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> xhr = createXHR();</span><br></pre></td></tr></table></figure>\n<p><a href=\"#\">⤴️Go Top</a></p>\n<h3 id=\"提前让函数退出代替嵌套条件分支\"><a href=\"#提前让函数退出代替嵌套条件分支\" class=\"headerlink\" title=\"提前让函数退出代替嵌套条件分支\"></a>提前让函数退出代替嵌套条件分支</h3><p>很多程序员👨‍💻‍都有这种观念 “每个函数只能有一个入口和一个出口”, 但是关于 “函数只有一个出口” 往往有一些不同的看法, 下面用代码来说明一下, 光讲概念有点晦涩.</p>\n<p><strong>例子:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 下面是 \"函数只有一个出口\" 的典型代码</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> del = <span class=\"function\">(<span class=\"params\">obj</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> ret;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!obj.isReadOnly) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj.isFolder) &#123;</span><br><span class=\"line\">      ret = delFolder(obj);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (obj.isFile) &#123;</span><br><span class=\"line\">      ret = delFile(obj);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>嵌套的条件分支绝对是代码维护者的噩梦, 多层嵌套的条件更加不容易理解, 有时候如果代码过长, 上一个 <code>if ()</code> 语句可能相隔很远. 严重影响了阅读体验啊. 重构的 <code>del</code> 函数如下:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> del = <span class=\"function\">(<span class=\"params\">obj</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (obj.isReadOnly) &#123; <span class=\"comment\">// 反转 if</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (obj.isFolder) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> delFolder(obj);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (obj.isFile) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> delFile(obj);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 瞬间清爽 👌</span></span><br></pre></td></tr></table></figure>\n<p><a href=\"#\">⤴️Go Top</a></p>\n<h3 id=\"传递对象参数代替过长的参数列表\"><a href=\"#传递对象参数代替过长的参数列表\" class=\"headerlink\" title=\"传递对象参数代替过长的参数列表\"></a>传递对象参数代替过长的参数列表</h3><p>有时候一个函数可能接收多个参数, 而且参数越多, 就越难理解和使用. 最重要的一点需要注意参数的顺序, 如果不传的情况要使用占位符代替. 如果参数超过 3 个, 请使用对象吧.</p>\n<p><strong>例子:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> setUserInfo = <span class=\"function\">(<span class=\"params\">id, name, address, sex, mobile, qq</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用 ☹️:</span></span><br><span class=\"line\">setUserInfo(<span class=\"number\">1</span>, <span class=\"string\">'ifyour'</span>, <span class=\"literal\">undefined</span>, <span class=\"string\">'male'</span>, <span class=\"literal\">undefined</span>, <span class=\"string\">'123456'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 重构 😁:</span></span><br><span class=\"line\">setUserInfo(&#123;</span><br><span class=\"line\">  id: <span class=\"number\">1</span>,</span><br><span class=\"line\">  name: <span class=\"string\">'ifyour'</span>,</span><br><span class=\"line\">  sex: <span class=\"string\">'male'</span>,</span><br><span class=\"line\">  qq: <span class=\"string\">'123456'</span>,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p><a href=\"#\">⤴️Go Top</a></p>\n<h3 id=\"尽量减少参数数量\"><a href=\"#尽量减少参数数量\" class=\"headerlink\" title=\"尽量减少参数数量\"></a>尽量减少参数数量</h3><p>如果调用一个函数, 需要传递很多参数, 这样的函数用起来就要小心了, 必须搞清楚每个参数的含义, 所以, 如果能尽量少传参数就少传参数. 把复杂的逻辑封装到函数内部.</p>\n<p><strong>例子:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 需求: 有一个画图函数 draw</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> draw = <span class=\"function\">(<span class=\"params\">width, height, square</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 优化如下:</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> draw = <span class=\"function\">(<span class=\"params\">width, height</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> square = width * height;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的 <code>square</code> 参数没必要, 可以通过 <code>width</code> 和 <code>height</code> 计算获得, 还有一种情况, 这个画图函数, 如果可以画多种图形呢? 所以需要在内部去处理, 什么时候需要 <code>square</code> 什么时候需要 <code>radius</code>, 然后可以使用 <strong>策略模式</strong> 让它支持画多种图形.</p>\n<p><a href=\"#\">⤴️Go Top</a></p>\n<h3 id=\"少用三目运算\"><a href=\"#少用三目运算\" class=\"headerlink\" title=\"少用三目运算\"></a>少用三目运算</h3><p>三目运算能减少代码量, 但是不能滥用, 如果以牺牲代码可读性为代价, 那就得不偿失了.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> global = <span class=\"keyword\">typeof</span> <span class=\"built_in\">window</span> !== <span class=\"string\">'undefined'</span> ? <span class=\"built_in\">window</span> : <span class=\"keyword\">this</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 但是这种情况就完全没必要了, 老实写 if..else...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!aup || !bup) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a === doc ? <span class=\"number\">-1</span> :</span><br><span class=\"line\">    b === doc ? <span class=\"number\">1</span> :</span><br><span class=\"line\">    aup ? <span class=\"number\">-1</span> :</span><br><span class=\"line\">    bup ? <span class=\"number\">1</span> :</span><br><span class=\"line\">    sortInput ?</span><br><span class=\"line\">    (indexOf.call(sortInput, a) - indexOf.call(sortInput, b)) :</span><br><span class=\"line\">    <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 😡 这是人看的吗</span></span><br></pre></td></tr></table></figure>\n<p><a href=\"#\">⤴️Go Top</a></p>\n<h3 id=\"合理使用链式调用\"><a href=\"#合理使用链式调用\" class=\"headerlink\" title=\"合理使用链式调用\"></a>合理使用链式调用</h3><p>jQuery 中的链式调用用起来还是很爽的, 它的实现也非常简单, 我们可以很容易的实现一个链式调用. 使用的前提就是链条的结构相对来说稳定, 不容易发生修改, 如果是经常发生修改的话, 还是建议使用普通的调用. 因为它调试的时候需要把这个链子拆开, 才知道是哪个环节有 Bug.</p>\n<p><strong>例子:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> User = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.id = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">User.prototype.setId = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>; <span class=\"comment\">// 返回实例本身</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">User.prototype.setName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 链式调用</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> User()</span><br><span class=\"line\">  .setId(<span class=\"number\">1</span>)</span><br><span class=\"line\">  .setNmae(<span class=\"string\">'ifyour'</span>);</span><br></pre></td></tr></table></figure>\n<p>或者这样:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> User = &#123;</span><br><span class=\"line\">  id: <span class=\"literal\">null</span>,</span><br><span class=\"line\">  name: <span class=\"literal\">null</span>,</span><br><span class=\"line\">  setId: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  setName: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">User.setId(<span class=\"number\">1</span>).setName(<span class=\"string\">'ifyour'</span>);</span><br></pre></td></tr></table></figure>\n<p><a href=\"#\">⤴️Go Top</a></p>\n<h3 id=\"分解大型类\"><a href=\"#分解大型类\" class=\"headerlink\" title=\"分解大型类\"></a>分解大型类</h3><p>从字面意思我们就能理解, 如果一个类里面有太多的方法, 我们要考虑把其中同一类型相关的方法抽离出来. 模块化的好处不言而喻, 把逻辑复杂的分离成小的单元, 这样更便于维护, 出现 bug 了也好定位问题. 来看一段代码.</p>\n<p><strong>例子:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 英雄类</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Spirit = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 原型上的攻击方法</span></span><br><span class=\"line\">Spirit.prototype.attack = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">type</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (type === <span class=\"string\">'waveBoxing'</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">': 使用波动拳'</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (type === <span class=\"string\">'whirlKick'</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">': 使用旋风腿'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// ... 还有很多攻击方法</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> spirit = <span class=\"keyword\">new</span> Spirit(<span class=\"string\">'RYU'</span>);</span><br><span class=\"line\">spirit.attack(<span class=\"string\">'waveBoxing'</span>); <span class=\"comment\">// RYU: 使用波动拳</span></span><br><span class=\"line\">spirit.attack(<span class=\"string\">'whirlKick'</span>); <span class=\"comment\">// RYU: 使用旋风腿</span></span><br></pre></td></tr></table></figure>\n<p>面向对象的设计鼓励将 <strong>行为</strong> 分解到合理数量的更小的对象中:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Attack = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">spirit</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.spirit = spirit;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Attack.prototype.start = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">type</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.list[type].call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Attack.prototype.list = &#123;</span><br><span class=\"line\">  waveBoxing: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.sprite.name + <span class=\"string\">': 使用波动拳'</span>)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  whirlKick: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.sprite.name + <span class=\"string\">': 使用旋风腿'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在 Sprite 类精简了很多, 不再直接包含攻击相关的方法, 而是把方法委托给 Attack 类来执行. 这段代码也是 <strong>策略模式</strong> 的运用之一, 看代码:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Spirit = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.attackObj = <span class=\"keyword\">new</span> Attack(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Spirit.prototype.attack = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">type</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.attackObj.start(type);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> spirit = <span class=\"keyword\">new</span> Spirit(<span class=\"string\">'RYU'</span>);</span><br><span class=\"line\">spirit.attack(<span class=\"string\">'waveBoxing'</span>); <span class=\"comment\">// RYU: 使用波动拳</span></span><br><span class=\"line\">spirit.attack(<span class=\"string\">'whirlKick'</span>); <span class=\"comment\">// RYU: 使用旋风腿</span></span><br></pre></td></tr></table></figure>\n<p><a href=\"#\">⤴️Go Top</a></p>\n<h3 id=\"退出多重循环\"><a href=\"#退出多重循环\" class=\"headerlink\" title=\"退出多重循环\"></a>退出多重循环</h3><p>使用 <code>return</code> 退出多重循环. 一定程度上能简化代码, 使代码更容易理解.</p>\n<p><strong>例子:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 需求: 假设在一个函数体内的多重循环内, 达到某个临界条件时退出循环</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> flag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">10</span>; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i * j &gt; <span class=\"number\">30</span>) &#123;</span><br><span class=\"line\">        flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这种代码看着就头晕目眩, 重构如下:</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">10</span>; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i * j &gt; <span class=\"number\">30</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>直接使用 <code>return</code> 后, 后面的代码无法执行, 还是有点小问题的:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">10</span>; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i * j &gt; <span class=\"number\">30</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i) <span class=\"comment\">// 无法执行</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>为了解决这个问题, 我们可以把相关的代码放到 <code>return</code> 后面. 如果需要执行的代码较多, 可以提取成一个函数:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> print = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">i</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">10</span>; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i * j &gt; <span class=\"number\">30</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> print(i); <span class=\"comment\">// 执行</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><a href=\"#\">⤴️Go Top</a></p>\n","site":{"data":{}},"excerpt":"<p>今天读了曾探的<a href=\"https://book.douban.com/subject/26382780/\" target=\"_blank\" rel=\"noopener\">《设计模式》</a>中的代码重构这一章节, 知识点不多却非常实用, 在实际项目中除了使用设计模式重构代码外, 还有一些容易忽略的细节. 这些细节也是重构的重要手段. 写这篇文章总结一下.</p>","more":"<blockquote>\n<p>代码是写给人看的, 顺便给机器运行. 优雅的代码应该是简单、易维护、可扩展的.</p>\n</blockquote>\n<h3 id=\"提炼函数\"><a href=\"#提炼函数\" class=\"headerlink\" title=\"提炼函数\"></a>提炼函数</h3><p>如果一个函数过长, 而且需要注释才清楚它是如何工作的, 那么需要考虑把它独立出来. 这样做的好处是:</p>\n<ul>\n<li>避免超大函数, 作用域过大变量不好维护</li>\n<li>抽离公共逻辑, 易于复用和覆写</li>\n<li>良好的命名起到了注释作用</li>\n</ul>\n<p><strong>例子:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> getUserInfo = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  fetch(<span class=\"string\">'https://xxx.com/userInfo'</span>, (data) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">      userId: <span class=\"subst\">$&#123;data.userId&#125;</span>\\n</span></span><br><span class=\"line\"><span class=\"string\">      userName: <span class=\"subst\">$&#123;data.userName&#125;</span>\\n</span></span><br><span class=\"line\"><span class=\"string\">      nickName: <span class=\"subst\">$&#123;data.NickName&#125;</span></span></span><br><span class=\"line\"><span class=\"string\">    `</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>重构如下:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> printDetail = <span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">    userId: <span class=\"subst\">$&#123;data.userId&#125;</span>\\n</span></span><br><span class=\"line\"><span class=\"string\">    userName: <span class=\"subst\">$&#123;data.userName&#125;</span>\\n</span></span><br><span class=\"line\"><span class=\"string\">    nickName: <span class=\"subst\">$&#123;data.NickName&#125;</span></span></span><br><span class=\"line\"><span class=\"string\">  `</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> getUserInfo = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  fetch(<span class=\"string\">'https://xxx.com/userInfo'</span>, (data) =&gt; &#123;</span><br><span class=\"line\">    printDetail(data);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><a href=\"#\">⤴️Go Top</a></p>\n<h3 id=\"合并重复的条件片段\"><a href=\"#合并重复的条件片段\" class=\"headerlink\" title=\"合并重复的条件片段\"></a>合并重复的条件片段</h3><p>如果一个函数体内有一些条件分支, 而且这些条件分支内散布了一些重复的代码, 这个时候就有必要进行合并去重操作.</p>\n<p><strong>例子:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> paging = <span class=\"function\">(<span class=\"params\">currPage</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (currPage &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    currPage = <span class=\"number\">0</span>;</span><br><span class=\"line\">    jump(currPage); <span class=\"comment\">// 跳转</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (currPage &gt;= totalPage) &#123;</span><br><span class=\"line\">    currPage = totalPage;</span><br><span class=\"line\">    jump(currPage); <span class=\"comment\">// 跳转</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    jump(currPage); <span class=\"comment\">// 跳转</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>可以看到上面的 <code>jump(currPage)</code> 重复了, 完全可以把它独立出来:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> paging = <span class=\"function\">(<span class=\"params\">currPage</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (currPage &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    currPage = <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (currPage &gt;= totalPage) &#123;</span><br><span class=\"line\">    currPage = totalPage;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  jump(currPage);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"#\">⤴️Go Top</a></p>\n<h3 id=\"把条件分支语句提炼成函数\"><a href=\"#把条件分支语句提炼成函数\" class=\"headerlink\" title=\"把条件分支语句提炼成函数\"></a>把条件分支语句提炼成函数</h3><p>复杂的条件分支语句是导致程序难以阅读和理解的重要原因, 而且很容易导致一个庞大的函数. 这种情况下就需要把条件分支语句提炼出来.</p>\n<p><strong>例子:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 需求: 如果当季是处于夏季, 那么所有的商品 8 折出售</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> getPrice = <span class=\"function\">(<span class=\"params\">price</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> date = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (date.getMonth() &gt;= <span class=\"number\">6</span> &amp;&amp; date.getMonth() &lt;= <span class=\"number\">9</span>) &#123; <span class=\"comment\">// 夏季</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> price * <span class=\"number\">0.8</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> price;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>观察这段代码:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (date.getMonth() &gt;= <span class=\"number\">6</span> &amp;&amp; date.getMonth() &lt;= <span class=\"number\">9</span>) &#123; <span class=\"comment\">// 夏季</span></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们需要让它更符合语义, 这样读代码的人能很轻松理解意图, 这里就可以提炼成一个单独函数.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> isSummer = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> date = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> date.getMonth() &gt;= <span class=\"number\">6</span> &amp;&amp; date.getMonth() &lt;= <span class=\"number\">9</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> getPrice = <span class=\"function\">(<span class=\"params\">price</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> date = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isSummer()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> price * <span class=\"number\">0.8</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> price;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><a href=\"#\">⤴️Go Top</a></p>\n<h3 id=\"合理的使用循环\"><a href=\"#合理的使用循环\" class=\"headerlink\" title=\"合理的使用循环\"></a>合理的使用循环</h3><p>在函数体内, 如果一些代码只是完成一些重复的工作, 那么可以合理利用循环完成同样的功能, 这样可以保持代码量更少.</p>\n<p><strong>例子:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 需求: IE9 以下创建一个 XHR 对象</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> createXHR = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> xhr;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    xhr = <span class=\"keyword\">new</span> ActiveXObject(<span class=\"string\">'MSXML2.XMLHttp.6.0'</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      xhr = <span class=\"keyword\">new</span> ActiveXObject(<span class=\"string\">'MSXML2.XMLHttp.3.0'</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">      xhr = <span class=\"keyword\">new</span> ActiveXObject(<span class=\"string\">'MSXML2.XMLHttp'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> xhr;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> xhr = createXHR();</span><br></pre></td></tr></table></figure>\n<p>这个时候, 使用循环来优化上面的代码:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这段代码就看着符合语义了, 而且好理解 🤡</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> createXHR = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> versions = [<span class=\"string\">'MSXML2.XMLHttp.6.0'</span>, <span class=\"string\">'MSXML2.XMLHttp.3.0'</span>, <span class=\"string\">'MSXML2.XMLHttp'</span>];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, version; version = versions[i++];) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ActiveXObject(version);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(e) &#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> xhr = createXHR();</span><br></pre></td></tr></table></figure>\n<p><a href=\"#\">⤴️Go Top</a></p>\n<h3 id=\"提前让函数退出代替嵌套条件分支\"><a href=\"#提前让函数退出代替嵌套条件分支\" class=\"headerlink\" title=\"提前让函数退出代替嵌套条件分支\"></a>提前让函数退出代替嵌套条件分支</h3><p>很多程序员👨‍💻‍都有这种观念 “每个函数只能有一个入口和一个出口”, 但是关于 “函数只有一个出口” 往往有一些不同的看法, 下面用代码来说明一下, 光讲概念有点晦涩.</p>\n<p><strong>例子:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 下面是 \"函数只有一个出口\" 的典型代码</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> del = <span class=\"function\">(<span class=\"params\">obj</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> ret;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!obj.isReadOnly) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj.isFolder) &#123;</span><br><span class=\"line\">      ret = delFolder(obj);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (obj.isFile) &#123;</span><br><span class=\"line\">      ret = delFile(obj);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>嵌套的条件分支绝对是代码维护者的噩梦, 多层嵌套的条件更加不容易理解, 有时候如果代码过长, 上一个 <code>if ()</code> 语句可能相隔很远. 严重影响了阅读体验啊. 重构的 <code>del</code> 函数如下:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> del = <span class=\"function\">(<span class=\"params\">obj</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (obj.isReadOnly) &#123; <span class=\"comment\">// 反转 if</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (obj.isFolder) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> delFolder(obj);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (obj.isFile) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> delFile(obj);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 瞬间清爽 👌</span></span><br></pre></td></tr></table></figure>\n<p><a href=\"#\">⤴️Go Top</a></p>\n<h3 id=\"传递对象参数代替过长的参数列表\"><a href=\"#传递对象参数代替过长的参数列表\" class=\"headerlink\" title=\"传递对象参数代替过长的参数列表\"></a>传递对象参数代替过长的参数列表</h3><p>有时候一个函数可能接收多个参数, 而且参数越多, 就越难理解和使用. 最重要的一点需要注意参数的顺序, 如果不传的情况要使用占位符代替. 如果参数超过 3 个, 请使用对象吧.</p>\n<p><strong>例子:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> setUserInfo = <span class=\"function\">(<span class=\"params\">id, name, address, sex, mobile, qq</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用 ☹️:</span></span><br><span class=\"line\">setUserInfo(<span class=\"number\">1</span>, <span class=\"string\">'ifyour'</span>, <span class=\"literal\">undefined</span>, <span class=\"string\">'male'</span>, <span class=\"literal\">undefined</span>, <span class=\"string\">'123456'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 重构 😁:</span></span><br><span class=\"line\">setUserInfo(&#123;</span><br><span class=\"line\">  id: <span class=\"number\">1</span>,</span><br><span class=\"line\">  name: <span class=\"string\">'ifyour'</span>,</span><br><span class=\"line\">  sex: <span class=\"string\">'male'</span>,</span><br><span class=\"line\">  qq: <span class=\"string\">'123456'</span>,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p><a href=\"#\">⤴️Go Top</a></p>\n<h3 id=\"尽量减少参数数量\"><a href=\"#尽量减少参数数量\" class=\"headerlink\" title=\"尽量减少参数数量\"></a>尽量减少参数数量</h3><p>如果调用一个函数, 需要传递很多参数, 这样的函数用起来就要小心了, 必须搞清楚每个参数的含义, 所以, 如果能尽量少传参数就少传参数. 把复杂的逻辑封装到函数内部.</p>\n<p><strong>例子:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 需求: 有一个画图函数 draw</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> draw = <span class=\"function\">(<span class=\"params\">width, height, square</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 优化如下:</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> draw = <span class=\"function\">(<span class=\"params\">width, height</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> square = width * height;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的 <code>square</code> 参数没必要, 可以通过 <code>width</code> 和 <code>height</code> 计算获得, 还有一种情况, 这个画图函数, 如果可以画多种图形呢? 所以需要在内部去处理, 什么时候需要 <code>square</code> 什么时候需要 <code>radius</code>, 然后可以使用 <strong>策略模式</strong> 让它支持画多种图形.</p>\n<p><a href=\"#\">⤴️Go Top</a></p>\n<h3 id=\"少用三目运算\"><a href=\"#少用三目运算\" class=\"headerlink\" title=\"少用三目运算\"></a>少用三目运算</h3><p>三目运算能减少代码量, 但是不能滥用, 如果以牺牲代码可读性为代价, 那就得不偿失了.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> global = <span class=\"keyword\">typeof</span> <span class=\"built_in\">window</span> !== <span class=\"string\">'undefined'</span> ? <span class=\"built_in\">window</span> : <span class=\"keyword\">this</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 但是这种情况就完全没必要了, 老实写 if..else...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!aup || !bup) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a === doc ? <span class=\"number\">-1</span> :</span><br><span class=\"line\">    b === doc ? <span class=\"number\">1</span> :</span><br><span class=\"line\">    aup ? <span class=\"number\">-1</span> :</span><br><span class=\"line\">    bup ? <span class=\"number\">1</span> :</span><br><span class=\"line\">    sortInput ?</span><br><span class=\"line\">    (indexOf.call(sortInput, a) - indexOf.call(sortInput, b)) :</span><br><span class=\"line\">    <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 😡 这是人看的吗</span></span><br></pre></td></tr></table></figure>\n<p><a href=\"#\">⤴️Go Top</a></p>\n<h3 id=\"合理使用链式调用\"><a href=\"#合理使用链式调用\" class=\"headerlink\" title=\"合理使用链式调用\"></a>合理使用链式调用</h3><p>jQuery 中的链式调用用起来还是很爽的, 它的实现也非常简单, 我们可以很容易的实现一个链式调用. 使用的前提就是链条的结构相对来说稳定, 不容易发生修改, 如果是经常发生修改的话, 还是建议使用普通的调用. 因为它调试的时候需要把这个链子拆开, 才知道是哪个环节有 Bug.</p>\n<p><strong>例子:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> User = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.id = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">User.prototype.setId = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>; <span class=\"comment\">// 返回实例本身</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">User.prototype.setName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 链式调用</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> User()</span><br><span class=\"line\">  .setId(<span class=\"number\">1</span>)</span><br><span class=\"line\">  .setNmae(<span class=\"string\">'ifyour'</span>);</span><br></pre></td></tr></table></figure>\n<p>或者这样:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> User = &#123;</span><br><span class=\"line\">  id: <span class=\"literal\">null</span>,</span><br><span class=\"line\">  name: <span class=\"literal\">null</span>,</span><br><span class=\"line\">  setId: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  setName: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">User.setId(<span class=\"number\">1</span>).setName(<span class=\"string\">'ifyour'</span>);</span><br></pre></td></tr></table></figure>\n<p><a href=\"#\">⤴️Go Top</a></p>\n<h3 id=\"分解大型类\"><a href=\"#分解大型类\" class=\"headerlink\" title=\"分解大型类\"></a>分解大型类</h3><p>从字面意思我们就能理解, 如果一个类里面有太多的方法, 我们要考虑把其中同一类型相关的方法抽离出来. 模块化的好处不言而喻, 把逻辑复杂的分离成小的单元, 这样更便于维护, 出现 bug 了也好定位问题. 来看一段代码.</p>\n<p><strong>例子:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 英雄类</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Spirit = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 原型上的攻击方法</span></span><br><span class=\"line\">Spirit.prototype.attack = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">type</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (type === <span class=\"string\">'waveBoxing'</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">': 使用波动拳'</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (type === <span class=\"string\">'whirlKick'</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">': 使用旋风腿'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// ... 还有很多攻击方法</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> spirit = <span class=\"keyword\">new</span> Spirit(<span class=\"string\">'RYU'</span>);</span><br><span class=\"line\">spirit.attack(<span class=\"string\">'waveBoxing'</span>); <span class=\"comment\">// RYU: 使用波动拳</span></span><br><span class=\"line\">spirit.attack(<span class=\"string\">'whirlKick'</span>); <span class=\"comment\">// RYU: 使用旋风腿</span></span><br></pre></td></tr></table></figure>\n<p>面向对象的设计鼓励将 <strong>行为</strong> 分解到合理数量的更小的对象中:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Attack = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">spirit</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.spirit = spirit;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Attack.prototype.start = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">type</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.list[type].call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Attack.prototype.list = &#123;</span><br><span class=\"line\">  waveBoxing: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.sprite.name + <span class=\"string\">': 使用波动拳'</span>)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  whirlKick: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.sprite.name + <span class=\"string\">': 使用旋风腿'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在 Sprite 类精简了很多, 不再直接包含攻击相关的方法, 而是把方法委托给 Attack 类来执行. 这段代码也是 <strong>策略模式</strong> 的运用之一, 看代码:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Spirit = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.attackObj = <span class=\"keyword\">new</span> Attack(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Spirit.prototype.attack = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">type</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.attackObj.start(type);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> spirit = <span class=\"keyword\">new</span> Spirit(<span class=\"string\">'RYU'</span>);</span><br><span class=\"line\">spirit.attack(<span class=\"string\">'waveBoxing'</span>); <span class=\"comment\">// RYU: 使用波动拳</span></span><br><span class=\"line\">spirit.attack(<span class=\"string\">'whirlKick'</span>); <span class=\"comment\">// RYU: 使用旋风腿</span></span><br></pre></td></tr></table></figure>\n<p><a href=\"#\">⤴️Go Top</a></p>\n<h3 id=\"退出多重循环\"><a href=\"#退出多重循环\" class=\"headerlink\" title=\"退出多重循环\"></a>退出多重循环</h3><p>使用 <code>return</code> 退出多重循环. 一定程度上能简化代码, 使代码更容易理解.</p>\n<p><strong>例子:</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 需求: 假设在一个函数体内的多重循环内, 达到某个临界条件时退出循环</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> flag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">10</span>; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i * j &gt; <span class=\"number\">30</span>) &#123;</span><br><span class=\"line\">        flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这种代码看着就头晕目眩, 重构如下:</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">10</span>; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i * j &gt; <span class=\"number\">30</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>直接使用 <code>return</code> 后, 后面的代码无法执行, 还是有点小问题的:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">10</span>; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i * j &gt; <span class=\"number\">30</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i) <span class=\"comment\">// 无法执行</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>为了解决这个问题, 我们可以把相关的代码放到 <code>return</code> 后面. 如果需要执行的代码较多, 可以提取成一个函数:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> print = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">i</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">10</span>; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i * j &gt; <span class=\"number\">30</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> print(i); <span class=\"comment\">// 执行</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><a href=\"#\">⤴️Go Top</a></p>"},{"title":"前后端鉴权方式总结","comments":1,"date":"2018-11-25T05:02:34.000Z","from":null,"_content":"\n今天来学习下常见的鉴权方式，从最开始了解的最简单的 Cookie 验证，到后来的 Session-cookie、Token 等，整体来说，安全性越来越高。当然还是对部分方式了解不是很深，这里做个简单总结，查漏补缺。\n\n<!-- more -->\n\n目前我们常用的鉴权有四种：\n\n1. HTTP Basic Authentication\n2. Session-cookie\n3. Token 验证\n4. OAuth(开放授权)\n\n### HTTP Basic Authentication\n\n这种授权方式是浏览器遵守 HTTP 协议实现的基本授权方式，HTTP 协议进行通信的过程中，HTTP 协议定义了基本认证认证允许 HTTP 服务器对客户端进行用户身份证的方法。\n\n#### 认证过程\n\n- 1️⃣ 客户端向服务器请求数据，请求的内容可能是一个网页或者是一个 ajax 异步请求，此时，假设客户端尚未被验证，则客户端提供如下请求至服务器：\n\n```text\nGet /index.html HTTP/1.0\nHost:www.google.com\n```\n\n- 2️⃣ 服务器向客户端发送验证请求代码 401，(`WWW-Authenticate: Basic realm=\"google.com\"` 这句话是关键，如果没有客户端不会弹出用户名和密码输入界面）服务器返回的数据如下：\n\n```text\nHTTP/1.0 401 Unauthorised\nServer: SokEvo/1.0\nWWW-Authenticate: Basic realm=\"google.com\"\nContent-Type: text/html\nContent-Length: xxx\n```\n\n- 3️⃣ 当符合 http1.0 或 1.1 规范的客户端（如 IE，FIREFOX）收到 401 返回值时，将自动弹出一个登录窗口，要求用户输入用户名和密码。\n\n- 4️⃣ 用户输入用户名和密码后，将用户名及密码以 BASE64 加密方式加密，并将密文放入前一条请求信息中，则客户端发送的第一条请求信息则变成如下内容：\n\n```text\nGet /index.html HTTP/1.0\nHost:www.google.com\nAuthorization: Basic d2FuZzp3YW5n\n```\n\n<div class=\"tip\">\n`d2FuZzp3YW5n` 表示加密后的用户名及密码（用户名：密码 然后通过 base64 加密，加密过程是浏览器默认的行为，不需要我们人为加密，我们只需要输入用户名密码即可）\n</div>\n\n- 5️⃣ 服务器收到上述请求信息后，将 Authorization 字段后的用户信息取出、解密，将解密后的用户名及密码与用户数据库进行比较验证，如用户名及密码正确，服务器则根据请求，将所请求资源发送给客户端。\n\n客户端未未认证的时候，会弹出用户名密码输入框，这个时候请求时属于 pending 状态，这个时候其实服务当用户输入用户名密码的时候客户端会再次发送带 Authentication 头的请求。\n\n请求认证 👇\n![image](https://user-images.githubusercontent.com/15377484/48976178-136a0300-f0bd-11e8-9fd6-b2e67d22bbc6.png)\n\n认证成功 👇\n![image](https://user-images.githubusercontent.com/15377484/48976167-d1d95800-f0bc-11e8-80fa-35c636dbc103.png)\n\n#### 完整代码\n\n**Server.js**\n\n```js\nlet express = require('express');\nlet app = express();\n\napp.use(express.static(__dirname + '/public'));\napp.get('/Authentication_base', function(req, res) {\n  console.log('req.headers.authorization:', req.headers);\n  if (!req.headers.authorization) {\n    res.set({\n      'WWW-Authenticate': 'Basic realm=\"wang\"'\n    });\n    res.status(401).end();\n  } else {\n    let base64 = req.headers.authorization.split(' ')[1];\n    let userPass = new Buffer(base64, 'base64').toString().split(':');\n    let user = userPass[0];\n    let pass = userPass[1];\n    if (user === 'wang' && pass === 'wang') {\n      res.end('OK');\n    } else {\n      res.status(401).end();\n    }\n  }\n});\n\napp.listen(9090);\n```\n\n**index.html**\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\" />\n    <title>HTTP Basic Authentication</title>\n  </head>\n  <body>\n    <div></div>\n    <script src=\"js/jquery-3.2.1.js\"></script>\n    <script>\n      $(function() {\n        send('./Authentication_base');\n      });\n      var send = function(url) {\n        $.ajax({\n          url: url,\n          method: 'GET'\n        });\n      };\n    </script>\n  </body>\n</html>\n```\n\n当然有登陆就有注销，我们会发现当我们认证成功后每次请求请求头都会带上 Authentication 及里面的内容，那么如何做到让这次登陆失效的？\n\n网上查了半天，目前最有效的方式就是在注销操作的时候，专门在服务器设置一个专门的注销账号，当接收到的 Authentication 信息为注销用户名密码的时候纠就带便注销成功了，而客户端在注销操作的时候，手动的的去修改请求头重的 Authentication，将他设置未服务器默认的注销账号和密码。\n\n通过上面的简单讲解 其实我们已经可以返现这种验证方式的缺陷加密方式简单，仅仅是 base64 加密，这种加密方式是可逆的。同时在每个请求的头上都会附带上用户名和密码信息，这样在外网是很容易被嗅探器探测到的。\n\n正式因为这样，这种加密方式一般多被用在内部安全性要求不高的的系统上，只是相对的多，总的来说现在使用这种鉴权比较少了。如果项目需要部署在公网上，这种方式不推荐，当然你也可以和 SSL 来加密传输，这样会好一点，这个如果我后面有时间来研究一下。\n\n### Session-cookie\n\n第二种这个方式是利用服务器端的 session（会话）和浏览器端的 cookie 来实现前后端的认证，由于 http 请求时是无状态的，服务器正常情况下是不知道当前请求之前有没有来过，这个时候我们如果要记录状态，就需要在服务器端创建一个会话 (seesion), 将同一个客户端的请求都维护在各自得会会话中，每当请求到达服务器端的时候，先去查一下该客户端有没有在服务器端创建 seesion，如果有则已经认证成功了，否则就没有认证。\n\n#### 认证过程\n\n1. 服务器在接受客户端首次访问时在服务器端创建 seesion，然后保存 seesion（我们可以将 seesion 保存在内存中，也可以保存在 redis 中，推荐使用后者），然后给这个 session 生成一个唯一的标识字符串, 然后在响应头中种下这个唯一标识字符串。\n2. 签名。这一步只是对 sid 进行加密处理，服务端会根据这个 secret 密钥进行解密。（非必需步骤）\n3. 浏览器中收到请求响应的时候会解析响应头，然后将 sid 保存在本地 cookie 中，浏览器在下次 http 请求的请求头中会带上该域名下的 cookie 信息。\n4. 服务器在接受客户端请求时会去解析请求头 cookie 中的 sid，然后根据这个 sid 去找服务器端保存的该客户端的 session，然后判断该请求是否合法。\n\n![](https://user-images.githubusercontent.com/15377484/38019076-382f84f8-32a9-11e8-9c5d-ef47b58185ad.png)\n\n#### 完整代码\n\n**server.js**\n\n```js\nvar express = require('express');\nvar RedisStore = require('connect-redis')(express.session);\nvar app = express();\nvar secret = 'ifyour';\n// 设置 Cookie\napp.use(express.cookieParser(secret));\n\n// 设置 Session\napp.use(\n  express.session({\n    store: new RedisStore({\n      host: '127.0.0.1',\n      port: 6379,\n      db: 'session_db'\n    }),\n    secret: secret\n  })\n);\n\napp.get('/', function(req, res) {\n  var session = req.session;\n  session.time = session.time || 0;\n  var n = session.time++;\n  res.send('hello, session id:' + session.id + 'count:' + n);\n});\n\napp.listen(9080);\n```\n\n### Token 验证\n\n#### 认证过程\n\n1. 客户端使用用户名跟密码请求登录\n2. 服务端收到请求，去验证用户名与密码\n3. 验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端\n4. 客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 LocalStorage 里\n5. 客户端每次向服务端请求资源的时候需要带着服务端签发的 Token\n6. 服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据\n\n总的来说就是客户端在首次登陆以后，服务端再次接收 http 请求的时候，就只认 token 了，请求只要每次把 token 带上就行了，服务器端会拦截所有的请求，然后校验 token 的合法性，合法就放行，不合法就返回 401（鉴权失败）。\n\n乍的一看好像和前面的 seesion-cookie 有点像，seesion-cookie 是通过 seesionid 来作为浏览器和服务端的链接桥梁，而 token 验证方式貌似是 token 来起到 seesionid 的角色。其实这两者差别是很大的。\n\n#### 与 seesion-cookie 的区别\n\n1. sessionid 是一个唯一标识的字符串，服务端是根据这个字符串，来查询在服务器端保持的 seesion，这里面才保存着用户的登陆状态。但是 token 本身就是一种登陆成功凭证，他是在登陆成功后根据某种规则生成的一种信息凭证，他里面本身就保存着用户的登陆状态。服务器端只需要根据定义的规则校验这个 token 是否合法就行。\n2. session-cookie 是需要 cookie 配合的，居然要 cookie，那么在 http 代理客户端的选择上就是只有浏览器了，因为只有浏览器才会去解析请求响应头里面的 cookie, 然后每次请求再默认带上该域名下的 cookie。但是我们知道 http 代理客户端不只有浏览器，还有原生 APP 等等，这个时候 cookie 是不起作用的，或者浏览器端是可以禁止 cookie 的 (虽然可以，但是这基本上是属于吃饱没事干的人干的事)，但是 token 就不一样，他是登陆请求在登陆成功后再请求响应体中返回的信息，客户端在收到响应的时候，可以把他存在本地的 cookie、storage，或者内存中，然后再下一次请求的请求头重带上这个 token 就行了。简单点来说 cookie-session 机制他限制了客户端的类型，而 token 验证机制丰富了客户端类型。\n3. 时效性。session-cookie 的 sessionid 是在登陆时生成的，而且在登出时一直不变，在一定程度上安全性就会降低，而 token 是可以在一段时间内动态改变的。\n4. 可扩展性。token 验证本身是比较灵活的，一是 token 的解决方案有许多，常用的是 JWT，二来我们可以基于 token 验证机制，专门做一个鉴权服务，用它向多个服务的请求进行统一鉴权。\n\n下面就拿最常用的 JWT（JSON WEB TOKEN）来说：\n\nJWT 是 Auth0 提出的通过对 JSON 进行加密签名来实现授权验证的方案，就是登陆成功后将相关信息组成 json 对象，然后对这个对象进行某中方式的加密，返回给客户端，客户端在下次请求时带上这个 token，服务端再收到请求时校验 token 合法性，其实也就是在校验请求的合法性。JWT 对象通常由三部分构成：\n\n1️⃣ Headers： 包括类别（typ）、加密算法（alg）\n\n```json\n{\n  \"alg\": \"HS256\",\n  \"typ\": \"JWT\"\n}\n```\n\n2️⃣ Claims：包括需要传递的用户信息\n\n```json\n{\n  \"sub\": \"1234567890\",\n  \"name\": \"John Doe\",\n  \"admin\": true\n}\n```\n\n3️⃣ Signature：根据 alg 算法与私有秘钥进行加密得到的签名字串，这一段是最重要的敏感信息，只能在服务端解密\n\n```text\nHMACSHA256(\n  base64UrlEncode(Headers) + '.' + base64UrlEncode(Claims),\n  SECREATE_KEY\n);\n```\n\n编码之后的 JWT 看起来是这样的一串字符：\n\n```text\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ\n```\n\n#### 完整代码\n\n**auth.js**\n\n```js\nlet jwt = require('jwt-simple');\nlet secret = 'wangyy';\nlet time = 10;\nmodule.exports = {\n  /* 检验 token 合法性 */\n  validate: function(req, res, next) {\n    let token = req.body.token || req.headers['xssToken'];\n    if (token) {\n      let decodeToken = null;\n      try {\n        // 防止假冒 token 解析报错\n        decodeToken = jwt.decode(token, secret, 'HS256');\n      } catch (err) {\n        res.status(401).send('非法访问');\n        return;\n      }\n      let exp = decodeToken.exp;\n      if (!exp) {\n        res.status(401).send('非法访问');\n      }\n      let now = new Date().getTime();\n      if (exp > now + time * 60 * 1000) {\n        res.send({ code: '002', errorMsg: '授权超时' });\n      }\n      next();\n    } else {\n      res.status(401).send('非法访问');\n    }\n  },\n  /* 生成 token*/\n  makeToken() {\n    let Token = null;\n    let payload = {\n      time: new Date().getTime(),\n      exp: this.makeExp(time)\n    };\n    Token = jwt.encode(payload, secret, HS256);\n    return Token;\n  },\n  /* 生成 token 过期时间 */\n  makeExp: function(time) {\n    let stam = time601000;\n  }\n};\n```\n\n**Server.js**\n\n```js\nlet express = require('express');\nlet app = express();\nlet bodyParser = require('body-parser');\nlet auth = require('./lib/auth.js');\nlet chalk = require('chalk');\n\napp.use(bodyParser.json());\napp.post('/login', function(req, res, next) {\n  let Token = auth.makeToken();\n  res.json({ result: 'success', token: Token }, 200);\n});\napp.use('*', [auth.validate], function(req, res, next) {\n  res.send('success');\n});\n\napp.listen('9999');\n```\n\n### OAuth(开放授权)\n\nOAuth（开放授权）是一个开放标准，允许用户授权第三方网站访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方网站或分享他们数据的所有内容，为了保护用户数据的安全和隐私，第三方网站访问用户数据前都需要显式的向用户征求授权。我们常见的提供 OAuth 认证服务的厂商有支付宝、QQ、微信。\n\nOAuth 协议又有 1.0 和 2.0 两个版本。相比较 1.0 版，2.0 版整个授权验证流程更简单更安全，也是目前最主要的用户身份验证和授权方式。\n\n#### 认证过程\n\n下面是一张 Auth2.0 的流程图：\n\n![image](https://user-images.githubusercontent.com/15377484/48976006-b7ea4600-f0b9-11e8-8f94-1102761320b0.png)\n\n从图中我们可以看出，Auth2.0 流程分为六步：\n\n1️⃣ 向用户请求授权，现在很多的网站在登陆的时候都有第三方登陆的入口，当我们点击等第三方入口时，第三方授权服务会引导我们进入第三方登陆授权页面。\n\n![image](https://user-images.githubusercontent.com/15377484/48976180-35638580-f0bd-11e8-9c0a-c6aee6bf7da5.png)\n\n通过第三方请求授权页面的浏览器地址栏地址可以看出：\n\n```text\nhttps://graph.qq.com/oauth2.0/show?which=Login&display=pc&response_type=code&client_id=100270989&redirect_uri=https%3A%2F%2Fpassport.csdn.net%2Faccount%2Flogin%3Foauth_provider%3DQQProvider&state=test\n```\n\n这里的地址里面的 `%` 是浏览器强制编码后的显示我们可以使用 `decodeURIComponent` 进行解码，解码后是这样：\n\n```text\nhttps://graph.qq.com/oauth2.0/show?which=Login&display=pc&response_type=code&client_id=100270989&redirect_uri=https://passport.csdn.net/account/login?oauth_provider=QQProvider&state=test\n```\n\n这个 url 地址我们可以看见 Auth2.0 常见的几个参数：\n\n```text\nresponse_type:  返回类型\nclient_id:      第三方应用 id, 由授权服务器（qq）在第三方应用提交时颁发给第三方应用。\nredirect_uri:   登陆成功重定向页面\noauth_provider: 第三方授权提供方\nstate:          由第三方应用给出的随机码\n```\n\n2️⃣ 返回用户凭证（code），并返回一个凭证（code），当用户点击授权并登陆后，授权服务器将生成一个用户凭证（code）。这个用户凭证会附加在重定向的地址 `redirect_uri` 的后面\n\n```text\nhttps://passport.csdn.net/account/login?code=9e3efa6cea739f9aaab2&state=XXX\n```\n\n3️⃣ 请求授权服务器授权\n\n经过第二部获取 code 后后面的工作就可以交给后台去处理的，和用户的交互就结束了。接下来我的需要获取凭证（Access Token），我们需要用他来向授权服务器获取用户信息等资源。 第三方应用后台通过第二步的凭证（code）向授权服务器请求凭证（Access Token），这时候需要以下几个信息：\n\n- `client_id`: 标识第三方应用的 id，由授权服务器在第三方应用提交时颁发给第三方应用\n- `client_secret`: 第三方应用和授权服务器之间的安全凭证，由授权服务器在第三方应用提交时颁发给第三方应用\n- `code`: 第一步中返回的用户凭证 `redirect_uri` 第一步生成用户凭证后跳转到第二步时的地址\n- `state`: 由第三方应用给出的随机码\n\n4️⃣ 授权服务器同意授权后，返回一个资源访问的凭证（Access Token）。\n\n5️⃣ 第三方应用通过第四步的凭证（Access Token）向资源服务器请求相关资源。\n\n6️⃣ 资源服务器验证凭证（Access Token）通过后，将第三方应用请求的资源返回。\n\n从用户角度来说，第三方授权可以让我们快速的登陆应用，无需进行繁琐的注册，同时不用记住各种账号密码。只需要记住自己常用的几个账号就 OK 了。 从产品经理的角度来所，这种授权方式提高用户的体验满意度。另一方面可以获取更多的用户。\n\n### 总结\n\n授权方式多种多样，主要还是要取决于我们对于产品的定位。如果我们的产品只是在企业内部使用，Token 和 Session-cookie 就可以满足我们的需求，如果是面向互联网的大众用户，那么第三方授权 OAuth 在用户体验度上会有一个很大的提升。\n","source":"_posts/前后端鉴权方式总结.md","raw":"---\ntitle: 前后端鉴权方式总结\ncomments: true\ndate: 2018-11-25 13:02:34\ntags:\nfrom:\n---\n\n今天来学习下常见的鉴权方式，从最开始了解的最简单的 Cookie 验证，到后来的 Session-cookie、Token 等，整体来说，安全性越来越高。当然还是对部分方式了解不是很深，这里做个简单总结，查漏补缺。\n\n<!-- more -->\n\n目前我们常用的鉴权有四种：\n\n1. HTTP Basic Authentication\n2. Session-cookie\n3. Token 验证\n4. OAuth(开放授权)\n\n### HTTP Basic Authentication\n\n这种授权方式是浏览器遵守 HTTP 协议实现的基本授权方式，HTTP 协议进行通信的过程中，HTTP 协议定义了基本认证认证允许 HTTP 服务器对客户端进行用户身份证的方法。\n\n#### 认证过程\n\n- 1️⃣ 客户端向服务器请求数据，请求的内容可能是一个网页或者是一个 ajax 异步请求，此时，假设客户端尚未被验证，则客户端提供如下请求至服务器：\n\n```text\nGet /index.html HTTP/1.0\nHost:www.google.com\n```\n\n- 2️⃣ 服务器向客户端发送验证请求代码 401，(`WWW-Authenticate: Basic realm=\"google.com\"` 这句话是关键，如果没有客户端不会弹出用户名和密码输入界面）服务器返回的数据如下：\n\n```text\nHTTP/1.0 401 Unauthorised\nServer: SokEvo/1.0\nWWW-Authenticate: Basic realm=\"google.com\"\nContent-Type: text/html\nContent-Length: xxx\n```\n\n- 3️⃣ 当符合 http1.0 或 1.1 规范的客户端（如 IE，FIREFOX）收到 401 返回值时，将自动弹出一个登录窗口，要求用户输入用户名和密码。\n\n- 4️⃣ 用户输入用户名和密码后，将用户名及密码以 BASE64 加密方式加密，并将密文放入前一条请求信息中，则客户端发送的第一条请求信息则变成如下内容：\n\n```text\nGet /index.html HTTP/1.0\nHost:www.google.com\nAuthorization: Basic d2FuZzp3YW5n\n```\n\n<div class=\"tip\">\n`d2FuZzp3YW5n` 表示加密后的用户名及密码（用户名：密码 然后通过 base64 加密，加密过程是浏览器默认的行为，不需要我们人为加密，我们只需要输入用户名密码即可）\n</div>\n\n- 5️⃣ 服务器收到上述请求信息后，将 Authorization 字段后的用户信息取出、解密，将解密后的用户名及密码与用户数据库进行比较验证，如用户名及密码正确，服务器则根据请求，将所请求资源发送给客户端。\n\n客户端未未认证的时候，会弹出用户名密码输入框，这个时候请求时属于 pending 状态，这个时候其实服务当用户输入用户名密码的时候客户端会再次发送带 Authentication 头的请求。\n\n请求认证 👇\n![image](https://user-images.githubusercontent.com/15377484/48976178-136a0300-f0bd-11e8-9fd6-b2e67d22bbc6.png)\n\n认证成功 👇\n![image](https://user-images.githubusercontent.com/15377484/48976167-d1d95800-f0bc-11e8-80fa-35c636dbc103.png)\n\n#### 完整代码\n\n**Server.js**\n\n```js\nlet express = require('express');\nlet app = express();\n\napp.use(express.static(__dirname + '/public'));\napp.get('/Authentication_base', function(req, res) {\n  console.log('req.headers.authorization:', req.headers);\n  if (!req.headers.authorization) {\n    res.set({\n      'WWW-Authenticate': 'Basic realm=\"wang\"'\n    });\n    res.status(401).end();\n  } else {\n    let base64 = req.headers.authorization.split(' ')[1];\n    let userPass = new Buffer(base64, 'base64').toString().split(':');\n    let user = userPass[0];\n    let pass = userPass[1];\n    if (user === 'wang' && pass === 'wang') {\n      res.end('OK');\n    } else {\n      res.status(401).end();\n    }\n  }\n});\n\napp.listen(9090);\n```\n\n**index.html**\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\" />\n    <title>HTTP Basic Authentication</title>\n  </head>\n  <body>\n    <div></div>\n    <script src=\"js/jquery-3.2.1.js\"></script>\n    <script>\n      $(function() {\n        send('./Authentication_base');\n      });\n      var send = function(url) {\n        $.ajax({\n          url: url,\n          method: 'GET'\n        });\n      };\n    </script>\n  </body>\n</html>\n```\n\n当然有登陆就有注销，我们会发现当我们认证成功后每次请求请求头都会带上 Authentication 及里面的内容，那么如何做到让这次登陆失效的？\n\n网上查了半天，目前最有效的方式就是在注销操作的时候，专门在服务器设置一个专门的注销账号，当接收到的 Authentication 信息为注销用户名密码的时候纠就带便注销成功了，而客户端在注销操作的时候，手动的的去修改请求头重的 Authentication，将他设置未服务器默认的注销账号和密码。\n\n通过上面的简单讲解 其实我们已经可以返现这种验证方式的缺陷加密方式简单，仅仅是 base64 加密，这种加密方式是可逆的。同时在每个请求的头上都会附带上用户名和密码信息，这样在外网是很容易被嗅探器探测到的。\n\n正式因为这样，这种加密方式一般多被用在内部安全性要求不高的的系统上，只是相对的多，总的来说现在使用这种鉴权比较少了。如果项目需要部署在公网上，这种方式不推荐，当然你也可以和 SSL 来加密传输，这样会好一点，这个如果我后面有时间来研究一下。\n\n### Session-cookie\n\n第二种这个方式是利用服务器端的 session（会话）和浏览器端的 cookie 来实现前后端的认证，由于 http 请求时是无状态的，服务器正常情况下是不知道当前请求之前有没有来过，这个时候我们如果要记录状态，就需要在服务器端创建一个会话 (seesion), 将同一个客户端的请求都维护在各自得会会话中，每当请求到达服务器端的时候，先去查一下该客户端有没有在服务器端创建 seesion，如果有则已经认证成功了，否则就没有认证。\n\n#### 认证过程\n\n1. 服务器在接受客户端首次访问时在服务器端创建 seesion，然后保存 seesion（我们可以将 seesion 保存在内存中，也可以保存在 redis 中，推荐使用后者），然后给这个 session 生成一个唯一的标识字符串, 然后在响应头中种下这个唯一标识字符串。\n2. 签名。这一步只是对 sid 进行加密处理，服务端会根据这个 secret 密钥进行解密。（非必需步骤）\n3. 浏览器中收到请求响应的时候会解析响应头，然后将 sid 保存在本地 cookie 中，浏览器在下次 http 请求的请求头中会带上该域名下的 cookie 信息。\n4. 服务器在接受客户端请求时会去解析请求头 cookie 中的 sid，然后根据这个 sid 去找服务器端保存的该客户端的 session，然后判断该请求是否合法。\n\n![](https://user-images.githubusercontent.com/15377484/38019076-382f84f8-32a9-11e8-9c5d-ef47b58185ad.png)\n\n#### 完整代码\n\n**server.js**\n\n```js\nvar express = require('express');\nvar RedisStore = require('connect-redis')(express.session);\nvar app = express();\nvar secret = 'ifyour';\n// 设置 Cookie\napp.use(express.cookieParser(secret));\n\n// 设置 Session\napp.use(\n  express.session({\n    store: new RedisStore({\n      host: '127.0.0.1',\n      port: 6379,\n      db: 'session_db'\n    }),\n    secret: secret\n  })\n);\n\napp.get('/', function(req, res) {\n  var session = req.session;\n  session.time = session.time || 0;\n  var n = session.time++;\n  res.send('hello, session id:' + session.id + 'count:' + n);\n});\n\napp.listen(9080);\n```\n\n### Token 验证\n\n#### 认证过程\n\n1. 客户端使用用户名跟密码请求登录\n2. 服务端收到请求，去验证用户名与密码\n3. 验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端\n4. 客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 LocalStorage 里\n5. 客户端每次向服务端请求资源的时候需要带着服务端签发的 Token\n6. 服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据\n\n总的来说就是客户端在首次登陆以后，服务端再次接收 http 请求的时候，就只认 token 了，请求只要每次把 token 带上就行了，服务器端会拦截所有的请求，然后校验 token 的合法性，合法就放行，不合法就返回 401（鉴权失败）。\n\n乍的一看好像和前面的 seesion-cookie 有点像，seesion-cookie 是通过 seesionid 来作为浏览器和服务端的链接桥梁，而 token 验证方式貌似是 token 来起到 seesionid 的角色。其实这两者差别是很大的。\n\n#### 与 seesion-cookie 的区别\n\n1. sessionid 是一个唯一标识的字符串，服务端是根据这个字符串，来查询在服务器端保持的 seesion，这里面才保存着用户的登陆状态。但是 token 本身就是一种登陆成功凭证，他是在登陆成功后根据某种规则生成的一种信息凭证，他里面本身就保存着用户的登陆状态。服务器端只需要根据定义的规则校验这个 token 是否合法就行。\n2. session-cookie 是需要 cookie 配合的，居然要 cookie，那么在 http 代理客户端的选择上就是只有浏览器了，因为只有浏览器才会去解析请求响应头里面的 cookie, 然后每次请求再默认带上该域名下的 cookie。但是我们知道 http 代理客户端不只有浏览器，还有原生 APP 等等，这个时候 cookie 是不起作用的，或者浏览器端是可以禁止 cookie 的 (虽然可以，但是这基本上是属于吃饱没事干的人干的事)，但是 token 就不一样，他是登陆请求在登陆成功后再请求响应体中返回的信息，客户端在收到响应的时候，可以把他存在本地的 cookie、storage，或者内存中，然后再下一次请求的请求头重带上这个 token 就行了。简单点来说 cookie-session 机制他限制了客户端的类型，而 token 验证机制丰富了客户端类型。\n3. 时效性。session-cookie 的 sessionid 是在登陆时生成的，而且在登出时一直不变，在一定程度上安全性就会降低，而 token 是可以在一段时间内动态改变的。\n4. 可扩展性。token 验证本身是比较灵活的，一是 token 的解决方案有许多，常用的是 JWT，二来我们可以基于 token 验证机制，专门做一个鉴权服务，用它向多个服务的请求进行统一鉴权。\n\n下面就拿最常用的 JWT（JSON WEB TOKEN）来说：\n\nJWT 是 Auth0 提出的通过对 JSON 进行加密签名来实现授权验证的方案，就是登陆成功后将相关信息组成 json 对象，然后对这个对象进行某中方式的加密，返回给客户端，客户端在下次请求时带上这个 token，服务端再收到请求时校验 token 合法性，其实也就是在校验请求的合法性。JWT 对象通常由三部分构成：\n\n1️⃣ Headers： 包括类别（typ）、加密算法（alg）\n\n```json\n{\n  \"alg\": \"HS256\",\n  \"typ\": \"JWT\"\n}\n```\n\n2️⃣ Claims：包括需要传递的用户信息\n\n```json\n{\n  \"sub\": \"1234567890\",\n  \"name\": \"John Doe\",\n  \"admin\": true\n}\n```\n\n3️⃣ Signature：根据 alg 算法与私有秘钥进行加密得到的签名字串，这一段是最重要的敏感信息，只能在服务端解密\n\n```text\nHMACSHA256(\n  base64UrlEncode(Headers) + '.' + base64UrlEncode(Claims),\n  SECREATE_KEY\n);\n```\n\n编码之后的 JWT 看起来是这样的一串字符：\n\n```text\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ\n```\n\n#### 完整代码\n\n**auth.js**\n\n```js\nlet jwt = require('jwt-simple');\nlet secret = 'wangyy';\nlet time = 10;\nmodule.exports = {\n  /* 检验 token 合法性 */\n  validate: function(req, res, next) {\n    let token = req.body.token || req.headers['xssToken'];\n    if (token) {\n      let decodeToken = null;\n      try {\n        // 防止假冒 token 解析报错\n        decodeToken = jwt.decode(token, secret, 'HS256');\n      } catch (err) {\n        res.status(401).send('非法访问');\n        return;\n      }\n      let exp = decodeToken.exp;\n      if (!exp) {\n        res.status(401).send('非法访问');\n      }\n      let now = new Date().getTime();\n      if (exp > now + time * 60 * 1000) {\n        res.send({ code: '002', errorMsg: '授权超时' });\n      }\n      next();\n    } else {\n      res.status(401).send('非法访问');\n    }\n  },\n  /* 生成 token*/\n  makeToken() {\n    let Token = null;\n    let payload = {\n      time: new Date().getTime(),\n      exp: this.makeExp(time)\n    };\n    Token = jwt.encode(payload, secret, HS256);\n    return Token;\n  },\n  /* 生成 token 过期时间 */\n  makeExp: function(time) {\n    let stam = time601000;\n  }\n};\n```\n\n**Server.js**\n\n```js\nlet express = require('express');\nlet app = express();\nlet bodyParser = require('body-parser');\nlet auth = require('./lib/auth.js');\nlet chalk = require('chalk');\n\napp.use(bodyParser.json());\napp.post('/login', function(req, res, next) {\n  let Token = auth.makeToken();\n  res.json({ result: 'success', token: Token }, 200);\n});\napp.use('*', [auth.validate], function(req, res, next) {\n  res.send('success');\n});\n\napp.listen('9999');\n```\n\n### OAuth(开放授权)\n\nOAuth（开放授权）是一个开放标准，允许用户授权第三方网站访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方网站或分享他们数据的所有内容，为了保护用户数据的安全和隐私，第三方网站访问用户数据前都需要显式的向用户征求授权。我们常见的提供 OAuth 认证服务的厂商有支付宝、QQ、微信。\n\nOAuth 协议又有 1.0 和 2.0 两个版本。相比较 1.0 版，2.0 版整个授权验证流程更简单更安全，也是目前最主要的用户身份验证和授权方式。\n\n#### 认证过程\n\n下面是一张 Auth2.0 的流程图：\n\n![image](https://user-images.githubusercontent.com/15377484/48976006-b7ea4600-f0b9-11e8-8f94-1102761320b0.png)\n\n从图中我们可以看出，Auth2.0 流程分为六步：\n\n1️⃣ 向用户请求授权，现在很多的网站在登陆的时候都有第三方登陆的入口，当我们点击等第三方入口时，第三方授权服务会引导我们进入第三方登陆授权页面。\n\n![image](https://user-images.githubusercontent.com/15377484/48976180-35638580-f0bd-11e8-9c0a-c6aee6bf7da5.png)\n\n通过第三方请求授权页面的浏览器地址栏地址可以看出：\n\n```text\nhttps://graph.qq.com/oauth2.0/show?which=Login&display=pc&response_type=code&client_id=100270989&redirect_uri=https%3A%2F%2Fpassport.csdn.net%2Faccount%2Flogin%3Foauth_provider%3DQQProvider&state=test\n```\n\n这里的地址里面的 `%` 是浏览器强制编码后的显示我们可以使用 `decodeURIComponent` 进行解码，解码后是这样：\n\n```text\nhttps://graph.qq.com/oauth2.0/show?which=Login&display=pc&response_type=code&client_id=100270989&redirect_uri=https://passport.csdn.net/account/login?oauth_provider=QQProvider&state=test\n```\n\n这个 url 地址我们可以看见 Auth2.0 常见的几个参数：\n\n```text\nresponse_type:  返回类型\nclient_id:      第三方应用 id, 由授权服务器（qq）在第三方应用提交时颁发给第三方应用。\nredirect_uri:   登陆成功重定向页面\noauth_provider: 第三方授权提供方\nstate:          由第三方应用给出的随机码\n```\n\n2️⃣ 返回用户凭证（code），并返回一个凭证（code），当用户点击授权并登陆后，授权服务器将生成一个用户凭证（code）。这个用户凭证会附加在重定向的地址 `redirect_uri` 的后面\n\n```text\nhttps://passport.csdn.net/account/login?code=9e3efa6cea739f9aaab2&state=XXX\n```\n\n3️⃣ 请求授权服务器授权\n\n经过第二部获取 code 后后面的工作就可以交给后台去处理的，和用户的交互就结束了。接下来我的需要获取凭证（Access Token），我们需要用他来向授权服务器获取用户信息等资源。 第三方应用后台通过第二步的凭证（code）向授权服务器请求凭证（Access Token），这时候需要以下几个信息：\n\n- `client_id`: 标识第三方应用的 id，由授权服务器在第三方应用提交时颁发给第三方应用\n- `client_secret`: 第三方应用和授权服务器之间的安全凭证，由授权服务器在第三方应用提交时颁发给第三方应用\n- `code`: 第一步中返回的用户凭证 `redirect_uri` 第一步生成用户凭证后跳转到第二步时的地址\n- `state`: 由第三方应用给出的随机码\n\n4️⃣ 授权服务器同意授权后，返回一个资源访问的凭证（Access Token）。\n\n5️⃣ 第三方应用通过第四步的凭证（Access Token）向资源服务器请求相关资源。\n\n6️⃣ 资源服务器验证凭证（Access Token）通过后，将第三方应用请求的资源返回。\n\n从用户角度来说，第三方授权可以让我们快速的登陆应用，无需进行繁琐的注册，同时不用记住各种账号密码。只需要记住自己常用的几个账号就 OK 了。 从产品经理的角度来所，这种授权方式提高用户的体验满意度。另一方面可以获取更多的用户。\n\n### 总结\n\n授权方式多种多样，主要还是要取决于我们对于产品的定位。如果我们的产品只是在企业内部使用，Token 和 Session-cookie 就可以满足我们的需求，如果是面向互联网的大众用户，那么第三方授权 OAuth 在用户体验度上会有一个很大的提升。\n","slug":"前后端鉴权方式总结","published":1,"updated":"2019-12-07T04:53:18.095Z","layout":"post","photos":[],"link":"","_id":"ck3v60jtl000nr9q9k1oinjt1","content":"<p>今天来学习下常见的鉴权方式，从最开始了解的最简单的 Cookie 验证，到后来的 Session-cookie、Token 等，整体来说，安全性越来越高。当然还是对部分方式了解不是很深，这里做个简单总结，查漏补缺。</p>\n<a id=\"more\"></a>\n<p>目前我们常用的鉴权有四种：</p>\n<ol>\n<li>HTTP Basic Authentication</li>\n<li>Session-cookie</li>\n<li>Token 验证</li>\n<li>OAuth(开放授权)</li>\n</ol>\n<h3 id=\"HTTP-Basic-Authentication\"><a href=\"#HTTP-Basic-Authentication\" class=\"headerlink\" title=\"HTTP Basic Authentication\"></a>HTTP Basic Authentication</h3><p>这种授权方式是浏览器遵守 HTTP 协议实现的基本授权方式，HTTP 协议进行通信的过程中，HTTP 协议定义了基本认证认证允许 HTTP 服务器对客户端进行用户身份证的方法。</p>\n<h4 id=\"认证过程\"><a href=\"#认证过程\" class=\"headerlink\" title=\"认证过程\"></a>认证过程</h4><ul>\n<li>1️⃣ 客户端向服务器请求数据，请求的内容可能是一个网页或者是一个 ajax 异步请求，此时，假设客户端尚未被验证，则客户端提供如下请求至服务器：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Get /index.html HTTP/1.0</span><br><span class=\"line\">Host:www.google.com</span><br></pre></td></tr></table></figure>\n<ul>\n<li>2️⃣ 服务器向客户端发送验证请求代码 401，(<code>WWW-Authenticate: Basic realm=&quot;google.com&quot;</code> 这句话是关键，如果没有客户端不会弹出用户名和密码输入界面）服务器返回的数据如下：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.0 401 Unauthorised</span><br><span class=\"line\">Server: SokEvo/1.0</span><br><span class=\"line\">WWW-Authenticate: Basic realm=&quot;google.com&quot;</span><br><span class=\"line\">Content-Type: text/html</span><br><span class=\"line\">Content-Length: xxx</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>3️⃣ 当符合 http1.0 或 1.1 规范的客户端（如 IE，FIREFOX）收到 401 返回值时，将自动弹出一个登录窗口，要求用户输入用户名和密码。</p>\n</li>\n<li><p>4️⃣ 用户输入用户名和密码后，将用户名及密码以 BASE64 加密方式加密，并将密文放入前一条请求信息中，则客户端发送的第一条请求信息则变成如下内容：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Get /index.html HTTP/1.0</span><br><span class=\"line\">Host:www.google.com</span><br><span class=\"line\">Authorization: Basic d2FuZzp3YW5n</span><br></pre></td></tr></table></figure>\n<div class=\"tip\"><br><code>d2FuZzp3YW5n</code> 表示加密后的用户名及密码（用户名：密码 然后通过 base64 加密，加密过程是浏览器默认的行为，不需要我们人为加密，我们只需要输入用户名密码即可）<br></div>\n\n<ul>\n<li>5️⃣ 服务器收到上述请求信息后，将 Authorization 字段后的用户信息取出、解密，将解密后的用户名及密码与用户数据库进行比较验证，如用户名及密码正确，服务器则根据请求，将所请求资源发送给客户端。</li>\n</ul>\n<p>客户端未未认证的时候，会弹出用户名密码输入框，这个时候请求时属于 pending 状态，这个时候其实服务当用户输入用户名密码的时候客户端会再次发送带 Authentication 头的请求。</p>\n<p>请求认证 👇<br><img src=\"https://user-images.githubusercontent.com/15377484/48976178-136a0300-f0bd-11e8-9fd6-b2e67d22bbc6.png\" alt=\"image\"></p>\n<p>认证成功 👇<br><img src=\"https://user-images.githubusercontent.com/15377484/48976167-d1d95800-f0bc-11e8-80fa-35c636dbc103.png\" alt=\"image\"></p>\n<h4 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h4><p><strong>Server.js</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> app = express();</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(express.static(__dirname + <span class=\"string\">'/public'</span>));</span><br><span class=\"line\">app.get(<span class=\"string\">'/Authentication_base'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'req.headers.authorization:'</span>, req.headers);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!req.headers.authorization) &#123;</span><br><span class=\"line\">    res.set(&#123;</span><br><span class=\"line\">      <span class=\"string\">'WWW-Authenticate'</span>: <span class=\"string\">'Basic realm=\"wang\"'</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    res.status(<span class=\"number\">401</span>).end();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> base64 = req.headers.authorization.split(<span class=\"string\">' '</span>)[<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> userPass = <span class=\"keyword\">new</span> Buffer(base64, <span class=\"string\">'base64'</span>).toString().split(<span class=\"string\">':'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> user = userPass[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> pass = userPass[<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (user === <span class=\"string\">'wang'</span> &amp;&amp; pass === <span class=\"string\">'wang'</span>) &#123;</span><br><span class=\"line\">      res.end(<span class=\"string\">'OK'</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      res.status(<span class=\"number\">401</span>).end();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">9090</span>);</span><br></pre></td></tr></table></figure>\n<p><strong>index.html</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>HTTP Basic Authentication<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"js/jquery-3.2.1.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">      $(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        send(<span class=\"string\">'./Authentication_base'</span>);</span></span><br><span class=\"line\"><span class=\"undefined\">      &#125;);</span></span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">var</span> send = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">url</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        $.ajax(&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">          url: url,</span></span><br><span class=\"line\"><span class=\"javascript\">          method: <span class=\"string\">'GET'</span></span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;);</span></span><br><span class=\"line\"><span class=\"undefined\">      &#125;;</span></span><br><span class=\"line\"><span class=\"undefined\">    </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>当然有登陆就有注销，我们会发现当我们认证成功后每次请求请求头都会带上 Authentication 及里面的内容，那么如何做到让这次登陆失效的？</p>\n<p>网上查了半天，目前最有效的方式就是在注销操作的时候，专门在服务器设置一个专门的注销账号，当接收到的 Authentication 信息为注销用户名密码的时候纠就带便注销成功了，而客户端在注销操作的时候，手动的的去修改请求头重的 Authentication，将他设置未服务器默认的注销账号和密码。</p>\n<p>通过上面的简单讲解 其实我们已经可以返现这种验证方式的缺陷加密方式简单，仅仅是 base64 加密，这种加密方式是可逆的。同时在每个请求的头上都会附带上用户名和密码信息，这样在外网是很容易被嗅探器探测到的。</p>\n<p>正式因为这样，这种加密方式一般多被用在内部安全性要求不高的的系统上，只是相对的多，总的来说现在使用这种鉴权比较少了。如果项目需要部署在公网上，这种方式不推荐，当然你也可以和 SSL 来加密传输，这样会好一点，这个如果我后面有时间来研究一下。</p>\n<h3 id=\"Session-cookie\"><a href=\"#Session-cookie\" class=\"headerlink\" title=\"Session-cookie\"></a>Session-cookie</h3><p>第二种这个方式是利用服务器端的 session（会话）和浏览器端的 cookie 来实现前后端的认证，由于 http 请求时是无状态的，服务器正常情况下是不知道当前请求之前有没有来过，这个时候我们如果要记录状态，就需要在服务器端创建一个会话 (seesion), 将同一个客户端的请求都维护在各自得会会话中，每当请求到达服务器端的时候，先去查一下该客户端有没有在服务器端创建 seesion，如果有则已经认证成功了，否则就没有认证。</p>\n<h4 id=\"认证过程-1\"><a href=\"#认证过程-1\" class=\"headerlink\" title=\"认证过程\"></a>认证过程</h4><ol>\n<li>服务器在接受客户端首次访问时在服务器端创建 seesion，然后保存 seesion（我们可以将 seesion 保存在内存中，也可以保存在 redis 中，推荐使用后者），然后给这个 session 生成一个唯一的标识字符串, 然后在响应头中种下这个唯一标识字符串。</li>\n<li>签名。这一步只是对 sid 进行加密处理，服务端会根据这个 secret 密钥进行解密。（非必需步骤）</li>\n<li>浏览器中收到请求响应的时候会解析响应头，然后将 sid 保存在本地 cookie 中，浏览器在下次 http 请求的请求头中会带上该域名下的 cookie 信息。</li>\n<li>服务器在接受客户端请求时会去解析请求头 cookie 中的 sid，然后根据这个 sid 去找服务器端保存的该客户端的 session，然后判断该请求是否合法。</li>\n</ol>\n<p><img src=\"https://user-images.githubusercontent.com/15377484/38019076-382f84f8-32a9-11e8-9c5d-ef47b58185ad.png\" alt=\"\"></p>\n<h4 id=\"完整代码-1\"><a href=\"#完整代码-1\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h4><p><strong>server.js</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> RedisStore = <span class=\"built_in\">require</span>(<span class=\"string\">'connect-redis'</span>)(express.session);</span><br><span class=\"line\"><span class=\"keyword\">var</span> app = express();</span><br><span class=\"line\"><span class=\"keyword\">var</span> secret = <span class=\"string\">'ifyour'</span>;</span><br><span class=\"line\"><span class=\"comment\">// 设置 Cookie</span></span><br><span class=\"line\">app.use(express.cookieParser(secret));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置 Session</span></span><br><span class=\"line\">app.use(</span><br><span class=\"line\">  express.session(&#123;</span><br><span class=\"line\">    store: <span class=\"keyword\">new</span> RedisStore(&#123;</span><br><span class=\"line\">      host: <span class=\"string\">'127.0.0.1'</span>,</span><br><span class=\"line\">      port: <span class=\"number\">6379</span>,</span><br><span class=\"line\">      db: <span class=\"string\">'session_db'</span></span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">    secret: secret</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(<span class=\"string\">'/'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> session = req.session;</span><br><span class=\"line\">  session.time = session.time || <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> n = session.time++;</span><br><span class=\"line\">  res.send(<span class=\"string\">'hello, session id:'</span> + session.id + <span class=\"string\">'count:'</span> + n);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">9080</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"Token-验证\"><a href=\"#Token-验证\" class=\"headerlink\" title=\"Token 验证\"></a>Token 验证</h3><h4 id=\"认证过程-2\"><a href=\"#认证过程-2\" class=\"headerlink\" title=\"认证过程\"></a>认证过程</h4><ol>\n<li>客户端使用用户名跟密码请求登录</li>\n<li>服务端收到请求，去验证用户名与密码</li>\n<li>验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端</li>\n<li>客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 LocalStorage 里</li>\n<li>客户端每次向服务端请求资源的时候需要带着服务端签发的 Token</li>\n<li>服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据</li>\n</ol>\n<p>总的来说就是客户端在首次登陆以后，服务端再次接收 http 请求的时候，就只认 token 了，请求只要每次把 token 带上就行了，服务器端会拦截所有的请求，然后校验 token 的合法性，合法就放行，不合法就返回 401（鉴权失败）。</p>\n<p>乍的一看好像和前面的 seesion-cookie 有点像，seesion-cookie 是通过 seesionid 来作为浏览器和服务端的链接桥梁，而 token 验证方式貌似是 token 来起到 seesionid 的角色。其实这两者差别是很大的。</p>\n<h4 id=\"与-seesion-cookie-的区别\"><a href=\"#与-seesion-cookie-的区别\" class=\"headerlink\" title=\"与 seesion-cookie 的区别\"></a>与 seesion-cookie 的区别</h4><ol>\n<li>sessionid 是一个唯一标识的字符串，服务端是根据这个字符串，来查询在服务器端保持的 seesion，这里面才保存着用户的登陆状态。但是 token 本身就是一种登陆成功凭证，他是在登陆成功后根据某种规则生成的一种信息凭证，他里面本身就保存着用户的登陆状态。服务器端只需要根据定义的规则校验这个 token 是否合法就行。</li>\n<li>session-cookie 是需要 cookie 配合的，居然要 cookie，那么在 http 代理客户端的选择上就是只有浏览器了，因为只有浏览器才会去解析请求响应头里面的 cookie, 然后每次请求再默认带上该域名下的 cookie。但是我们知道 http 代理客户端不只有浏览器，还有原生 APP 等等，这个时候 cookie 是不起作用的，或者浏览器端是可以禁止 cookie 的 (虽然可以，但是这基本上是属于吃饱没事干的人干的事)，但是 token 就不一样，他是登陆请求在登陆成功后再请求响应体中返回的信息，客户端在收到响应的时候，可以把他存在本地的 cookie、storage，或者内存中，然后再下一次请求的请求头重带上这个 token 就行了。简单点来说 cookie-session 机制他限制了客户端的类型，而 token 验证机制丰富了客户端类型。</li>\n<li>时效性。session-cookie 的 sessionid 是在登陆时生成的，而且在登出时一直不变，在一定程度上安全性就会降低，而 token 是可以在一段时间内动态改变的。</li>\n<li>可扩展性。token 验证本身是比较灵活的，一是 token 的解决方案有许多，常用的是 JWT，二来我们可以基于 token 验证机制，专门做一个鉴权服务，用它向多个服务的请求进行统一鉴权。</li>\n</ol>\n<p>下面就拿最常用的 JWT（JSON WEB TOKEN）来说：</p>\n<p>JWT 是 Auth0 提出的通过对 JSON 进行加密签名来实现授权验证的方案，就是登陆成功后将相关信息组成 json 对象，然后对这个对象进行某中方式的加密，返回给客户端，客户端在下次请求时带上这个 token，服务端再收到请求时校验 token 合法性，其实也就是在校验请求的合法性。JWT 对象通常由三部分构成：</p>\n<p>1️⃣ Headers： 包括类别（typ）、加密算法（alg）</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"alg\"</span>: <span class=\"string\">\"HS256\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"typ\"</span>: <span class=\"string\">\"JWT\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2️⃣ Claims：包括需要传递的用户信息</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"sub\"</span>: <span class=\"string\">\"1234567890\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"John Doe\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"admin\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>3️⃣ Signature：根据 alg 算法与私有秘钥进行加密得到的签名字串，这一段是最重要的敏感信息，只能在服务端解密</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HMACSHA256(</span><br><span class=\"line\">  base64UrlEncode(Headers) + &apos;.&apos; + base64UrlEncode(Claims),</span><br><span class=\"line\">  SECREATE_KEY</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>编码之后的 JWT 看起来是这样的一串字符：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</span><br></pre></td></tr></table></figure>\n<h4 id=\"完整代码-2\"><a href=\"#完整代码-2\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h4><p><strong>auth.js</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> jwt = <span class=\"built_in\">require</span>(<span class=\"string\">'jwt-simple'</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> secret = <span class=\"string\">'wangyy'</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> time = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">/* 检验 token 合法性 */</span></span><br><span class=\"line\">  validate: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res, next</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> token = req.body.token || req.headers[<span class=\"string\">'xssToken'</span>];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (token) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> decodeToken = <span class=\"literal\">null</span>;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 防止假冒 token 解析报错</span></span><br><span class=\"line\">        decodeToken = jwt.decode(token, secret, <span class=\"string\">'HS256'</span>);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">        res.status(<span class=\"number\">401</span>).send(<span class=\"string\">'非法访问'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> exp = decodeToken.exp;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!exp) &#123;</span><br><span class=\"line\">        res.status(<span class=\"number\">401</span>).send(<span class=\"string\">'非法访问'</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> now = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (exp &gt; now + time * <span class=\"number\">60</span> * <span class=\"number\">1000</span>) &#123;</span><br><span class=\"line\">        res.send(&#123; <span class=\"attr\">code</span>: <span class=\"string\">'002'</span>, <span class=\"attr\">errorMsg</span>: <span class=\"string\">'授权超时'</span> &#125;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      next();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      res.status(<span class=\"number\">401</span>).send(<span class=\"string\">'非法访问'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">/* 生成 token*/</span></span><br><span class=\"line\">  makeToken() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> Token = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> payload = &#123;</span><br><span class=\"line\">      time: <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime(),</span><br><span class=\"line\">      exp: <span class=\"keyword\">this</span>.makeExp(time)</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    Token = jwt.encode(payload, secret, HS256);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Token;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">/* 生成 token 过期时间 */</span></span><br><span class=\"line\">  makeExp: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">time</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> stam = time601000;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>Server.js</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> app = express();</span><br><span class=\"line\"><span class=\"keyword\">let</span> bodyParser = <span class=\"built_in\">require</span>(<span class=\"string\">'body-parser'</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> auth = <span class=\"built_in\">require</span>(<span class=\"string\">'./lib/auth.js'</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> chalk = <span class=\"built_in\">require</span>(<span class=\"string\">'chalk'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(bodyParser.json());</span><br><span class=\"line\">app.post(<span class=\"string\">'/login'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res, next</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> Token = auth.makeToken();</span><br><span class=\"line\">  res.json(&#123; <span class=\"attr\">result</span>: <span class=\"string\">'success'</span>, <span class=\"attr\">token</span>: Token &#125;, <span class=\"number\">200</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">app.use(<span class=\"string\">'*'</span>, [auth.validate], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res, next</span>) </span>&#123;</span><br><span class=\"line\">  res.send(<span class=\"string\">'success'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"string\">'9999'</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"OAuth-开放授权\"><a href=\"#OAuth-开放授权\" class=\"headerlink\" title=\"OAuth(开放授权)\"></a>OAuth(开放授权)</h3><p>OAuth（开放授权）是一个开放标准，允许用户授权第三方网站访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方网站或分享他们数据的所有内容，为了保护用户数据的安全和隐私，第三方网站访问用户数据前都需要显式的向用户征求授权。我们常见的提供 OAuth 认证服务的厂商有支付宝、QQ、微信。</p>\n<p>OAuth 协议又有 1.0 和 2.0 两个版本。相比较 1.0 版，2.0 版整个授权验证流程更简单更安全，也是目前最主要的用户身份验证和授权方式。</p>\n<h4 id=\"认证过程-3\"><a href=\"#认证过程-3\" class=\"headerlink\" title=\"认证过程\"></a>认证过程</h4><p>下面是一张 Auth2.0 的流程图：</p>\n<p><img src=\"https://user-images.githubusercontent.com/15377484/48976006-b7ea4600-f0b9-11e8-8f94-1102761320b0.png\" alt=\"image\"></p>\n<p>从图中我们可以看出，Auth2.0 流程分为六步：</p>\n<p>1️⃣ 向用户请求授权，现在很多的网站在登陆的时候都有第三方登陆的入口，当我们点击等第三方入口时，第三方授权服务会引导我们进入第三方登陆授权页面。</p>\n<p><img src=\"https://user-images.githubusercontent.com/15377484/48976180-35638580-f0bd-11e8-9c0a-c6aee6bf7da5.png\" alt=\"image\"></p>\n<p>通过第三方请求授权页面的浏览器地址栏地址可以看出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://graph.qq.com/oauth2.0/show?which=Login&amp;display=pc&amp;response_type=code&amp;client_id=100270989&amp;redirect_uri=https%3A%2F%2Fpassport.csdn.net%2Faccount%2Flogin%3Foauth_provider%3DQQProvider&amp;state=test</span><br></pre></td></tr></table></figure>\n<p>这里的地址里面的 <code>%</code> 是浏览器强制编码后的显示我们可以使用 <code>decodeURIComponent</code> 进行解码，解码后是这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://graph.qq.com/oauth2.0/show?which=Login&amp;display=pc&amp;response_type=code&amp;client_id=100270989&amp;redirect_uri=https://passport.csdn.net/account/login?oauth_provider=QQProvider&amp;state=test</span><br></pre></td></tr></table></figure>\n<p>这个 url 地址我们可以看见 Auth2.0 常见的几个参数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">response_type:  返回类型</span><br><span class=\"line\">client_id:      第三方应用 id, 由授权服务器（qq）在第三方应用提交时颁发给第三方应用。</span><br><span class=\"line\">redirect_uri:   登陆成功重定向页面</span><br><span class=\"line\">oauth_provider: 第三方授权提供方</span><br><span class=\"line\">state:          由第三方应用给出的随机码</span><br></pre></td></tr></table></figure>\n<p>2️⃣ 返回用户凭证（code），并返回一个凭证（code），当用户点击授权并登陆后，授权服务器将生成一个用户凭证（code）。这个用户凭证会附加在重定向的地址 <code>redirect_uri</code> 的后面</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://passport.csdn.net/account/login?code=9e3efa6cea739f9aaab2&amp;state=XXX</span><br></pre></td></tr></table></figure>\n<p>3️⃣ 请求授权服务器授权</p>\n<p>经过第二部获取 code 后后面的工作就可以交给后台去处理的，和用户的交互就结束了。接下来我的需要获取凭证（Access Token），我们需要用他来向授权服务器获取用户信息等资源。 第三方应用后台通过第二步的凭证（code）向授权服务器请求凭证（Access Token），这时候需要以下几个信息：</p>\n<ul>\n<li><code>client_id</code>: 标识第三方应用的 id，由授权服务器在第三方应用提交时颁发给第三方应用</li>\n<li><code>client_secret</code>: 第三方应用和授权服务器之间的安全凭证，由授权服务器在第三方应用提交时颁发给第三方应用</li>\n<li><code>code</code>: 第一步中返回的用户凭证 <code>redirect_uri</code> 第一步生成用户凭证后跳转到第二步时的地址</li>\n<li><code>state</code>: 由第三方应用给出的随机码</li>\n</ul>\n<p>4️⃣ 授权服务器同意授权后，返回一个资源访问的凭证（Access Token）。</p>\n<p>5️⃣ 第三方应用通过第四步的凭证（Access Token）向资源服务器请求相关资源。</p>\n<p>6️⃣ 资源服务器验证凭证（Access Token）通过后，将第三方应用请求的资源返回。</p>\n<p>从用户角度来说，第三方授权可以让我们快速的登陆应用，无需进行繁琐的注册，同时不用记住各种账号密码。只需要记住自己常用的几个账号就 OK 了。 从产品经理的角度来所，这种授权方式提高用户的体验满意度。另一方面可以获取更多的用户。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>授权方式多种多样，主要还是要取决于我们对于产品的定位。如果我们的产品只是在企业内部使用，Token 和 Session-cookie 就可以满足我们的需求，如果是面向互联网的大众用户，那么第三方授权 OAuth 在用户体验度上会有一个很大的提升。</p>\n","site":{"data":{}},"excerpt":"<p>今天来学习下常见的鉴权方式，从最开始了解的最简单的 Cookie 验证，到后来的 Session-cookie、Token 等，整体来说，安全性越来越高。当然还是对部分方式了解不是很深，这里做个简单总结，查漏补缺。</p>","more":"<p>目前我们常用的鉴权有四种：</p>\n<ol>\n<li>HTTP Basic Authentication</li>\n<li>Session-cookie</li>\n<li>Token 验证</li>\n<li>OAuth(开放授权)</li>\n</ol>\n<h3 id=\"HTTP-Basic-Authentication\"><a href=\"#HTTP-Basic-Authentication\" class=\"headerlink\" title=\"HTTP Basic Authentication\"></a>HTTP Basic Authentication</h3><p>这种授权方式是浏览器遵守 HTTP 协议实现的基本授权方式，HTTP 协议进行通信的过程中，HTTP 协议定义了基本认证认证允许 HTTP 服务器对客户端进行用户身份证的方法。</p>\n<h4 id=\"认证过程\"><a href=\"#认证过程\" class=\"headerlink\" title=\"认证过程\"></a>认证过程</h4><ul>\n<li>1️⃣ 客户端向服务器请求数据，请求的内容可能是一个网页或者是一个 ajax 异步请求，此时，假设客户端尚未被验证，则客户端提供如下请求至服务器：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Get /index.html HTTP/1.0</span><br><span class=\"line\">Host:www.google.com</span><br></pre></td></tr></table></figure>\n<ul>\n<li>2️⃣ 服务器向客户端发送验证请求代码 401，(<code>WWW-Authenticate: Basic realm=&quot;google.com&quot;</code> 这句话是关键，如果没有客户端不会弹出用户名和密码输入界面）服务器返回的数据如下：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.0 401 Unauthorised</span><br><span class=\"line\">Server: SokEvo/1.0</span><br><span class=\"line\">WWW-Authenticate: Basic realm=&quot;google.com&quot;</span><br><span class=\"line\">Content-Type: text/html</span><br><span class=\"line\">Content-Length: xxx</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>3️⃣ 当符合 http1.0 或 1.1 规范的客户端（如 IE，FIREFOX）收到 401 返回值时，将自动弹出一个登录窗口，要求用户输入用户名和密码。</p>\n</li>\n<li><p>4️⃣ 用户输入用户名和密码后，将用户名及密码以 BASE64 加密方式加密，并将密文放入前一条请求信息中，则客户端发送的第一条请求信息则变成如下内容：</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Get /index.html HTTP/1.0</span><br><span class=\"line\">Host:www.google.com</span><br><span class=\"line\">Authorization: Basic d2FuZzp3YW5n</span><br></pre></td></tr></table></figure>\n<div class=\"tip\"><br><code>d2FuZzp3YW5n</code> 表示加密后的用户名及密码（用户名：密码 然后通过 base64 加密，加密过程是浏览器默认的行为，不需要我们人为加密，我们只需要输入用户名密码即可）<br></div>\n\n<ul>\n<li>5️⃣ 服务器收到上述请求信息后，将 Authorization 字段后的用户信息取出、解密，将解密后的用户名及密码与用户数据库进行比较验证，如用户名及密码正确，服务器则根据请求，将所请求资源发送给客户端。</li>\n</ul>\n<p>客户端未未认证的时候，会弹出用户名密码输入框，这个时候请求时属于 pending 状态，这个时候其实服务当用户输入用户名密码的时候客户端会再次发送带 Authentication 头的请求。</p>\n<p>请求认证 👇<br><img src=\"https://user-images.githubusercontent.com/15377484/48976178-136a0300-f0bd-11e8-9fd6-b2e67d22bbc6.png\" alt=\"image\"></p>\n<p>认证成功 👇<br><img src=\"https://user-images.githubusercontent.com/15377484/48976167-d1d95800-f0bc-11e8-80fa-35c636dbc103.png\" alt=\"image\"></p>\n<h4 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h4><p><strong>Server.js</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> app = express();</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(express.static(__dirname + <span class=\"string\">'/public'</span>));</span><br><span class=\"line\">app.get(<span class=\"string\">'/Authentication_base'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'req.headers.authorization:'</span>, req.headers);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!req.headers.authorization) &#123;</span><br><span class=\"line\">    res.set(&#123;</span><br><span class=\"line\">      <span class=\"string\">'WWW-Authenticate'</span>: <span class=\"string\">'Basic realm=\"wang\"'</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    res.status(<span class=\"number\">401</span>).end();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> base64 = req.headers.authorization.split(<span class=\"string\">' '</span>)[<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> userPass = <span class=\"keyword\">new</span> Buffer(base64, <span class=\"string\">'base64'</span>).toString().split(<span class=\"string\">':'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> user = userPass[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> pass = userPass[<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (user === <span class=\"string\">'wang'</span> &amp;&amp; pass === <span class=\"string\">'wang'</span>) &#123;</span><br><span class=\"line\">      res.end(<span class=\"string\">'OK'</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      res.status(<span class=\"number\">401</span>).end();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">9090</span>);</span><br></pre></td></tr></table></figure>\n<p><strong>index.html</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>HTTP Basic Authentication<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"js/jquery-3.2.1.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">      $(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        send(<span class=\"string\">'./Authentication_base'</span>);</span></span><br><span class=\"line\"><span class=\"undefined\">      &#125;);</span></span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">var</span> send = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">url</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        $.ajax(&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">          url: url,</span></span><br><span class=\"line\"><span class=\"javascript\">          method: <span class=\"string\">'GET'</span></span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;);</span></span><br><span class=\"line\"><span class=\"undefined\">      &#125;;</span></span><br><span class=\"line\"><span class=\"undefined\">    </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>当然有登陆就有注销，我们会发现当我们认证成功后每次请求请求头都会带上 Authentication 及里面的内容，那么如何做到让这次登陆失效的？</p>\n<p>网上查了半天，目前最有效的方式就是在注销操作的时候，专门在服务器设置一个专门的注销账号，当接收到的 Authentication 信息为注销用户名密码的时候纠就带便注销成功了，而客户端在注销操作的时候，手动的的去修改请求头重的 Authentication，将他设置未服务器默认的注销账号和密码。</p>\n<p>通过上面的简单讲解 其实我们已经可以返现这种验证方式的缺陷加密方式简单，仅仅是 base64 加密，这种加密方式是可逆的。同时在每个请求的头上都会附带上用户名和密码信息，这样在外网是很容易被嗅探器探测到的。</p>\n<p>正式因为这样，这种加密方式一般多被用在内部安全性要求不高的的系统上，只是相对的多，总的来说现在使用这种鉴权比较少了。如果项目需要部署在公网上，这种方式不推荐，当然你也可以和 SSL 来加密传输，这样会好一点，这个如果我后面有时间来研究一下。</p>\n<h3 id=\"Session-cookie\"><a href=\"#Session-cookie\" class=\"headerlink\" title=\"Session-cookie\"></a>Session-cookie</h3><p>第二种这个方式是利用服务器端的 session（会话）和浏览器端的 cookie 来实现前后端的认证，由于 http 请求时是无状态的，服务器正常情况下是不知道当前请求之前有没有来过，这个时候我们如果要记录状态，就需要在服务器端创建一个会话 (seesion), 将同一个客户端的请求都维护在各自得会会话中，每当请求到达服务器端的时候，先去查一下该客户端有没有在服务器端创建 seesion，如果有则已经认证成功了，否则就没有认证。</p>\n<h4 id=\"认证过程-1\"><a href=\"#认证过程-1\" class=\"headerlink\" title=\"认证过程\"></a>认证过程</h4><ol>\n<li>服务器在接受客户端首次访问时在服务器端创建 seesion，然后保存 seesion（我们可以将 seesion 保存在内存中，也可以保存在 redis 中，推荐使用后者），然后给这个 session 生成一个唯一的标识字符串, 然后在响应头中种下这个唯一标识字符串。</li>\n<li>签名。这一步只是对 sid 进行加密处理，服务端会根据这个 secret 密钥进行解密。（非必需步骤）</li>\n<li>浏览器中收到请求响应的时候会解析响应头，然后将 sid 保存在本地 cookie 中，浏览器在下次 http 请求的请求头中会带上该域名下的 cookie 信息。</li>\n<li>服务器在接受客户端请求时会去解析请求头 cookie 中的 sid，然后根据这个 sid 去找服务器端保存的该客户端的 session，然后判断该请求是否合法。</li>\n</ol>\n<p><img src=\"https://user-images.githubusercontent.com/15377484/38019076-382f84f8-32a9-11e8-9c5d-ef47b58185ad.png\" alt=\"\"></p>\n<h4 id=\"完整代码-1\"><a href=\"#完整代码-1\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h4><p><strong>server.js</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> RedisStore = <span class=\"built_in\">require</span>(<span class=\"string\">'connect-redis'</span>)(express.session);</span><br><span class=\"line\"><span class=\"keyword\">var</span> app = express();</span><br><span class=\"line\"><span class=\"keyword\">var</span> secret = <span class=\"string\">'ifyour'</span>;</span><br><span class=\"line\"><span class=\"comment\">// 设置 Cookie</span></span><br><span class=\"line\">app.use(express.cookieParser(secret));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置 Session</span></span><br><span class=\"line\">app.use(</span><br><span class=\"line\">  express.session(&#123;</span><br><span class=\"line\">    store: <span class=\"keyword\">new</span> RedisStore(&#123;</span><br><span class=\"line\">      host: <span class=\"string\">'127.0.0.1'</span>,</span><br><span class=\"line\">      port: <span class=\"number\">6379</span>,</span><br><span class=\"line\">      db: <span class=\"string\">'session_db'</span></span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">    secret: secret</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(<span class=\"string\">'/'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> session = req.session;</span><br><span class=\"line\">  session.time = session.time || <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> n = session.time++;</span><br><span class=\"line\">  res.send(<span class=\"string\">'hello, session id:'</span> + session.id + <span class=\"string\">'count:'</span> + n);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">9080</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"Token-验证\"><a href=\"#Token-验证\" class=\"headerlink\" title=\"Token 验证\"></a>Token 验证</h3><h4 id=\"认证过程-2\"><a href=\"#认证过程-2\" class=\"headerlink\" title=\"认证过程\"></a>认证过程</h4><ol>\n<li>客户端使用用户名跟密码请求登录</li>\n<li>服务端收到请求，去验证用户名与密码</li>\n<li>验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端</li>\n<li>客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 LocalStorage 里</li>\n<li>客户端每次向服务端请求资源的时候需要带着服务端签发的 Token</li>\n<li>服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据</li>\n</ol>\n<p>总的来说就是客户端在首次登陆以后，服务端再次接收 http 请求的时候，就只认 token 了，请求只要每次把 token 带上就行了，服务器端会拦截所有的请求，然后校验 token 的合法性，合法就放行，不合法就返回 401（鉴权失败）。</p>\n<p>乍的一看好像和前面的 seesion-cookie 有点像，seesion-cookie 是通过 seesionid 来作为浏览器和服务端的链接桥梁，而 token 验证方式貌似是 token 来起到 seesionid 的角色。其实这两者差别是很大的。</p>\n<h4 id=\"与-seesion-cookie-的区别\"><a href=\"#与-seesion-cookie-的区别\" class=\"headerlink\" title=\"与 seesion-cookie 的区别\"></a>与 seesion-cookie 的区别</h4><ol>\n<li>sessionid 是一个唯一标识的字符串，服务端是根据这个字符串，来查询在服务器端保持的 seesion，这里面才保存着用户的登陆状态。但是 token 本身就是一种登陆成功凭证，他是在登陆成功后根据某种规则生成的一种信息凭证，他里面本身就保存着用户的登陆状态。服务器端只需要根据定义的规则校验这个 token 是否合法就行。</li>\n<li>session-cookie 是需要 cookie 配合的，居然要 cookie，那么在 http 代理客户端的选择上就是只有浏览器了，因为只有浏览器才会去解析请求响应头里面的 cookie, 然后每次请求再默认带上该域名下的 cookie。但是我们知道 http 代理客户端不只有浏览器，还有原生 APP 等等，这个时候 cookie 是不起作用的，或者浏览器端是可以禁止 cookie 的 (虽然可以，但是这基本上是属于吃饱没事干的人干的事)，但是 token 就不一样，他是登陆请求在登陆成功后再请求响应体中返回的信息，客户端在收到响应的时候，可以把他存在本地的 cookie、storage，或者内存中，然后再下一次请求的请求头重带上这个 token 就行了。简单点来说 cookie-session 机制他限制了客户端的类型，而 token 验证机制丰富了客户端类型。</li>\n<li>时效性。session-cookie 的 sessionid 是在登陆时生成的，而且在登出时一直不变，在一定程度上安全性就会降低，而 token 是可以在一段时间内动态改变的。</li>\n<li>可扩展性。token 验证本身是比较灵活的，一是 token 的解决方案有许多，常用的是 JWT，二来我们可以基于 token 验证机制，专门做一个鉴权服务，用它向多个服务的请求进行统一鉴权。</li>\n</ol>\n<p>下面就拿最常用的 JWT（JSON WEB TOKEN）来说：</p>\n<p>JWT 是 Auth0 提出的通过对 JSON 进行加密签名来实现授权验证的方案，就是登陆成功后将相关信息组成 json 对象，然后对这个对象进行某中方式的加密，返回给客户端，客户端在下次请求时带上这个 token，服务端再收到请求时校验 token 合法性，其实也就是在校验请求的合法性。JWT 对象通常由三部分构成：</p>\n<p>1️⃣ Headers： 包括类别（typ）、加密算法（alg）</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"alg\"</span>: <span class=\"string\">\"HS256\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"typ\"</span>: <span class=\"string\">\"JWT\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2️⃣ Claims：包括需要传递的用户信息</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"sub\"</span>: <span class=\"string\">\"1234567890\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"John Doe\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"admin\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>3️⃣ Signature：根据 alg 算法与私有秘钥进行加密得到的签名字串，这一段是最重要的敏感信息，只能在服务端解密</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HMACSHA256(</span><br><span class=\"line\">  base64UrlEncode(Headers) + &apos;.&apos; + base64UrlEncode(Claims),</span><br><span class=\"line\">  SECREATE_KEY</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>编码之后的 JWT 看起来是这样的一串字符：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</span><br></pre></td></tr></table></figure>\n<h4 id=\"完整代码-2\"><a href=\"#完整代码-2\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h4><p><strong>auth.js</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> jwt = <span class=\"built_in\">require</span>(<span class=\"string\">'jwt-simple'</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> secret = <span class=\"string\">'wangyy'</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> time = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">/* 检验 token 合法性 */</span></span><br><span class=\"line\">  validate: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res, next</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> token = req.body.token || req.headers[<span class=\"string\">'xssToken'</span>];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (token) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> decodeToken = <span class=\"literal\">null</span>;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 防止假冒 token 解析报错</span></span><br><span class=\"line\">        decodeToken = jwt.decode(token, secret, <span class=\"string\">'HS256'</span>);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">        res.status(<span class=\"number\">401</span>).send(<span class=\"string\">'非法访问'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> exp = decodeToken.exp;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!exp) &#123;</span><br><span class=\"line\">        res.status(<span class=\"number\">401</span>).send(<span class=\"string\">'非法访问'</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> now = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (exp &gt; now + time * <span class=\"number\">60</span> * <span class=\"number\">1000</span>) &#123;</span><br><span class=\"line\">        res.send(&#123; <span class=\"attr\">code</span>: <span class=\"string\">'002'</span>, <span class=\"attr\">errorMsg</span>: <span class=\"string\">'授权超时'</span> &#125;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      next();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      res.status(<span class=\"number\">401</span>).send(<span class=\"string\">'非法访问'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">/* 生成 token*/</span></span><br><span class=\"line\">  makeToken() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> Token = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> payload = &#123;</span><br><span class=\"line\">      time: <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime(),</span><br><span class=\"line\">      exp: <span class=\"keyword\">this</span>.makeExp(time)</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    Token = jwt.encode(payload, secret, HS256);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Token;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">/* 生成 token 过期时间 */</span></span><br><span class=\"line\">  makeExp: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">time</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> stam = time601000;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>Server.js</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> app = express();</span><br><span class=\"line\"><span class=\"keyword\">let</span> bodyParser = <span class=\"built_in\">require</span>(<span class=\"string\">'body-parser'</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> auth = <span class=\"built_in\">require</span>(<span class=\"string\">'./lib/auth.js'</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> chalk = <span class=\"built_in\">require</span>(<span class=\"string\">'chalk'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(bodyParser.json());</span><br><span class=\"line\">app.post(<span class=\"string\">'/login'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res, next</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> Token = auth.makeToken();</span><br><span class=\"line\">  res.json(&#123; <span class=\"attr\">result</span>: <span class=\"string\">'success'</span>, <span class=\"attr\">token</span>: Token &#125;, <span class=\"number\">200</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">app.use(<span class=\"string\">'*'</span>, [auth.validate], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res, next</span>) </span>&#123;</span><br><span class=\"line\">  res.send(<span class=\"string\">'success'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"string\">'9999'</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"OAuth-开放授权\"><a href=\"#OAuth-开放授权\" class=\"headerlink\" title=\"OAuth(开放授权)\"></a>OAuth(开放授权)</h3><p>OAuth（开放授权）是一个开放标准，允许用户授权第三方网站访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方网站或分享他们数据的所有内容，为了保护用户数据的安全和隐私，第三方网站访问用户数据前都需要显式的向用户征求授权。我们常见的提供 OAuth 认证服务的厂商有支付宝、QQ、微信。</p>\n<p>OAuth 协议又有 1.0 和 2.0 两个版本。相比较 1.0 版，2.0 版整个授权验证流程更简单更安全，也是目前最主要的用户身份验证和授权方式。</p>\n<h4 id=\"认证过程-3\"><a href=\"#认证过程-3\" class=\"headerlink\" title=\"认证过程\"></a>认证过程</h4><p>下面是一张 Auth2.0 的流程图：</p>\n<p><img src=\"https://user-images.githubusercontent.com/15377484/48976006-b7ea4600-f0b9-11e8-8f94-1102761320b0.png\" alt=\"image\"></p>\n<p>从图中我们可以看出，Auth2.0 流程分为六步：</p>\n<p>1️⃣ 向用户请求授权，现在很多的网站在登陆的时候都有第三方登陆的入口，当我们点击等第三方入口时，第三方授权服务会引导我们进入第三方登陆授权页面。</p>\n<p><img src=\"https://user-images.githubusercontent.com/15377484/48976180-35638580-f0bd-11e8-9c0a-c6aee6bf7da5.png\" alt=\"image\"></p>\n<p>通过第三方请求授权页面的浏览器地址栏地址可以看出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://graph.qq.com/oauth2.0/show?which=Login&amp;display=pc&amp;response_type=code&amp;client_id=100270989&amp;redirect_uri=https%3A%2F%2Fpassport.csdn.net%2Faccount%2Flogin%3Foauth_provider%3DQQProvider&amp;state=test</span><br></pre></td></tr></table></figure>\n<p>这里的地址里面的 <code>%</code> 是浏览器强制编码后的显示我们可以使用 <code>decodeURIComponent</code> 进行解码，解码后是这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://graph.qq.com/oauth2.0/show?which=Login&amp;display=pc&amp;response_type=code&amp;client_id=100270989&amp;redirect_uri=https://passport.csdn.net/account/login?oauth_provider=QQProvider&amp;state=test</span><br></pre></td></tr></table></figure>\n<p>这个 url 地址我们可以看见 Auth2.0 常见的几个参数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">response_type:  返回类型</span><br><span class=\"line\">client_id:      第三方应用 id, 由授权服务器（qq）在第三方应用提交时颁发给第三方应用。</span><br><span class=\"line\">redirect_uri:   登陆成功重定向页面</span><br><span class=\"line\">oauth_provider: 第三方授权提供方</span><br><span class=\"line\">state:          由第三方应用给出的随机码</span><br></pre></td></tr></table></figure>\n<p>2️⃣ 返回用户凭证（code），并返回一个凭证（code），当用户点击授权并登陆后，授权服务器将生成一个用户凭证（code）。这个用户凭证会附加在重定向的地址 <code>redirect_uri</code> 的后面</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://passport.csdn.net/account/login?code=9e3efa6cea739f9aaab2&amp;state=XXX</span><br></pre></td></tr></table></figure>\n<p>3️⃣ 请求授权服务器授权</p>\n<p>经过第二部获取 code 后后面的工作就可以交给后台去处理的，和用户的交互就结束了。接下来我的需要获取凭证（Access Token），我们需要用他来向授权服务器获取用户信息等资源。 第三方应用后台通过第二步的凭证（code）向授权服务器请求凭证（Access Token），这时候需要以下几个信息：</p>\n<ul>\n<li><code>client_id</code>: 标识第三方应用的 id，由授权服务器在第三方应用提交时颁发给第三方应用</li>\n<li><code>client_secret</code>: 第三方应用和授权服务器之间的安全凭证，由授权服务器在第三方应用提交时颁发给第三方应用</li>\n<li><code>code</code>: 第一步中返回的用户凭证 <code>redirect_uri</code> 第一步生成用户凭证后跳转到第二步时的地址</li>\n<li><code>state</code>: 由第三方应用给出的随机码</li>\n</ul>\n<p>4️⃣ 授权服务器同意授权后，返回一个资源访问的凭证（Access Token）。</p>\n<p>5️⃣ 第三方应用通过第四步的凭证（Access Token）向资源服务器请求相关资源。</p>\n<p>6️⃣ 资源服务器验证凭证（Access Token）通过后，将第三方应用请求的资源返回。</p>\n<p>从用户角度来说，第三方授权可以让我们快速的登陆应用，无需进行繁琐的注册，同时不用记住各种账号密码。只需要记住自己常用的几个账号就 OK 了。 从产品经理的角度来所，这种授权方式提高用户的体验满意度。另一方面可以获取更多的用户。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>授权方式多种多样，主要还是要取决于我们对于产品的定位。如果我们的产品只是在企业内部使用，Token 和 Session-cookie 就可以满足我们的需求，如果是面向互联网的大众用户，那么第三方授权 OAuth 在用户体验度上会有一个很大的提升。</p>"},{"title":"如何在 Git 中使用撤消操作","comments":1,"date":"2018-06-26T23:19:14.000Z","from":"https://blog.github.com/2015-06-08-how-to-undo-almost-anything-with-git/","_content":"\n版本控制系统的一个好处就是你可以轻易地撤销之前错误的操作。当你用 `git commit` 提交了一个新的更改后 git 会将当时的文件内容暂时保存下来，之后你就可以用 git 随意回滚到任意一个版本。这篇文章会介绍一些常见的可能用到撤销 `undo` 操作的情况。\n\n<!-- more -->\n\n### 撤销一个已发布的更新\n\n**情景**: 你已经用 `git push` 将代码提交到了 GitHub，然后你意识到这其中的一个 commit 有错误，于是你想撤销那个 commit。\n\n**操作**: `git revert <SHA>`\n\n**效果**: git 会新建一个新的 commit 来执行提供的 <SHA> 对应 commit 的相反的更改，任何在该旧 commit 中删除的内容将会在新 commit 中添加进去，反之亦然。\n\n这是 git 里最安全的撤消操作的办法，因为这不会影响你的提交历史。于是现在你可以提交新的 commit 去撤销之前错误的操作了。\n\n### 修改上次 commit 的提交信息\n\n**情景**: 你在上次 commit 提交信息中打错了一个单词，比如你执行了 `git commit -m \"fxied bug #42\"` 然后你意识到应该是 `fixed bug #42`。\n\n**操作**: `git commit --amend` 或 `git commit --amend -m \"Fixes bug #42\"`\n\n**效果**: `git commit --amend` 结合最新的文件修改情况和上一次提交信息更新并替换上一次提交。没有新的文件更改就直接覆盖上次提交。\n\n### 撤销本地修改\n\n**情景**: 你家的喵星人跑到你的键盘上装逼用双爪打字然后不知怎么还点了保存，然后编辑器还崩溃了，你还没有 commit 这只猫做的修改，你想撤销那个文件里被猫修改的内容。\n\n**操作**: `git checkout -- <bad filename>`\n\n**效果**: `git checkout` 会将该文件的内容恢复到上一次 git commit 的状态。你可以提供一个分支名称或者直接提供要回到的 SHA。\n\n请记住，这种方法作出的撤销是彻底的，这些内容不会被 commit 所以之后你并不能再用 git 恢复这些内容。\n\n### 重置本地修改\n\n**情景**: 你在本地 commit 了一些内容（并没有 push），但是你搞错了，你想撤销最近这三个 commit，就像让它们从来不存在那样。\n\n**操作**: `git reset <last good SHA>` 或 `git reset --hard <last good SHA>`\n\n**效果**: `git reset` 会让你的 git 历史会退到你指定的 SHA 的状态。这些 commit 不存在了但是你硬盘上的这些文件还是维持在被修改了的状态，这是最安全的做法。但是有时你也想同时撤销硬盘上的修改，这时加上 `--hard` 就会很有用。\n\n### 撤销本地修改之后重做\n\n**情景**: 你提交了一些 commit，然后执行 `git reset --hard` 来撤消这些 commit 并清除本地硬盘上的修改。但是最后你意识到你想要回这些 commit！\n\n**操作**: `git reflog` 和 `git reset` 或 `git checkout`\n\n**效果**: `git reflog` 是个修复项目提交历史的好方法。你可以找回几乎所有内容 —— 所有你 commit 过的内容 —— 用 reflog 就行。\n\n你可能对 `git log` 很熟悉，这个操作会列出你的 git 提交历史。`git reflog` 很像它，但是列出的是 `HEAD` 修改的时间。\n\n一些说明:\n\n- `HEAD` 修改。在切换分支时 `HEAD` 会被修改，用 commit 保存修改然后用 reset 撤消修改。但是在你 `git checkout -- <bad filename>` 时并不会被修改，就像上面说过的那样，这些修改不会被 commit，所以 `git reflog` 也不能帮你找回这些内容。\n- `git reflog` 不是永远有用的。git 会定期清理那些无法追溯的内容。不要期望能用 `git reflog` 找回一个多月以前的内容。\n- 你的 `git reflog` 仅对你有用。你不能用 `git reflog` 来找回其他人 commit 的修改。\n\n![reflog](https://cloud.githubusercontent.com/assets/2077/6953866/f6b9f054-d891-11e4-8c53-838eff9f40ae.png)\n\n然后...接下来怎么做才能撤销之前的撤销？这取决你到你要干什么:\n\n- 如果你想回到一个特定的时间，用 `git reset --hard <SHA>`。\n- 如果你想在不修改提交历史的情况下找回那些文件并作为新文件保存，用 `git checkout <SHA> -- <filename>`。\n- 如果你想使其中一个 commit 回到你的项目历史中，用 `git cherry-pick <SHA>`。\n\n### 提交到了另一个分支\n\n**情景**: 你提交了一些 commits，然后意识到你当前是在 master 分支上，而你其实是想提交到一个 `feature` 分支上。\n\n**操作**: `git branch feature`, `git reset --hard origin/master`, 和 `git checkout feature`\n\n**效果**: 你可能常常使用 `git checkout -b <name>` 操作来检出一个新分支，这是一个很方便的创建新分支的操作，但是你并不想同时切换到那个分支上。现在使用 `git branch feature` 既可以创建一个 `feature` 新分支并且不会切换到那个分支，同时该分支会指向你当前分支最新的一个 commit。\n\n下一步，用 `git reset --hard` 去恢复 `master` 分支到 `origin/master` 的状态。\n\n最后，`git checkout` 到你的 `feature` 分支，你能看到所有的更改。\n\n### 覆盖整个分支\n\n**情景**: 你基于 `master` 分支创建了 `feature` 分支，但是 `master` 分支远远落后 `origin/master` 的更改。现在 `master` 分支和 `origin/master` 同步了，你想马上同步到 `feature` 分支，还不是再次远远落后。\n\n**操作**: `git checkout feature` 和 `git rebase master`\n\n**效果**: 你可能知道用 `git reset` 然后重新 commit 来达到类似效果，不过那样会丢失 commit 历史。\n\n<div class=\"tip\">文章翻译: [@egoist](https://egoist.moe/2015/10/04/how-to-undo-with-git)，版权归原作者所有。</div>\n","source":"_posts/如何在-Git-中使用撤消操作.md","raw":"---\ntitle: 如何在 Git 中使用撤消操作\ncomments: true\ndate: 2018-06-27 07:19:14\ntags:\nfrom: https://blog.github.com/2015-06-08-how-to-undo-almost-anything-with-git/\n---\n\n版本控制系统的一个好处就是你可以轻易地撤销之前错误的操作。当你用 `git commit` 提交了一个新的更改后 git 会将当时的文件内容暂时保存下来，之后你就可以用 git 随意回滚到任意一个版本。这篇文章会介绍一些常见的可能用到撤销 `undo` 操作的情况。\n\n<!-- more -->\n\n### 撤销一个已发布的更新\n\n**情景**: 你已经用 `git push` 将代码提交到了 GitHub，然后你意识到这其中的一个 commit 有错误，于是你想撤销那个 commit。\n\n**操作**: `git revert <SHA>`\n\n**效果**: git 会新建一个新的 commit 来执行提供的 <SHA> 对应 commit 的相反的更改，任何在该旧 commit 中删除的内容将会在新 commit 中添加进去，反之亦然。\n\n这是 git 里最安全的撤消操作的办法，因为这不会影响你的提交历史。于是现在你可以提交新的 commit 去撤销之前错误的操作了。\n\n### 修改上次 commit 的提交信息\n\n**情景**: 你在上次 commit 提交信息中打错了一个单词，比如你执行了 `git commit -m \"fxied bug #42\"` 然后你意识到应该是 `fixed bug #42`。\n\n**操作**: `git commit --amend` 或 `git commit --amend -m \"Fixes bug #42\"`\n\n**效果**: `git commit --amend` 结合最新的文件修改情况和上一次提交信息更新并替换上一次提交。没有新的文件更改就直接覆盖上次提交。\n\n### 撤销本地修改\n\n**情景**: 你家的喵星人跑到你的键盘上装逼用双爪打字然后不知怎么还点了保存，然后编辑器还崩溃了，你还没有 commit 这只猫做的修改，你想撤销那个文件里被猫修改的内容。\n\n**操作**: `git checkout -- <bad filename>`\n\n**效果**: `git checkout` 会将该文件的内容恢复到上一次 git commit 的状态。你可以提供一个分支名称或者直接提供要回到的 SHA。\n\n请记住，这种方法作出的撤销是彻底的，这些内容不会被 commit 所以之后你并不能再用 git 恢复这些内容。\n\n### 重置本地修改\n\n**情景**: 你在本地 commit 了一些内容（并没有 push），但是你搞错了，你想撤销最近这三个 commit，就像让它们从来不存在那样。\n\n**操作**: `git reset <last good SHA>` 或 `git reset --hard <last good SHA>`\n\n**效果**: `git reset` 会让你的 git 历史会退到你指定的 SHA 的状态。这些 commit 不存在了但是你硬盘上的这些文件还是维持在被修改了的状态，这是最安全的做法。但是有时你也想同时撤销硬盘上的修改，这时加上 `--hard` 就会很有用。\n\n### 撤销本地修改之后重做\n\n**情景**: 你提交了一些 commit，然后执行 `git reset --hard` 来撤消这些 commit 并清除本地硬盘上的修改。但是最后你意识到你想要回这些 commit！\n\n**操作**: `git reflog` 和 `git reset` 或 `git checkout`\n\n**效果**: `git reflog` 是个修复项目提交历史的好方法。你可以找回几乎所有内容 —— 所有你 commit 过的内容 —— 用 reflog 就行。\n\n你可能对 `git log` 很熟悉，这个操作会列出你的 git 提交历史。`git reflog` 很像它，但是列出的是 `HEAD` 修改的时间。\n\n一些说明:\n\n- `HEAD` 修改。在切换分支时 `HEAD` 会被修改，用 commit 保存修改然后用 reset 撤消修改。但是在你 `git checkout -- <bad filename>` 时并不会被修改，就像上面说过的那样，这些修改不会被 commit，所以 `git reflog` 也不能帮你找回这些内容。\n- `git reflog` 不是永远有用的。git 会定期清理那些无法追溯的内容。不要期望能用 `git reflog` 找回一个多月以前的内容。\n- 你的 `git reflog` 仅对你有用。你不能用 `git reflog` 来找回其他人 commit 的修改。\n\n![reflog](https://cloud.githubusercontent.com/assets/2077/6953866/f6b9f054-d891-11e4-8c53-838eff9f40ae.png)\n\n然后...接下来怎么做才能撤销之前的撤销？这取决你到你要干什么:\n\n- 如果你想回到一个特定的时间，用 `git reset --hard <SHA>`。\n- 如果你想在不修改提交历史的情况下找回那些文件并作为新文件保存，用 `git checkout <SHA> -- <filename>`。\n- 如果你想使其中一个 commit 回到你的项目历史中，用 `git cherry-pick <SHA>`。\n\n### 提交到了另一个分支\n\n**情景**: 你提交了一些 commits，然后意识到你当前是在 master 分支上，而你其实是想提交到一个 `feature` 分支上。\n\n**操作**: `git branch feature`, `git reset --hard origin/master`, 和 `git checkout feature`\n\n**效果**: 你可能常常使用 `git checkout -b <name>` 操作来检出一个新分支，这是一个很方便的创建新分支的操作，但是你并不想同时切换到那个分支上。现在使用 `git branch feature` 既可以创建一个 `feature` 新分支并且不会切换到那个分支，同时该分支会指向你当前分支最新的一个 commit。\n\n下一步，用 `git reset --hard` 去恢复 `master` 分支到 `origin/master` 的状态。\n\n最后，`git checkout` 到你的 `feature` 分支，你能看到所有的更改。\n\n### 覆盖整个分支\n\n**情景**: 你基于 `master` 分支创建了 `feature` 分支，但是 `master` 分支远远落后 `origin/master` 的更改。现在 `master` 分支和 `origin/master` 同步了，你想马上同步到 `feature` 分支，还不是再次远远落后。\n\n**操作**: `git checkout feature` 和 `git rebase master`\n\n**效果**: 你可能知道用 `git reset` 然后重新 commit 来达到类似效果，不过那样会丢失 commit 历史。\n\n<div class=\"tip\">文章翻译: [@egoist](https://egoist.moe/2015/10/04/how-to-undo-with-git)，版权归原作者所有。</div>\n","slug":"如何在-Git-中使用撤消操作","published":1,"updated":"2018-12-26T16:01:04.000Z","layout":"post","photos":[],"link":"","_id":"ck3v60jtm000or9q99u6phvas","content":"<p>版本控制系统的一个好处就是你可以轻易地撤销之前错误的操作。当你用 <code>git commit</code> 提交了一个新的更改后 git 会将当时的文件内容暂时保存下来，之后你就可以用 git 随意回滚到任意一个版本。这篇文章会介绍一些常见的可能用到撤销 <code>undo</code> 操作的情况。</p>\n<a id=\"more\"></a>\n<h3 id=\"撤销一个已发布的更新\"><a href=\"#撤销一个已发布的更新\" class=\"headerlink\" title=\"撤销一个已发布的更新\"></a>撤销一个已发布的更新</h3><p><strong>情景</strong>: 你已经用 <code>git push</code> 将代码提交到了 GitHub，然后你意识到这其中的一个 commit 有错误，于是你想撤销那个 commit。</p>\n<p><strong>操作</strong>: <code>git revert &lt;SHA&gt;</code></p>\n<p><strong>效果</strong>: git 会新建一个新的 commit 来执行提供的 <sha> 对应 commit 的相反的更改，任何在该旧 commit 中删除的内容将会在新 commit 中添加进去，反之亦然。</sha></p>\n<p>这是 git 里最安全的撤消操作的办法，因为这不会影响你的提交历史。于是现在你可以提交新的 commit 去撤销之前错误的操作了。</p>\n<h3 id=\"修改上次-commit-的提交信息\"><a href=\"#修改上次-commit-的提交信息\" class=\"headerlink\" title=\"修改上次 commit 的提交信息\"></a>修改上次 commit 的提交信息</h3><p><strong>情景</strong>: 你在上次 commit 提交信息中打错了一个单词，比如你执行了 <code>git commit -m &quot;fxied bug #42&quot;</code> 然后你意识到应该是 <code>fixed bug #42</code>。</p>\n<p><strong>操作</strong>: <code>git commit --amend</code> 或 <code>git commit --amend -m &quot;Fixes bug #42&quot;</code></p>\n<p><strong>效果</strong>: <code>git commit --amend</code> 结合最新的文件修改情况和上一次提交信息更新并替换上一次提交。没有新的文件更改就直接覆盖上次提交。</p>\n<h3 id=\"撤销本地修改\"><a href=\"#撤销本地修改\" class=\"headerlink\" title=\"撤销本地修改\"></a>撤销本地修改</h3><p><strong>情景</strong>: 你家的喵星人跑到你的键盘上装逼用双爪打字然后不知怎么还点了保存，然后编辑器还崩溃了，你还没有 commit 这只猫做的修改，你想撤销那个文件里被猫修改的内容。</p>\n<p><strong>操作</strong>: <code>git checkout -- &lt;bad filename&gt;</code></p>\n<p><strong>效果</strong>: <code>git checkout</code> 会将该文件的内容恢复到上一次 git commit 的状态。你可以提供一个分支名称或者直接提供要回到的 SHA。</p>\n<p>请记住，这种方法作出的撤销是彻底的，这些内容不会被 commit 所以之后你并不能再用 git 恢复这些内容。</p>\n<h3 id=\"重置本地修改\"><a href=\"#重置本地修改\" class=\"headerlink\" title=\"重置本地修改\"></a>重置本地修改</h3><p><strong>情景</strong>: 你在本地 commit 了一些内容（并没有 push），但是你搞错了，你想撤销最近这三个 commit，就像让它们从来不存在那样。</p>\n<p><strong>操作</strong>: <code>git reset &lt;last good SHA&gt;</code> 或 <code>git reset --hard &lt;last good SHA&gt;</code></p>\n<p><strong>效果</strong>: <code>git reset</code> 会让你的 git 历史会退到你指定的 SHA 的状态。这些 commit 不存在了但是你硬盘上的这些文件还是维持在被修改了的状态，这是最安全的做法。但是有时你也想同时撤销硬盘上的修改，这时加上 <code>--hard</code> 就会很有用。</p>\n<h3 id=\"撤销本地修改之后重做\"><a href=\"#撤销本地修改之后重做\" class=\"headerlink\" title=\"撤销本地修改之后重做\"></a>撤销本地修改之后重做</h3><p><strong>情景</strong>: 你提交了一些 commit，然后执行 <code>git reset --hard</code> 来撤消这些 commit 并清除本地硬盘上的修改。但是最后你意识到你想要回这些 commit！</p>\n<p><strong>操作</strong>: <code>git reflog</code> 和 <code>git reset</code> 或 <code>git checkout</code></p>\n<p><strong>效果</strong>: <code>git reflog</code> 是个修复项目提交历史的好方法。你可以找回几乎所有内容 —— 所有你 commit 过的内容 —— 用 reflog 就行。</p>\n<p>你可能对 <code>git log</code> 很熟悉，这个操作会列出你的 git 提交历史。<code>git reflog</code> 很像它，但是列出的是 <code>HEAD</code> 修改的时间。</p>\n<p>一些说明:</p>\n<ul>\n<li><code>HEAD</code> 修改。在切换分支时 <code>HEAD</code> 会被修改，用 commit 保存修改然后用 reset 撤消修改。但是在你 <code>git checkout -- &lt;bad filename&gt;</code> 时并不会被修改，就像上面说过的那样，这些修改不会被 commit，所以 <code>git reflog</code> 也不能帮你找回这些内容。</li>\n<li><code>git reflog</code> 不是永远有用的。git 会定期清理那些无法追溯的内容。不要期望能用 <code>git reflog</code> 找回一个多月以前的内容。</li>\n<li>你的 <code>git reflog</code> 仅对你有用。你不能用 <code>git reflog</code> 来找回其他人 commit 的修改。</li>\n</ul>\n<p><img src=\"https://cloud.githubusercontent.com/assets/2077/6953866/f6b9f054-d891-11e4-8c53-838eff9f40ae.png\" alt=\"reflog\"></p>\n<p>然后…接下来怎么做才能撤销之前的撤销？这取决你到你要干什么:</p>\n<ul>\n<li>如果你想回到一个特定的时间，用 <code>git reset --hard &lt;SHA&gt;</code>。</li>\n<li>如果你想在不修改提交历史的情况下找回那些文件并作为新文件保存，用 <code>git checkout &lt;SHA&gt; -- &lt;filename&gt;</code>。</li>\n<li>如果你想使其中一个 commit 回到你的项目历史中，用 <code>git cherry-pick &lt;SHA&gt;</code>。</li>\n</ul>\n<h3 id=\"提交到了另一个分支\"><a href=\"#提交到了另一个分支\" class=\"headerlink\" title=\"提交到了另一个分支\"></a>提交到了另一个分支</h3><p><strong>情景</strong>: 你提交了一些 commits，然后意识到你当前是在 master 分支上，而你其实是想提交到一个 <code>feature</code> 分支上。</p>\n<p><strong>操作</strong>: <code>git branch feature</code>, <code>git reset --hard origin/master</code>, 和 <code>git checkout feature</code></p>\n<p><strong>效果</strong>: 你可能常常使用 <code>git checkout -b &lt;name&gt;</code> 操作来检出一个新分支，这是一个很方便的创建新分支的操作，但是你并不想同时切换到那个分支上。现在使用 <code>git branch feature</code> 既可以创建一个 <code>feature</code> 新分支并且不会切换到那个分支，同时该分支会指向你当前分支最新的一个 commit。</p>\n<p>下一步，用 <code>git reset --hard</code> 去恢复 <code>master</code> 分支到 <code>origin/master</code> 的状态。</p>\n<p>最后，<code>git checkout</code> 到你的 <code>feature</code> 分支，你能看到所有的更改。</p>\n<h3 id=\"覆盖整个分支\"><a href=\"#覆盖整个分支\" class=\"headerlink\" title=\"覆盖整个分支\"></a>覆盖整个分支</h3><p><strong>情景</strong>: 你基于 <code>master</code> 分支创建了 <code>feature</code> 分支，但是 <code>master</code> 分支远远落后 <code>origin/master</code> 的更改。现在 <code>master</code> 分支和 <code>origin/master</code> 同步了，你想马上同步到 <code>feature</code> 分支，还不是再次远远落后。</p>\n<p><strong>操作</strong>: <code>git checkout feature</code> 和 <code>git rebase master</code></p>\n<p><strong>效果</strong>: 你可能知道用 <code>git reset</code> 然后重新 commit 来达到类似效果，不过那样会丢失 commit 历史。</p>\n<div class=\"tip\">文章翻译: <a href=\"https://egoist.moe/2015/10/04/how-to-undo-with-git\" target=\"_blank\" rel=\"noopener\">@egoist</a>，版权归原作者所有。</div>\n","site":{"data":{}},"excerpt":"<p>版本控制系统的一个好处就是你可以轻易地撤销之前错误的操作。当你用 <code>git commit</code> 提交了一个新的更改后 git 会将当时的文件内容暂时保存下来，之后你就可以用 git 随意回滚到任意一个版本。这篇文章会介绍一些常见的可能用到撤销 <code>undo</code> 操作的情况。</p>","more":"<h3 id=\"撤销一个已发布的更新\"><a href=\"#撤销一个已发布的更新\" class=\"headerlink\" title=\"撤销一个已发布的更新\"></a>撤销一个已发布的更新</h3><p><strong>情景</strong>: 你已经用 <code>git push</code> 将代码提交到了 GitHub，然后你意识到这其中的一个 commit 有错误，于是你想撤销那个 commit。</p>\n<p><strong>操作</strong>: <code>git revert &lt;SHA&gt;</code></p>\n<p><strong>效果</strong>: git 会新建一个新的 commit 来执行提供的 <sha> 对应 commit 的相反的更改，任何在该旧 commit 中删除的内容将会在新 commit 中添加进去，反之亦然。</sha></p>\n<p>这是 git 里最安全的撤消操作的办法，因为这不会影响你的提交历史。于是现在你可以提交新的 commit 去撤销之前错误的操作了。</p>\n<h3 id=\"修改上次-commit-的提交信息\"><a href=\"#修改上次-commit-的提交信息\" class=\"headerlink\" title=\"修改上次 commit 的提交信息\"></a>修改上次 commit 的提交信息</h3><p><strong>情景</strong>: 你在上次 commit 提交信息中打错了一个单词，比如你执行了 <code>git commit -m &quot;fxied bug #42&quot;</code> 然后你意识到应该是 <code>fixed bug #42</code>。</p>\n<p><strong>操作</strong>: <code>git commit --amend</code> 或 <code>git commit --amend -m &quot;Fixes bug #42&quot;</code></p>\n<p><strong>效果</strong>: <code>git commit --amend</code> 结合最新的文件修改情况和上一次提交信息更新并替换上一次提交。没有新的文件更改就直接覆盖上次提交。</p>\n<h3 id=\"撤销本地修改\"><a href=\"#撤销本地修改\" class=\"headerlink\" title=\"撤销本地修改\"></a>撤销本地修改</h3><p><strong>情景</strong>: 你家的喵星人跑到你的键盘上装逼用双爪打字然后不知怎么还点了保存，然后编辑器还崩溃了，你还没有 commit 这只猫做的修改，你想撤销那个文件里被猫修改的内容。</p>\n<p><strong>操作</strong>: <code>git checkout -- &lt;bad filename&gt;</code></p>\n<p><strong>效果</strong>: <code>git checkout</code> 会将该文件的内容恢复到上一次 git commit 的状态。你可以提供一个分支名称或者直接提供要回到的 SHA。</p>\n<p>请记住，这种方法作出的撤销是彻底的，这些内容不会被 commit 所以之后你并不能再用 git 恢复这些内容。</p>\n<h3 id=\"重置本地修改\"><a href=\"#重置本地修改\" class=\"headerlink\" title=\"重置本地修改\"></a>重置本地修改</h3><p><strong>情景</strong>: 你在本地 commit 了一些内容（并没有 push），但是你搞错了，你想撤销最近这三个 commit，就像让它们从来不存在那样。</p>\n<p><strong>操作</strong>: <code>git reset &lt;last good SHA&gt;</code> 或 <code>git reset --hard &lt;last good SHA&gt;</code></p>\n<p><strong>效果</strong>: <code>git reset</code> 会让你的 git 历史会退到你指定的 SHA 的状态。这些 commit 不存在了但是你硬盘上的这些文件还是维持在被修改了的状态，这是最安全的做法。但是有时你也想同时撤销硬盘上的修改，这时加上 <code>--hard</code> 就会很有用。</p>\n<h3 id=\"撤销本地修改之后重做\"><a href=\"#撤销本地修改之后重做\" class=\"headerlink\" title=\"撤销本地修改之后重做\"></a>撤销本地修改之后重做</h3><p><strong>情景</strong>: 你提交了一些 commit，然后执行 <code>git reset --hard</code> 来撤消这些 commit 并清除本地硬盘上的修改。但是最后你意识到你想要回这些 commit！</p>\n<p><strong>操作</strong>: <code>git reflog</code> 和 <code>git reset</code> 或 <code>git checkout</code></p>\n<p><strong>效果</strong>: <code>git reflog</code> 是个修复项目提交历史的好方法。你可以找回几乎所有内容 —— 所有你 commit 过的内容 —— 用 reflog 就行。</p>\n<p>你可能对 <code>git log</code> 很熟悉，这个操作会列出你的 git 提交历史。<code>git reflog</code> 很像它，但是列出的是 <code>HEAD</code> 修改的时间。</p>\n<p>一些说明:</p>\n<ul>\n<li><code>HEAD</code> 修改。在切换分支时 <code>HEAD</code> 会被修改，用 commit 保存修改然后用 reset 撤消修改。但是在你 <code>git checkout -- &lt;bad filename&gt;</code> 时并不会被修改，就像上面说过的那样，这些修改不会被 commit，所以 <code>git reflog</code> 也不能帮你找回这些内容。</li>\n<li><code>git reflog</code> 不是永远有用的。git 会定期清理那些无法追溯的内容。不要期望能用 <code>git reflog</code> 找回一个多月以前的内容。</li>\n<li>你的 <code>git reflog</code> 仅对你有用。你不能用 <code>git reflog</code> 来找回其他人 commit 的修改。</li>\n</ul>\n<p><img src=\"https://cloud.githubusercontent.com/assets/2077/6953866/f6b9f054-d891-11e4-8c53-838eff9f40ae.png\" alt=\"reflog\"></p>\n<p>然后…接下来怎么做才能撤销之前的撤销？这取决你到你要干什么:</p>\n<ul>\n<li>如果你想回到一个特定的时间，用 <code>git reset --hard &lt;SHA&gt;</code>。</li>\n<li>如果你想在不修改提交历史的情况下找回那些文件并作为新文件保存，用 <code>git checkout &lt;SHA&gt; -- &lt;filename&gt;</code>。</li>\n<li>如果你想使其中一个 commit 回到你的项目历史中，用 <code>git cherry-pick &lt;SHA&gt;</code>。</li>\n</ul>\n<h3 id=\"提交到了另一个分支\"><a href=\"#提交到了另一个分支\" class=\"headerlink\" title=\"提交到了另一个分支\"></a>提交到了另一个分支</h3><p><strong>情景</strong>: 你提交了一些 commits，然后意识到你当前是在 master 分支上，而你其实是想提交到一个 <code>feature</code> 分支上。</p>\n<p><strong>操作</strong>: <code>git branch feature</code>, <code>git reset --hard origin/master</code>, 和 <code>git checkout feature</code></p>\n<p><strong>效果</strong>: 你可能常常使用 <code>git checkout -b &lt;name&gt;</code> 操作来检出一个新分支，这是一个很方便的创建新分支的操作，但是你并不想同时切换到那个分支上。现在使用 <code>git branch feature</code> 既可以创建一个 <code>feature</code> 新分支并且不会切换到那个分支，同时该分支会指向你当前分支最新的一个 commit。</p>\n<p>下一步，用 <code>git reset --hard</code> 去恢复 <code>master</code> 分支到 <code>origin/master</code> 的状态。</p>\n<p>最后，<code>git checkout</code> 到你的 <code>feature</code> 分支，你能看到所有的更改。</p>\n<h3 id=\"覆盖整个分支\"><a href=\"#覆盖整个分支\" class=\"headerlink\" title=\"覆盖整个分支\"></a>覆盖整个分支</h3><p><strong>情景</strong>: 你基于 <code>master</code> 分支创建了 <code>feature</code> 分支，但是 <code>master</code> 分支远远落后 <code>origin/master</code> 的更改。现在 <code>master</code> 分支和 <code>origin/master</code> 同步了，你想马上同步到 <code>feature</code> 分支，还不是再次远远落后。</p>\n<p><strong>操作</strong>: <code>git checkout feature</code> 和 <code>git rebase master</code></p>\n<p><strong>效果</strong>: 你可能知道用 <code>git reset</code> 然后重新 commit 来达到类似效果，不过那样会丢失 commit 历史。</p>\n<div class=\"tip\">文章翻译: <a href=\"https://egoist.moe/2015/10/04/how-to-undo-with-git\" target=\"_blank\" rel=\"noopener\">@egoist</a>，版权归原作者所有。</div>"},{"title":"一段神奇的 CSS 调试代码","date":"2016-03-22T08:32:52.000Z","comments":0,"_content":"\n现在到处都是 JavaScript，倘若花点时间去深入分析，每次都能学到点新的东西。当我发现些有意思的东西，习惯先收藏起来。等时技（时间＋技术）成熟，再去 Review 他们的代码，看一看它们是如何做到的，览一览大牛们的 “奇技淫巧”。\n<!-- more -->\n### 代码片段\n\n```js\n[].forEach.call($$(\"*\"),function(a){\n    a.style.outline=\"1px solid #\"+(~~(Math.random()*(1<<24))).toString(16);\n})\n```\n在浏览器控制台运行此段代码，会给页面里所有的 DOM 元素添加一个 1px 的描边（outline），方便我们在调试 CSS 过程中分析、排查问题。\n![](http://ww1.sinaimg.cn/large/6057861cgy1fbzi0vggl6j21kw0vyq8s.jpg)\n\n\n### 代码分析\n这段代码是 Github 上的 140 Bytes 活动中的代码，简单分析下这段 JS 代码，作者使用了不少技巧：\n\n首先是需要选择页面上的所有元素，这里使用了只能在 Console 调试工具中使用的 `$$` 函数，你可以在 Console 中输入 `$$('a')` 自己试一下。它会返回当前页面的所有 anchor（链接）元素。`$$` 与 `document.querySelectorAll` 是等价的，有兴趣可[查看](http://ourjs.com/detail/54ab768a5695544119000007) $$ 和 $ 选择器的历史。\n\n其次遍历所有元素，这里用的是 `[].forEach.call(...)`，使用 forEach 替代 for 之类循环能减少不少代码量，而 forEach 是 Array 对象的方法，所以用了个 `[]` 空数组来代替 `Array.prototype` 更显简洁，得到所有元素的节点列表（NodeList），但是它并没有实现 Array 的所有接口，因此使用 `$$(\"*\").forEach` 会返回错误，这里使用 `call` 方法来更改 forEach 内部 `this` 指向，当然也可以使用 `apply`。\n\n之后就是让元素有一个漂亮的边框，并拥有不同的颜色了。在 CSS 渲染的盒子模型（Box Model）中，`outline` ***并不会改变元素及其布局的位置***。这里较有意思的是定义不同的颜色的色值：\n```js\n~~(Math.random()*(1<<24))).toString(16)\n```\n这里想构造的其实是一个 16 进制的颜色值，即 `000000～ffffff`，也就是 `parseInt('0',16)` 到 `parseInt('ffffff',16)` 之间的一个值。\n\n```js\nparseInt('ffffff',16) == 16777215 == (2^24-1) == (1<<24 - 1)\n```\n\n而 `Math.random()`，得到的是一个 0~1 之间的浮点数，`(Math.random()*(1<<24)`，即得到 0~16777215 之间的浮点数，而色值是需要整数的，所以就需要将浮点数进行 int 转换。这里用到了 `~~`，可[参见](http://www.jeffjade.com/2015/05/31/2015-05-31-javascript-operational%EF%BC%8Dsymbol/)理解 JavaScript 非运算符(~/~~ )。当然可以将 `~~` 视为 `parseInt` 的简写。并且使用按位或 `|` 操作符也可以得到相同的结果：\n\n```js\nvar a = 1.234567890;\nvar b = 0.000000001;\n~~a == 0|a == parseInt(a, 10) == 1\n~~b == 0|b == parseInt(b, 10) == 0\n```\n`toString(16)` 使用数字类型的 `toString` 方法进行十进制到 16 进制的转换。至此我们得到了一个 0 到 16777215 之间的随机数，然后使用 `toString(16)` 转换成 16 进制，将此值赋予到页面上所有元素节点的 `outline` 附加属性上。它就是这样工作的。精致巧妙而且非常实用，顶一个！\n","source":"_posts/一段神奇的-CSS-调试代码.md","raw":"---\ntitle: 一段神奇的 CSS 调试代码\ndate: 2016-03-22 16:32:52\ntags:\ncomments: false\n---\n\n现在到处都是 JavaScript，倘若花点时间去深入分析，每次都能学到点新的东西。当我发现些有意思的东西，习惯先收藏起来。等时技（时间＋技术）成熟，再去 Review 他们的代码，看一看它们是如何做到的，览一览大牛们的 “奇技淫巧”。\n<!-- more -->\n### 代码片段\n\n```js\n[].forEach.call($$(\"*\"),function(a){\n    a.style.outline=\"1px solid #\"+(~~(Math.random()*(1<<24))).toString(16);\n})\n```\n在浏览器控制台运行此段代码，会给页面里所有的 DOM 元素添加一个 1px 的描边（outline），方便我们在调试 CSS 过程中分析、排查问题。\n![](http://ww1.sinaimg.cn/large/6057861cgy1fbzi0vggl6j21kw0vyq8s.jpg)\n\n\n### 代码分析\n这段代码是 Github 上的 140 Bytes 活动中的代码，简单分析下这段 JS 代码，作者使用了不少技巧：\n\n首先是需要选择页面上的所有元素，这里使用了只能在 Console 调试工具中使用的 `$$` 函数，你可以在 Console 中输入 `$$('a')` 自己试一下。它会返回当前页面的所有 anchor（链接）元素。`$$` 与 `document.querySelectorAll` 是等价的，有兴趣可[查看](http://ourjs.com/detail/54ab768a5695544119000007) $$ 和 $ 选择器的历史。\n\n其次遍历所有元素，这里用的是 `[].forEach.call(...)`，使用 forEach 替代 for 之类循环能减少不少代码量，而 forEach 是 Array 对象的方法，所以用了个 `[]` 空数组来代替 `Array.prototype` 更显简洁，得到所有元素的节点列表（NodeList），但是它并没有实现 Array 的所有接口，因此使用 `$$(\"*\").forEach` 会返回错误，这里使用 `call` 方法来更改 forEach 内部 `this` 指向，当然也可以使用 `apply`。\n\n之后就是让元素有一个漂亮的边框，并拥有不同的颜色了。在 CSS 渲染的盒子模型（Box Model）中，`outline` ***并不会改变元素及其布局的位置***。这里较有意思的是定义不同的颜色的色值：\n```js\n~~(Math.random()*(1<<24))).toString(16)\n```\n这里想构造的其实是一个 16 进制的颜色值，即 `000000～ffffff`，也就是 `parseInt('0',16)` 到 `parseInt('ffffff',16)` 之间的一个值。\n\n```js\nparseInt('ffffff',16) == 16777215 == (2^24-1) == (1<<24 - 1)\n```\n\n而 `Math.random()`，得到的是一个 0~1 之间的浮点数，`(Math.random()*(1<<24)`，即得到 0~16777215 之间的浮点数，而色值是需要整数的，所以就需要将浮点数进行 int 转换。这里用到了 `~~`，可[参见](http://www.jeffjade.com/2015/05/31/2015-05-31-javascript-operational%EF%BC%8Dsymbol/)理解 JavaScript 非运算符(~/~~ )。当然可以将 `~~` 视为 `parseInt` 的简写。并且使用按位或 `|` 操作符也可以得到相同的结果：\n\n```js\nvar a = 1.234567890;\nvar b = 0.000000001;\n~~a == 0|a == parseInt(a, 10) == 1\n~~b == 0|b == parseInt(b, 10) == 0\n```\n`toString(16)` 使用数字类型的 `toString` 方法进行十进制到 16 进制的转换。至此我们得到了一个 0 到 16777215 之间的随机数，然后使用 `toString(16)` 转换成 16 进制，将此值赋予到页面上所有元素节点的 `outline` 附加属性上。它就是这样工作的。精致巧妙而且非常实用，顶一个！\n","slug":"一段神奇的-CSS-调试代码","published":1,"updated":"2019-12-07T04:59:35.962Z","layout":"post","photos":[],"link":"","_id":"ck3v60jtn000pr9q91hujgb7h","content":"<p>现在到处都是 JavaScript，倘若花点时间去深入分析，每次都能学到点新的东西。当我发现些有意思的东西，习惯先收藏起来。等时技（时间＋技术）成熟，再去 Review 他们的代码，看一看它们是如何做到的，览一览大牛们的 “奇技淫巧”。<br><a id=\"more\"></a></p>\n<h3 id=\"代码片段\"><a href=\"#代码片段\" class=\"headerlink\" title=\"代码片段\"></a>代码片段</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[].forEach.call($$(<span class=\"string\">\"*\"</span>),<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">    a.style.outline=<span class=\"string\">\"1px solid #\"</span>+(~~(<span class=\"built_in\">Math</span>.random()*(<span class=\"number\">1</span>&lt;&lt;<span class=\"number\">24</span>))).toString(<span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>在浏览器控制台运行此段代码，会给页面里所有的 DOM 元素添加一个 1px 的描边（outline），方便我们在调试 CSS 过程中分析、排查问题。<br><img src=\"http://ww1.sinaimg.cn/large/6057861cgy1fbzi0vggl6j21kw0vyq8s.jpg\" alt=\"\"></p>\n<h3 id=\"代码分析\"><a href=\"#代码分析\" class=\"headerlink\" title=\"代码分析\"></a>代码分析</h3><p>这段代码是 Github 上的 140 Bytes 活动中的代码，简单分析下这段 JS 代码，作者使用了不少技巧：</p>\n<p>首先是需要选择页面上的所有元素，这里使用了只能在 Console 调试工具中使用的 <code>$$</code> 函数，你可以在 Console 中输入 <code>$$(&#39;a&#39;)</code> 自己试一下。它会返回当前页面的所有 anchor（链接）元素。<code>$$</code> 与 <code>document.querySelectorAll</code> 是等价的，有兴趣可<a href=\"http://ourjs.com/detail/54ab768a5695544119000007\" target=\"_blank\" rel=\"noopener\">查看</a> $$ 和 $ 选择器的历史。</p>\n<p>其次遍历所有元素，这里用的是 <code>[].forEach.call(...)</code>，使用 forEach 替代 for 之类循环能减少不少代码量，而 forEach 是 Array 对象的方法，所以用了个 <code>[]</code> 空数组来代替 <code>Array.prototype</code> 更显简洁，得到所有元素的节点列表（NodeList），但是它并没有实现 Array 的所有接口，因此使用 <code>$$(&quot;*&quot;).forEach</code> 会返回错误，这里使用 <code>call</code> 方法来更改 forEach 内部 <code>this</code> 指向，当然也可以使用 <code>apply</code>。</p>\n<p>之后就是让元素有一个漂亮的边框，并拥有不同的颜色了。在 CSS 渲染的盒子模型（Box Model）中，<code>outline</code> <strong><em>并不会改变元素及其布局的位置</em></strong>。这里较有意思的是定义不同的颜色的色值：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~~(<span class=\"built_in\">Math</span>.random()*(<span class=\"number\">1</span>&lt;&lt;<span class=\"number\">24</span>))).toString(<span class=\"number\">16</span>)</span><br></pre></td></tr></table></figure></p>\n<p>这里想构造的其实是一个 16 进制的颜色值，即 <code>000000～ffffff</code>，也就是 <code>parseInt(&#39;0&#39;,16)</code> 到 <code>parseInt(&#39;ffffff&#39;,16)</code> 之间的一个值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"string\">'ffffff'</span>,<span class=\"number\">16</span>) == <span class=\"number\">16777215</span> == (<span class=\"number\">2</span>^<span class=\"number\">24</span><span class=\"number\">-1</span>) == (<span class=\"number\">1</span>&lt;&lt;<span class=\"number\">24</span> - <span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n<p>而 <code>Math.random()</code>，得到的是一个 0~1 之间的浮点数，<code>(Math.random()*(1&lt;&lt;24)</code>，即得到 0~16777215 之间的浮点数，而色值是需要整数的，所以就需要将浮点数进行 int 转换。这里用到了 <code>~~</code>，可<a href=\"http://www.jeffjade.com/2015/05/31/2015-05-31-javascript-operational%EF%BC%8Dsymbol/\" target=\"_blank\" rel=\"noopener\">参见</a>理解 JavaScript 非运算符(~/~~ )。当然可以将 <code>~~</code> 视为 <code>parseInt</code> 的简写。并且使用按位或 <code>|</code> 操作符也可以得到相同的结果：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1.234567890</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">0.000000001</span>;</span><br><span class=\"line\">~~a == <span class=\"number\">0</span>|a == <span class=\"built_in\">parseInt</span>(a, <span class=\"number\">10</span>) == <span class=\"number\">1</span></span><br><span class=\"line\">~~b == <span class=\"number\">0</span>|b == <span class=\"built_in\">parseInt</span>(b, <span class=\"number\">10</span>) == <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<p><code>toString(16)</code> 使用数字类型的 <code>toString</code> 方法进行十进制到 16 进制的转换。至此我们得到了一个 0 到 16777215 之间的随机数，然后使用 <code>toString(16)</code> 转换成 16 进制，将此值赋予到页面上所有元素节点的 <code>outline</code> 附加属性上。它就是这样工作的。精致巧妙而且非常实用，顶一个！</p>\n","site":{"data":{}},"excerpt":"<p>现在到处都是 JavaScript，倘若花点时间去深入分析，每次都能学到点新的东西。当我发现些有意思的东西，习惯先收藏起来。等时技（时间＋技术）成熟，再去 Review 他们的代码，看一看它们是如何做到的，览一览大牛们的 “奇技淫巧”。<br>","more":"</p>\n<h3 id=\"代码片段\"><a href=\"#代码片段\" class=\"headerlink\" title=\"代码片段\"></a>代码片段</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[].forEach.call($$(<span class=\"string\">\"*\"</span>),<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">    a.style.outline=<span class=\"string\">\"1px solid #\"</span>+(~~(<span class=\"built_in\">Math</span>.random()*(<span class=\"number\">1</span>&lt;&lt;<span class=\"number\">24</span>))).toString(<span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>在浏览器控制台运行此段代码，会给页面里所有的 DOM 元素添加一个 1px 的描边（outline），方便我们在调试 CSS 过程中分析、排查问题。<br><img src=\"http://ww1.sinaimg.cn/large/6057861cgy1fbzi0vggl6j21kw0vyq8s.jpg\" alt=\"\"></p>\n<h3 id=\"代码分析\"><a href=\"#代码分析\" class=\"headerlink\" title=\"代码分析\"></a>代码分析</h3><p>这段代码是 Github 上的 140 Bytes 活动中的代码，简单分析下这段 JS 代码，作者使用了不少技巧：</p>\n<p>首先是需要选择页面上的所有元素，这里使用了只能在 Console 调试工具中使用的 <code>$$</code> 函数，你可以在 Console 中输入 <code>$$(&#39;a&#39;)</code> 自己试一下。它会返回当前页面的所有 anchor（链接）元素。<code>$$</code> 与 <code>document.querySelectorAll</code> 是等价的，有兴趣可<a href=\"http://ourjs.com/detail/54ab768a5695544119000007\" target=\"_blank\" rel=\"noopener\">查看</a> $$ 和 $ 选择器的历史。</p>\n<p>其次遍历所有元素，这里用的是 <code>[].forEach.call(...)</code>，使用 forEach 替代 for 之类循环能减少不少代码量，而 forEach 是 Array 对象的方法，所以用了个 <code>[]</code> 空数组来代替 <code>Array.prototype</code> 更显简洁，得到所有元素的节点列表（NodeList），但是它并没有实现 Array 的所有接口，因此使用 <code>$$(&quot;*&quot;).forEach</code> 会返回错误，这里使用 <code>call</code> 方法来更改 forEach 内部 <code>this</code> 指向，当然也可以使用 <code>apply</code>。</p>\n<p>之后就是让元素有一个漂亮的边框，并拥有不同的颜色了。在 CSS 渲染的盒子模型（Box Model）中，<code>outline</code> <strong><em>并不会改变元素及其布局的位置</em></strong>。这里较有意思的是定义不同的颜色的色值：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~~(<span class=\"built_in\">Math</span>.random()*(<span class=\"number\">1</span>&lt;&lt;<span class=\"number\">24</span>))).toString(<span class=\"number\">16</span>)</span><br></pre></td></tr></table></figure></p>\n<p>这里想构造的其实是一个 16 进制的颜色值，即 <code>000000～ffffff</code>，也就是 <code>parseInt(&#39;0&#39;,16)</code> 到 <code>parseInt(&#39;ffffff&#39;,16)</code> 之间的一个值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"string\">'ffffff'</span>,<span class=\"number\">16</span>) == <span class=\"number\">16777215</span> == (<span class=\"number\">2</span>^<span class=\"number\">24</span><span class=\"number\">-1</span>) == (<span class=\"number\">1</span>&lt;&lt;<span class=\"number\">24</span> - <span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n<p>而 <code>Math.random()</code>，得到的是一个 0~1 之间的浮点数，<code>(Math.random()*(1&lt;&lt;24)</code>，即得到 0~16777215 之间的浮点数，而色值是需要整数的，所以就需要将浮点数进行 int 转换。这里用到了 <code>~~</code>，可<a href=\"http://www.jeffjade.com/2015/05/31/2015-05-31-javascript-operational%EF%BC%8Dsymbol/\" target=\"_blank\" rel=\"noopener\">参见</a>理解 JavaScript 非运算符(~/~~ )。当然可以将 <code>~~</code> 视为 <code>parseInt</code> 的简写。并且使用按位或 <code>|</code> 操作符也可以得到相同的结果：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1.234567890</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">0.000000001</span>;</span><br><span class=\"line\">~~a == <span class=\"number\">0</span>|a == <span class=\"built_in\">parseInt</span>(a, <span class=\"number\">10</span>) == <span class=\"number\">1</span></span><br><span class=\"line\">~~b == <span class=\"number\">0</span>|b == <span class=\"built_in\">parseInt</span>(b, <span class=\"number\">10</span>) == <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<p><code>toString(16)</code> 使用数字类型的 <code>toString</code> 方法进行十进制到 16 进制的转换。至此我们得到了一个 0 到 16777215 之间的随机数，然后使用 <code>toString(16)</code> 转换成 16 进制，将此值赋予到页面上所有元素节点的 <code>outline</code> 附加属性上。它就是这样工作的。精致巧妙而且非常实用，顶一个！</p>"},{"title":"我的主管给我的一些建议","comments":1,"date":"2018-06-20T23:43:58.000Z","from":null,"_content":"\n本文翻译自 [Reddit](https://www.reddit.com/r/startups/comments/74pms1/my_manager_who_i_loved_recently_left_my_company_i/) 上的一篇文章。其主要内容为一名职工记录了他与其已离职的主管的一对一交流。其中总结了大量关于职业生涯，工作内容，人际关系，自我成长的建议。\n\n<!-- more -->\n\n### 首要任务\n\n**确定并专注于你的首要任务 – 如果不，那么你整天在干什么？**\n\n优先任务真的是最首要任务的吗？ 当前你需要做得最为重要的事是什么？如果你不能回答这个问题，那么你就应该停下手头的所有工作然后先弄清楚你的答案。有明确的答案能让你更加明确目标与专注。没有明确的答案往往会导致你经常在做一些并不重要的事并且浪费大量宝贵的时间。\n\n每天总会有源源不断需要做的事儿。人们常会倾向于先做简单、有趣或熟悉的任务。但长远来看这是一个陷阱。完成首要任务 5%-10% 的工作量比做大量对目标无益的任务更好。\n\n> 往往自己认为应该优先做的工作其实并不是当前目标的首要任务\n\n你负责什么？ 企业中的每个人都应该负责一定的工作。理想情况下，它应该是与你的首要目标相关的度量指标。如果不是，那么你就应该和你的主管或者老板好好谈一谈来确定你的首要任务。当你确立好你的首要任务后，你还会保证你已了解了足够的信息来提升这个指标。\n\n掌控好你的负责范围。 一般人们都会想善于完成他们的工作。听起来很明显，但有时候环境会诱惑你去做一些无关紧要的事情。这时候就值得注意了，返回去看第一条 – 保持首要任务的优先。\n\n精确你的目标。 如果目标有点模糊，空出一点时间来确立它的精确性。不要去做较为模糊的工作 – 它们常常会令人分心和做一些超出目标范围的事。要学会鉴别自己思考，文字，及交流中的模糊地带，然后把这些模糊都消除掉，使之清晰明了。\n\n### 高效管理\n\n**把自己当做宝贵且重要的资源一样管理**\n\n不要不懂装懂。 对自己要坦诚相待，对自己有清晰的自我认识能让你更快的学习和提升。如果你抱着坦诚的心态与他人交流，别人也会坦诚对待你，由此一个舒适健康的交流环境就建立起来了，并且不断的影响着周围的人。\n\n制定计划并执行。 我小时候非常讨厌日历和时间表，并且花费了大量时间应付各种截至日期的潜在压力。但事实是：无论讨厌还是喜欢计划，我们只有有限的时间和无尽的任务需要做，这些都不会随着我们的主观意识而改变。没有良好的计划，我们最终会无休止的工作。如果你不主动提前决定你应该怎么花费你得时间和精力，那么会有其他的事情会帮你做决定 – 被别人打断或者一些无关紧要的任务（它们都会让你不由自主的花时间去处理）。\n\n经过多年的反思和摇摆，我逐渐意识到我的问题并非是指定计划，而且被动的去做一些我不想做的事儿。我只是潜意识的对日历，计划有着反抗态度。如果你和我一样，这需要花费大量精力去消除这些影响。开始制定一些简单的计划然后完成。写下一些你能 5 分钟内完成的事，然后执行，完成。反复如此计划执行，计划执行，直到你做的越来越好，然后逐渐加多时间。冰冻三尺非一日之寒，通过不断练习及加大任务量及时间，会变得越来越复杂，就像玩游戏一样。当你开始习惯这样的循序渐进方式时，会变得越来越有趣和令人激动。你将会越来越了解你自己及你周围的世界。\n\n劳逸结合。 你是一项宝贵的资源，并且需要休整。不要快速耗尽精力，要学会细水长流，当做马拉松来看。但我开始工作时，我感觉我获得了一个难得可贵的机会、觉的自己还不够格、顶着压力、常常埋头苦干、但还感到自己落后于工作，然后我开始拖延和延期直到我休了个假。现在回过头来看，这真是个滑稽的行为，而且我非常后悔。如果当初我抗住压力和提前安排好时间，我会更加开心，健康，完成更多得工作。\n\n吾日三省吾身。 分析过去的工作，哪些完成了，哪些没有，哪些最终效果不错，哪些失败…… 你应该定期独立这样回顾分析工作。我经常偷懒记笔记，即使记了也基本不会回头再看。如果我能重新来过，我会更加系统的严于利己的对待此事。\n\n> 通过定期复盘能够不断强化自己对一个项目的理解，如果项目越滚越大，还是会对项目的掌控游刃有余。定期的复盘还能起到找出弱项，弥补不足，吸取经验，让自己之后能够更优异的完成任务。很多宝贵的经验，经历了一次就完了的人算作普通人；经历了一次并吸取经验在以后遇到同样问题能够通过经验解决的人算作优秀的人；经历了一次不仅吸取了经验，还能做到复盘举一反三的能称之为非常有前景的人才了\n\n表述你的进度。 这在多个层面上均非常有帮助。首先，只需要给高强度工作的大脑腾点休息时间，把工作进度手写在纸上，这是一个非常有用的习惯。这会强迫你把想要表达的东西表述出来。你想要达成什么目标？你是如果做出决策的？当你在用文字表述你的进度的时候，你还能顺带分析下。你能找出弱项并强化它们。这就像是在看自己的回放一样，能够注意到更多的细节。当然，你还能与他人分享你的表述，并收到反馈，这又是更进一步的提升了。\n\n> 通过具体的语言或者文字表述自己工作的进度，可以把大脑里抽象的思考具体化，并由此观察细节找出问题或者弱点并强化。通过具体的表述能够增强逻辑能力，锻炼表达能力与更清晰的认识自己做的事儿。\n\n为自己负责。 即使你有非常优秀的主管，但是你最终会为自己的学习、执行和成长进行负责。回顾以前，我觉得我自己花费了第一个 3-4 年在舒适区，从不主动出击。我的确有一个非常优秀的主管，给我了大量的目标、建议和规划，也许他们还给我剧透了一些信息。但我花了几年的时间才发现『我必须给自己设定更高的目标，并努力达成』。除非你有一个非常疯狂的老板或者主管分配给你高难度工作，不然没有人能比你更适合把自己推到极限。（我并不是暗示大量的工作和大量的时间，我想表达的是跳出你的舒适区，挑战自己达到下一个高度。尝试新鲜事物，学习超出你工作范畴的新东西等等）\n\n花时间学习。 当你发现一些和你工作相关的干货资料时，标注一下稍后再看，然后定期去浏览学习这些存货。按周来规划是非常不错的。如果你已经在大量的阅读和学习了，那么和其他人分享下你的心得。这会帮助你更加深刻的理解你学到的东西。建议设置月度或者季度学习目标。\n\n> 学习的最高形式便是传授；不积跬步无以至千里，要想通过 7 天学会 XXX，21 天学会 XXX 的这类爆款无异于痴人说梦，这些鸡汤往往只能教会你最基础的 hello, world. 合理的设定学习计划与目标按部就班的学习不仅能缓和学习压力而且能打下坚实的基础。\n\n### 用心沟通\n\n**你在团队中的影响力是非常重要的**\n\n尽早沟通，经常交流。 早期，我非常害羞并且经常独自一人解决所有问题。如果我欠着某人一些工作，我会尝试把所有任务都做完了再转交给下一个人。如果我遇到困难了，我要么会小激动要么拖延一阵直到我没时间了，然后会慌张的做完工作。展示你的工作，分享你的草图和草稿，你需要和你的团队建立融洽的关系和信任，如此你才会感到舒适的去沟通分享。早期的反馈对比晚期的反馈更加有用并且更具有高执行度。有时候只需要简单的问同事几个问题或者交流下看法就会得到一个意想不到的解决你问题的方法。\n\n提有效的问题。 在你尚未意识到的情况下，所有事都一定程度上是模糊的。由此尝试把事情给精确化。对期望的结果非常明确是非常重要的。人们通常对一个场景有不同的期待，不同的理解 – 这些都是摩擦和挫折的来源。所以，这非常值得花费一定的时间和精力确保每个人都对你做的事情保持一致的理解。\n\n三人行必有我师焉。 真实的生活并不是一本书，你只需要独自一人阅读理解就行了。有需要就寻求帮助，这也许在不同的公司文化和同事个性稍有不同。有些人也去会强行打扰他人，但我能觉察到那些聪明，有修养的人能小心避免打扰到他人的情况下寻求帮助。这也就是说，当你寻求帮助的时候，要简洁明礼貌的提出『小强，当你有空的时候来帮助我下，我需要旁观者来看看我的 PPT 是否有任何值得提升的地方』。不要强行打断别人的工作，那是不礼貌的。当你有礼貌的提出明确的帮助需求的时候，有时候人们会不在意分心来帮助你。\n\n心态要积极向上。 这不仅对自己，对整个工作氛围都非常有帮助！\n\n### 尝试交际\n\n**公司和组织都是由人构成的，尝试与他人建立关系**\n\n协作工作。 有时候非常容易陷入一个困境：你觉得自己需要处理所有摆在你面前的问题。总会有做不完的工作，你需要既能综观大局又能专注细节。去认识一些做和你工作性质差不多的人，这会对你的工作非常有帮助。人们知道一些东西，他们也许不会写在博客里但他们会愿意当面教授你这些东西，并且这些东西可能会对你非常有用。人们可以帮你开门，可以帮你预先把东西处理好。有时候你花费了大量时间都未解决的问题，正好有人的脑袋里早有解决方法，你也许只需要请他们一杯咖啡就可以寻求帮助了。\n\n招人内推。 即使你不负责招聘工作，列出一堆你想要共同工作的人或者想要学习的榜样给相关负责人也是有帮助的。\n\n尝试演讲。 与他人交流你知道的内容是一项非常强大的技能。这会使你更加专业，也会让你在工作时更加轻松，因为通过教授预分享能让你在你的领域内更加自信。\n\n### 其它思考\n\n甄别束缚你的外因。 是钱吗？是念头吗？是执行力吗？是时间吗？是什么阻碍了你完成 2 倍，4 倍甚至 10 倍于挡墙你的成就？\n\n白日梦有时候还是很有用的。 如果你有更多的资源可以用？如果你每周有额外 500 块钱你要做什么？那么 1000 块，2000 块，5000 块喃？如果你从头再来，你会做什么不一样的事儿吗？如果你只用工作当前时间的一半？如果你做了你当前目标完全相反的结果会发生什么？\n\n换位思考。 很多情况下，市场营销就是关于换位思考。为什么人们要用你的产品而不是其它的？为什么人们关系一些特定的内容数据？为什么别人要雇佣你？你有什么价值，特点值得别人注意？\n\n了解行业工作市场。 我尽量避免这个很久了，因为我喜欢我现在工作的地方，而且哪怕有浏览其他工作职位信息的念头都感觉可怕。但了解实时行业动态及招人信息是非常有用的。你可以由此规划你的职业生涯，看看对应的职位都需要什么条件，自问自己还差什么，然后弥补这些不足。而且这些行业信息也能够提供对你的职位晋升及加薪的有效信息。\n\n主人翁意识。 让你的老板更加信任你，对你的建议更容易说同意。每个老板都喜欢雇佣能直接把活给干完的员工，而且过程不寻求任何建议与管理。当你即了解你的首要任务与目标时，执行计划并完成。你的老板是雇佣你来完成工作的，他并不想和你一起做出每一个决定。（当然一个好老板会在最初教你一些计划与职责内容）。尝试替老板思考，做出计划，并且只需要让老板做出同意或者否决的决定。\n\n照顾好自己身心健康。 你的工作会占据你的大部分生活，所以尝试做好它，严肃对待它，享受其过程，并不断挑战自我。但是如果你发现你精力耗尽，身心疲惫，这时候不要再自己催眠强撑下去了。毕竟，你才是你生活中最重要的人，照顾好你自己。\n\n<div class=\"tip\">\n本文转载自: [MOYU](https://moyu.io/2017/10/advices-from-my-supervisor/)，版权归原作者所有。\n</div>\n","source":"_posts/我的主管给我的一些建议.md","raw":"---\ntitle: 我的主管给我的一些建议\ncomments: true\ndate: 2018-06-21 07:43:58\ntags:\nfrom:\n---\n\n本文翻译自 [Reddit](https://www.reddit.com/r/startups/comments/74pms1/my_manager_who_i_loved_recently_left_my_company_i/) 上的一篇文章。其主要内容为一名职工记录了他与其已离职的主管的一对一交流。其中总结了大量关于职业生涯，工作内容，人际关系，自我成长的建议。\n\n<!-- more -->\n\n### 首要任务\n\n**确定并专注于你的首要任务 – 如果不，那么你整天在干什么？**\n\n优先任务真的是最首要任务的吗？ 当前你需要做得最为重要的事是什么？如果你不能回答这个问题，那么你就应该停下手头的所有工作然后先弄清楚你的答案。有明确的答案能让你更加明确目标与专注。没有明确的答案往往会导致你经常在做一些并不重要的事并且浪费大量宝贵的时间。\n\n每天总会有源源不断需要做的事儿。人们常会倾向于先做简单、有趣或熟悉的任务。但长远来看这是一个陷阱。完成首要任务 5%-10% 的工作量比做大量对目标无益的任务更好。\n\n> 往往自己认为应该优先做的工作其实并不是当前目标的首要任务\n\n你负责什么？ 企业中的每个人都应该负责一定的工作。理想情况下，它应该是与你的首要目标相关的度量指标。如果不是，那么你就应该和你的主管或者老板好好谈一谈来确定你的首要任务。当你确立好你的首要任务后，你还会保证你已了解了足够的信息来提升这个指标。\n\n掌控好你的负责范围。 一般人们都会想善于完成他们的工作。听起来很明显，但有时候环境会诱惑你去做一些无关紧要的事情。这时候就值得注意了，返回去看第一条 – 保持首要任务的优先。\n\n精确你的目标。 如果目标有点模糊，空出一点时间来确立它的精确性。不要去做较为模糊的工作 – 它们常常会令人分心和做一些超出目标范围的事。要学会鉴别自己思考，文字，及交流中的模糊地带，然后把这些模糊都消除掉，使之清晰明了。\n\n### 高效管理\n\n**把自己当做宝贵且重要的资源一样管理**\n\n不要不懂装懂。 对自己要坦诚相待，对自己有清晰的自我认识能让你更快的学习和提升。如果你抱着坦诚的心态与他人交流，别人也会坦诚对待你，由此一个舒适健康的交流环境就建立起来了，并且不断的影响着周围的人。\n\n制定计划并执行。 我小时候非常讨厌日历和时间表，并且花费了大量时间应付各种截至日期的潜在压力。但事实是：无论讨厌还是喜欢计划，我们只有有限的时间和无尽的任务需要做，这些都不会随着我们的主观意识而改变。没有良好的计划，我们最终会无休止的工作。如果你不主动提前决定你应该怎么花费你得时间和精力，那么会有其他的事情会帮你做决定 – 被别人打断或者一些无关紧要的任务（它们都会让你不由自主的花时间去处理）。\n\n经过多年的反思和摇摆，我逐渐意识到我的问题并非是指定计划，而且被动的去做一些我不想做的事儿。我只是潜意识的对日历，计划有着反抗态度。如果你和我一样，这需要花费大量精力去消除这些影响。开始制定一些简单的计划然后完成。写下一些你能 5 分钟内完成的事，然后执行，完成。反复如此计划执行，计划执行，直到你做的越来越好，然后逐渐加多时间。冰冻三尺非一日之寒，通过不断练习及加大任务量及时间，会变得越来越复杂，就像玩游戏一样。当你开始习惯这样的循序渐进方式时，会变得越来越有趣和令人激动。你将会越来越了解你自己及你周围的世界。\n\n劳逸结合。 你是一项宝贵的资源，并且需要休整。不要快速耗尽精力，要学会细水长流，当做马拉松来看。但我开始工作时，我感觉我获得了一个难得可贵的机会、觉的自己还不够格、顶着压力、常常埋头苦干、但还感到自己落后于工作，然后我开始拖延和延期直到我休了个假。现在回过头来看，这真是个滑稽的行为，而且我非常后悔。如果当初我抗住压力和提前安排好时间，我会更加开心，健康，完成更多得工作。\n\n吾日三省吾身。 分析过去的工作，哪些完成了，哪些没有，哪些最终效果不错，哪些失败…… 你应该定期独立这样回顾分析工作。我经常偷懒记笔记，即使记了也基本不会回头再看。如果我能重新来过，我会更加系统的严于利己的对待此事。\n\n> 通过定期复盘能够不断强化自己对一个项目的理解，如果项目越滚越大，还是会对项目的掌控游刃有余。定期的复盘还能起到找出弱项，弥补不足，吸取经验，让自己之后能够更优异的完成任务。很多宝贵的经验，经历了一次就完了的人算作普通人；经历了一次并吸取经验在以后遇到同样问题能够通过经验解决的人算作优秀的人；经历了一次不仅吸取了经验，还能做到复盘举一反三的能称之为非常有前景的人才了\n\n表述你的进度。 这在多个层面上均非常有帮助。首先，只需要给高强度工作的大脑腾点休息时间，把工作进度手写在纸上，这是一个非常有用的习惯。这会强迫你把想要表达的东西表述出来。你想要达成什么目标？你是如果做出决策的？当你在用文字表述你的进度的时候，你还能顺带分析下。你能找出弱项并强化它们。这就像是在看自己的回放一样，能够注意到更多的细节。当然，你还能与他人分享你的表述，并收到反馈，这又是更进一步的提升了。\n\n> 通过具体的语言或者文字表述自己工作的进度，可以把大脑里抽象的思考具体化，并由此观察细节找出问题或者弱点并强化。通过具体的表述能够增强逻辑能力，锻炼表达能力与更清晰的认识自己做的事儿。\n\n为自己负责。 即使你有非常优秀的主管，但是你最终会为自己的学习、执行和成长进行负责。回顾以前，我觉得我自己花费了第一个 3-4 年在舒适区，从不主动出击。我的确有一个非常优秀的主管，给我了大量的目标、建议和规划，也许他们还给我剧透了一些信息。但我花了几年的时间才发现『我必须给自己设定更高的目标，并努力达成』。除非你有一个非常疯狂的老板或者主管分配给你高难度工作，不然没有人能比你更适合把自己推到极限。（我并不是暗示大量的工作和大量的时间，我想表达的是跳出你的舒适区，挑战自己达到下一个高度。尝试新鲜事物，学习超出你工作范畴的新东西等等）\n\n花时间学习。 当你发现一些和你工作相关的干货资料时，标注一下稍后再看，然后定期去浏览学习这些存货。按周来规划是非常不错的。如果你已经在大量的阅读和学习了，那么和其他人分享下你的心得。这会帮助你更加深刻的理解你学到的东西。建议设置月度或者季度学习目标。\n\n> 学习的最高形式便是传授；不积跬步无以至千里，要想通过 7 天学会 XXX，21 天学会 XXX 的这类爆款无异于痴人说梦，这些鸡汤往往只能教会你最基础的 hello, world. 合理的设定学习计划与目标按部就班的学习不仅能缓和学习压力而且能打下坚实的基础。\n\n### 用心沟通\n\n**你在团队中的影响力是非常重要的**\n\n尽早沟通，经常交流。 早期，我非常害羞并且经常独自一人解决所有问题。如果我欠着某人一些工作，我会尝试把所有任务都做完了再转交给下一个人。如果我遇到困难了，我要么会小激动要么拖延一阵直到我没时间了，然后会慌张的做完工作。展示你的工作，分享你的草图和草稿，你需要和你的团队建立融洽的关系和信任，如此你才会感到舒适的去沟通分享。早期的反馈对比晚期的反馈更加有用并且更具有高执行度。有时候只需要简单的问同事几个问题或者交流下看法就会得到一个意想不到的解决你问题的方法。\n\n提有效的问题。 在你尚未意识到的情况下，所有事都一定程度上是模糊的。由此尝试把事情给精确化。对期望的结果非常明确是非常重要的。人们通常对一个场景有不同的期待，不同的理解 – 这些都是摩擦和挫折的来源。所以，这非常值得花费一定的时间和精力确保每个人都对你做的事情保持一致的理解。\n\n三人行必有我师焉。 真实的生活并不是一本书，你只需要独自一人阅读理解就行了。有需要就寻求帮助，这也许在不同的公司文化和同事个性稍有不同。有些人也去会强行打扰他人，但我能觉察到那些聪明，有修养的人能小心避免打扰到他人的情况下寻求帮助。这也就是说，当你寻求帮助的时候，要简洁明礼貌的提出『小强，当你有空的时候来帮助我下，我需要旁观者来看看我的 PPT 是否有任何值得提升的地方』。不要强行打断别人的工作，那是不礼貌的。当你有礼貌的提出明确的帮助需求的时候，有时候人们会不在意分心来帮助你。\n\n心态要积极向上。 这不仅对自己，对整个工作氛围都非常有帮助！\n\n### 尝试交际\n\n**公司和组织都是由人构成的，尝试与他人建立关系**\n\n协作工作。 有时候非常容易陷入一个困境：你觉得自己需要处理所有摆在你面前的问题。总会有做不完的工作，你需要既能综观大局又能专注细节。去认识一些做和你工作性质差不多的人，这会对你的工作非常有帮助。人们知道一些东西，他们也许不会写在博客里但他们会愿意当面教授你这些东西，并且这些东西可能会对你非常有用。人们可以帮你开门，可以帮你预先把东西处理好。有时候你花费了大量时间都未解决的问题，正好有人的脑袋里早有解决方法，你也许只需要请他们一杯咖啡就可以寻求帮助了。\n\n招人内推。 即使你不负责招聘工作，列出一堆你想要共同工作的人或者想要学习的榜样给相关负责人也是有帮助的。\n\n尝试演讲。 与他人交流你知道的内容是一项非常强大的技能。这会使你更加专业，也会让你在工作时更加轻松，因为通过教授预分享能让你在你的领域内更加自信。\n\n### 其它思考\n\n甄别束缚你的外因。 是钱吗？是念头吗？是执行力吗？是时间吗？是什么阻碍了你完成 2 倍，4 倍甚至 10 倍于挡墙你的成就？\n\n白日梦有时候还是很有用的。 如果你有更多的资源可以用？如果你每周有额外 500 块钱你要做什么？那么 1000 块，2000 块，5000 块喃？如果你从头再来，你会做什么不一样的事儿吗？如果你只用工作当前时间的一半？如果你做了你当前目标完全相反的结果会发生什么？\n\n换位思考。 很多情况下，市场营销就是关于换位思考。为什么人们要用你的产品而不是其它的？为什么人们关系一些特定的内容数据？为什么别人要雇佣你？你有什么价值，特点值得别人注意？\n\n了解行业工作市场。 我尽量避免这个很久了，因为我喜欢我现在工作的地方，而且哪怕有浏览其他工作职位信息的念头都感觉可怕。但了解实时行业动态及招人信息是非常有用的。你可以由此规划你的职业生涯，看看对应的职位都需要什么条件，自问自己还差什么，然后弥补这些不足。而且这些行业信息也能够提供对你的职位晋升及加薪的有效信息。\n\n主人翁意识。 让你的老板更加信任你，对你的建议更容易说同意。每个老板都喜欢雇佣能直接把活给干完的员工，而且过程不寻求任何建议与管理。当你即了解你的首要任务与目标时，执行计划并完成。你的老板是雇佣你来完成工作的，他并不想和你一起做出每一个决定。（当然一个好老板会在最初教你一些计划与职责内容）。尝试替老板思考，做出计划，并且只需要让老板做出同意或者否决的决定。\n\n照顾好自己身心健康。 你的工作会占据你的大部分生活，所以尝试做好它，严肃对待它，享受其过程，并不断挑战自我。但是如果你发现你精力耗尽，身心疲惫，这时候不要再自己催眠强撑下去了。毕竟，你才是你生活中最重要的人，照顾好你自己。\n\n<div class=\"tip\">\n本文转载自: [MOYU](https://moyu.io/2017/10/advices-from-my-supervisor/)，版权归原作者所有。\n</div>\n","slug":"我的主管给我的一些建议","published":1,"updated":"2019-12-07T04:59:36.112Z","layout":"post","photos":[],"link":"","_id":"ck3v60jto000qr9q9z9onkc5b","content":"<p>本文翻译自 <a href=\"https://www.reddit.com/r/startups/comments/74pms1/my_manager_who_i_loved_recently_left_my_company_i/\" target=\"_blank\" rel=\"noopener\">Reddit</a> 上的一篇文章。其主要内容为一名职工记录了他与其已离职的主管的一对一交流。其中总结了大量关于职业生涯，工作内容，人际关系，自我成长的建议。</p>\n<a id=\"more\"></a>\n<h3 id=\"首要任务\"><a href=\"#首要任务\" class=\"headerlink\" title=\"首要任务\"></a>首要任务</h3><p><strong>确定并专注于你的首要任务 – 如果不，那么你整天在干什么？</strong></p>\n<p>优先任务真的是最首要任务的吗？ 当前你需要做得最为重要的事是什么？如果你不能回答这个问题，那么你就应该停下手头的所有工作然后先弄清楚你的答案。有明确的答案能让你更加明确目标与专注。没有明确的答案往往会导致你经常在做一些并不重要的事并且浪费大量宝贵的时间。</p>\n<p>每天总会有源源不断需要做的事儿。人们常会倾向于先做简单、有趣或熟悉的任务。但长远来看这是一个陷阱。完成首要任务 5%-10% 的工作量比做大量对目标无益的任务更好。</p>\n<blockquote>\n<p>往往自己认为应该优先做的工作其实并不是当前目标的首要任务</p>\n</blockquote>\n<p>你负责什么？ 企业中的每个人都应该负责一定的工作。理想情况下，它应该是与你的首要目标相关的度量指标。如果不是，那么你就应该和你的主管或者老板好好谈一谈来确定你的首要任务。当你确立好你的首要任务后，你还会保证你已了解了足够的信息来提升这个指标。</p>\n<p>掌控好你的负责范围。 一般人们都会想善于完成他们的工作。听起来很明显，但有时候环境会诱惑你去做一些无关紧要的事情。这时候就值得注意了，返回去看第一条 – 保持首要任务的优先。</p>\n<p>精确你的目标。 如果目标有点模糊，空出一点时间来确立它的精确性。不要去做较为模糊的工作 – 它们常常会令人分心和做一些超出目标范围的事。要学会鉴别自己思考，文字，及交流中的模糊地带，然后把这些模糊都消除掉，使之清晰明了。</p>\n<h3 id=\"高效管理\"><a href=\"#高效管理\" class=\"headerlink\" title=\"高效管理\"></a>高效管理</h3><p><strong>把自己当做宝贵且重要的资源一样管理</strong></p>\n<p>不要不懂装懂。 对自己要坦诚相待，对自己有清晰的自我认识能让你更快的学习和提升。如果你抱着坦诚的心态与他人交流，别人也会坦诚对待你，由此一个舒适健康的交流环境就建立起来了，并且不断的影响着周围的人。</p>\n<p>制定计划并执行。 我小时候非常讨厌日历和时间表，并且花费了大量时间应付各种截至日期的潜在压力。但事实是：无论讨厌还是喜欢计划，我们只有有限的时间和无尽的任务需要做，这些都不会随着我们的主观意识而改变。没有良好的计划，我们最终会无休止的工作。如果你不主动提前决定你应该怎么花费你得时间和精力，那么会有其他的事情会帮你做决定 – 被别人打断或者一些无关紧要的任务（它们都会让你不由自主的花时间去处理）。</p>\n<p>经过多年的反思和摇摆，我逐渐意识到我的问题并非是指定计划，而且被动的去做一些我不想做的事儿。我只是潜意识的对日历，计划有着反抗态度。如果你和我一样，这需要花费大量精力去消除这些影响。开始制定一些简单的计划然后完成。写下一些你能 5 分钟内完成的事，然后执行，完成。反复如此计划执行，计划执行，直到你做的越来越好，然后逐渐加多时间。冰冻三尺非一日之寒，通过不断练习及加大任务量及时间，会变得越来越复杂，就像玩游戏一样。当你开始习惯这样的循序渐进方式时，会变得越来越有趣和令人激动。你将会越来越了解你自己及你周围的世界。</p>\n<p>劳逸结合。 你是一项宝贵的资源，并且需要休整。不要快速耗尽精力，要学会细水长流，当做马拉松来看。但我开始工作时，我感觉我获得了一个难得可贵的机会、觉的自己还不够格、顶着压力、常常埋头苦干、但还感到自己落后于工作，然后我开始拖延和延期直到我休了个假。现在回过头来看，这真是个滑稽的行为，而且我非常后悔。如果当初我抗住压力和提前安排好时间，我会更加开心，健康，完成更多得工作。</p>\n<p>吾日三省吾身。 分析过去的工作，哪些完成了，哪些没有，哪些最终效果不错，哪些失败…… 你应该定期独立这样回顾分析工作。我经常偷懒记笔记，即使记了也基本不会回头再看。如果我能重新来过，我会更加系统的严于利己的对待此事。</p>\n<blockquote>\n<p>通过定期复盘能够不断强化自己对一个项目的理解，如果项目越滚越大，还是会对项目的掌控游刃有余。定期的复盘还能起到找出弱项，弥补不足，吸取经验，让自己之后能够更优异的完成任务。很多宝贵的经验，经历了一次就完了的人算作普通人；经历了一次并吸取经验在以后遇到同样问题能够通过经验解决的人算作优秀的人；经历了一次不仅吸取了经验，还能做到复盘举一反三的能称之为非常有前景的人才了</p>\n</blockquote>\n<p>表述你的进度。 这在多个层面上均非常有帮助。首先，只需要给高强度工作的大脑腾点休息时间，把工作进度手写在纸上，这是一个非常有用的习惯。这会强迫你把想要表达的东西表述出来。你想要达成什么目标？你是如果做出决策的？当你在用文字表述你的进度的时候，你还能顺带分析下。你能找出弱项并强化它们。这就像是在看自己的回放一样，能够注意到更多的细节。当然，你还能与他人分享你的表述，并收到反馈，这又是更进一步的提升了。</p>\n<blockquote>\n<p>通过具体的语言或者文字表述自己工作的进度，可以把大脑里抽象的思考具体化，并由此观察细节找出问题或者弱点并强化。通过具体的表述能够增强逻辑能力，锻炼表达能力与更清晰的认识自己做的事儿。</p>\n</blockquote>\n<p>为自己负责。 即使你有非常优秀的主管，但是你最终会为自己的学习、执行和成长进行负责。回顾以前，我觉得我自己花费了第一个 3-4 年在舒适区，从不主动出击。我的确有一个非常优秀的主管，给我了大量的目标、建议和规划，也许他们还给我剧透了一些信息。但我花了几年的时间才发现『我必须给自己设定更高的目标，并努力达成』。除非你有一个非常疯狂的老板或者主管分配给你高难度工作，不然没有人能比你更适合把自己推到极限。（我并不是暗示大量的工作和大量的时间，我想表达的是跳出你的舒适区，挑战自己达到下一个高度。尝试新鲜事物，学习超出你工作范畴的新东西等等）</p>\n<p>花时间学习。 当你发现一些和你工作相关的干货资料时，标注一下稍后再看，然后定期去浏览学习这些存货。按周来规划是非常不错的。如果你已经在大量的阅读和学习了，那么和其他人分享下你的心得。这会帮助你更加深刻的理解你学到的东西。建议设置月度或者季度学习目标。</p>\n<blockquote>\n<p>学习的最高形式便是传授；不积跬步无以至千里，要想通过 7 天学会 XXX，21 天学会 XXX 的这类爆款无异于痴人说梦，这些鸡汤往往只能教会你最基础的 hello, world. 合理的设定学习计划与目标按部就班的学习不仅能缓和学习压力而且能打下坚实的基础。</p>\n</blockquote>\n<h3 id=\"用心沟通\"><a href=\"#用心沟通\" class=\"headerlink\" title=\"用心沟通\"></a>用心沟通</h3><p><strong>你在团队中的影响力是非常重要的</strong></p>\n<p>尽早沟通，经常交流。 早期，我非常害羞并且经常独自一人解决所有问题。如果我欠着某人一些工作，我会尝试把所有任务都做完了再转交给下一个人。如果我遇到困难了，我要么会小激动要么拖延一阵直到我没时间了，然后会慌张的做完工作。展示你的工作，分享你的草图和草稿，你需要和你的团队建立融洽的关系和信任，如此你才会感到舒适的去沟通分享。早期的反馈对比晚期的反馈更加有用并且更具有高执行度。有时候只需要简单的问同事几个问题或者交流下看法就会得到一个意想不到的解决你问题的方法。</p>\n<p>提有效的问题。 在你尚未意识到的情况下，所有事都一定程度上是模糊的。由此尝试把事情给精确化。对期望的结果非常明确是非常重要的。人们通常对一个场景有不同的期待，不同的理解 – 这些都是摩擦和挫折的来源。所以，这非常值得花费一定的时间和精力确保每个人都对你做的事情保持一致的理解。</p>\n<p>三人行必有我师焉。 真实的生活并不是一本书，你只需要独自一人阅读理解就行了。有需要就寻求帮助，这也许在不同的公司文化和同事个性稍有不同。有些人也去会强行打扰他人，但我能觉察到那些聪明，有修养的人能小心避免打扰到他人的情况下寻求帮助。这也就是说，当你寻求帮助的时候，要简洁明礼貌的提出『小强，当你有空的时候来帮助我下，我需要旁观者来看看我的 PPT 是否有任何值得提升的地方』。不要强行打断别人的工作，那是不礼貌的。当你有礼貌的提出明确的帮助需求的时候，有时候人们会不在意分心来帮助你。</p>\n<p>心态要积极向上。 这不仅对自己，对整个工作氛围都非常有帮助！</p>\n<h3 id=\"尝试交际\"><a href=\"#尝试交际\" class=\"headerlink\" title=\"尝试交际\"></a>尝试交际</h3><p><strong>公司和组织都是由人构成的，尝试与他人建立关系</strong></p>\n<p>协作工作。 有时候非常容易陷入一个困境：你觉得自己需要处理所有摆在你面前的问题。总会有做不完的工作，你需要既能综观大局又能专注细节。去认识一些做和你工作性质差不多的人，这会对你的工作非常有帮助。人们知道一些东西，他们也许不会写在博客里但他们会愿意当面教授你这些东西，并且这些东西可能会对你非常有用。人们可以帮你开门，可以帮你预先把东西处理好。有时候你花费了大量时间都未解决的问题，正好有人的脑袋里早有解决方法，你也许只需要请他们一杯咖啡就可以寻求帮助了。</p>\n<p>招人内推。 即使你不负责招聘工作，列出一堆你想要共同工作的人或者想要学习的榜样给相关负责人也是有帮助的。</p>\n<p>尝试演讲。 与他人交流你知道的内容是一项非常强大的技能。这会使你更加专业，也会让你在工作时更加轻松，因为通过教授预分享能让你在你的领域内更加自信。</p>\n<h3 id=\"其它思考\"><a href=\"#其它思考\" class=\"headerlink\" title=\"其它思考\"></a>其它思考</h3><p>甄别束缚你的外因。 是钱吗？是念头吗？是执行力吗？是时间吗？是什么阻碍了你完成 2 倍，4 倍甚至 10 倍于挡墙你的成就？</p>\n<p>白日梦有时候还是很有用的。 如果你有更多的资源可以用？如果你每周有额外 500 块钱你要做什么？那么 1000 块，2000 块，5000 块喃？如果你从头再来，你会做什么不一样的事儿吗？如果你只用工作当前时间的一半？如果你做了你当前目标完全相反的结果会发生什么？</p>\n<p>换位思考。 很多情况下，市场营销就是关于换位思考。为什么人们要用你的产品而不是其它的？为什么人们关系一些特定的内容数据？为什么别人要雇佣你？你有什么价值，特点值得别人注意？</p>\n<p>了解行业工作市场。 我尽量避免这个很久了，因为我喜欢我现在工作的地方，而且哪怕有浏览其他工作职位信息的念头都感觉可怕。但了解实时行业动态及招人信息是非常有用的。你可以由此规划你的职业生涯，看看对应的职位都需要什么条件，自问自己还差什么，然后弥补这些不足。而且这些行业信息也能够提供对你的职位晋升及加薪的有效信息。</p>\n<p>主人翁意识。 让你的老板更加信任你，对你的建议更容易说同意。每个老板都喜欢雇佣能直接把活给干完的员工，而且过程不寻求任何建议与管理。当你即了解你的首要任务与目标时，执行计划并完成。你的老板是雇佣你来完成工作的，他并不想和你一起做出每一个决定。（当然一个好老板会在最初教你一些计划与职责内容）。尝试替老板思考，做出计划，并且只需要让老板做出同意或者否决的决定。</p>\n<p>照顾好自己身心健康。 你的工作会占据你的大部分生活，所以尝试做好它，严肃对待它，享受其过程，并不断挑战自我。但是如果你发现你精力耗尽，身心疲惫，这时候不要再自己催眠强撑下去了。毕竟，你才是你生活中最重要的人，照顾好你自己。</p>\n<div class=\"tip\"><br>本文转载自: <a href=\"https://moyu.io/2017/10/advices-from-my-supervisor/\" target=\"_blank\" rel=\"noopener\">MOYU</a>，版权归原作者所有。<br></div>\n","site":{"data":{}},"excerpt":"<p>本文翻译自 <a href=\"https://www.reddit.com/r/startups/comments/74pms1/my_manager_who_i_loved_recently_left_my_company_i/\" target=\"_blank\" rel=\"noopener\">Reddit</a> 上的一篇文章。其主要内容为一名职工记录了他与其已离职的主管的一对一交流。其中总结了大量关于职业生涯，工作内容，人际关系，自我成长的建议。</p>","more":"<h3 id=\"首要任务\"><a href=\"#首要任务\" class=\"headerlink\" title=\"首要任务\"></a>首要任务</h3><p><strong>确定并专注于你的首要任务 – 如果不，那么你整天在干什么？</strong></p>\n<p>优先任务真的是最首要任务的吗？ 当前你需要做得最为重要的事是什么？如果你不能回答这个问题，那么你就应该停下手头的所有工作然后先弄清楚你的答案。有明确的答案能让你更加明确目标与专注。没有明确的答案往往会导致你经常在做一些并不重要的事并且浪费大量宝贵的时间。</p>\n<p>每天总会有源源不断需要做的事儿。人们常会倾向于先做简单、有趣或熟悉的任务。但长远来看这是一个陷阱。完成首要任务 5%-10% 的工作量比做大量对目标无益的任务更好。</p>\n<blockquote>\n<p>往往自己认为应该优先做的工作其实并不是当前目标的首要任务</p>\n</blockquote>\n<p>你负责什么？ 企业中的每个人都应该负责一定的工作。理想情况下，它应该是与你的首要目标相关的度量指标。如果不是，那么你就应该和你的主管或者老板好好谈一谈来确定你的首要任务。当你确立好你的首要任务后，你还会保证你已了解了足够的信息来提升这个指标。</p>\n<p>掌控好你的负责范围。 一般人们都会想善于完成他们的工作。听起来很明显，但有时候环境会诱惑你去做一些无关紧要的事情。这时候就值得注意了，返回去看第一条 – 保持首要任务的优先。</p>\n<p>精确你的目标。 如果目标有点模糊，空出一点时间来确立它的精确性。不要去做较为模糊的工作 – 它们常常会令人分心和做一些超出目标范围的事。要学会鉴别自己思考，文字，及交流中的模糊地带，然后把这些模糊都消除掉，使之清晰明了。</p>\n<h3 id=\"高效管理\"><a href=\"#高效管理\" class=\"headerlink\" title=\"高效管理\"></a>高效管理</h3><p><strong>把自己当做宝贵且重要的资源一样管理</strong></p>\n<p>不要不懂装懂。 对自己要坦诚相待，对自己有清晰的自我认识能让你更快的学习和提升。如果你抱着坦诚的心态与他人交流，别人也会坦诚对待你，由此一个舒适健康的交流环境就建立起来了，并且不断的影响着周围的人。</p>\n<p>制定计划并执行。 我小时候非常讨厌日历和时间表，并且花费了大量时间应付各种截至日期的潜在压力。但事实是：无论讨厌还是喜欢计划，我们只有有限的时间和无尽的任务需要做，这些都不会随着我们的主观意识而改变。没有良好的计划，我们最终会无休止的工作。如果你不主动提前决定你应该怎么花费你得时间和精力，那么会有其他的事情会帮你做决定 – 被别人打断或者一些无关紧要的任务（它们都会让你不由自主的花时间去处理）。</p>\n<p>经过多年的反思和摇摆，我逐渐意识到我的问题并非是指定计划，而且被动的去做一些我不想做的事儿。我只是潜意识的对日历，计划有着反抗态度。如果你和我一样，这需要花费大量精力去消除这些影响。开始制定一些简单的计划然后完成。写下一些你能 5 分钟内完成的事，然后执行，完成。反复如此计划执行，计划执行，直到你做的越来越好，然后逐渐加多时间。冰冻三尺非一日之寒，通过不断练习及加大任务量及时间，会变得越来越复杂，就像玩游戏一样。当你开始习惯这样的循序渐进方式时，会变得越来越有趣和令人激动。你将会越来越了解你自己及你周围的世界。</p>\n<p>劳逸结合。 你是一项宝贵的资源，并且需要休整。不要快速耗尽精力，要学会细水长流，当做马拉松来看。但我开始工作时，我感觉我获得了一个难得可贵的机会、觉的自己还不够格、顶着压力、常常埋头苦干、但还感到自己落后于工作，然后我开始拖延和延期直到我休了个假。现在回过头来看，这真是个滑稽的行为，而且我非常后悔。如果当初我抗住压力和提前安排好时间，我会更加开心，健康，完成更多得工作。</p>\n<p>吾日三省吾身。 分析过去的工作，哪些完成了，哪些没有，哪些最终效果不错，哪些失败…… 你应该定期独立这样回顾分析工作。我经常偷懒记笔记，即使记了也基本不会回头再看。如果我能重新来过，我会更加系统的严于利己的对待此事。</p>\n<blockquote>\n<p>通过定期复盘能够不断强化自己对一个项目的理解，如果项目越滚越大，还是会对项目的掌控游刃有余。定期的复盘还能起到找出弱项，弥补不足，吸取经验，让自己之后能够更优异的完成任务。很多宝贵的经验，经历了一次就完了的人算作普通人；经历了一次并吸取经验在以后遇到同样问题能够通过经验解决的人算作优秀的人；经历了一次不仅吸取了经验，还能做到复盘举一反三的能称之为非常有前景的人才了</p>\n</blockquote>\n<p>表述你的进度。 这在多个层面上均非常有帮助。首先，只需要给高强度工作的大脑腾点休息时间，把工作进度手写在纸上，这是一个非常有用的习惯。这会强迫你把想要表达的东西表述出来。你想要达成什么目标？你是如果做出决策的？当你在用文字表述你的进度的时候，你还能顺带分析下。你能找出弱项并强化它们。这就像是在看自己的回放一样，能够注意到更多的细节。当然，你还能与他人分享你的表述，并收到反馈，这又是更进一步的提升了。</p>\n<blockquote>\n<p>通过具体的语言或者文字表述自己工作的进度，可以把大脑里抽象的思考具体化，并由此观察细节找出问题或者弱点并强化。通过具体的表述能够增强逻辑能力，锻炼表达能力与更清晰的认识自己做的事儿。</p>\n</blockquote>\n<p>为自己负责。 即使你有非常优秀的主管，但是你最终会为自己的学习、执行和成长进行负责。回顾以前，我觉得我自己花费了第一个 3-4 年在舒适区，从不主动出击。我的确有一个非常优秀的主管，给我了大量的目标、建议和规划，也许他们还给我剧透了一些信息。但我花了几年的时间才发现『我必须给自己设定更高的目标，并努力达成』。除非你有一个非常疯狂的老板或者主管分配给你高难度工作，不然没有人能比你更适合把自己推到极限。（我并不是暗示大量的工作和大量的时间，我想表达的是跳出你的舒适区，挑战自己达到下一个高度。尝试新鲜事物，学习超出你工作范畴的新东西等等）</p>\n<p>花时间学习。 当你发现一些和你工作相关的干货资料时，标注一下稍后再看，然后定期去浏览学习这些存货。按周来规划是非常不错的。如果你已经在大量的阅读和学习了，那么和其他人分享下你的心得。这会帮助你更加深刻的理解你学到的东西。建议设置月度或者季度学习目标。</p>\n<blockquote>\n<p>学习的最高形式便是传授；不积跬步无以至千里，要想通过 7 天学会 XXX，21 天学会 XXX 的这类爆款无异于痴人说梦，这些鸡汤往往只能教会你最基础的 hello, world. 合理的设定学习计划与目标按部就班的学习不仅能缓和学习压力而且能打下坚实的基础。</p>\n</blockquote>\n<h3 id=\"用心沟通\"><a href=\"#用心沟通\" class=\"headerlink\" title=\"用心沟通\"></a>用心沟通</h3><p><strong>你在团队中的影响力是非常重要的</strong></p>\n<p>尽早沟通，经常交流。 早期，我非常害羞并且经常独自一人解决所有问题。如果我欠着某人一些工作，我会尝试把所有任务都做完了再转交给下一个人。如果我遇到困难了，我要么会小激动要么拖延一阵直到我没时间了，然后会慌张的做完工作。展示你的工作，分享你的草图和草稿，你需要和你的团队建立融洽的关系和信任，如此你才会感到舒适的去沟通分享。早期的反馈对比晚期的反馈更加有用并且更具有高执行度。有时候只需要简单的问同事几个问题或者交流下看法就会得到一个意想不到的解决你问题的方法。</p>\n<p>提有效的问题。 在你尚未意识到的情况下，所有事都一定程度上是模糊的。由此尝试把事情给精确化。对期望的结果非常明确是非常重要的。人们通常对一个场景有不同的期待，不同的理解 – 这些都是摩擦和挫折的来源。所以，这非常值得花费一定的时间和精力确保每个人都对你做的事情保持一致的理解。</p>\n<p>三人行必有我师焉。 真实的生活并不是一本书，你只需要独自一人阅读理解就行了。有需要就寻求帮助，这也许在不同的公司文化和同事个性稍有不同。有些人也去会强行打扰他人，但我能觉察到那些聪明，有修养的人能小心避免打扰到他人的情况下寻求帮助。这也就是说，当你寻求帮助的时候，要简洁明礼貌的提出『小强，当你有空的时候来帮助我下，我需要旁观者来看看我的 PPT 是否有任何值得提升的地方』。不要强行打断别人的工作，那是不礼貌的。当你有礼貌的提出明确的帮助需求的时候，有时候人们会不在意分心来帮助你。</p>\n<p>心态要积极向上。 这不仅对自己，对整个工作氛围都非常有帮助！</p>\n<h3 id=\"尝试交际\"><a href=\"#尝试交际\" class=\"headerlink\" title=\"尝试交际\"></a>尝试交际</h3><p><strong>公司和组织都是由人构成的，尝试与他人建立关系</strong></p>\n<p>协作工作。 有时候非常容易陷入一个困境：你觉得自己需要处理所有摆在你面前的问题。总会有做不完的工作，你需要既能综观大局又能专注细节。去认识一些做和你工作性质差不多的人，这会对你的工作非常有帮助。人们知道一些东西，他们也许不会写在博客里但他们会愿意当面教授你这些东西，并且这些东西可能会对你非常有用。人们可以帮你开门，可以帮你预先把东西处理好。有时候你花费了大量时间都未解决的问题，正好有人的脑袋里早有解决方法，你也许只需要请他们一杯咖啡就可以寻求帮助了。</p>\n<p>招人内推。 即使你不负责招聘工作，列出一堆你想要共同工作的人或者想要学习的榜样给相关负责人也是有帮助的。</p>\n<p>尝试演讲。 与他人交流你知道的内容是一项非常强大的技能。这会使你更加专业，也会让你在工作时更加轻松，因为通过教授预分享能让你在你的领域内更加自信。</p>\n<h3 id=\"其它思考\"><a href=\"#其它思考\" class=\"headerlink\" title=\"其它思考\"></a>其它思考</h3><p>甄别束缚你的外因。 是钱吗？是念头吗？是执行力吗？是时间吗？是什么阻碍了你完成 2 倍，4 倍甚至 10 倍于挡墙你的成就？</p>\n<p>白日梦有时候还是很有用的。 如果你有更多的资源可以用？如果你每周有额外 500 块钱你要做什么？那么 1000 块，2000 块，5000 块喃？如果你从头再来，你会做什么不一样的事儿吗？如果你只用工作当前时间的一半？如果你做了你当前目标完全相反的结果会发生什么？</p>\n<p>换位思考。 很多情况下，市场营销就是关于换位思考。为什么人们要用你的产品而不是其它的？为什么人们关系一些特定的内容数据？为什么别人要雇佣你？你有什么价值，特点值得别人注意？</p>\n<p>了解行业工作市场。 我尽量避免这个很久了，因为我喜欢我现在工作的地方，而且哪怕有浏览其他工作职位信息的念头都感觉可怕。但了解实时行业动态及招人信息是非常有用的。你可以由此规划你的职业生涯，看看对应的职位都需要什么条件，自问自己还差什么，然后弥补这些不足。而且这些行业信息也能够提供对你的职位晋升及加薪的有效信息。</p>\n<p>主人翁意识。 让你的老板更加信任你，对你的建议更容易说同意。每个老板都喜欢雇佣能直接把活给干完的员工，而且过程不寻求任何建议与管理。当你即了解你的首要任务与目标时，执行计划并完成。你的老板是雇佣你来完成工作的，他并不想和你一起做出每一个决定。（当然一个好老板会在最初教你一些计划与职责内容）。尝试替老板思考，做出计划，并且只需要让老板做出同意或者否决的决定。</p>\n<p>照顾好自己身心健康。 你的工作会占据你的大部分生活，所以尝试做好它，严肃对待它，享受其过程，并不断挑战自我。但是如果你发现你精力耗尽，身心疲惫，这时候不要再自己催眠强撑下去了。毕竟，你才是你生活中最重要的人，照顾好你自己。</p>\n<div class=\"tip\"><br>本文转载自: <a href=\"https://moyu.io/2017/10/advices-from-my-supervisor/\" target=\"_blank\" rel=\"noopener\">MOYU</a>，版权归原作者所有。<br></div>"},{"title":"持续集成 (CI) 及简单实践","date":"2018-04-30T01:00:00.000Z","comments":1,"_content":"\n在软件开发领域, 一直有很多比较专业的术语, 本着科普的精神, 来填一下自己的 ~~知识盲区~~ 😂, 什么是持续集成? 如何做持续集成? 为什么要做持续集成? 带着这些问题, 本篇文章会给你答案.\n\n<!-- more -->\n\n## What\n\n> 持续集成（英语：Continuous integration，缩写 CI）是一种软件工程流程，是将所有软件工程师对于软件的工作副本持续提交到共用主线（mainline）的一种措施。\n\n## Why\n\n持续集成的目的，就是让产品可以快速迭代，同时还能保持高质量。\n\n![image](https://user-images.githubusercontent.com/15377484/39465580-acb719cc-4d56-11e8-9915-2964d5e523c5.png)\n\n## How\n\n它的核心措施是，代码集成到主干之前，必须通过自动化测试。只要有一个测试用例失败，就不能集成。以本次给博客做持续集成为例，它的流程是这样子的：\n\n1. 写完博客后，直接 push 到 GitHub 的 `src` 分支(我的 `master` 分支是 pages)\n2. CI 服务通过配置文件 `.travis.yml` 监听当前 `src` 分支发生变化，触发 webhook\n3. CI 服务将当前项目 clone 过去，根据 `.travis.yml` 的配置执行测试和构建\n4. 将最终可以作为生产环境的代码推送到线上环境，并且 push 回  `src` 分支\n\n这样做的好处就是：\n\n- 发布新文章，只需 push 一次到仓库，剩下的测试、构建、部署生产环境等，CI 帮我自动完成。\n- 快速发现错误。每完成一点更新，就集成到主干，定位错误也比较容易。\n- 防止分支大幅偏离主干。如果不是经常集成，主干又在不断更新，会导致以后集成的难度变大。\n\n## More\n\n- [持续集成是什么](http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html)\n- [使用 Travis 自动部署 Hexo](https://segmentfault.com/a/1190000009054888)\n","source":"_posts/持续集成-CI-及简单实践.md","raw":"---\ntitle: '持续集成 (CI) 及简单实践'\ndate: 2018-04-30 9:00:00\ntags:\ncomments: true\n---\n\n在软件开发领域, 一直有很多比较专业的术语, 本着科普的精神, 来填一下自己的 ~~知识盲区~~ 😂, 什么是持续集成? 如何做持续集成? 为什么要做持续集成? 带着这些问题, 本篇文章会给你答案.\n\n<!-- more -->\n\n## What\n\n> 持续集成（英语：Continuous integration，缩写 CI）是一种软件工程流程，是将所有软件工程师对于软件的工作副本持续提交到共用主线（mainline）的一种措施。\n\n## Why\n\n持续集成的目的，就是让产品可以快速迭代，同时还能保持高质量。\n\n![image](https://user-images.githubusercontent.com/15377484/39465580-acb719cc-4d56-11e8-9915-2964d5e523c5.png)\n\n## How\n\n它的核心措施是，代码集成到主干之前，必须通过自动化测试。只要有一个测试用例失败，就不能集成。以本次给博客做持续集成为例，它的流程是这样子的：\n\n1. 写完博客后，直接 push 到 GitHub 的 `src` 分支(我的 `master` 分支是 pages)\n2. CI 服务通过配置文件 `.travis.yml` 监听当前 `src` 分支发生变化，触发 webhook\n3. CI 服务将当前项目 clone 过去，根据 `.travis.yml` 的配置执行测试和构建\n4. 将最终可以作为生产环境的代码推送到线上环境，并且 push 回  `src` 分支\n\n这样做的好处就是：\n\n- 发布新文章，只需 push 一次到仓库，剩下的测试、构建、部署生产环境等，CI 帮我自动完成。\n- 快速发现错误。每完成一点更新，就集成到主干，定位错误也比较容易。\n- 防止分支大幅偏离主干。如果不是经常集成，主干又在不断更新，会导致以后集成的难度变大。\n\n## More\n\n- [持续集成是什么](http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html)\n- [使用 Travis 自动部署 Hexo](https://segmentfault.com/a/1190000009054888)\n","slug":"持续集成-CI-及简单实践","published":1,"updated":"2018-12-26T16:01:04.000Z","layout":"post","photos":[],"link":"","_id":"ck3v60jtp000rr9q9tlz37gwl","content":"<p>在软件开发领域, 一直有很多比较专业的术语, 本着科普的精神, 来填一下自己的 <del>知识盲区</del> 😂, 什么是持续集成? 如何做持续集成? 为什么要做持续集成? 带着这些问题, 本篇文章会给你答案.</p>\n<a id=\"more\"></a>\n<h2 id=\"What\"><a href=\"#What\" class=\"headerlink\" title=\"What\"></a>What</h2><blockquote>\n<p>持续集成（英语：Continuous integration，缩写 CI）是一种软件工程流程，是将所有软件工程师对于软件的工作副本持续提交到共用主线（mainline）的一种措施。</p>\n</blockquote>\n<h2 id=\"Why\"><a href=\"#Why\" class=\"headerlink\" title=\"Why\"></a>Why</h2><p>持续集成的目的，就是让产品可以快速迭代，同时还能保持高质量。</p>\n<p><img src=\"https://user-images.githubusercontent.com/15377484/39465580-acb719cc-4d56-11e8-9915-2964d5e523c5.png\" alt=\"image\"></p>\n<h2 id=\"How\"><a href=\"#How\" class=\"headerlink\" title=\"How\"></a>How</h2><p>它的核心措施是，代码集成到主干之前，必须通过自动化测试。只要有一个测试用例失败，就不能集成。以本次给博客做持续集成为例，它的流程是这样子的：</p>\n<ol>\n<li>写完博客后，直接 push 到 GitHub 的 <code>src</code> 分支(我的 <code>master</code> 分支是 pages)</li>\n<li>CI 服务通过配置文件 <code>.travis.yml</code> 监听当前 <code>src</code> 分支发生变化，触发 webhook</li>\n<li>CI 服务将当前项目 clone 过去，根据 <code>.travis.yml</code> 的配置执行测试和构建</li>\n<li>将最终可以作为生产环境的代码推送到线上环境，并且 push 回  <code>src</code> 分支</li>\n</ol>\n<p>这样做的好处就是：</p>\n<ul>\n<li>发布新文章，只需 push 一次到仓库，剩下的测试、构建、部署生产环境等，CI 帮我自动完成。</li>\n<li>快速发现错误。每完成一点更新，就集成到主干，定位错误也比较容易。</li>\n<li>防止分支大幅偏离主干。如果不是经常集成，主干又在不断更新，会导致以后集成的难度变大。</li>\n</ul>\n<h2 id=\"More\"><a href=\"#More\" class=\"headerlink\" title=\"More\"></a>More</h2><ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html\" target=\"_blank\" rel=\"noopener\">持续集成是什么</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000009054888\" target=\"_blank\" rel=\"noopener\">使用 Travis 自动部署 Hexo</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>在软件开发领域, 一直有很多比较专业的术语, 本着科普的精神, 来填一下自己的 <del>知识盲区</del> 😂, 什么是持续集成? 如何做持续集成? 为什么要做持续集成? 带着这些问题, 本篇文章会给你答案.</p>","more":"<h2 id=\"What\"><a href=\"#What\" class=\"headerlink\" title=\"What\"></a>What</h2><blockquote>\n<p>持续集成（英语：Continuous integration，缩写 CI）是一种软件工程流程，是将所有软件工程师对于软件的工作副本持续提交到共用主线（mainline）的一种措施。</p>\n</blockquote>\n<h2 id=\"Why\"><a href=\"#Why\" class=\"headerlink\" title=\"Why\"></a>Why</h2><p>持续集成的目的，就是让产品可以快速迭代，同时还能保持高质量。</p>\n<p><img src=\"https://user-images.githubusercontent.com/15377484/39465580-acb719cc-4d56-11e8-9915-2964d5e523c5.png\" alt=\"image\"></p>\n<h2 id=\"How\"><a href=\"#How\" class=\"headerlink\" title=\"How\"></a>How</h2><p>它的核心措施是，代码集成到主干之前，必须通过自动化测试。只要有一个测试用例失败，就不能集成。以本次给博客做持续集成为例，它的流程是这样子的：</p>\n<ol>\n<li>写完博客后，直接 push 到 GitHub 的 <code>src</code> 分支(我的 <code>master</code> 分支是 pages)</li>\n<li>CI 服务通过配置文件 <code>.travis.yml</code> 监听当前 <code>src</code> 分支发生变化，触发 webhook</li>\n<li>CI 服务将当前项目 clone 过去，根据 <code>.travis.yml</code> 的配置执行测试和构建</li>\n<li>将最终可以作为生产环境的代码推送到线上环境，并且 push 回  <code>src</code> 分支</li>\n</ol>\n<p>这样做的好处就是：</p>\n<ul>\n<li>发布新文章，只需 push 一次到仓库，剩下的测试、构建、部署生产环境等，CI 帮我自动完成。</li>\n<li>快速发现错误。每完成一点更新，就集成到主干，定位错误也比较容易。</li>\n<li>防止分支大幅偏离主干。如果不是经常集成，主干又在不断更新，会导致以后集成的难度变大。</li>\n</ul>\n<h2 id=\"More\"><a href=\"#More\" class=\"headerlink\" title=\"More\"></a>More</h2><ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html\" target=\"_blank\" rel=\"noopener\">持续集成是什么</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000009054888\" target=\"_blank\" rel=\"noopener\">使用 Travis 自动部署 Hexo</a></li>\n</ul>"},{"title":"浏览器跨域请求数据总结","date":"2016-01-19T13:06:08.000Z","comments":0,"_content":"\n首先说下同源，同源策略是浏览器的一种安全策略，所谓同源是指：域名、协议、端口完全相同。而跨域就是不同源！一般 `a`, `img`, `link`, `video`, `audio`, 等等能够发出请求的标签都可以实现跨域访问。但是这些标签不能得到返回的东西，所以一般不会用他们来请求资源。\n<!-- more -->\n\n### 跨域方法\n#### 原生 JavaScript 跨域\n```html\n<script type=\"text/javascript\">\nfunction showuser(data) {\n    var data = JSON.parse(data);\n    console.log(data);// 处理得到的 data\n};\n</script>\n\n<script src=\"http://x.cn/showalluser.html?callback=showuser\" charset=\"utf-8\"></script>\n```\n#### jQuery 跨域\n```js\n$.ajax({\n    type: \"post\",\n    url: \"http://127.0.0.1:8080/showalluser.html\",\n    dataType: \"jsonp\",\n    jsonp: \"callback\",\n    success: function(data) {\n        console.log(data);// 处理得到的 data\n    }\n});\n```\n#### iframe 跨域\n```js\nfunction(URL, callBack) {\n    $iframe = $(\"<iframe style='display: none;'></iframe>\");\n    $iframe.prop(\"src\", URL);\n    $(\"body\").append($iframe);\n\n    $iframe.on('load', function() {\n        // 转换成 jsonStr\n        // contentDocument是 iframe 节点的方法获取contentDocument\n        var ifrDocument = this.contentDocument;\n\n        var jsonStr = $(ifrDocument).find(\"body\").text();\n\n        // 转换成 json 对象\n        var jsonObj = JSON.parse(jsonStr);\n\n        // 把 json 对象传给回调函数\n        callBack(jsonObj);\n        // 删除当前的 iframe\n        $(this).remove();\n    });\n}\n```\n#### 原生 JavaScript 跨域封装\n```html\n<script>\n// 封装数据  跨域url  params fn\nfunction crossDomain(url,params,fn){\n    var head = document.getElementsByTagName('head')[0];\n    // 1. 处理回调函数\n    var cbName = 'jsonp'+\n    (Math.random() * Math.random()).toString().substr(2) +\n    new Date().getTime();\n    // 将回调函数挂载到 window 对象上\n    window[cbName] = function(data){\n        // 拿到并处理数据，交给回调函数\n        fn(data);\n        // 拿到数据后remove掉\n        //head.removeChild(scriptObj);\n    }\n    // 2. 解析url，处理查询字符串 解决这样的需求 ?count=5\n    var qstring = '';\n    for(var key in params){\n        qstring += key + '=' + params[key] + '&';\n    }\n    qstring += 'callback=' + cbName;\n    url += '?' + qstring;\n    // 3. 插入script\n    var scriptObj = document.createElement('script');\n    scriptObj.src = url;\n    head.appendChild(scriptObj);\n}\n</script>\n\n<script>\n// 使用\ncrossDomain('http://api.douban.com/v2/movie/in_theaters',{},function(data){\n    console.log(data);\n})\n</script>\n```\n```html\n<!-- 解读：注意上面封装的函数会在 head 标签生成下面的内容，并随机产生函数名防止冲突 -->\n<script src=\"jsonp412964552676679031484646377133(data)”>// 挂载在 window 上可以直接执行\n      /*远程获取的 data 传入 jsonp* 函数内容，交给回调函数fn(data) */\n</script>\n```\n","source":"_posts/浏览器跨域请求数据总结.md","raw":"---\ntitle: 浏览器跨域请求数据总结\ndate: 2016-01-19 21:06:08\ntags:\ncomments: false\n---\n\n首先说下同源，同源策略是浏览器的一种安全策略，所谓同源是指：域名、协议、端口完全相同。而跨域就是不同源！一般 `a`, `img`, `link`, `video`, `audio`, 等等能够发出请求的标签都可以实现跨域访问。但是这些标签不能得到返回的东西，所以一般不会用他们来请求资源。\n<!-- more -->\n\n### 跨域方法\n#### 原生 JavaScript 跨域\n```html\n<script type=\"text/javascript\">\nfunction showuser(data) {\n    var data = JSON.parse(data);\n    console.log(data);// 处理得到的 data\n};\n</script>\n\n<script src=\"http://x.cn/showalluser.html?callback=showuser\" charset=\"utf-8\"></script>\n```\n#### jQuery 跨域\n```js\n$.ajax({\n    type: \"post\",\n    url: \"http://127.0.0.1:8080/showalluser.html\",\n    dataType: \"jsonp\",\n    jsonp: \"callback\",\n    success: function(data) {\n        console.log(data);// 处理得到的 data\n    }\n});\n```\n#### iframe 跨域\n```js\nfunction(URL, callBack) {\n    $iframe = $(\"<iframe style='display: none;'></iframe>\");\n    $iframe.prop(\"src\", URL);\n    $(\"body\").append($iframe);\n\n    $iframe.on('load', function() {\n        // 转换成 jsonStr\n        // contentDocument是 iframe 节点的方法获取contentDocument\n        var ifrDocument = this.contentDocument;\n\n        var jsonStr = $(ifrDocument).find(\"body\").text();\n\n        // 转换成 json 对象\n        var jsonObj = JSON.parse(jsonStr);\n\n        // 把 json 对象传给回调函数\n        callBack(jsonObj);\n        // 删除当前的 iframe\n        $(this).remove();\n    });\n}\n```\n#### 原生 JavaScript 跨域封装\n```html\n<script>\n// 封装数据  跨域url  params fn\nfunction crossDomain(url,params,fn){\n    var head = document.getElementsByTagName('head')[0];\n    // 1. 处理回调函数\n    var cbName = 'jsonp'+\n    (Math.random() * Math.random()).toString().substr(2) +\n    new Date().getTime();\n    // 将回调函数挂载到 window 对象上\n    window[cbName] = function(data){\n        // 拿到并处理数据，交给回调函数\n        fn(data);\n        // 拿到数据后remove掉\n        //head.removeChild(scriptObj);\n    }\n    // 2. 解析url，处理查询字符串 解决这样的需求 ?count=5\n    var qstring = '';\n    for(var key in params){\n        qstring += key + '=' + params[key] + '&';\n    }\n    qstring += 'callback=' + cbName;\n    url += '?' + qstring;\n    // 3. 插入script\n    var scriptObj = document.createElement('script');\n    scriptObj.src = url;\n    head.appendChild(scriptObj);\n}\n</script>\n\n<script>\n// 使用\ncrossDomain('http://api.douban.com/v2/movie/in_theaters',{},function(data){\n    console.log(data);\n})\n</script>\n```\n```html\n<!-- 解读：注意上面封装的函数会在 head 标签生成下面的内容，并随机产生函数名防止冲突 -->\n<script src=\"jsonp412964552676679031484646377133(data)”>// 挂载在 window 上可以直接执行\n      /*远程获取的 data 传入 jsonp* 函数内容，交给回调函数fn(data) */\n</script>\n```\n","slug":"浏览器跨域请求数据总结","published":1,"updated":"2018-12-26T16:01:04.000Z","layout":"post","photos":[],"link":"","_id":"ck3v60jtp000sr9q9tgvpmenu","content":"<p>首先说下同源，同源策略是浏览器的一种安全策略，所谓同源是指：域名、协议、端口完全相同。而跨域就是不同源！一般 <code>a</code>, <code>img</code>, <code>link</code>, <code>video</code>, <code>audio</code>, 等等能够发出请求的标签都可以实现跨域访问。但是这些标签不能得到返回的东西，所以一般不会用他们来请求资源。<br><a id=\"more\"></a></p>\n<h3 id=\"跨域方法\"><a href=\"#跨域方法\" class=\"headerlink\" title=\"跨域方法\"></a>跨域方法</h3><h4 id=\"原生-JavaScript-跨域\"><a href=\"#原生-JavaScript-跨域\" class=\"headerlink\" title=\"原生 JavaScript 跨域\"></a>原生 JavaScript 跨域</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">showuser</span>(<span class=\"params\">data</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> data = <span class=\"built_in\">JSON</span>.parse(data);</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(data);<span class=\"comment\">// 处理得到的 data</span></span></span><br><span class=\"line\"><span class=\"undefined\">&#125;;</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"http://x.cn/showalluser.html?callback=showuser\"</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"utf-8\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"jQuery-跨域\"><a href=\"#jQuery-跨域\" class=\"headerlink\" title=\"jQuery 跨域\"></a>jQuery 跨域</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">    type: <span class=\"string\">\"post\"</span>,</span><br><span class=\"line\">    url: <span class=\"string\">\"http://127.0.0.1:8080/showalluser.html\"</span>,</span><br><span class=\"line\">    dataType: <span class=\"string\">\"jsonp\"</span>,</span><br><span class=\"line\">    jsonp: <span class=\"string\">\"callback\"</span>,</span><br><span class=\"line\">    success: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(data);<span class=\"comment\">// 处理得到的 data</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"iframe-跨域\"><a href=\"#iframe-跨域\" class=\"headerlink\" title=\"iframe 跨域\"></a>iframe 跨域</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">URL, callBack</span>) </span>&#123;</span><br><span class=\"line\">    $iframe = $(<span class=\"string\">\"&lt;iframe style='display: none;'&gt;&lt;/iframe&gt;\"</span>);</span><br><span class=\"line\">    $iframe.prop(<span class=\"string\">\"src\"</span>, URL);</span><br><span class=\"line\">    $(<span class=\"string\">\"body\"</span>).append($iframe);</span><br><span class=\"line\"></span><br><span class=\"line\">    $iframe.on(<span class=\"string\">'load'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 转换成 jsonStr</span></span><br><span class=\"line\">        <span class=\"comment\">// contentDocument是 iframe 节点的方法获取contentDocument</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> ifrDocument = <span class=\"keyword\">this</span>.contentDocument;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> jsonStr = $(ifrDocument).find(<span class=\"string\">\"body\"</span>).text();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 转换成 json 对象</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> jsonObj = <span class=\"built_in\">JSON</span>.parse(jsonStr);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 把 json 对象传给回调函数</span></span><br><span class=\"line\">        callBack(jsonObj);</span><br><span class=\"line\">        <span class=\"comment\">// 删除当前的 iframe</span></span><br><span class=\"line\">        $(<span class=\"keyword\">this</span>).remove();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"原生-JavaScript-跨域封装\"><a href=\"#原生-JavaScript-跨域封装\" class=\"headerlink\" title=\"原生 JavaScript 跨域封装\"></a>原生 JavaScript 跨域封装</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"comment\">// 封装数据  跨域url  params fn</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">crossDomain</span>(<span class=\"params\">url,params,fn</span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> head = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'head'</span>)[<span class=\"number\">0</span>];</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 1. 处理回调函数</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> cbName = <span class=\"string\">'jsonp'</span>+</span></span><br><span class=\"line\"><span class=\"javascript\">    (<span class=\"built_in\">Math</span>.random() * <span class=\"built_in\">Math</span>.random()).toString().substr(<span class=\"number\">2</span>) +</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime();</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 将回调函数挂载到 window 对象上</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">window</span>[cbName] = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// 拿到并处理数据，交给回调函数</span></span></span><br><span class=\"line\"><span class=\"undefined\">        fn(data);</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// 拿到数据后remove掉</span></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">//head.removeChild(scriptObj);</span></span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 2. 解析url，处理查询字符串 解决这样的需求 ?count=5</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> qstring = <span class=\"string\">''</span>;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> params)&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        qstring += key + <span class=\"string\">'='</span> + params[key] + <span class=\"string\">'&amp;'</span>;</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;</span></span><br><span class=\"line\"><span class=\"javascript\">    qstring += <span class=\"string\">'callback='</span> + cbName;</span></span><br><span class=\"line\"><span class=\"javascript\">    url += <span class=\"string\">'?'</span> + qstring;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 3. 插入script</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> scriptObj = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'script'</span>);</span></span><br><span class=\"line\"><span class=\"undefined\">    scriptObj.src = url;</span></span><br><span class=\"line\"><span class=\"undefined\">    head.appendChild(scriptObj);</span></span><br><span class=\"line\"><span class=\"undefined\">&#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"comment\">// 使用</span></span></span><br><span class=\"line\"><span class=\"javascript\">crossDomain(<span class=\"string\">'http://api.douban.com/v2/movie/in_theaters'</span>,&#123;&#125;,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(data);</span></span><br><span class=\"line\"><span class=\"undefined\">&#125;)</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 解读：注意上面封装的函数会在 head 标签生成下面的内容，并随机产生函数名防止冲突 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"jsonp412964552676679031484646377133(data)”&gt;// 挂载在 window 上可以直接执行</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">      /*远程获取的 data 传入 jsonp* 函数内容，交给回调函数fn(data) */</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">&lt;/script&gt;</span></span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>首先说下同源，同源策略是浏览器的一种安全策略，所谓同源是指：域名、协议、端口完全相同。而跨域就是不同源！一般 <code>a</code>, <code>img</code>, <code>link</code>, <code>video</code>, <code>audio</code>, 等等能够发出请求的标签都可以实现跨域访问。但是这些标签不能得到返回的东西，所以一般不会用他们来请求资源。<br>","more":"</p>\n<h3 id=\"跨域方法\"><a href=\"#跨域方法\" class=\"headerlink\" title=\"跨域方法\"></a>跨域方法</h3><h4 id=\"原生-JavaScript-跨域\"><a href=\"#原生-JavaScript-跨域\" class=\"headerlink\" title=\"原生 JavaScript 跨域\"></a>原生 JavaScript 跨域</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">showuser</span>(<span class=\"params\">data</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> data = <span class=\"built_in\">JSON</span>.parse(data);</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(data);<span class=\"comment\">// 处理得到的 data</span></span></span><br><span class=\"line\"><span class=\"undefined\">&#125;;</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"http://x.cn/showalluser.html?callback=showuser\"</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"utf-8\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"jQuery-跨域\"><a href=\"#jQuery-跨域\" class=\"headerlink\" title=\"jQuery 跨域\"></a>jQuery 跨域</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">    type: <span class=\"string\">\"post\"</span>,</span><br><span class=\"line\">    url: <span class=\"string\">\"http://127.0.0.1:8080/showalluser.html\"</span>,</span><br><span class=\"line\">    dataType: <span class=\"string\">\"jsonp\"</span>,</span><br><span class=\"line\">    jsonp: <span class=\"string\">\"callback\"</span>,</span><br><span class=\"line\">    success: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(data);<span class=\"comment\">// 处理得到的 data</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"iframe-跨域\"><a href=\"#iframe-跨域\" class=\"headerlink\" title=\"iframe 跨域\"></a>iframe 跨域</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">URL, callBack</span>) </span>&#123;</span><br><span class=\"line\">    $iframe = $(<span class=\"string\">\"&lt;iframe style='display: none;'&gt;&lt;/iframe&gt;\"</span>);</span><br><span class=\"line\">    $iframe.prop(<span class=\"string\">\"src\"</span>, URL);</span><br><span class=\"line\">    $(<span class=\"string\">\"body\"</span>).append($iframe);</span><br><span class=\"line\"></span><br><span class=\"line\">    $iframe.on(<span class=\"string\">'load'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 转换成 jsonStr</span></span><br><span class=\"line\">        <span class=\"comment\">// contentDocument是 iframe 节点的方法获取contentDocument</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> ifrDocument = <span class=\"keyword\">this</span>.contentDocument;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> jsonStr = $(ifrDocument).find(<span class=\"string\">\"body\"</span>).text();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 转换成 json 对象</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> jsonObj = <span class=\"built_in\">JSON</span>.parse(jsonStr);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 把 json 对象传给回调函数</span></span><br><span class=\"line\">        callBack(jsonObj);</span><br><span class=\"line\">        <span class=\"comment\">// 删除当前的 iframe</span></span><br><span class=\"line\">        $(<span class=\"keyword\">this</span>).remove();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"原生-JavaScript-跨域封装\"><a href=\"#原生-JavaScript-跨域封装\" class=\"headerlink\" title=\"原生 JavaScript 跨域封装\"></a>原生 JavaScript 跨域封装</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"comment\">// 封装数据  跨域url  params fn</span></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">crossDomain</span>(<span class=\"params\">url,params,fn</span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> head = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'head'</span>)[<span class=\"number\">0</span>];</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 1. 处理回调函数</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> cbName = <span class=\"string\">'jsonp'</span>+</span></span><br><span class=\"line\"><span class=\"javascript\">    (<span class=\"built_in\">Math</span>.random() * <span class=\"built_in\">Math</span>.random()).toString().substr(<span class=\"number\">2</span>) +</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime();</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 将回调函数挂载到 window 对象上</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">window</span>[cbName] = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// 拿到并处理数据，交给回调函数</span></span></span><br><span class=\"line\"><span class=\"undefined\">        fn(data);</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// 拿到数据后remove掉</span></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">//head.removeChild(scriptObj);</span></span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 2. 解析url，处理查询字符串 解决这样的需求 ?count=5</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> qstring = <span class=\"string\">''</span>;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> params)&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        qstring += key + <span class=\"string\">'='</span> + params[key] + <span class=\"string\">'&amp;'</span>;</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;</span></span><br><span class=\"line\"><span class=\"javascript\">    qstring += <span class=\"string\">'callback='</span> + cbName;</span></span><br><span class=\"line\"><span class=\"javascript\">    url += <span class=\"string\">'?'</span> + qstring;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 3. 插入script</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> scriptObj = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'script'</span>);</span></span><br><span class=\"line\"><span class=\"undefined\">    scriptObj.src = url;</span></span><br><span class=\"line\"><span class=\"undefined\">    head.appendChild(scriptObj);</span></span><br><span class=\"line\"><span class=\"undefined\">&#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"comment\">// 使用</span></span></span><br><span class=\"line\"><span class=\"javascript\">crossDomain(<span class=\"string\">'http://api.douban.com/v2/movie/in_theaters'</span>,&#123;&#125;,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(data);</span></span><br><span class=\"line\"><span class=\"undefined\">&#125;)</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 解读：注意上面封装的函数会在 head 标签生成下面的内容，并随机产生函数名防止冲突 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"jsonp412964552676679031484646377133(data)”&gt;// 挂载在 window 上可以直接执行</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">      /*远程获取的 data 传入 jsonp* 函数内容，交给回调函数fn(data) */</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">&lt;/script&gt;</span></span></span><br></pre></td></tr></table></figure>"},{"title":"如何避免 async/await 地狱","comments":1,"date":"2018-05-20T14:11:35.000Z","from":"https://medium.freecodecamp.org/avoiding-the-async-await-hell-c77a0fb71c4c","_content":"\n最近阅读了 Aditya Agarwal 的一篇文章：How to escape async/await hell。这篇文章主要讨论了过度使用 async/await 导致的新的「地狱」问题，其已经在 Medium 上获得了 19k+ 的 Applause。\n\n<!-- more -->\n\n<div class=\"tip\">\n  async/await 是 ES7 的新语法。在 async/await 标准出来之前，JavaScript 的异步编程经历了 callback --> promise --> generator 的演变过程。\n</div>\n\n在 callback 的时代，最让人头疼的问题就是回调地狱 (callback hell)。所以，在 async/await 一经推出，社区就有人认为「这是 JavaScript 异步编程的终极解决方案」。但 async/await 也可能带来新的问题。\n\n> 好不容易逃离了一个「地狱」，又马上陷入另一个「地狱」了。\n\n### 何为 async/await 地狱\n\n在编写异步代码时，人们总是喜欢一次写多个语句，并且在一个函数调用之前使用 await 关键字。这可能会导致性能问题，因为很多时候一个语句并不依赖于前一个语句——但使用 await 关键字后，你就需要等待前一个语句完成。\n\n#### 示例\n\n假设你要写一个订购 pizza 和 drink 的脚本，代码可能是如下这样的：\n\n```js\n(async () => {\n  const pizzaData = await getPizzaData(); // async call\n  const drinkData = await getDrinkData(); // async call\n  const chosenPizza = choosePizza(); // sync call\n  const chosenDrink = chooseDrink(); // sync call\n  await addPizzaToCart(chosenPizza); // async call\n  await addDrinkToCart(chosenDrink); // async call\n  orderItems(); // async call\n})();\n```\n\n这段代码开起来没什么问题，也能正常的运行。但是，这并不是一个好的实现，因为这把本身可以并行执行的任务变成了串行执行。\n\n选择一个 drink 添加到购物车和选择一个 pizza 添加到购物车可以看作是两个任务，而这两个任务之间并没有相互依赖的关系，也没有特定的顺序执行关系。所以这两个任务是可以并行执行的，这样能提高性能。而上述代码将二者变成了串行执行，显然是降低了程序性能的。\n\n### 更糟糕的例子\n\n假设要写一个程序，根据 followers 数用来显示 GitHub 中国区用户的排名情况。\n\n如果只是获取排名，我们可以调用 Github 官方的 [Search users](https://developer.github.com/v3/search/#search-users) 接口，伪代码如下：\n\n```js\nasync function getUserRank() {\n  const data = await fetch(search_url);\n  return data;\n}\n\ngetUserRank();\n```\n\n调用 getUserRank 函数就能获取到想要的结果。但是，你可能还要想要获取每个用户的 follower 数、email、地区和仓库等数据，而 Search users 接口并没有返回这些数据，你可能需要再去调用 [Single user](https://developer.github.com/v3/users/#get-a-single-user) 接口。\n\n然后上述代码可能被改写为：\n\n```js\nasync function getUserRank() {\n  const data = await fetch(search_url);\n  const res = [];\n\n  for (let i = 0; i < data.length; i++) {\n    const item = data[i];\n    const user = await fetch(user_url);\n    res.push({...item, ...user});\n  }\n\n  return res;\n}\n\ngetUserRank();\n```\n\n运行查看结果，自己想要的数据都拿到了。但是，你发现一个问题，程序运行时间有点长，该怎么优化下呢？\n\n其实，铺垫了这么长，就是想说明一个问题：你陷入了 async/await 的地狱。\n\n上述代码的问题在于，获取每个用户资料的请求并不存在依赖性，就类似上文中的选择 pizza 和 drink 一样，这是可以并行执行的请求。而根据上述代码，请求都变成了串行执行，这当然会损耗程序的性能。\n\n按照上述代码，可以看一下其异步请求的动态图：\n\n![image](https://user-images.githubusercontent.com/7871813/40270076-c08ec820-5bb9-11e8-8470-5e716e87dc76.gif)\n\n可以看到，获取用户资料的每个请求都需要等到上一个请求完成之后才能执行，Waterfall 处于一个串行的状态。那要怎么改进这个问题呢？\n\n既然获取每个用户资料的请求并不存在依赖性，那么我们可以先触发异步请求，然后延迟处理异步请求的结果，而不是一直等该请求完成。根据这个思路，那可能改进的代码如下：\n\n```js\nasync function getUserDetails (username) {\n  const user = await fetch(user_url);\n  return user;\n}\n\nasync function getUserRank () {\n  const data = await fetch(search_url);\n  const promises = data.map((item) => getUserDetails(item.username));\n  await Promise.all(promises).then(handleYourData);\n}\n\ngetUserRank();\n```\n\n可以看一下异步请求的动态图：\n\n![image](https://user-images.githubusercontent.com/7871813/40270077-c2536602-5bb9-11e8-9438-a15ac05b41e0.gif)\n\n可以看到，获取用户资料的异步请求处理不再是串行执行，而是并行执行了，这将大大提高程序的运行效率和性能。\n\n### 总结\n\nAditya Agarwal 在其文章中也给出了怎么避免陷入 async/await 地狱的建议：\n\n1. 首先找出依赖于其他语句的执行的语句\n2. 然后将有依赖关系的一系列语句进行组合，合并成一个异步函数\n3. 最后用正确的方式执行这些函数\n\n### 参考\n\n* [精读《async/await 是把双刃剑》](https://github.com/dt-fe/weekly/blob/master/55.%E7%B2%BE%E8%AF%BB%E3%80%8Aasync%20await%20%E6%98%AF%E6%8A%8A%E5%8F%8C%E5%88%83%E5%89%91%E3%80%8B.md)\n* [async 函数的含义和用法](http://www.ruanyifeng.com/blog/2015/05/async.html)\n* [体验异步的终极解决方案 - ES7 的 Async/Await](https://cnodejs.org/topic/5640b80d3a6aa72c5e0030b6)\n* [How to escape async/await hell](https://github.com/dwqs/blog/issues/65)\n","source":"_posts/如何避免-async-await-地狱.md","raw":"---\ntitle: 如何避免 async/await 地狱\ncomments: true\ndate: 2018-05-20 22:11:35\ntags:\nfrom: https://medium.freecodecamp.org/avoiding-the-async-await-hell-c77a0fb71c4c\n---\n\n最近阅读了 Aditya Agarwal 的一篇文章：How to escape async/await hell。这篇文章主要讨论了过度使用 async/await 导致的新的「地狱」问题，其已经在 Medium 上获得了 19k+ 的 Applause。\n\n<!-- more -->\n\n<div class=\"tip\">\n  async/await 是 ES7 的新语法。在 async/await 标准出来之前，JavaScript 的异步编程经历了 callback --> promise --> generator 的演变过程。\n</div>\n\n在 callback 的时代，最让人头疼的问题就是回调地狱 (callback hell)。所以，在 async/await 一经推出，社区就有人认为「这是 JavaScript 异步编程的终极解决方案」。但 async/await 也可能带来新的问题。\n\n> 好不容易逃离了一个「地狱」，又马上陷入另一个「地狱」了。\n\n### 何为 async/await 地狱\n\n在编写异步代码时，人们总是喜欢一次写多个语句，并且在一个函数调用之前使用 await 关键字。这可能会导致性能问题，因为很多时候一个语句并不依赖于前一个语句——但使用 await 关键字后，你就需要等待前一个语句完成。\n\n#### 示例\n\n假设你要写一个订购 pizza 和 drink 的脚本，代码可能是如下这样的：\n\n```js\n(async () => {\n  const pizzaData = await getPizzaData(); // async call\n  const drinkData = await getDrinkData(); // async call\n  const chosenPizza = choosePizza(); // sync call\n  const chosenDrink = chooseDrink(); // sync call\n  await addPizzaToCart(chosenPizza); // async call\n  await addDrinkToCart(chosenDrink); // async call\n  orderItems(); // async call\n})();\n```\n\n这段代码开起来没什么问题，也能正常的运行。但是，这并不是一个好的实现，因为这把本身可以并行执行的任务变成了串行执行。\n\n选择一个 drink 添加到购物车和选择一个 pizza 添加到购物车可以看作是两个任务，而这两个任务之间并没有相互依赖的关系，也没有特定的顺序执行关系。所以这两个任务是可以并行执行的，这样能提高性能。而上述代码将二者变成了串行执行，显然是降低了程序性能的。\n\n### 更糟糕的例子\n\n假设要写一个程序，根据 followers 数用来显示 GitHub 中国区用户的排名情况。\n\n如果只是获取排名，我们可以调用 Github 官方的 [Search users](https://developer.github.com/v3/search/#search-users) 接口，伪代码如下：\n\n```js\nasync function getUserRank() {\n  const data = await fetch(search_url);\n  return data;\n}\n\ngetUserRank();\n```\n\n调用 getUserRank 函数就能获取到想要的结果。但是，你可能还要想要获取每个用户的 follower 数、email、地区和仓库等数据，而 Search users 接口并没有返回这些数据，你可能需要再去调用 [Single user](https://developer.github.com/v3/users/#get-a-single-user) 接口。\n\n然后上述代码可能被改写为：\n\n```js\nasync function getUserRank() {\n  const data = await fetch(search_url);\n  const res = [];\n\n  for (let i = 0; i < data.length; i++) {\n    const item = data[i];\n    const user = await fetch(user_url);\n    res.push({...item, ...user});\n  }\n\n  return res;\n}\n\ngetUserRank();\n```\n\n运行查看结果，自己想要的数据都拿到了。但是，你发现一个问题，程序运行时间有点长，该怎么优化下呢？\n\n其实，铺垫了这么长，就是想说明一个问题：你陷入了 async/await 的地狱。\n\n上述代码的问题在于，获取每个用户资料的请求并不存在依赖性，就类似上文中的选择 pizza 和 drink 一样，这是可以并行执行的请求。而根据上述代码，请求都变成了串行执行，这当然会损耗程序的性能。\n\n按照上述代码，可以看一下其异步请求的动态图：\n\n![image](https://user-images.githubusercontent.com/7871813/40270076-c08ec820-5bb9-11e8-8470-5e716e87dc76.gif)\n\n可以看到，获取用户资料的每个请求都需要等到上一个请求完成之后才能执行，Waterfall 处于一个串行的状态。那要怎么改进这个问题呢？\n\n既然获取每个用户资料的请求并不存在依赖性，那么我们可以先触发异步请求，然后延迟处理异步请求的结果，而不是一直等该请求完成。根据这个思路，那可能改进的代码如下：\n\n```js\nasync function getUserDetails (username) {\n  const user = await fetch(user_url);\n  return user;\n}\n\nasync function getUserRank () {\n  const data = await fetch(search_url);\n  const promises = data.map((item) => getUserDetails(item.username));\n  await Promise.all(promises).then(handleYourData);\n}\n\ngetUserRank();\n```\n\n可以看一下异步请求的动态图：\n\n![image](https://user-images.githubusercontent.com/7871813/40270077-c2536602-5bb9-11e8-9438-a15ac05b41e0.gif)\n\n可以看到，获取用户资料的异步请求处理不再是串行执行，而是并行执行了，这将大大提高程序的运行效率和性能。\n\n### 总结\n\nAditya Agarwal 在其文章中也给出了怎么避免陷入 async/await 地狱的建议：\n\n1. 首先找出依赖于其他语句的执行的语句\n2. 然后将有依赖关系的一系列语句进行组合，合并成一个异步函数\n3. 最后用正确的方式执行这些函数\n\n### 参考\n\n* [精读《async/await 是把双刃剑》](https://github.com/dt-fe/weekly/blob/master/55.%E7%B2%BE%E8%AF%BB%E3%80%8Aasync%20await%20%E6%98%AF%E6%8A%8A%E5%8F%8C%E5%88%83%E5%89%91%E3%80%8B.md)\n* [async 函数的含义和用法](http://www.ruanyifeng.com/blog/2015/05/async.html)\n* [体验异步的终极解决方案 - ES7 的 Async/Await](https://cnodejs.org/topic/5640b80d3a6aa72c5e0030b6)\n* [How to escape async/await hell](https://github.com/dwqs/blog/issues/65)\n","slug":"如何避免-async-await-地狱","published":1,"updated":"2018-12-26T16:01:04.000Z","layout":"post","photos":[],"link":"","_id":"ck3v60jtq000tr9q9fjh0ovd5","content":"<p>最近阅读了 Aditya Agarwal 的一篇文章：How to escape async/await hell。这篇文章主要讨论了过度使用 async/await 导致的新的「地狱」问题，其已经在 Medium 上获得了 19k+ 的 Applause。</p>\n<a id=\"more\"></a>\n<div class=\"tip\"><br>  async/await 是 ES7 的新语法。在 async/await 标准出来之前，JavaScript 的异步编程经历了 callback –&gt; promise –&gt; generator 的演变过程。<br></div>\n\n<p>在 callback 的时代，最让人头疼的问题就是回调地狱 (callback hell)。所以，在 async/await 一经推出，社区就有人认为「这是 JavaScript 异步编程的终极解决方案」。但 async/await 也可能带来新的问题。</p>\n<blockquote>\n<p>好不容易逃离了一个「地狱」，又马上陷入另一个「地狱」了。</p>\n</blockquote>\n<h3 id=\"何为-async-await-地狱\"><a href=\"#何为-async-await-地狱\" class=\"headerlink\" title=\"何为 async/await 地狱\"></a>何为 async/await 地狱</h3><p>在编写异步代码时，人们总是喜欢一次写多个语句，并且在一个函数调用之前使用 await 关键字。这可能会导致性能问题，因为很多时候一个语句并不依赖于前一个语句——但使用 await 关键字后，你就需要等待前一个语句完成。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><p>假设你要写一个订购 pizza 和 drink 的脚本，代码可能是如下这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> pizzaData = <span class=\"keyword\">await</span> getPizzaData(); <span class=\"comment\">// async call</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> drinkData = <span class=\"keyword\">await</span> getDrinkData(); <span class=\"comment\">// async call</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> chosenPizza = choosePizza(); <span class=\"comment\">// sync call</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> chosenDrink = chooseDrink(); <span class=\"comment\">// sync call</span></span><br><span class=\"line\">  <span class=\"keyword\">await</span> addPizzaToCart(chosenPizza); <span class=\"comment\">// async call</span></span><br><span class=\"line\">  <span class=\"keyword\">await</span> addDrinkToCart(chosenDrink); <span class=\"comment\">// async call</span></span><br><span class=\"line\">  orderItems(); <span class=\"comment\">// async call</span></span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>这段代码开起来没什么问题，也能正常的运行。但是，这并不是一个好的实现，因为这把本身可以并行执行的任务变成了串行执行。</p>\n<p>选择一个 drink 添加到购物车和选择一个 pizza 添加到购物车可以看作是两个任务，而这两个任务之间并没有相互依赖的关系，也没有特定的顺序执行关系。所以这两个任务是可以并行执行的，这样能提高性能。而上述代码将二者变成了串行执行，显然是降低了程序性能的。</p>\n<h3 id=\"更糟糕的例子\"><a href=\"#更糟糕的例子\" class=\"headerlink\" title=\"更糟糕的例子\"></a>更糟糕的例子</h3><p>假设要写一个程序，根据 followers 数用来显示 GitHub 中国区用户的排名情况。</p>\n<p>如果只是获取排名，我们可以调用 Github 官方的 <a href=\"https://developer.github.com/v3/search/#search-users\" target=\"_blank\" rel=\"noopener\">Search users</a> 接口，伪代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getUserRank</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> fetch(search_url);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> data;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">getUserRank();</span><br></pre></td></tr></table></figure>\n<p>调用 getUserRank 函数就能获取到想要的结果。但是，你可能还要想要获取每个用户的 follower 数、email、地区和仓库等数据，而 Search users 接口并没有返回这些数据，你可能需要再去调用 <a href=\"https://developer.github.com/v3/users/#get-a-single-user\" target=\"_blank\" rel=\"noopener\">Single user</a> 接口。</p>\n<p>然后上述代码可能被改写为：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getUserRank</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> fetch(search_url);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = [];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; data.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> item = data[i];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> user = <span class=\"keyword\">await</span> fetch(user_url);</span><br><span class=\"line\">    res.push(&#123;...item, ...user&#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">getUserRank();</span><br></pre></td></tr></table></figure>\n<p>运行查看结果，自己想要的数据都拿到了。但是，你发现一个问题，程序运行时间有点长，该怎么优化下呢？</p>\n<p>其实，铺垫了这么长，就是想说明一个问题：你陷入了 async/await 的地狱。</p>\n<p>上述代码的问题在于，获取每个用户资料的请求并不存在依赖性，就类似上文中的选择 pizza 和 drink 一样，这是可以并行执行的请求。而根据上述代码，请求都变成了串行执行，这当然会损耗程序的性能。</p>\n<p>按照上述代码，可以看一下其异步请求的动态图：</p>\n<p><img src=\"https://user-images.githubusercontent.com/7871813/40270076-c08ec820-5bb9-11e8-8470-5e716e87dc76.gif\" alt=\"image\"></p>\n<p>可以看到，获取用户资料的每个请求都需要等到上一个请求完成之后才能执行，Waterfall 处于一个串行的状态。那要怎么改进这个问题呢？</p>\n<p>既然获取每个用户资料的请求并不存在依赖性，那么我们可以先触发异步请求，然后延迟处理异步请求的结果，而不是一直等该请求完成。根据这个思路，那可能改进的代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getUserDetails</span> (<span class=\"params\">username</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> user = <span class=\"keyword\">await</span> fetch(user_url);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> user;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getUserRank</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> fetch(search_url);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> promises = data.map(<span class=\"function\">(<span class=\"params\">item</span>) =&gt;</span> getUserDetails(item.username));</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.all(promises).then(handleYourData);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">getUserRank();</span><br></pre></td></tr></table></figure>\n<p>可以看一下异步请求的动态图：</p>\n<p><img src=\"https://user-images.githubusercontent.com/7871813/40270077-c2536602-5bb9-11e8-9438-a15ac05b41e0.gif\" alt=\"image\"></p>\n<p>可以看到，获取用户资料的异步请求处理不再是串行执行，而是并行执行了，这将大大提高程序的运行效率和性能。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>Aditya Agarwal 在其文章中也给出了怎么避免陷入 async/await 地狱的建议：</p>\n<ol>\n<li>首先找出依赖于其他语句的执行的语句</li>\n<li>然后将有依赖关系的一系列语句进行组合，合并成一个异步函数</li>\n<li>最后用正确的方式执行这些函数</li>\n</ol>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><a href=\"https://github.com/dt-fe/weekly/blob/master/55.%E7%B2%BE%E8%AF%BB%E3%80%8Aasync%20await%20%E6%98%AF%E6%8A%8A%E5%8F%8C%E5%88%83%E5%89%91%E3%80%8B.md\" target=\"_blank\" rel=\"noopener\">精读《async/await 是把双刃剑》</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/05/async.html\" target=\"_blank\" rel=\"noopener\">async 函数的含义和用法</a></li>\n<li><a href=\"https://cnodejs.org/topic/5640b80d3a6aa72c5e0030b6\" target=\"_blank\" rel=\"noopener\">体验异步的终极解决方案 - ES7 的 Async/Await</a></li>\n<li><a href=\"https://github.com/dwqs/blog/issues/65\" target=\"_blank\" rel=\"noopener\">How to escape async/await hell</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>最近阅读了 Aditya Agarwal 的一篇文章：How to escape async/await hell。这篇文章主要讨论了过度使用 async/await 导致的新的「地狱」问题，其已经在 Medium 上获得了 19k+ 的 Applause。</p>","more":"<div class=\"tip\"><br>  async/await 是 ES7 的新语法。在 async/await 标准出来之前，JavaScript 的异步编程经历了 callback –&gt; promise –&gt; generator 的演变过程。<br></div>\n\n<p>在 callback 的时代，最让人头疼的问题就是回调地狱 (callback hell)。所以，在 async/await 一经推出，社区就有人认为「这是 JavaScript 异步编程的终极解决方案」。但 async/await 也可能带来新的问题。</p>\n<blockquote>\n<p>好不容易逃离了一个「地狱」，又马上陷入另一个「地狱」了。</p>\n</blockquote>\n<h3 id=\"何为-async-await-地狱\"><a href=\"#何为-async-await-地狱\" class=\"headerlink\" title=\"何为 async/await 地狱\"></a>何为 async/await 地狱</h3><p>在编写异步代码时，人们总是喜欢一次写多个语句，并且在一个函数调用之前使用 await 关键字。这可能会导致性能问题，因为很多时候一个语句并不依赖于前一个语句——但使用 await 关键字后，你就需要等待前一个语句完成。</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><p>假设你要写一个订购 pizza 和 drink 的脚本，代码可能是如下这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> pizzaData = <span class=\"keyword\">await</span> getPizzaData(); <span class=\"comment\">// async call</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> drinkData = <span class=\"keyword\">await</span> getDrinkData(); <span class=\"comment\">// async call</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> chosenPizza = choosePizza(); <span class=\"comment\">// sync call</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> chosenDrink = chooseDrink(); <span class=\"comment\">// sync call</span></span><br><span class=\"line\">  <span class=\"keyword\">await</span> addPizzaToCart(chosenPizza); <span class=\"comment\">// async call</span></span><br><span class=\"line\">  <span class=\"keyword\">await</span> addDrinkToCart(chosenDrink); <span class=\"comment\">// async call</span></span><br><span class=\"line\">  orderItems(); <span class=\"comment\">// async call</span></span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>这段代码开起来没什么问题，也能正常的运行。但是，这并不是一个好的实现，因为这把本身可以并行执行的任务变成了串行执行。</p>\n<p>选择一个 drink 添加到购物车和选择一个 pizza 添加到购物车可以看作是两个任务，而这两个任务之间并没有相互依赖的关系，也没有特定的顺序执行关系。所以这两个任务是可以并行执行的，这样能提高性能。而上述代码将二者变成了串行执行，显然是降低了程序性能的。</p>\n<h3 id=\"更糟糕的例子\"><a href=\"#更糟糕的例子\" class=\"headerlink\" title=\"更糟糕的例子\"></a>更糟糕的例子</h3><p>假设要写一个程序，根据 followers 数用来显示 GitHub 中国区用户的排名情况。</p>\n<p>如果只是获取排名，我们可以调用 Github 官方的 <a href=\"https://developer.github.com/v3/search/#search-users\" target=\"_blank\" rel=\"noopener\">Search users</a> 接口，伪代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getUserRank</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> fetch(search_url);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> data;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">getUserRank();</span><br></pre></td></tr></table></figure>\n<p>调用 getUserRank 函数就能获取到想要的结果。但是，你可能还要想要获取每个用户的 follower 数、email、地区和仓库等数据，而 Search users 接口并没有返回这些数据，你可能需要再去调用 <a href=\"https://developer.github.com/v3/users/#get-a-single-user\" target=\"_blank\" rel=\"noopener\">Single user</a> 接口。</p>\n<p>然后上述代码可能被改写为：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getUserRank</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> fetch(search_url);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = [];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; data.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> item = data[i];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> user = <span class=\"keyword\">await</span> fetch(user_url);</span><br><span class=\"line\">    res.push(&#123;...item, ...user&#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">getUserRank();</span><br></pre></td></tr></table></figure>\n<p>运行查看结果，自己想要的数据都拿到了。但是，你发现一个问题，程序运行时间有点长，该怎么优化下呢？</p>\n<p>其实，铺垫了这么长，就是想说明一个问题：你陷入了 async/await 的地狱。</p>\n<p>上述代码的问题在于，获取每个用户资料的请求并不存在依赖性，就类似上文中的选择 pizza 和 drink 一样，这是可以并行执行的请求。而根据上述代码，请求都变成了串行执行，这当然会损耗程序的性能。</p>\n<p>按照上述代码，可以看一下其异步请求的动态图：</p>\n<p><img src=\"https://user-images.githubusercontent.com/7871813/40270076-c08ec820-5bb9-11e8-8470-5e716e87dc76.gif\" alt=\"image\"></p>\n<p>可以看到，获取用户资料的每个请求都需要等到上一个请求完成之后才能执行，Waterfall 处于一个串行的状态。那要怎么改进这个问题呢？</p>\n<p>既然获取每个用户资料的请求并不存在依赖性，那么我们可以先触发异步请求，然后延迟处理异步请求的结果，而不是一直等该请求完成。根据这个思路，那可能改进的代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getUserDetails</span> (<span class=\"params\">username</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> user = <span class=\"keyword\">await</span> fetch(user_url);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> user;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getUserRank</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> fetch(search_url);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> promises = data.map(<span class=\"function\">(<span class=\"params\">item</span>) =&gt;</span> getUserDetails(item.username));</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.all(promises).then(handleYourData);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">getUserRank();</span><br></pre></td></tr></table></figure>\n<p>可以看一下异步请求的动态图：</p>\n<p><img src=\"https://user-images.githubusercontent.com/7871813/40270077-c2536602-5bb9-11e8-9438-a15ac05b41e0.gif\" alt=\"image\"></p>\n<p>可以看到，获取用户资料的异步请求处理不再是串行执行，而是并行执行了，这将大大提高程序的运行效率和性能。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>Aditya Agarwal 在其文章中也给出了怎么避免陷入 async/await 地狱的建议：</p>\n<ol>\n<li>首先找出依赖于其他语句的执行的语句</li>\n<li>然后将有依赖关系的一系列语句进行组合，合并成一个异步函数</li>\n<li>最后用正确的方式执行这些函数</li>\n</ol>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><a href=\"https://github.com/dt-fe/weekly/blob/master/55.%E7%B2%BE%E8%AF%BB%E3%80%8Aasync%20await%20%E6%98%AF%E6%8A%8A%E5%8F%8C%E5%88%83%E5%89%91%E3%80%8B.md\" target=\"_blank\" rel=\"noopener\">精读《async/await 是把双刃剑》</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/05/async.html\" target=\"_blank\" rel=\"noopener\">async 函数的含义和用法</a></li>\n<li><a href=\"https://cnodejs.org/topic/5640b80d3a6aa72c5e0030b6\" target=\"_blank\" rel=\"noopener\">体验异步的终极解决方案 - ES7 的 Async/Await</a></li>\n<li><a href=\"https://github.com/dwqs/blog/issues/65\" target=\"_blank\" rel=\"noopener\">How to escape async/await hell</a></li>\n</ul>"},{"title":"给小白读的 WEB 托管服务进化史","comments":1,"date":"2018-06-09T10:29:12.000Z","from":null,"_content":"这篇文章是来拓展自己知识面的, 在我读高中那会 (08 年), 我身边就有沉迷电脑技术的同学, 那个时候我想着做一个自己的网站, 肯定是非常牛逼的事了. 从最开始接触的服务, 依次来排个序. 永硕 E 盘 -> 免费空间建站 (国外居多) -> 虚拟空间 -> 虚拟服务器 (VPS) -> 独立服务器. 看完这篇文章后, 我总算对这方面知识有了一个比较系统性的认识了. 一起来学习一下.\n\n<!-- more -->\n### 引子\n\n文章开始之前, 我觉得还是有必要把这些专有名词先科普一下, 不要觉得很高大上, 简称而已.\n\n* IaaS - 基础设施即服务\n* PaaS - 平台即服务\n* CaaS - 容器即服务\n\n本文介绍了 Web 托管服务进化的历史, 从专用服务器到虚拟化到 IaaS、PaaS 和最新的 CaaS; 说明了每种方式的优点和缺点. 着重阐述了构建 PaaS 应用的各个组件, 以及在选择 CaaS 提供商时应该考虑的问题. 最后从成本和功能性的角度论述了 PaaS 用户应该迁移到 CaaS 平台.\n\n读完这篇博文, 你应该可以清楚的理解:\n\n* 这些名词到底指什么\n* 这为什么对你很重要\n* 对于你的使用场景，哪种方式最适合\n\n当然没有一种方式能够适合所有的 Web 基础设施的场景, 你的特殊场景或许需要特殊的考虑.\n\n### 从头开始——专用服务器\n\nWeb 托管的本质还是在一个数据中心里布满了服务器、交换机、路由器、存储阵列和其它网络组件. 我们所讨论的每一个选项不管它是 PaaS、IaaS 还是 CaaS, 它底层使用的基础设施都是相同的, 即在一个大屋子里的很多独立服务器. 他们只是上面增加了很多抽象层使得管理变得更简单, 和使用自动化的方式处理以前很慢或者需要手动步骤的任务.\n\n专用服务器, 或者叫做 “裸机” 有它的优点和缺点.\n\n#### 优点\n\n* 性能——你在直接使用一个服务器, 没有任何抽象层例如虚拟化带来的性能开销.\n* 可靠性——没有抽象层和虚拟化, 出错的可能性会降低.\n* 资源利用率——使用专用服务器, 你的进程不需要跟其它的虚拟机或者进程竞争资源例如 CPU、内存和带宽.\n\n#### 缺点\n\n* 管理复杂性——你无法容易地克隆专用服务器来产生更多的实例, 专用服务器没有 AMI（译者注: Amazon Machine Image）或者镜像的概念. 想扩展你的基础设施到多个服务器上？我希望你用配置管理, 或者使用可信赖的老朋友 rsync.\n* 成本——使用专用服务器, 在大多数情况下你需要预先支付服务器的硬件价格, 然后再付租用场地的成本, 或者你从一个服务提供商那里租赁它们. 无论哪种方式, 你都没法在不使用时终止服务器的租赁来节省成本, 因此你需要更加谨慎的对待你的财务计划.\n* 你所有的进程和应用都运行在专用服务器上, 因此运行在相同的操作系统上. 为了可扩展性的目的, 你往往希望服务器只运行单一的进程, 例如 Web 服务或者数据库服务. 在一个服务器上运行所有的应用使得操作系统的调优变得更困难.\n\n### 使事情变得更容易——虚拟化\n\n尽管专用服务器有很多优点, 但是它的缺点在大多数情况下会远远超过其优点. 公司为了能够迅速进入市场赢得竞争, 对于部署的速度提出了更高的要求, 虚拟化就很自然的成为了数据中心进化中的下一个步骤.\n\n#### 什么是虚拟化\n\n简而言之, 虚拟化就是将物理服务器分成更小的虚拟机, 这些虚拟机只能访问物理机的部分资源. 例如你有一个 8CPU 核以及 16GB 内存的物理服务器, 则可以将它分成 8 个虚拟机, 每个虚拟机有 1 个 CPU 和 2GB 内存. 你或许已经听说过一些虚拟化技术如 Xen, KVM, VMware 和 Hyper-V, 其实很有更多.\n\n#### 优点\n\n* 你可以在需要更多虚拟机实例或者想要虚拟机共享时进行虚拟机的克隆.\n* 你可以备份虚拟机镜像作为安全保护或者灾备.\n\n#### 缺点\n\n* 使用虚拟化意味着额外的性能开销, 可能造成性能下降.\n* 虚拟机镜像在不同的服务提供商和虚拟化技术之间基本上是不可移植的.\n* 管理虚拟机依然是手工步骤, 需要管理的时间和专业知识.\n\n### 进化——虚拟化变成 IaaS\n\n你知道 [51% 的人认为 “云” 会被天气影响吗](http://www.businessinsider.com/people-think-stormy-weather-affects-cloud-computing-2012-8)？你知道当人们谈论 “云” 时他们实际上是在讨论基础设施即服务 (IaaS) 吗？\n\n#### 什么是基础设施即服务 (IaaS)\n\n* 通过 API 来管理硬件的虚拟化.\n* 通过编程接口访问计算、存储和网络资源和配置.\n* 当你需要是申请一个新的虚拟机, 当你完成后终止虚拟机, 你只需要为你使用的资源付费.\n* 将数据中心资源视为公共设施.\n\n亚马逊在 2006 年发布了其 Amazon Web Services（AWS）和 EC2 产品，成为了这个领域的先驱。\n\n#### 为什么这个进化如此重要\n\n在过去当你需要上线一个在线业务时, 你不得不进行复杂的计划来保证你在数据中心内有足够的机架空间、足够的服务器和存储来处理业务的增长, 足够的网络带宽来处理所有的用户流量. 这种计划并不容易, 尤其是对早期的业务来讲, 你无法预测业务的未来和增长轨迹.\n\n1. 它给了开发者超能量:\n    * 构思一个想法立即上线.\n    * 如果成功了, 可以容易的扩展规模.\n    * 如果失败了, 关闭虚拟机以节约成本.\n2. 它使得数据中心自动化变得更强大:\n    * 全自动基础设施管理成为可能, 出现了 “基础设施即代码” 的概念.\n    * 弹性伸缩在过去是不可能实现的, 但是现在 web 基础设施可以当业务变化时自动的扩展或者收缩.\n    * 在服务器的自动化管理之后, 数据中心的自动化也扩展到了存储、网络以及其它大量的需要专业知识的系统, 在代码和 API 能够处理这些自动化之后, 这给全球的开发者社区带来了新的机遇.\n\n### 进一步演化——平台即服务 (PaaS)\n\n平台即服务 (PaaS) 使得开发人员可以很容易的部署和管理应用而隐藏掉所有的实现细节例如服务器、负载均衡器、DNS 等等. 他们或多或少的去除了对运维团队的需求, 而是让开发人员去关注应用部署. 有很多 PaaS 提供商, 其中一个最流行的是 Heroku. 关于 Heroku 的一个有趣的事情是 Heroku 完全是运行在 AWS 之上并依赖 AWS 的. 如果你不愿意你的应用运行在美国东部或者欧洲西部的 AWS 上的话, 这或许是一个问题. 没有 IaaS, 像 Heroku 这样的平台可能就不会存在了. PaaS 提供商利用 IaaS 作为一个非常重要的组成部分来交付它们的服务. 在减少从想法到部署的时间、自动化流程以及减少特殊的系统知识需求的趋势中, PaaS 是合理的下一步, 就像是从专用服务器到 IaaS 一样.\n\n#### 构建 PaaS 是困难的\n\n能够通过抽象而避免处理服务器相关的问题是不容易的, 需要引入很多东西才能做到.\n\n在 PaaS 的概念之下有几个主要的模块：\n\n* 编译系统——把你的代码编译成可以运行的应用, 并且把它存储到某个地方作为后续使用.\n* 应用管理数据库——管理 Git 版本、build 版本和应用元数据.\n* 集群调度器——将一组服务器作为一台大的服务器来管理, 在服务器资源池的某个服务器上运行你的程序, 并检查和替换失效的作业.\n* 负载均衡——允许从 Internet 和内部程序来的业务负载被正确的路由到合适的位置.\n* DNS——在你产生和修改应用时自动配置 DNS 条目.\n* 或许是最重要的——某个形式的容器化例如  freebsd jails、solaris zones、或者 linux containers, 容器化使得某个的应用不会进入和影响到其它的应用.\n\n第一个和最后一个点是 Docker 迅速发展的非常重要的原因. Linux 容器技术已经存在了一段时间了, 但是只有某些大的公司或者 PaaS 提供商自动化了容器的使用, Docker 使 Linux 容器的使用变得非常简单, 也提供了标准化的镜像格式, 它成为了 PaaS 中重要的组成部分.\n\n这非常强大, 因为很多公司在处理爆发式的用户增长, 来自于移动、社交和 IoT 的新的业务模式, 以及期望从传统的长的版本发布周期转变到持续交付. 他们利用基于软件的架构或者微服务. 他们需要能够自动部署和测试新的代码, 并根据业务的变化弹性伸缩. 但问题是他们没有足够的资源和经验来交付到他们的开发团队, 所以他们不得不将其外包给 PaaS 提供商. 不幸的是, 当你这么做的时候, 你就放弃了对于这个黑盒子的很多控制, 而是花很多钱并使得自己完全依赖于它. 另外一个选项是, 很多公司反复的重新发明轮子或者使用那些难于维护的、运行缓慢的和易于出错的工具.\n\n最好的情形是在自己的数据中心或者 Cloud 帐号中运行一个 PaaS 平台, 你可以全权控制, 你的团队可以直接参与应用的部署, 因此可以形成一种真正的 DevOps 文化. Docker 及其标准化的生态系统是这种愿景成为现实的重要一步.\n\n### 最后——容器托管平台 (CaaS)\n\n什么是容器托管平台, 或者叫容器即服务呢？这就是我在上面的章节中提到的另外一种构建在 Docker 基础上的 Web 托管方式. 它是你用容器来部署复杂的多层次的应用所需要的自动化的编译系统, 集群调度器, 负载均衡, DNS 自动化以及服务发现. 这是 PaaS 的另外一部分内容, 但是你不是用一个复杂的编译系统来编译你的应用, 而是用 Docker 镜像. 镜像可以非常容易的进行编译和本地测试, 因此你在部署应用之前就确认应用可以正常工作. 现在 PaaS 用户也可以得到相同的体验, 但是不需要拥有自己的硬件或者云帐号的前提下节约大量的成本. 他们不再受限于其服务提供商所支持的环境, 可以通过将应用打包成 Docker 镜像的方式在任何地方运行.\n\n在这个过程中, 利用诸如 ContainerShip Cloud, 你可以在任何地方, 在任何云平台上甚至是裸机上用相同的方式运行你的应用. 你不再被卡在构建复杂的应用来解决非常困难的问题, 或者卡在使用某个提供商的特殊的自动化部署工具上.\n\n* 但是选择一个正确的 Docker 容器托管平台并不是一件容易的事情, 有很多的问题需要你去思考和注意.\n* 有大量的选项, 因此选择其中一个进行研究就变得困难. 好消息是如果你的应用已经容器化, 你就可以轻松的测试其中的每一个.\n* 你正在使用的服务提供商例如 Triton 或者 ECS 的某个解决方案或许使得你无法脱离这个提供商, 这也使得 Docker 的最令人兴奋的可移植性变得不那么重要了.\n* 许多 CaaS 方案在他们自己的硬件上运行所有的管理系统, 你自己的服务器上只是运行某个代理程序来连接他们的 API, 因此如果他们的系统宕机后你的集群将无法工作.\n* 允许你在防火墙后运行整个系统的方案是非常复杂的, 需要一个团队去管理和升级.\n* 能够容易的在防火墙后运行整个系统的方案会使得高可用成为低优先级的事情.\n* 当你选择了一个 CaaS 提供商时, 你就可以摆脱了你的服务托管提供商的锁定, 但是你将陷入到 CaaS 提供商的锁定. 你无法不使用他们的 SaaS 管理接口而在你自己的硬件上运行整个系统包括管理系统, API 和 UI. 你一旦决定付钱, 你最好可以一直付钱.\n\n### 总结\n\n终于看完了, 真的是又臭又长啊. 回顾一下这篇文章, 总体来说是经历了这样一个过程:\n\n1. 专有服务器\n2. 虚拟化技术\n3. 基础设施即服务 (IaaS)\n4. 平台即服务 (PaaS)\n5. 容器即服务 (CaaS)\n\n总结一下, 我觉得开发人员还是有必要了解一下关于产品部署相关的技术发展. 然后根据自己的业务来选择合适的服务提供商.\n","source":"_posts/给小白读的-WEB-托管服务进化史.md","raw":"---\ntitle: 给小白读的 WEB 托管服务进化史\ncomments: true\ndate: 2018-06-09 18:29:12\ntags:\nfrom:\n---\n这篇文章是来拓展自己知识面的, 在我读高中那会 (08 年), 我身边就有沉迷电脑技术的同学, 那个时候我想着做一个自己的网站, 肯定是非常牛逼的事了. 从最开始接触的服务, 依次来排个序. 永硕 E 盘 -> 免费空间建站 (国外居多) -> 虚拟空间 -> 虚拟服务器 (VPS) -> 独立服务器. 看完这篇文章后, 我总算对这方面知识有了一个比较系统性的认识了. 一起来学习一下.\n\n<!-- more -->\n### 引子\n\n文章开始之前, 我觉得还是有必要把这些专有名词先科普一下, 不要觉得很高大上, 简称而已.\n\n* IaaS - 基础设施即服务\n* PaaS - 平台即服务\n* CaaS - 容器即服务\n\n本文介绍了 Web 托管服务进化的历史, 从专用服务器到虚拟化到 IaaS、PaaS 和最新的 CaaS; 说明了每种方式的优点和缺点. 着重阐述了构建 PaaS 应用的各个组件, 以及在选择 CaaS 提供商时应该考虑的问题. 最后从成本和功能性的角度论述了 PaaS 用户应该迁移到 CaaS 平台.\n\n读完这篇博文, 你应该可以清楚的理解:\n\n* 这些名词到底指什么\n* 这为什么对你很重要\n* 对于你的使用场景，哪种方式最适合\n\n当然没有一种方式能够适合所有的 Web 基础设施的场景, 你的特殊场景或许需要特殊的考虑.\n\n### 从头开始——专用服务器\n\nWeb 托管的本质还是在一个数据中心里布满了服务器、交换机、路由器、存储阵列和其它网络组件. 我们所讨论的每一个选项不管它是 PaaS、IaaS 还是 CaaS, 它底层使用的基础设施都是相同的, 即在一个大屋子里的很多独立服务器. 他们只是上面增加了很多抽象层使得管理变得更简单, 和使用自动化的方式处理以前很慢或者需要手动步骤的任务.\n\n专用服务器, 或者叫做 “裸机” 有它的优点和缺点.\n\n#### 优点\n\n* 性能——你在直接使用一个服务器, 没有任何抽象层例如虚拟化带来的性能开销.\n* 可靠性——没有抽象层和虚拟化, 出错的可能性会降低.\n* 资源利用率——使用专用服务器, 你的进程不需要跟其它的虚拟机或者进程竞争资源例如 CPU、内存和带宽.\n\n#### 缺点\n\n* 管理复杂性——你无法容易地克隆专用服务器来产生更多的实例, 专用服务器没有 AMI（译者注: Amazon Machine Image）或者镜像的概念. 想扩展你的基础设施到多个服务器上？我希望你用配置管理, 或者使用可信赖的老朋友 rsync.\n* 成本——使用专用服务器, 在大多数情况下你需要预先支付服务器的硬件价格, 然后再付租用场地的成本, 或者你从一个服务提供商那里租赁它们. 无论哪种方式, 你都没法在不使用时终止服务器的租赁来节省成本, 因此你需要更加谨慎的对待你的财务计划.\n* 你所有的进程和应用都运行在专用服务器上, 因此运行在相同的操作系统上. 为了可扩展性的目的, 你往往希望服务器只运行单一的进程, 例如 Web 服务或者数据库服务. 在一个服务器上运行所有的应用使得操作系统的调优变得更困难.\n\n### 使事情变得更容易——虚拟化\n\n尽管专用服务器有很多优点, 但是它的缺点在大多数情况下会远远超过其优点. 公司为了能够迅速进入市场赢得竞争, 对于部署的速度提出了更高的要求, 虚拟化就很自然的成为了数据中心进化中的下一个步骤.\n\n#### 什么是虚拟化\n\n简而言之, 虚拟化就是将物理服务器分成更小的虚拟机, 这些虚拟机只能访问物理机的部分资源. 例如你有一个 8CPU 核以及 16GB 内存的物理服务器, 则可以将它分成 8 个虚拟机, 每个虚拟机有 1 个 CPU 和 2GB 内存. 你或许已经听说过一些虚拟化技术如 Xen, KVM, VMware 和 Hyper-V, 其实很有更多.\n\n#### 优点\n\n* 你可以在需要更多虚拟机实例或者想要虚拟机共享时进行虚拟机的克隆.\n* 你可以备份虚拟机镜像作为安全保护或者灾备.\n\n#### 缺点\n\n* 使用虚拟化意味着额外的性能开销, 可能造成性能下降.\n* 虚拟机镜像在不同的服务提供商和虚拟化技术之间基本上是不可移植的.\n* 管理虚拟机依然是手工步骤, 需要管理的时间和专业知识.\n\n### 进化——虚拟化变成 IaaS\n\n你知道 [51% 的人认为 “云” 会被天气影响吗](http://www.businessinsider.com/people-think-stormy-weather-affects-cloud-computing-2012-8)？你知道当人们谈论 “云” 时他们实际上是在讨论基础设施即服务 (IaaS) 吗？\n\n#### 什么是基础设施即服务 (IaaS)\n\n* 通过 API 来管理硬件的虚拟化.\n* 通过编程接口访问计算、存储和网络资源和配置.\n* 当你需要是申请一个新的虚拟机, 当你完成后终止虚拟机, 你只需要为你使用的资源付费.\n* 将数据中心资源视为公共设施.\n\n亚马逊在 2006 年发布了其 Amazon Web Services（AWS）和 EC2 产品，成为了这个领域的先驱。\n\n#### 为什么这个进化如此重要\n\n在过去当你需要上线一个在线业务时, 你不得不进行复杂的计划来保证你在数据中心内有足够的机架空间、足够的服务器和存储来处理业务的增长, 足够的网络带宽来处理所有的用户流量. 这种计划并不容易, 尤其是对早期的业务来讲, 你无法预测业务的未来和增长轨迹.\n\n1. 它给了开发者超能量:\n    * 构思一个想法立即上线.\n    * 如果成功了, 可以容易的扩展规模.\n    * 如果失败了, 关闭虚拟机以节约成本.\n2. 它使得数据中心自动化变得更强大:\n    * 全自动基础设施管理成为可能, 出现了 “基础设施即代码” 的概念.\n    * 弹性伸缩在过去是不可能实现的, 但是现在 web 基础设施可以当业务变化时自动的扩展或者收缩.\n    * 在服务器的自动化管理之后, 数据中心的自动化也扩展到了存储、网络以及其它大量的需要专业知识的系统, 在代码和 API 能够处理这些自动化之后, 这给全球的开发者社区带来了新的机遇.\n\n### 进一步演化——平台即服务 (PaaS)\n\n平台即服务 (PaaS) 使得开发人员可以很容易的部署和管理应用而隐藏掉所有的实现细节例如服务器、负载均衡器、DNS 等等. 他们或多或少的去除了对运维团队的需求, 而是让开发人员去关注应用部署. 有很多 PaaS 提供商, 其中一个最流行的是 Heroku. 关于 Heroku 的一个有趣的事情是 Heroku 完全是运行在 AWS 之上并依赖 AWS 的. 如果你不愿意你的应用运行在美国东部或者欧洲西部的 AWS 上的话, 这或许是一个问题. 没有 IaaS, 像 Heroku 这样的平台可能就不会存在了. PaaS 提供商利用 IaaS 作为一个非常重要的组成部分来交付它们的服务. 在减少从想法到部署的时间、自动化流程以及减少特殊的系统知识需求的趋势中, PaaS 是合理的下一步, 就像是从专用服务器到 IaaS 一样.\n\n#### 构建 PaaS 是困难的\n\n能够通过抽象而避免处理服务器相关的问题是不容易的, 需要引入很多东西才能做到.\n\n在 PaaS 的概念之下有几个主要的模块：\n\n* 编译系统——把你的代码编译成可以运行的应用, 并且把它存储到某个地方作为后续使用.\n* 应用管理数据库——管理 Git 版本、build 版本和应用元数据.\n* 集群调度器——将一组服务器作为一台大的服务器来管理, 在服务器资源池的某个服务器上运行你的程序, 并检查和替换失效的作业.\n* 负载均衡——允许从 Internet 和内部程序来的业务负载被正确的路由到合适的位置.\n* DNS——在你产生和修改应用时自动配置 DNS 条目.\n* 或许是最重要的——某个形式的容器化例如  freebsd jails、solaris zones、或者 linux containers, 容器化使得某个的应用不会进入和影响到其它的应用.\n\n第一个和最后一个点是 Docker 迅速发展的非常重要的原因. Linux 容器技术已经存在了一段时间了, 但是只有某些大的公司或者 PaaS 提供商自动化了容器的使用, Docker 使 Linux 容器的使用变得非常简单, 也提供了标准化的镜像格式, 它成为了 PaaS 中重要的组成部分.\n\n这非常强大, 因为很多公司在处理爆发式的用户增长, 来自于移动、社交和 IoT 的新的业务模式, 以及期望从传统的长的版本发布周期转变到持续交付. 他们利用基于软件的架构或者微服务. 他们需要能够自动部署和测试新的代码, 并根据业务的变化弹性伸缩. 但问题是他们没有足够的资源和经验来交付到他们的开发团队, 所以他们不得不将其外包给 PaaS 提供商. 不幸的是, 当你这么做的时候, 你就放弃了对于这个黑盒子的很多控制, 而是花很多钱并使得自己完全依赖于它. 另外一个选项是, 很多公司反复的重新发明轮子或者使用那些难于维护的、运行缓慢的和易于出错的工具.\n\n最好的情形是在自己的数据中心或者 Cloud 帐号中运行一个 PaaS 平台, 你可以全权控制, 你的团队可以直接参与应用的部署, 因此可以形成一种真正的 DevOps 文化. Docker 及其标准化的生态系统是这种愿景成为现实的重要一步.\n\n### 最后——容器托管平台 (CaaS)\n\n什么是容器托管平台, 或者叫容器即服务呢？这就是我在上面的章节中提到的另外一种构建在 Docker 基础上的 Web 托管方式. 它是你用容器来部署复杂的多层次的应用所需要的自动化的编译系统, 集群调度器, 负载均衡, DNS 自动化以及服务发现. 这是 PaaS 的另外一部分内容, 但是你不是用一个复杂的编译系统来编译你的应用, 而是用 Docker 镜像. 镜像可以非常容易的进行编译和本地测试, 因此你在部署应用之前就确认应用可以正常工作. 现在 PaaS 用户也可以得到相同的体验, 但是不需要拥有自己的硬件或者云帐号的前提下节约大量的成本. 他们不再受限于其服务提供商所支持的环境, 可以通过将应用打包成 Docker 镜像的方式在任何地方运行.\n\n在这个过程中, 利用诸如 ContainerShip Cloud, 你可以在任何地方, 在任何云平台上甚至是裸机上用相同的方式运行你的应用. 你不再被卡在构建复杂的应用来解决非常困难的问题, 或者卡在使用某个提供商的特殊的自动化部署工具上.\n\n* 但是选择一个正确的 Docker 容器托管平台并不是一件容易的事情, 有很多的问题需要你去思考和注意.\n* 有大量的选项, 因此选择其中一个进行研究就变得困难. 好消息是如果你的应用已经容器化, 你就可以轻松的测试其中的每一个.\n* 你正在使用的服务提供商例如 Triton 或者 ECS 的某个解决方案或许使得你无法脱离这个提供商, 这也使得 Docker 的最令人兴奋的可移植性变得不那么重要了.\n* 许多 CaaS 方案在他们自己的硬件上运行所有的管理系统, 你自己的服务器上只是运行某个代理程序来连接他们的 API, 因此如果他们的系统宕机后你的集群将无法工作.\n* 允许你在防火墙后运行整个系统的方案是非常复杂的, 需要一个团队去管理和升级.\n* 能够容易的在防火墙后运行整个系统的方案会使得高可用成为低优先级的事情.\n* 当你选择了一个 CaaS 提供商时, 你就可以摆脱了你的服务托管提供商的锁定, 但是你将陷入到 CaaS 提供商的锁定. 你无法不使用他们的 SaaS 管理接口而在你自己的硬件上运行整个系统包括管理系统, API 和 UI. 你一旦决定付钱, 你最好可以一直付钱.\n\n### 总结\n\n终于看完了, 真的是又臭又长啊. 回顾一下这篇文章, 总体来说是经历了这样一个过程:\n\n1. 专有服务器\n2. 虚拟化技术\n3. 基础设施即服务 (IaaS)\n4. 平台即服务 (PaaS)\n5. 容器即服务 (CaaS)\n\n总结一下, 我觉得开发人员还是有必要了解一下关于产品部署相关的技术发展. 然后根据自己的业务来选择合适的服务提供商.\n","slug":"给小白读的-WEB-托管服务进化史","published":1,"updated":"2019-12-07T04:53:18.096Z","layout":"post","photos":[],"link":"","_id":"ck3v60jtq000ur9q9szdjjfva","content":"<p>这篇文章是来拓展自己知识面的, 在我读高中那会 (08 年), 我身边就有沉迷电脑技术的同学, 那个时候我想着做一个自己的网站, 肯定是非常牛逼的事了. 从最开始接触的服务, 依次来排个序. 永硕 E 盘 -&gt; 免费空间建站 (国外居多) -&gt; 虚拟空间 -&gt; 虚拟服务器 (VPS) -&gt; 独立服务器. 看完这篇文章后, 我总算对这方面知识有了一个比较系统性的认识了. 一起来学习一下.</p>\n<a id=\"more\"></a>\n<h3 id=\"引子\"><a href=\"#引子\" class=\"headerlink\" title=\"引子\"></a>引子</h3><p>文章开始之前, 我觉得还是有必要把这些专有名词先科普一下, 不要觉得很高大上, 简称而已.</p>\n<ul>\n<li>IaaS - 基础设施即服务</li>\n<li>PaaS - 平台即服务</li>\n<li>CaaS - 容器即服务</li>\n</ul>\n<p>本文介绍了 Web 托管服务进化的历史, 从专用服务器到虚拟化到 IaaS、PaaS 和最新的 CaaS; 说明了每种方式的优点和缺点. 着重阐述了构建 PaaS 应用的各个组件, 以及在选择 CaaS 提供商时应该考虑的问题. 最后从成本和功能性的角度论述了 PaaS 用户应该迁移到 CaaS 平台.</p>\n<p>读完这篇博文, 你应该可以清楚的理解:</p>\n<ul>\n<li>这些名词到底指什么</li>\n<li>这为什么对你很重要</li>\n<li>对于你的使用场景，哪种方式最适合</li>\n</ul>\n<p>当然没有一种方式能够适合所有的 Web 基础设施的场景, 你的特殊场景或许需要特殊的考虑.</p>\n<h3 id=\"从头开始——专用服务器\"><a href=\"#从头开始——专用服务器\" class=\"headerlink\" title=\"从头开始——专用服务器\"></a>从头开始——专用服务器</h3><p>Web 托管的本质还是在一个数据中心里布满了服务器、交换机、路由器、存储阵列和其它网络组件. 我们所讨论的每一个选项不管它是 PaaS、IaaS 还是 CaaS, 它底层使用的基础设施都是相同的, 即在一个大屋子里的很多独立服务器. 他们只是上面增加了很多抽象层使得管理变得更简单, 和使用自动化的方式处理以前很慢或者需要手动步骤的任务.</p>\n<p>专用服务器, 或者叫做 “裸机” 有它的优点和缺点.</p>\n<h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><ul>\n<li>性能——你在直接使用一个服务器, 没有任何抽象层例如虚拟化带来的性能开销.</li>\n<li>可靠性——没有抽象层和虚拟化, 出错的可能性会降低.</li>\n<li>资源利用率——使用专用服务器, 你的进程不需要跟其它的虚拟机或者进程竞争资源例如 CPU、内存和带宽.</li>\n</ul>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><ul>\n<li>管理复杂性——你无法容易地克隆专用服务器来产生更多的实例, 专用服务器没有 AMI（译者注: Amazon Machine Image）或者镜像的概念. 想扩展你的基础设施到多个服务器上？我希望你用配置管理, 或者使用可信赖的老朋友 rsync.</li>\n<li>成本——使用专用服务器, 在大多数情况下你需要预先支付服务器的硬件价格, 然后再付租用场地的成本, 或者你从一个服务提供商那里租赁它们. 无论哪种方式, 你都没法在不使用时终止服务器的租赁来节省成本, 因此你需要更加谨慎的对待你的财务计划.</li>\n<li>你所有的进程和应用都运行在专用服务器上, 因此运行在相同的操作系统上. 为了可扩展性的目的, 你往往希望服务器只运行单一的进程, 例如 Web 服务或者数据库服务. 在一个服务器上运行所有的应用使得操作系统的调优变得更困难.</li>\n</ul>\n<h3 id=\"使事情变得更容易——虚拟化\"><a href=\"#使事情变得更容易——虚拟化\" class=\"headerlink\" title=\"使事情变得更容易——虚拟化\"></a>使事情变得更容易——虚拟化</h3><p>尽管专用服务器有很多优点, 但是它的缺点在大多数情况下会远远超过其优点. 公司为了能够迅速进入市场赢得竞争, 对于部署的速度提出了更高的要求, 虚拟化就很自然的成为了数据中心进化中的下一个步骤.</p>\n<h4 id=\"什么是虚拟化\"><a href=\"#什么是虚拟化\" class=\"headerlink\" title=\"什么是虚拟化\"></a>什么是虚拟化</h4><p>简而言之, 虚拟化就是将物理服务器分成更小的虚拟机, 这些虚拟机只能访问物理机的部分资源. 例如你有一个 8CPU 核以及 16GB 内存的物理服务器, 则可以将它分成 8 个虚拟机, 每个虚拟机有 1 个 CPU 和 2GB 内存. 你或许已经听说过一些虚拟化技术如 Xen, KVM, VMware 和 Hyper-V, 其实很有更多.</p>\n<h4 id=\"优点-1\"><a href=\"#优点-1\" class=\"headerlink\" title=\"优点\"></a>优点</h4><ul>\n<li>你可以在需要更多虚拟机实例或者想要虚拟机共享时进行虚拟机的克隆.</li>\n<li>你可以备份虚拟机镜像作为安全保护或者灾备.</li>\n</ul>\n<h4 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><ul>\n<li>使用虚拟化意味着额外的性能开销, 可能造成性能下降.</li>\n<li>虚拟机镜像在不同的服务提供商和虚拟化技术之间基本上是不可移植的.</li>\n<li>管理虚拟机依然是手工步骤, 需要管理的时间和专业知识.</li>\n</ul>\n<h3 id=\"进化——虚拟化变成-IaaS\"><a href=\"#进化——虚拟化变成-IaaS\" class=\"headerlink\" title=\"进化——虚拟化变成 IaaS\"></a>进化——虚拟化变成 IaaS</h3><p>你知道 <a href=\"http://www.businessinsider.com/people-think-stormy-weather-affects-cloud-computing-2012-8\" target=\"_blank\" rel=\"noopener\">51% 的人认为 “云” 会被天气影响吗</a>？你知道当人们谈论 “云” 时他们实际上是在讨论基础设施即服务 (IaaS) 吗？</p>\n<h4 id=\"什么是基础设施即服务-IaaS\"><a href=\"#什么是基础设施即服务-IaaS\" class=\"headerlink\" title=\"什么是基础设施即服务 (IaaS)\"></a>什么是基础设施即服务 (IaaS)</h4><ul>\n<li>通过 API 来管理硬件的虚拟化.</li>\n<li>通过编程接口访问计算、存储和网络资源和配置.</li>\n<li>当你需要是申请一个新的虚拟机, 当你完成后终止虚拟机, 你只需要为你使用的资源付费.</li>\n<li>将数据中心资源视为公共设施.</li>\n</ul>\n<p>亚马逊在 2006 年发布了其 Amazon Web Services（AWS）和 EC2 产品，成为了这个领域的先驱。</p>\n<h4 id=\"为什么这个进化如此重要\"><a href=\"#为什么这个进化如此重要\" class=\"headerlink\" title=\"为什么这个进化如此重要\"></a>为什么这个进化如此重要</h4><p>在过去当你需要上线一个在线业务时, 你不得不进行复杂的计划来保证你在数据中心内有足够的机架空间、足够的服务器和存储来处理业务的增长, 足够的网络带宽来处理所有的用户流量. 这种计划并不容易, 尤其是对早期的业务来讲, 你无法预测业务的未来和增长轨迹.</p>\n<ol>\n<li>它给了开发者超能量:<ul>\n<li>构思一个想法立即上线.</li>\n<li>如果成功了, 可以容易的扩展规模.</li>\n<li>如果失败了, 关闭虚拟机以节约成本.</li>\n</ul>\n</li>\n<li>它使得数据中心自动化变得更强大:<ul>\n<li>全自动基础设施管理成为可能, 出现了 “基础设施即代码” 的概念.</li>\n<li>弹性伸缩在过去是不可能实现的, 但是现在 web 基础设施可以当业务变化时自动的扩展或者收缩.</li>\n<li>在服务器的自动化管理之后, 数据中心的自动化也扩展到了存储、网络以及其它大量的需要专业知识的系统, 在代码和 API 能够处理这些自动化之后, 这给全球的开发者社区带来了新的机遇.</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"进一步演化——平台即服务-PaaS\"><a href=\"#进一步演化——平台即服务-PaaS\" class=\"headerlink\" title=\"进一步演化——平台即服务 (PaaS)\"></a>进一步演化——平台即服务 (PaaS)</h3><p>平台即服务 (PaaS) 使得开发人员可以很容易的部署和管理应用而隐藏掉所有的实现细节例如服务器、负载均衡器、DNS 等等. 他们或多或少的去除了对运维团队的需求, 而是让开发人员去关注应用部署. 有很多 PaaS 提供商, 其中一个最流行的是 Heroku. 关于 Heroku 的一个有趣的事情是 Heroku 完全是运行在 AWS 之上并依赖 AWS 的. 如果你不愿意你的应用运行在美国东部或者欧洲西部的 AWS 上的话, 这或许是一个问题. 没有 IaaS, 像 Heroku 这样的平台可能就不会存在了. PaaS 提供商利用 IaaS 作为一个非常重要的组成部分来交付它们的服务. 在减少从想法到部署的时间、自动化流程以及减少特殊的系统知识需求的趋势中, PaaS 是合理的下一步, 就像是从专用服务器到 IaaS 一样.</p>\n<h4 id=\"构建-PaaS-是困难的\"><a href=\"#构建-PaaS-是困难的\" class=\"headerlink\" title=\"构建 PaaS 是困难的\"></a>构建 PaaS 是困难的</h4><p>能够通过抽象而避免处理服务器相关的问题是不容易的, 需要引入很多东西才能做到.</p>\n<p>在 PaaS 的概念之下有几个主要的模块：</p>\n<ul>\n<li>编译系统——把你的代码编译成可以运行的应用, 并且把它存储到某个地方作为后续使用.</li>\n<li>应用管理数据库——管理 Git 版本、build 版本和应用元数据.</li>\n<li>集群调度器——将一组服务器作为一台大的服务器来管理, 在服务器资源池的某个服务器上运行你的程序, 并检查和替换失效的作业.</li>\n<li>负载均衡——允许从 Internet 和内部程序来的业务负载被正确的路由到合适的位置.</li>\n<li>DNS——在你产生和修改应用时自动配置 DNS 条目.</li>\n<li>或许是最重要的——某个形式的容器化例如  freebsd jails、solaris zones、或者 linux containers, 容器化使得某个的应用不会进入和影响到其它的应用.</li>\n</ul>\n<p>第一个和最后一个点是 Docker 迅速发展的非常重要的原因. Linux 容器技术已经存在了一段时间了, 但是只有某些大的公司或者 PaaS 提供商自动化了容器的使用, Docker 使 Linux 容器的使用变得非常简单, 也提供了标准化的镜像格式, 它成为了 PaaS 中重要的组成部分.</p>\n<p>这非常强大, 因为很多公司在处理爆发式的用户增长, 来自于移动、社交和 IoT 的新的业务模式, 以及期望从传统的长的版本发布周期转变到持续交付. 他们利用基于软件的架构或者微服务. 他们需要能够自动部署和测试新的代码, 并根据业务的变化弹性伸缩. 但问题是他们没有足够的资源和经验来交付到他们的开发团队, 所以他们不得不将其外包给 PaaS 提供商. 不幸的是, 当你这么做的时候, 你就放弃了对于这个黑盒子的很多控制, 而是花很多钱并使得自己完全依赖于它. 另外一个选项是, 很多公司反复的重新发明轮子或者使用那些难于维护的、运行缓慢的和易于出错的工具.</p>\n<p>最好的情形是在自己的数据中心或者 Cloud 帐号中运行一个 PaaS 平台, 你可以全权控制, 你的团队可以直接参与应用的部署, 因此可以形成一种真正的 DevOps 文化. Docker 及其标准化的生态系统是这种愿景成为现实的重要一步.</p>\n<h3 id=\"最后——容器托管平台-CaaS\"><a href=\"#最后——容器托管平台-CaaS\" class=\"headerlink\" title=\"最后——容器托管平台 (CaaS)\"></a>最后——容器托管平台 (CaaS)</h3><p>什么是容器托管平台, 或者叫容器即服务呢？这就是我在上面的章节中提到的另外一种构建在 Docker 基础上的 Web 托管方式. 它是你用容器来部署复杂的多层次的应用所需要的自动化的编译系统, 集群调度器, 负载均衡, DNS 自动化以及服务发现. 这是 PaaS 的另外一部分内容, 但是你不是用一个复杂的编译系统来编译你的应用, 而是用 Docker 镜像. 镜像可以非常容易的进行编译和本地测试, 因此你在部署应用之前就确认应用可以正常工作. 现在 PaaS 用户也可以得到相同的体验, 但是不需要拥有自己的硬件或者云帐号的前提下节约大量的成本. 他们不再受限于其服务提供商所支持的环境, 可以通过将应用打包成 Docker 镜像的方式在任何地方运行.</p>\n<p>在这个过程中, 利用诸如 ContainerShip Cloud, 你可以在任何地方, 在任何云平台上甚至是裸机上用相同的方式运行你的应用. 你不再被卡在构建复杂的应用来解决非常困难的问题, 或者卡在使用某个提供商的特殊的自动化部署工具上.</p>\n<ul>\n<li>但是选择一个正确的 Docker 容器托管平台并不是一件容易的事情, 有很多的问题需要你去思考和注意.</li>\n<li>有大量的选项, 因此选择其中一个进行研究就变得困难. 好消息是如果你的应用已经容器化, 你就可以轻松的测试其中的每一个.</li>\n<li>你正在使用的服务提供商例如 Triton 或者 ECS 的某个解决方案或许使得你无法脱离这个提供商, 这也使得 Docker 的最令人兴奋的可移植性变得不那么重要了.</li>\n<li>许多 CaaS 方案在他们自己的硬件上运行所有的管理系统, 你自己的服务器上只是运行某个代理程序来连接他们的 API, 因此如果他们的系统宕机后你的集群将无法工作.</li>\n<li>允许你在防火墙后运行整个系统的方案是非常复杂的, 需要一个团队去管理和升级.</li>\n<li>能够容易的在防火墙后运行整个系统的方案会使得高可用成为低优先级的事情.</li>\n<li>当你选择了一个 CaaS 提供商时, 你就可以摆脱了你的服务托管提供商的锁定, 但是你将陷入到 CaaS 提供商的锁定. 你无法不使用他们的 SaaS 管理接口而在你自己的硬件上运行整个系统包括管理系统, API 和 UI. 你一旦决定付钱, 你最好可以一直付钱.</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>终于看完了, 真的是又臭又长啊. 回顾一下这篇文章, 总体来说是经历了这样一个过程:</p>\n<ol>\n<li>专有服务器</li>\n<li>虚拟化技术</li>\n<li>基础设施即服务 (IaaS)</li>\n<li>平台即服务 (PaaS)</li>\n<li>容器即服务 (CaaS)</li>\n</ol>\n<p>总结一下, 我觉得开发人员还是有必要了解一下关于产品部署相关的技术发展. 然后根据自己的业务来选择合适的服务提供商.</p>\n","site":{"data":{}},"excerpt":"<p>这篇文章是来拓展自己知识面的, 在我读高中那会 (08 年), 我身边就有沉迷电脑技术的同学, 那个时候我想着做一个自己的网站, 肯定是非常牛逼的事了. 从最开始接触的服务, 依次来排个序. 永硕 E 盘 -&gt; 免费空间建站 (国外居多) -&gt; 虚拟空间 -&gt; 虚拟服务器 (VPS) -&gt; 独立服务器. 看完这篇文章后, 我总算对这方面知识有了一个比较系统性的认识了. 一起来学习一下.</p>","more":"<h3 id=\"引子\"><a href=\"#引子\" class=\"headerlink\" title=\"引子\"></a>引子</h3><p>文章开始之前, 我觉得还是有必要把这些专有名词先科普一下, 不要觉得很高大上, 简称而已.</p>\n<ul>\n<li>IaaS - 基础设施即服务</li>\n<li>PaaS - 平台即服务</li>\n<li>CaaS - 容器即服务</li>\n</ul>\n<p>本文介绍了 Web 托管服务进化的历史, 从专用服务器到虚拟化到 IaaS、PaaS 和最新的 CaaS; 说明了每种方式的优点和缺点. 着重阐述了构建 PaaS 应用的各个组件, 以及在选择 CaaS 提供商时应该考虑的问题. 最后从成本和功能性的角度论述了 PaaS 用户应该迁移到 CaaS 平台.</p>\n<p>读完这篇博文, 你应该可以清楚的理解:</p>\n<ul>\n<li>这些名词到底指什么</li>\n<li>这为什么对你很重要</li>\n<li>对于你的使用场景，哪种方式最适合</li>\n</ul>\n<p>当然没有一种方式能够适合所有的 Web 基础设施的场景, 你的特殊场景或许需要特殊的考虑.</p>\n<h3 id=\"从头开始——专用服务器\"><a href=\"#从头开始——专用服务器\" class=\"headerlink\" title=\"从头开始——专用服务器\"></a>从头开始——专用服务器</h3><p>Web 托管的本质还是在一个数据中心里布满了服务器、交换机、路由器、存储阵列和其它网络组件. 我们所讨论的每一个选项不管它是 PaaS、IaaS 还是 CaaS, 它底层使用的基础设施都是相同的, 即在一个大屋子里的很多独立服务器. 他们只是上面增加了很多抽象层使得管理变得更简单, 和使用自动化的方式处理以前很慢或者需要手动步骤的任务.</p>\n<p>专用服务器, 或者叫做 “裸机” 有它的优点和缺点.</p>\n<h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><ul>\n<li>性能——你在直接使用一个服务器, 没有任何抽象层例如虚拟化带来的性能开销.</li>\n<li>可靠性——没有抽象层和虚拟化, 出错的可能性会降低.</li>\n<li>资源利用率——使用专用服务器, 你的进程不需要跟其它的虚拟机或者进程竞争资源例如 CPU、内存和带宽.</li>\n</ul>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><ul>\n<li>管理复杂性——你无法容易地克隆专用服务器来产生更多的实例, 专用服务器没有 AMI（译者注: Amazon Machine Image）或者镜像的概念. 想扩展你的基础设施到多个服务器上？我希望你用配置管理, 或者使用可信赖的老朋友 rsync.</li>\n<li>成本——使用专用服务器, 在大多数情况下你需要预先支付服务器的硬件价格, 然后再付租用场地的成本, 或者你从一个服务提供商那里租赁它们. 无论哪种方式, 你都没法在不使用时终止服务器的租赁来节省成本, 因此你需要更加谨慎的对待你的财务计划.</li>\n<li>你所有的进程和应用都运行在专用服务器上, 因此运行在相同的操作系统上. 为了可扩展性的目的, 你往往希望服务器只运行单一的进程, 例如 Web 服务或者数据库服务. 在一个服务器上运行所有的应用使得操作系统的调优变得更困难.</li>\n</ul>\n<h3 id=\"使事情变得更容易——虚拟化\"><a href=\"#使事情变得更容易——虚拟化\" class=\"headerlink\" title=\"使事情变得更容易——虚拟化\"></a>使事情变得更容易——虚拟化</h3><p>尽管专用服务器有很多优点, 但是它的缺点在大多数情况下会远远超过其优点. 公司为了能够迅速进入市场赢得竞争, 对于部署的速度提出了更高的要求, 虚拟化就很自然的成为了数据中心进化中的下一个步骤.</p>\n<h4 id=\"什么是虚拟化\"><a href=\"#什么是虚拟化\" class=\"headerlink\" title=\"什么是虚拟化\"></a>什么是虚拟化</h4><p>简而言之, 虚拟化就是将物理服务器分成更小的虚拟机, 这些虚拟机只能访问物理机的部分资源. 例如你有一个 8CPU 核以及 16GB 内存的物理服务器, 则可以将它分成 8 个虚拟机, 每个虚拟机有 1 个 CPU 和 2GB 内存. 你或许已经听说过一些虚拟化技术如 Xen, KVM, VMware 和 Hyper-V, 其实很有更多.</p>\n<h4 id=\"优点-1\"><a href=\"#优点-1\" class=\"headerlink\" title=\"优点\"></a>优点</h4><ul>\n<li>你可以在需要更多虚拟机实例或者想要虚拟机共享时进行虚拟机的克隆.</li>\n<li>你可以备份虚拟机镜像作为安全保护或者灾备.</li>\n</ul>\n<h4 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><ul>\n<li>使用虚拟化意味着额外的性能开销, 可能造成性能下降.</li>\n<li>虚拟机镜像在不同的服务提供商和虚拟化技术之间基本上是不可移植的.</li>\n<li>管理虚拟机依然是手工步骤, 需要管理的时间和专业知识.</li>\n</ul>\n<h3 id=\"进化——虚拟化变成-IaaS\"><a href=\"#进化——虚拟化变成-IaaS\" class=\"headerlink\" title=\"进化——虚拟化变成 IaaS\"></a>进化——虚拟化变成 IaaS</h3><p>你知道 <a href=\"http://www.businessinsider.com/people-think-stormy-weather-affects-cloud-computing-2012-8\" target=\"_blank\" rel=\"noopener\">51% 的人认为 “云” 会被天气影响吗</a>？你知道当人们谈论 “云” 时他们实际上是在讨论基础设施即服务 (IaaS) 吗？</p>\n<h4 id=\"什么是基础设施即服务-IaaS\"><a href=\"#什么是基础设施即服务-IaaS\" class=\"headerlink\" title=\"什么是基础设施即服务 (IaaS)\"></a>什么是基础设施即服务 (IaaS)</h4><ul>\n<li>通过 API 来管理硬件的虚拟化.</li>\n<li>通过编程接口访问计算、存储和网络资源和配置.</li>\n<li>当你需要是申请一个新的虚拟机, 当你完成后终止虚拟机, 你只需要为你使用的资源付费.</li>\n<li>将数据中心资源视为公共设施.</li>\n</ul>\n<p>亚马逊在 2006 年发布了其 Amazon Web Services（AWS）和 EC2 产品，成为了这个领域的先驱。</p>\n<h4 id=\"为什么这个进化如此重要\"><a href=\"#为什么这个进化如此重要\" class=\"headerlink\" title=\"为什么这个进化如此重要\"></a>为什么这个进化如此重要</h4><p>在过去当你需要上线一个在线业务时, 你不得不进行复杂的计划来保证你在数据中心内有足够的机架空间、足够的服务器和存储来处理业务的增长, 足够的网络带宽来处理所有的用户流量. 这种计划并不容易, 尤其是对早期的业务来讲, 你无法预测业务的未来和增长轨迹.</p>\n<ol>\n<li>它给了开发者超能量:<ul>\n<li>构思一个想法立即上线.</li>\n<li>如果成功了, 可以容易的扩展规模.</li>\n<li>如果失败了, 关闭虚拟机以节约成本.</li>\n</ul>\n</li>\n<li>它使得数据中心自动化变得更强大:<ul>\n<li>全自动基础设施管理成为可能, 出现了 “基础设施即代码” 的概念.</li>\n<li>弹性伸缩在过去是不可能实现的, 但是现在 web 基础设施可以当业务变化时自动的扩展或者收缩.</li>\n<li>在服务器的自动化管理之后, 数据中心的自动化也扩展到了存储、网络以及其它大量的需要专业知识的系统, 在代码和 API 能够处理这些自动化之后, 这给全球的开发者社区带来了新的机遇.</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"进一步演化——平台即服务-PaaS\"><a href=\"#进一步演化——平台即服务-PaaS\" class=\"headerlink\" title=\"进一步演化——平台即服务 (PaaS)\"></a>进一步演化——平台即服务 (PaaS)</h3><p>平台即服务 (PaaS) 使得开发人员可以很容易的部署和管理应用而隐藏掉所有的实现细节例如服务器、负载均衡器、DNS 等等. 他们或多或少的去除了对运维团队的需求, 而是让开发人员去关注应用部署. 有很多 PaaS 提供商, 其中一个最流行的是 Heroku. 关于 Heroku 的一个有趣的事情是 Heroku 完全是运行在 AWS 之上并依赖 AWS 的. 如果你不愿意你的应用运行在美国东部或者欧洲西部的 AWS 上的话, 这或许是一个问题. 没有 IaaS, 像 Heroku 这样的平台可能就不会存在了. PaaS 提供商利用 IaaS 作为一个非常重要的组成部分来交付它们的服务. 在减少从想法到部署的时间、自动化流程以及减少特殊的系统知识需求的趋势中, PaaS 是合理的下一步, 就像是从专用服务器到 IaaS 一样.</p>\n<h4 id=\"构建-PaaS-是困难的\"><a href=\"#构建-PaaS-是困难的\" class=\"headerlink\" title=\"构建 PaaS 是困难的\"></a>构建 PaaS 是困难的</h4><p>能够通过抽象而避免处理服务器相关的问题是不容易的, 需要引入很多东西才能做到.</p>\n<p>在 PaaS 的概念之下有几个主要的模块：</p>\n<ul>\n<li>编译系统——把你的代码编译成可以运行的应用, 并且把它存储到某个地方作为后续使用.</li>\n<li>应用管理数据库——管理 Git 版本、build 版本和应用元数据.</li>\n<li>集群调度器——将一组服务器作为一台大的服务器来管理, 在服务器资源池的某个服务器上运行你的程序, 并检查和替换失效的作业.</li>\n<li>负载均衡——允许从 Internet 和内部程序来的业务负载被正确的路由到合适的位置.</li>\n<li>DNS——在你产生和修改应用时自动配置 DNS 条目.</li>\n<li>或许是最重要的——某个形式的容器化例如  freebsd jails、solaris zones、或者 linux containers, 容器化使得某个的应用不会进入和影响到其它的应用.</li>\n</ul>\n<p>第一个和最后一个点是 Docker 迅速发展的非常重要的原因. Linux 容器技术已经存在了一段时间了, 但是只有某些大的公司或者 PaaS 提供商自动化了容器的使用, Docker 使 Linux 容器的使用变得非常简单, 也提供了标准化的镜像格式, 它成为了 PaaS 中重要的组成部分.</p>\n<p>这非常强大, 因为很多公司在处理爆发式的用户增长, 来自于移动、社交和 IoT 的新的业务模式, 以及期望从传统的长的版本发布周期转变到持续交付. 他们利用基于软件的架构或者微服务. 他们需要能够自动部署和测试新的代码, 并根据业务的变化弹性伸缩. 但问题是他们没有足够的资源和经验来交付到他们的开发团队, 所以他们不得不将其外包给 PaaS 提供商. 不幸的是, 当你这么做的时候, 你就放弃了对于这个黑盒子的很多控制, 而是花很多钱并使得自己完全依赖于它. 另外一个选项是, 很多公司反复的重新发明轮子或者使用那些难于维护的、运行缓慢的和易于出错的工具.</p>\n<p>最好的情形是在自己的数据中心或者 Cloud 帐号中运行一个 PaaS 平台, 你可以全权控制, 你的团队可以直接参与应用的部署, 因此可以形成一种真正的 DevOps 文化. Docker 及其标准化的生态系统是这种愿景成为现实的重要一步.</p>\n<h3 id=\"最后——容器托管平台-CaaS\"><a href=\"#最后——容器托管平台-CaaS\" class=\"headerlink\" title=\"最后——容器托管平台 (CaaS)\"></a>最后——容器托管平台 (CaaS)</h3><p>什么是容器托管平台, 或者叫容器即服务呢？这就是我在上面的章节中提到的另外一种构建在 Docker 基础上的 Web 托管方式. 它是你用容器来部署复杂的多层次的应用所需要的自动化的编译系统, 集群调度器, 负载均衡, DNS 自动化以及服务发现. 这是 PaaS 的另外一部分内容, 但是你不是用一个复杂的编译系统来编译你的应用, 而是用 Docker 镜像. 镜像可以非常容易的进行编译和本地测试, 因此你在部署应用之前就确认应用可以正常工作. 现在 PaaS 用户也可以得到相同的体验, 但是不需要拥有自己的硬件或者云帐号的前提下节约大量的成本. 他们不再受限于其服务提供商所支持的环境, 可以通过将应用打包成 Docker 镜像的方式在任何地方运行.</p>\n<p>在这个过程中, 利用诸如 ContainerShip Cloud, 你可以在任何地方, 在任何云平台上甚至是裸机上用相同的方式运行你的应用. 你不再被卡在构建复杂的应用来解决非常困难的问题, 或者卡在使用某个提供商的特殊的自动化部署工具上.</p>\n<ul>\n<li>但是选择一个正确的 Docker 容器托管平台并不是一件容易的事情, 有很多的问题需要你去思考和注意.</li>\n<li>有大量的选项, 因此选择其中一个进行研究就变得困难. 好消息是如果你的应用已经容器化, 你就可以轻松的测试其中的每一个.</li>\n<li>你正在使用的服务提供商例如 Triton 或者 ECS 的某个解决方案或许使得你无法脱离这个提供商, 这也使得 Docker 的最令人兴奋的可移植性变得不那么重要了.</li>\n<li>许多 CaaS 方案在他们自己的硬件上运行所有的管理系统, 你自己的服务器上只是运行某个代理程序来连接他们的 API, 因此如果他们的系统宕机后你的集群将无法工作.</li>\n<li>允许你在防火墙后运行整个系统的方案是非常复杂的, 需要一个团队去管理和升级.</li>\n<li>能够容易的在防火墙后运行整个系统的方案会使得高可用成为低优先级的事情.</li>\n<li>当你选择了一个 CaaS 提供商时, 你就可以摆脱了你的服务托管提供商的锁定, 但是你将陷入到 CaaS 提供商的锁定. 你无法不使用他们的 SaaS 管理接口而在你自己的硬件上运行整个系统包括管理系统, API 和 UI. 你一旦决定付钱, 你最好可以一直付钱.</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>终于看完了, 真的是又臭又长啊. 回顾一下这篇文章, 总体来说是经历了这样一个过程:</p>\n<ol>\n<li>专有服务器</li>\n<li>虚拟化技术</li>\n<li>基础设施即服务 (IaaS)</li>\n<li>平台即服务 (PaaS)</li>\n<li>容器即服务 (CaaS)</li>\n</ol>\n<p>总结一下, 我觉得开发人员还是有必要了解一下关于产品部署相关的技术发展. 然后根据自己的业务来选择合适的服务提供商.</p>"},{"title":"Webpack 4 定制前端开发环境","comments":1,"date":"2018-09-11T14:16:37.000Z","from":null,"_content":"\n本文总结了 Webpack 4 的一些配置点，希望通过学习这些配置点，降低使用门槛。纵观前端的打包历史，似乎是欠了太多债，有很多历史包袱，所以工程化这一块一直是一大痛点。配置繁琐，容易出错，本文总结了最新的 Webpack 4 功能点，一起来学习一下，可以点击右侧的文章目录直达。\n\n<!-- more -->\n\n### webpack 概念和基础使用\n\n#### 安装和使用\n\n```bash\n# 安装 webpack\n$ npm install webpack webpack-cli -g\n\n# or\n$ yarn global add webpack webpack-cli\n\n# 然后就可以全局执行命令了\n$ webpack --help\n```\n\n#### webpack 的基本概念\n\n> webpack 本质上是一个打包工具，它会根据代码的内容解析模块依赖，帮助我们把多个模块的代码打包\n\n![image](https://user-images.githubusercontent.com/15377484/59234564-f1cb0600-8c1f-11e9-8bdf-c6041410225a.png)\n\n> webpack 会把我们项目中使用到的多个代码模块（可以是不同文件类型），打包构建成项目运行仅需要的几个静态文件\n\n**入口（entry）**\n\n> 入口可以使用 `entry` 字段来进行配置，`webpack` 支持配置多个入口来进行构建\n\n```js\nmodule.exports = {\n  entry: './src/index.js'\n};\n\n// 上述配置等同于\nmodule.exports = {\n  entry: {\n    main: './src/index.js'\n  }\n};\n\n// 或者配置多个入口\nmodule.exports = {\n  entry: {\n    foo: './src/page-foo.js',\n    bar: './src/page-bar.js'\n    // ...\n  }\n};\n\n// 使用数组来对多个文件进行打包\nmodule.exports = {\n  entry: {\n    main: ['./src/foo.js', './src/bar.js']\n  }\n};\n```\n\n**转换器（loader）**\n\n> 可以把 `loader` 理解为是一个转换器，负责把某种文件格式的内容转换成 webpack 可以支持打包的模块\n\n- 当我们需要使用不同的 `loader` 来解析处理不同类型的文件时，我们可以在 `module.rules` 字段下来配置相关的规则，例如使用 `Babel` 来处理 `.js` 文件\n\n```js\nmodule: {\n  // ...\n  rules: [\n    {\n      test: /\\.jsx?/, // 匹配文件路径的正则表达式，通常我们都是匹配文件类型后缀\n      include: [\n        path.resolve(__dirname, 'src') // 指定哪些路径下的文件需要经过 loader 处理\n      ],\n      use: 'babel-loader', // 指定使用的 loader\n    },\n  ],\n}\n```\n\n**插件（plugin）**\n\n> 模块代码转换的工作由 `loader` 来处理，除此之外的其他任何工作都可以交由 `plugin` 来完成。通过添加我们需要的 `plugin`，可以满足更多构建中特殊的需求。例如，要使用压缩 `JS` 代码的 `uglifyjs-webpack-plugin` 插件，只需在配置中通过 `plugins` 字段添加新的 `plugin` 即可...\n\n```js\nconst UglifyPlugin = require('uglifyjs-webpack-plugin');\n\nmodule.exports = {\n  plugins: [new UglifyPlugin()]\n};\n```\n\n> `plugin` 理论上可以干涉 `webpack` 整个构建流程，可以在流程的每一个步骤中定制自己的构建需求\n\n**输出（output）**\n\n> 构建结果的文件名、路径等都是可以配置的，使用 `output` 字段\n\n```js\nmodule.exports = {\n  // ...\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'bundle.js'\n  }\n};\n\n// 或者多个入口生成不同文件\nmodule.exports = {\n  entry: {\n    foo: './src/foo.js',\n    bar: './src/bar.js'\n  },\n  output: {\n    filename: '[name].js',\n    path: __dirname + '/dist'\n  }\n};\n\n// 路径中使用 hash，每次构建时会有一个不同 hash 值，避免发布新版本时线上使用浏览器缓存\nmodule.exports = {\n  // ...\n  output: {\n    filename: '[name].js',\n    path: __dirname + '/dist/[hash]'\n  }\n};\n```\n\n> 我们一开始直接使用 `webpack` 构建时，默认创建的输出内容就是 `./dist/main.js`\n\n**一个简单的 webpack 配置**\n\n> 我们把上述涉及的几部分配置内容合到一起，就可以创建一个简单的 `webpack` 配置了，`webpack` 运行时默认读取项目下的 `webpack.config.js` 文件作为配置。所以我们在项目中创建一个 `webpack.config.js` 文件\n\n```js\nconst path = require('path');\nconst UglifyPlugin = require('uglifyjs-webpack-plugin');\n\nmodule.exports = {\n  entry: './src/index.js',\n\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'bundle.js'\n  },\n\n  module: {\n    rules: [\n      {\n        test: /\\.jsx?/,\n        include: [path.resolve(__dirname, 'src')],\n        use: 'babel-loader'\n      }\n    ]\n  },\n\n  // 代码模块路径解析的配置\n  resolve: {\n    modules: ['node_modules', path.resolve(__dirname, 'src')],\n\n    extensions: ['.wasm', '.mjs', '.js', '.json', '.jsx']\n  },\n\n  plugins: [\n    new UglifyPlugin()\n    // 使用 uglifyjs-webpack-plugin 来压缩 JS 代码\n    // 如果你留意了我们一开始直接使用 webpack 构建的结果，你会发现默认已经使用了 JS 代码压缩的插件\n    // 这其实也是我们命令中的 --mode production 的效果，后续的小节会介绍 webpack 的 mode 参数\n  ]\n};\n```\n\n### 搭建基础的前端开发环境\n\n#### 关联 HTML\n\n> `webpack` 默认从作为入口的 `.js` 文件进行构建（更多是基于 `SPA` 去考虑），但通常一个前端项目都是从一个页面（即 HTML）出发的，最简单的方法是，创建一个 HTML 文件，使用 `script` 标签直接引用构建好的 JS 文件，如...\n\n```plain\n<script src=\"./dist/bundle.js\"></script>\n```\n\n- 但是，如果我们的文件名或者路径会变化，例如使用 `[hash]` 来进行命名，那么最好是将 `HTML` 引用路径和我们的构建结果关联起来，这个时候我们可以使用 `html-webpack-plugin`\n- `html-webpack-plugin` 是一个独立的 `node package`，所以在使用之前我们需要先安装它，把它安装到项目的开发依赖中\n\n```bash\nnpm install html-webpack-plugin -D\n```\n\n> 然后在 `webpack` 配置中，将 `html-webpack-plugin` 添加到 `plugins` 列表中\n\n```js\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  // ...\n  plugins: [new HtmlWebpackPlugin()]\n};\n```\n\n> 这样配置好之后，构建时 `html-webpack-plugin` 会为我们创建一个 `HTML` 文件，其中会引用构建出来的 JS 文件。实际项目中，默认创建的 `HTML` 文件并没有什么用，我们需要自己来写 `HTML` 文件，可以通过 `html-webpack-plugin` 的配置，传递一个写好的 HTML 模板...\n\n```js\nmodule.exports = {\n  // ...\n  plugins: [\n    new HtmlWebpackPlugin({\n      filename: 'index.html', // 配置输出文件名和路径\n      template: 'assets/index.html' // 配置文件模板\n    })\n  ]\n};\n```\n\n> 这样，通过 `html-webpack-plugin` 就可以将我们的页面和构建 `JS` 关联起来，回归日常，从页面开始开发。如果需要添加多个页面关联，那么实例化多个 `html-webpack-plugin`， 并将它们都放到 `plugins` 字段数组中就可以了...\n\n#### 构建 CSS\n\n> 我们编写 `CSS`，并且希望使用 `webpack` 来进行构建，为此，需要在配置中引入 `loader` 来解析和处理 `CSS` 文件\n\n```js\nmodule.exports = {\n  module: {\n    rules: [\n      // ...\n      {\n        test: /\\.css/,\n        include: [path.resolve(__dirname, 'src')],\n        use: ['style-loader', 'css-loader']\n      }\n    ]\n  }\n};\n```\n\n- `css-loader` 负责解析 `CSS` 代码，主要是为了处理 `CSS` 中的依赖，例如 `@import` 和 `url()` 等引用外部文件的声明；\n- `style-loader` 会将 `css-loader` 解析的结果转变成 `JS` 代码，运行时动态插入 `style` 标签来让 `CSS` 代码生效...\n\n> 经由上述两个 `loader` 的处理后，CSS 代码会转变为 JS，和 `index.js` 一起打包了。如果需要单独把 CSS 文件分离出来，我们需要使用 `extract-text-webpack-plugin` 插件\n\n```js\nconst ExtractTextPlugin = require('extract-text-webpack-plugin');\n\nmodule.exports = {\n  // ...\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        // 因为这个插件需要干涉模块转换的内容，所以需要使用它对应的 loader\n        use: ExtractTextPlugin.extract({\n          fallback: 'style-loader',\n          use: 'css-loader'\n        })\n      }\n    ]\n  },\n  plugins: [\n    // 引入插件，配置文件名，这里同样可以使用 [hash]\n    new ExtractTextPlugin('index.css')\n  ]\n};\n```\n\n#### CSS 预处理器\n\n> 在上述使用 CSS 的基础上，通常我们会使用 `Less/Sass` 等 CSS 预处理器，webpack 可以通过添加对应的 `loader` 来支持，以使用 `Less` 为例，我们可以在官方文档中找到对应的 `loader`\n\n```js\nmodule.exports = {\n  // ...\n  module: {\n    rules: [\n      {\n        test: /\\.less$/,\n        // 因为这个插件需要干涉模块转换的内容，所以需要使用它对应的 loader\n        use: ExtractTextPlugin.extract({\n          fallback: 'style-loader',\n          use: ['css-loader', 'less-loader']\n        })\n      }\n    ]\n  }\n  // ...\n};\n```\n\n#### 处理图片文件\n\n> 在前端项目的样式中总会使用到图片，虽然我们已经提到 `css-loader` 会解析样式中用 `url()` 引用的文件路径，但是图片对应的 `jpg/png/gif` 等文件格式，`webpack` 处理不了。是的，我们只要添加一个处理图片的 `loader` 配置就可以了，现有的 `file-loader` 就是个不错的选择...\n\n- `file-loader` 可以用于处理很多类型的文件，它的主要作用是直接输出文件，把构建后的文件路径返回。配置很简单，在 `rules` 中添加一个字段，增加图片类型文件的解析配置\n\n```js\nmodule.exports = {\n  // ...\n  module: {\n    rules: [\n      {\n        test: /\\.(png|jpg|gif)$/,\n        use: [\n          {\n            loader: 'file-loader',\n            options: {}\n          }\n        ]\n      }\n    ]\n  }\n};\n```\n\n#### 使用 Babel\n\n> `Babel` 是一个让我们能够使用 `ES` 新特性的 `JS` 编译工具，我们可以在 `webpack` 中配置 Babel，以便使用 `ES6`、`ES7` 标准来编写 `JS` 代码\n\n```js\nmodule.exports = {\n  // ...\n  module: {\n    rules: [\n      {\n        test: /\\.jsx?/, // 支持 js 和 jsx\n        include: [\n          path.resolve(__dirname, 'src') // src 目录下的才需要经过 babel-loader 处理\n        ],\n        loader: 'babel-loader'\n      }\n    ]\n  }\n};\n```\n\n#### 启动静态服务\n\n> 至此，我们完成了处理多种文件类型的 webpack 配置。我们可以使用 `webpack-dev-server` 在本地开启一个简单的静态服务来进行开发\n\n```js\n\"scripts\": {\n  \"build\": \"webpack --mode production\",\n  \"start\": \"webpack-dev-server --mode development\"\n}\n```\n\n> 尝试着运行 `npm start` 或者 `yarn start`，然后就可以访问 `http://localhost:8080/` 来查看你的页面了。默认是访问 `index.html`，如果是其他页面要注意访问的 URL 是否正确\n\n#### 完整示例代码\n\n```js\nconst path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\nconst ExtractTextPlugin = require('extract-text-webpack-plugin');\n\nmodule.exports = {\n  entry: './src/index.js',\n\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: '[name].js'\n  },\n\n  module: {\n    rules: [\n      {\n        test: /\\.jsx?/,\n        include: [path.resolve(__dirname, 'src')],\n        use: 'babel-loader'\n      },\n      {\n        test: /\\.less$/,\n        // 因为这个插件需要干涉模块转换的内容，所以需要使用它对应的 loader\n        use: ExtractTextPlugin.extract({\n          fallback: 'style-loader',\n          use: ['css-loader', 'less-loader']\n        })\n      },\n      {\n        test: /\\.(png|jpg|gif)$/,\n        use: [\n          {\n            loader: 'file-loader'\n          }\n        ]\n      }\n    ]\n  },\n\n  // 代码模块路径解析的配置\n  resolve: {\n    modules: ['node_modules', path.resolve(__dirname, 'src')],\n\n    extensions: ['.wasm', '.mjs', '.js', '.json', '.jsx']\n  },\n\n  plugins: [\n    new HtmlWebpackPlugin({\n      filename: 'index.html', // 配置输出文件名和路径\n      template: 'src/index.html' // 配置文件模板\n    }),\n    new ExtractTextPlugin('[name].css')\n  ]\n};\n```\n\n### webpack 如何解析代码模块路径\n\n> webpack 中有一个很关键的模块 `enhanced-resolve` 就是处理依赖模块路径的解析的，这个模块可以说是 Node.js 那一套模块路径解析的增强版本，有很多可以自定义的解析配置\n\n- 在 webpack 配置中，和模块路径解析相关的配置都在 `resolve` 字段下\n\n```js\nmodule.exports = {\n  resolve: {\n    // ...\n  }\n};\n```\n\n#### 常用的一些配置\n\n**resolve.alias**\n\n> 假设我们有个 `utils` 模块极其常用，经常编写相对路径很麻烦，希望可以直接 `import 'utils'` 来引用，那么我们可以配置某个模块的别名，如\n\n```js\nalias: {\n  utils: path.resolve(__dirname, 'src/utils'); // 这里使用 path.resolve 和 __dirname 来获取绝对路径\n}\n```\n\n> 上述的配置是模糊匹配，意味着只要模块路径中携带了 utils 就可以被替换掉，如：\n\n```plain\nimport 'utils/query.js' // 等同于 import '[项目绝对路径]/src/utils/query.js'\n```\n\n> 如果需要进行精确匹配可以使用：\n\n```js\nalias: {\n  utils$: path.resolve(__dirname, 'src/utils'); // 只会匹配 import 'utils'\n}\n```\n\n**resolve.extensions**\n\n```js\nextensions: ['.wasm', '.mjs', '.js', '.json', '.jsx'],\n// 这里的顺序代表匹配后缀的优先级，例如对于 index.js 和 index.jsx，会优先选择 index.js\n```\n\n> 这个配置的作用是和文件后缀名有关的, 这个配置可以定义在进行模块路径解析时，webpack 会尝试帮你补全那些后缀名来进行查找\n\n### 配置 loader\n\n#### loader 匹配规则\n\n> 当我们需要配置 `loader` 时，都是在 `module.rules` 中添加新的配置项，在该字段中，每一项被视为一条匹配使用 `loader` 的规则\n\n```js\nmodule.exports = {\n  // ...\n  module: {\n    rules: [\n      {\n        test: /\\.jsx?/, // 条件\n        include: [path.resolve(__dirname, 'src')], // 条件\n        use: 'babel-loader' // 规则应用结果\u000e\n      } // 一个 object 即一条规则\n      // ...\n    ]\n  }\n};\n```\n\n> `loader` 的匹配规则中有两个最关键的因素：一个是匹配条件，一个是匹配规则后的应用\n\n#### 规则条件配置\n\n> 大多数情况下，配置 `loader` 的匹配条件时，只要使用 `test` 字段就好了，很多时候都只需要匹配文件后缀名来决定使用什么 `loader`，但也不排除在某些特殊场景下，我们需要配置比较复杂的匹配条件。webpack 的规则提供了多种配置形式...\n\n- `{test: ...}` 匹配特定条件\n- `{include: ...}` 匹配特定路径\n- `{exclude: ...}` 排除特定路径\n- `{and: [...] }` 必须匹配数组中所有条件\n- `{or: [...] }` 匹配数组中任意一个条件\n- `{not: [...] }` 排除匹配数组中所有条件...\n\n> 上述的所谓条件的值可以是：\n\n- 字符串：必须以提供的字符串开始，所以是字符串的话，这里我们需要提供绝对路径\n- 正则表达式：调用正则的 `test` 方法来判断匹配\n- 函数：`(path) => boolean`，返回 `true` 表示匹配\n- 数组：至少包含一个条件的数组\n- 对象：匹配所有属性值的条件...\n\n```js\nrules: [\n  {\n    test: /\\.jsx?/, // 正则\n    include: [\n      path.resolve(__dirname, 'src'), // 字符串，注意是绝对路径\n    ], // 数组\n    // ...\n  },\n  {\n    test: {\n      js: /\\.js/,\n      jsx: /\\.jsx/,\n    }, // 对象，不建议使用\n    not: [\n      (value) => { /* ... */ return true; }, // 函数，通常需要高度自定义时才会使用\n    ],\n  },\n]\n```\n\n#### 使用 loader 配置\n\n> `module.rules` 的匹配规则最重要的还是用于配置 `loader`，我们可以使用 `use` 字段\n\n```js\nrules: [\n  {\n    test: /\\.less/,\n    use: [\n      'style-loader', // 直接使用字符串表示 loader\n      {\n        loader: 'css-loader',\n        options: {\n          importLoaders: 1\n        },\n      }, // 用对象表示 loader，可以传递 loader 配置等\n      {\n        loader: 'less-loader',\n        options: {\n          noIeCompat: true\n        }, // 传递 loader 配置\n      },\n    ],\n  },\n]\n```\n\n> `use` 字段可以是一个数组，也可以是一个字符串或者表示 `loader` 的对象。如果只需要一个 `loader`，也可以这样：`use: {loader: 'babel-loader'`, `options: { ...} }`\n\n#### loader 应用顺序\n\n- 对于上面的 `less` 规则配置，一个 `style.less` 文件会途径 `less-loader`、`css-loader`、`style-loader` 处理，成为一个可以打包的模块。\n- `loader` 的应用顺序在配置多个 `loader` 一起工作时很重要，通常会使用在 CSS 配置上，除了 `style-loader` 和 `css-loader`，你可能还要配置 `less-loader` 然后再加个 `postcss` 的 `autoprefixer` 等。\n- 上述从后到前的顺序是在同一个 `rule` 中进行的，那如果多个 `rule` 匹配了同一个模块文件，`loader` 的应用顺序又是怎样的呢？看一份这样的配置...\n\n```js\nrules: [\n  {\n    test: /\\.js$/,\n    exclude: /node_modules/,\n    loader: \"eslint-loader\",\n  },\n  {\n    test: /\\.js$/,\n    exclude: /node_modules/,\n    loader: \"babel-loader\",\n  },\n]\n```\n\n> 这样无法法保证 `eslint-loader` 在 `babel-loader` 应用前执行。`webpack` 在 `rules` 中提供了一个 `enforce` 的字段来配置当前 `rule` 的 `loader` 类型，没配置的话是普通类型，我们可以配置 `pre` 或 `post`，分别对应前置类型或后置类型的 `loader`...\n\n- 所有的 `loader` 按照 **前置** -> **行内** -> **普通** -> **后置** 的顺序执行。所以当我们要确保 `eslint-loader` 在 `babel-loader` 之前执行时，可以如下添加 `enforce` 配置\n\n```js\nrules: [\n  {\n    enforce: 'pre', // 指定为前置类型\n    test: /\\.js$/,\n    exclude: /node_modules/,\n    loader: \"eslint-loader\",\n  },\n]\n```\n\n> 当项目文件类型和应用的 `loader` 不是特别复杂的时候，通常建议把要应用的同一类型 `loader` 都写在同一个匹配规则中，这样更好维护和控制\n\n#### 完整代码\n\n```js\nconst path = require('path');\nconst webpack = require('webpack');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\nconst ExtractTextPlugin = require('extract-text-webpack-plugin');\nconst CopyWebpackPlugin = require('copy-webpack-plugin');\n\nmodule.exports = {\n  entry: './src/index',\n\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: '[name].js'\n  },\n\n  module: {\n    rules: [\n      {\n        enforce: 'pre', // 指定为前置类型\n        test: /\\.jsx?$/,\n        exclude: /node_modules/,\n        loader: 'eslint-loader'\n      },\n      {\n        test: /\\.jsx?$/,\n        include: [path.resolve(__dirname, 'src')],\n        use: 'babel-loader'\n      },\n      {\n        test: /\\.css$/,\n        use: ExtractTextPlugin.extract({\n          fallback: 'style-loader',\n          use: ['css-loader']\n        })\n      },\n      {\n        test: /\\.less$/,\n        use: ExtractTextPlugin.extract({\n          fallback: 'style-loader',\n          use: ['css-loader', 'less-loader']\n        })\n      },\n      {\n        test: /\\.(png|jpg|gif)$/,\n        use: [\n          {\n            loader: 'file-loader'\n          }\n        ]\n      }\n    ]\n  },\n\n  resolve: {\n    alias: {\n      utils: path.resolve(__dirname, 'src/utils'), // 这里使用 path.resolve 和 __dirname 来获取绝对路径\n      log$: path.resolve(__dirname, 'src/utils/log.js') // 只匹配 log\n    },\n    extensions: ['.js', '.json', '.jsx', '.css', '.less'],\n    modules: [\n      path.resolve(__dirname, 'node_modules') // 指定当前目录下的 node_modules 优先查找\n    ]\n  },\n\n  plugins: [\n    new HtmlWebpackPlugin({\n      filename: 'index.html', // 配置输出文件名和路径\n      template: 'src/index.html' // 配置文件模板\n    }),\n    new ExtractTextPlugin('[name].css'),\n    new webpack.DefinePlugin({\n      TWO: '1+1',\n      CONSTANTS: {\n        APP_VERSION: JSON.stringify('1.1.2') // const CONSTANTS = { APP_VERSION: '1.1.2' }\n      }\n    }),\n    new CopyWebpackPlugin([\n      { from: 'src/assets/favicon.ico', to: 'favicon.ico' } // 顾名思义，from 配置来源，to 配置目标路径\n    ]),\n    new webpack.ProvidePlugin({\n      _: 'lodash'\n    })\n  ],\n\n  devServer: {\n    port: '1234',\n    before(app) {\n      app.get('/api/test.json', function(req, res) {\n        // 当访问 /some/path 路径时，返回自定义的 json 数据\n        res.json({ code: 200, message: 'hello world' });\n      });\n    }\n  }\n};\n```\n\n### 使用 plugin\n\n> 更多的插件可以在这里查找：[plugins in awesome-webpack](https://github.com/webpack-contrib/awesome-webpack#webpack-plugins)\n\n#### DefinePlugin\n\n> `DefinePlugin` 是 `webpack` 内置的插件，可以使用 `webpack.DefinePlugin` 直接获取\n\n- 这个插件用于创建一些在编译时可以配置的全局常量，这些常量的值我们可以在 `webpack` 的配置中去指定，例如\n\n```js\nmodule.exports = {\n  // ...\n  plugins: [\n    new webpack.DefinePlugin({\n      PRODUCTION: JSON.stringify(true), // const PRODUCTION = true\n      VERSION: JSON.stringify('5fa3b9'), // const VERSION = '5fa3b9'\n      BROWSER_SUPPORTS_HTML5: true, // const BROWSER_SUPPORTS_HTML5 = 'true'\n      TWO: '1+1', // const TWO = 1 + 1,\n      CONSTANTS: {\n        APP_VERSION: JSON.stringify('1.1.2') // const CONSTANTS = { APP_VERSION: '1.1.2' }\n      }\n    })\n  ]\n};\n```\n\n> 有了上面的配置，就可以在应用代码文件中，访问配置好的变量了，如：\n\n```js\nconsole.log('Running App version' + VERSION);\n\nif (!BROWSER_SUPPORTS_HTML5) require('html5shiv');\n```\n\n> 上面配置的注释已经简单说明了这些配置的效果，这里再简述一下整个配置规则。\n\n- 如果配置的值是字符串，那么整个字符串会被当成代码片段来执行，其结果作为最终变量的值，如上面的 `\"1+1\"`，最后的结果是 `2`\n- 如果配置的值不是字符串，也不是一个对象字面量，那么该值会被转为一个字符串，如 `true`，最后的结果是 `'true'`\n- 如果配置的是一个对象字面量，那么该对象的所有 `key` 会以同样的方式去定义\n- 这样我们就可以理解为什么要使用 `JSON.stringify()` 了，因为 `JSON.stringify(true)` 的结果是 `'true'`，`JSON.stringify(\"5fa3b9\")` 的结果是 `\"5fa3b9\"`。\n\n> 社区中关于 `DefinePlugin` 使用得最多的方式是定义环境变量，例如 `PRODUCTION = true` 或者 `__DEV__ = true` 等。部分类库在开发环境时依赖这样的环境变量来给予开发者更多的开发调试反馈，例如 react 等。\n\n- 建议使用 `process.env.NODE_ENV`: ... 的方式来定义 `process.env.NODE_ENV`，而不是使用 `process: {env: { NODE_ENV: ...} }` 的方式，因为这样会覆盖掉 `process` 这个对象，可能会对其他代码造成影响...\n\n#### copy-webpack-plugin\n\n> 我们一般会把开发的所有源码和资源文件放在 `src/` 目录下，构建的时候产出一个 `build/` 目录，通常会直接拿 `build` 中的所有文件来发布。有些文件没经过 `webpack` 处理，但是我们希望它们也能出现在 `build` 目录下，这时就可以使用 `CopyWebpackPlugin` 来处理了...\n\n```js\nconst CopyWebpackPlugin = require('copy-webpack-plugin');\n\nmodule.exports = {\n  // ...\n  plugins: [\n    new CopyWebpackPlugin([\n      { from: 'src/file.txt', to: 'build/file.txt' }, // 顾名思义，from 配置来源，to 配置目标路径\n      { from: 'src/*.ico', to: 'build/*.ico' } // 配置项可以使用 glob\n      // 可以配置很多项复制规则\n    ])\n  ]\n};\n```\n\n#### extract-text-webpack-plugin\n\n> 我们用它来把依赖的 `CSS` 分离出来成为单独的文件。这里再看一下使用 `extract-text-webpack-plugin` 的配置\n\n```js\nconst ExtractTextPlugin = require('extract-text-webpack-plugin');\n\nmodule.exports = {\n  // ...\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        // 因为这个插件需要干涉模块转换的内容，所以需要使用它对应的 loader\n        use: ExtractTextPlugin.extract({\n          fallback: 'style-loader',\n          use: 'css-loader'\n        })\n      }\n    ]\n  },\n  plugins: [\n    // 引入插件，配置文件名，这里同样可以使用 [hash]\n    new ExtractTextPlugin('index.css')\n  ]\n};\n```\n\n> 在上述的配置中，我们使用了 `index.css` 作为单独分离出来的文件名，但有的时候构建入口不止一个，`extract-text-webpack-plugin` 会为每一个入口创建单独分离的文件，因此最好这样配置\n\n```js\n// 这样确保在使用多个构建入口时，生成不同名称的文件\nplugins: [\n  new ExtractTextPlugin('[name].css'),\n],\n```\n\n### 更好使用 webpack-dev-server\n\n> `webpack-dev-server` 是 `webpack` 官方提供的一个工具，可以基于当前的 `webpack` 构建配置快速启动一个静态服务。当 `mode` 为 `development` 时，会具备 `hot reload` 的功能，即当源码文件变化时，会即时更新当前页面，以便你看到最新的效果...\n\n#### 基础使用\n\n> `webpack-dev-server` 是一个 `npm package`，安装后在已经有 `webpack` 配置文件的项目目录下直接启动就可以\n\n- `webpack-dev-server` 默认使用 `8080` 端口\n\n```bash\nnpm install webpack-dev-server -g\nwebpack-dev-server --mode development\n```\n\n> `package` 中的 `scripts` 配置：\n\n```js\n{\n  // ...\n  \"scripts\": {\n    \"start\": \"webpack-dev-server --mode development\"\n  }\n}\n```\n\n#### 配置\n\n> 在 webpack 的配置中，可以通过 `devServer` 字段来配置 `webpack-dev-server`，如端口设置、启动 `gzip` 压缩等，这里简单讲解几个常用的配置\n\n- `public` 字段用于指定静态服务的域名，默认是 `http://localhost:8080/` ，当你使用 `Nginx` 来做反向代理时，应该就需要使用该配置来指定 `Nginx` 配置使用的服务域名\n- `port` 字段用于指定静态服务的端口，如上，默认是 `8080`，通常情况下都不需要改动\n- `publicPath` 字段用于指定构建好的静态文件在浏览器中用什么路径去访问，默认是 `/`，例如，对于一个构建好的文件 `bundle.js`，完整的访问路径是 `http://localhost:8080/bundle.js`，如果你配置了 `publicPath: 'assets/'`，那么上述 `bundle.js` 的完整访问路径就是 `http://localhost:8080/assets/bundle.js`。可以使用整个 `URL` 来作为 `publicPath` 的值，如 `publicPath: 'http://localhost:8080/assets/'`。如果你使用了 `HMR`，那么要设置 `publicPath` 就必须使用完整的 `URL`\n\n> 建议将 `devServer.publicPath` 和 `output.publicPath` 的值保持一致\n\n- `proxy` 用于配置 `webpack-dev-server` 将特定 `URL` 的请求代理到另外一台服务器上。当你有单独的后端开发服务器用于请求 API 时，这个配置相当有用。例如\n\n```js\nproxy: {\n  '/api': {\n    target: \"http://localhost:3000\", // 将 URL 中带有 /api 的请求代理到本地的 3000 端口的服务上\n    pathRewrite: {'^/api': ''}, // 把 URL 中 path 部分的 `api` 移除掉\n  },\n}\n```\n\n- `before` 和 `after` 配置用于在 `webpack-dev-server` 定义额外的中间件，如\n\n```js\nbefore(app){\n  app.get('/some/path', function(req, res) { // 当访问 /some/path 路径时，返回自定义的 json 数据\n    res.json({custom: 'response'})\n  })\n}\n```\n\n- `before` 在 `webpack-dev-server` 静态资源中间件处理之前，可以用于拦截部分请求返回特定内容，或者实现简单的数据 `mock`。\n- `after` 在 `webpack-dev-server` 静态资源中间件处理之后，比较少用到，可以用于打印日志或者做一些额外处理...\n\n### 开发和生产环境的构建配置差异\n\n- 我们在日常的前端开发工作中，一般都会有两套构建环境：一套开发时使用，构建结果用于本地开发调试，不进行代码压缩，打印 `debug` 信息，包含 `sourcemap` 文件\n- 另外一套构建后的结果是直接应用于线上的，即代码都是压缩后，运行时不打印 `debug` 信息，静态文件不包括 `sourcemap` 的。有的时候可能还需要多一套测试环境，在运行时直接进行请求 `mock` 等工作\n- `webpack 4.x` 版本引入了 `mode` 的概念，在运行 `webpack` 时需要指定使用 `production` 或 `development` 两个 `mode` 其中一个，这个功能也就是我们所需要的运行两套构建环境的能力。\n\n#### 在配置文件中区分 mode\n\n> 之前我们的配置文件都是直接对外暴露一个 `JS` 对象，这种方式暂时没有办法获取到 `webpack` 的 `mode` 参数，我们需要更换一种方式来处理配置。根据官方的文档多种配置类型，配置文件可以对外暴露一个函数，因此我们可以这样做\n\n```js\nmodule.exports = (env, argv) => ({\n  // ... 其他配置\n  optimization: {\n    minimize: false,\n    // 使用 argv 来获取 mode 参数的值\n    minimizer:\n      argv.mode === 'production'\n        ? [\n            new UglifyJsPlugin({\n              /* 你自己的配置 */\n            })\n            // 仅在我们要自定义压缩配置时才需要这么做\n            // mode 为 production 时 webpack 会默认使用压缩 JS 的 plugin\n          ]\n        : []\n  }\n});\n```\n\n> 这样获取 `mode` 之后，我们就能够区分不同的构建环境，然后根据不同环境再对特殊的 `loader` 或 `plugin` 做额外的配置就可以了\n\n- 以上是 `webpack 4.x` 的做法，由于有了 `mode` 参数，区分环境变得简单了。不过在当前业界，估计还是使用 `webpack 3.x` 版本的居多，所以这里也简单介绍一下 `3.x` 如何区分环境\n\n> `webpack` 的运行时环境是 `Node.js`，我们可以通过 `Node.js` 提供的机制给要运行的 `webpack` 程序传递环境变量，来控制不同环境下的构建行为。例如，我们在 `npm` 中的 `scripts` 字段添加一个用于生产环境的构建命令...\n\n```js\n{\n  \"scripts\": {\n    \"build\": \"NODE_ENV=production webpack\",\n    \"develop\": \"NODE_ENV=development webpack-dev-server\"\n  }\n}\n```\n\n> 然后在 `webpack.config.js` 文件中可以通过 `process.env.NODE_ENV` 来获取命令传入的环境变量\n\n```js\nconst config = {\n  // ... webpack 配置\n};\n\nif (process.env.NODE_ENV === 'production') {\n  // 生产环境需要做的事情，如使用代码压缩插件等\n  config.plugins.push(new UglifyJsPlugin());\n}\n\nmodule.exports = config;\n```\n\n#### 运行时的环境变量\n\n> 我们使用 webpack 时传递的 mode 参数，是可以在我们的应用代码运行时，通过 `process.env.NODE_ENV` 这个变量获取的。这样方便我们在运行时判断当前执行的构建环境，使用最多的场景莫过于控制是否打印 `debug` 信息...\n\n- 下面这个简单的例子，在应用开发的代码中实现一个简单的 `console` 打印封装\n\n```js\nexport default function log(...args) {\n  if (process.env.NODE_ENV === 'development' && console && console.log) {\n    console.log.apply(console, args);\n  }\n}\n```\n\n> 同样，以上是 `webpack 4.x` 的做法，下面简单介绍一下 `3.x` 版本应该如何实现。这里需要用到 `DefinePlugin` 插件，它可以帮助我们在构建时给运行时定义变量，那么我们只要在前面 `webpack 3.x` 版本区分构建环境的例子的基础上，再使用 `DefinePlugin` 添加环境变量即可影响到运行时的代码...\n\n```js\nmodule.exports = {\n  // ...\n  // webpack 的配置\n\n  plugins: [\n    new webpack.DefinePlugin({\n      // webpack 3.x 的 process.env.NODE_ENV 是通过手动在命令行中指定 NODE_ENV=... 的方式来传递的\n      'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV)\n    })\n  ]\n};\n```\n\n#### 常见的环境差异配置\n\n**常见的 webpack 构建差异配置**\n\n- 生产环境可能需要分离 `CSS` 成单独的文件，以便多个页面共享同一个 `CSS` 文件\n- 生产环境需要压缩 `HTML/CSS/JS` 代码\n- 生产环境需要压缩图片\n- 开发环境需要生成 `sourcemap` 文件\n- 开发环境需要打印 `debug` 信息\n- 开发环境需要 `live reload` 或者 `hot reload` 的功能...\n\n> `webpack 4.x` 的 `mode` 已经提供了上述差异配置的大部分功能，`mode` 为 `production` 时默认使用 `JS` 代码压缩，而 `mode` 为 `development` 时默认启用 `hot` `reload`，等等。这样让我们的配置更为简洁，我们只需要针对特别使用的 `loader` 和 `plugin` 做区分配置就可以了...\n\n- `webpack 3.x` 版本还是只能自己动手修改配置来满足大部分环境差异需求，所以如果你要开始一个新的项目，建议直接使用 `webpack 4.x` 版本\n\n#### 拆分配置\n\n> 前面我们列出了几个环境差异配置，可能这些构建需求就已经有点多了，会让整个 `webpack` 的配置变得复杂，尤其是有着大量环境变量判断的配置。我们可以把 `webpack` 的配置按照不同的环境拆分成多个文件，运行时直接根据环境变量加载对应的配置即可。基本的划分如下...\n\n- `webpack.base.js`：基础部分，即多个文件中共享的配置\n- `webpack.development.js`：开发环境使用的配置\n- `webpack.production.js`：生产环境使用的配置\n- `webpack.test.js`：测试环境使用的配置...\n\n**如何处理这样的配置拆分**\n\n> 首先我们要明白，对于 `webpack` 的配置，其实是对外暴露一个 `JS` 对象，所以对于这个对象，我们都可以用 `JS` 代码来修改它，例如\n\n```js\nconst config = {\n  // ... webpack 配置\n};\n\n// 我们可以修改这个 config 来调整配置，例如添加一个新的插件\nconfig.plugins.push(new YourPlugin());\n\nmodule.exports = config;\n```\n\n> 因此，只要有一个工具能比较智能地合并多个配置对象，我们就可以很轻松地拆分 webpack 配置，然后通过判断环境变量，使用工具将对应环境的多个配置对象整合后提供给 webpack 使用。这个工具就是 **[webpack-merge](https://github.com/survivejs/webpack-merge)**\n\n- 我们的 webpack 配置基础部分，即 `webpack.base.js` 应该大致是这样的\n\n```js\nmodule.exports = {\n  entry: '...',\n  output: {\n    // ...\n  },\n  resolve: {\n    // ...\n  },\n  module: {\n    // 这里是一个简单的例子，后面介绍 API 时会用到\n    rules: [\n      {\n        test: /\\.js$/,\n        use: ['babel']\n      }\n    ]\n    // ...\n  },\n  plugins: [\n    // ...\n  ]\n};\n```\n\n> 然后 `webpack.development.js` 需要添加 `loader` 或 `plugin`，就可以使用 `webpack-merge` 的 `API`，例如\n\n```js\nconst {smart} = require('webpack-merge')\nconst webpack = require('webpack')\nconst base = require('./webpack.base.js')\n\nmodule.exports = smart(base, {\n  module: {\n    rules: [\n      // 用 smart API，当这里的匹配规则相同且 use 值都是数组时，smart 会识别后处理\n      // 和上述 base 配置合并后，这里会是 {test: /\\.js$/, use: ['babel', 'coffee'] }\n      // 如果这里 use 的值用的是字符串或者对象的话，那么会替换掉原本的规则 use 的值\n      {\n        test: /\\.js$/,\n        use: ['coffee'],\n      },\n      // ...\n    ],\n  },\n  plugins: [\n    // plugins 这里的数组会和 base 中的 plugins 数组进行合并\n    new webpack.DefinePlugin({\n      'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV),\n    }),\n  ],\n})；\n```\n\n> 可见 `webpack-merge` 提供的 `smart` 方法，可以帮助我们更加轻松地处理 `loader` 配置的合并。`webpack-merge` 还有其他 `API` 可以用于自定义合并行为\n\n#### 完整代码\n\n> `webpack.config.js`\n\n```js\nmodule.exports = function(env, argv) {\n  return argv.mode === 'production'\n    ? require('./configs/webpack.production')\n    : require('./configs/webpack.development');\n};\n```\n\n> `configs/webpack.base.js`\n\n```js\nconst path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  entry: './src/index.js',\n\n  output: {\n    path: path.resolve(__dirname, '../dist'),\n    filename: '[name].js'\n  },\n\n  module: {\n    rules: [\n      {\n        test: /\\.jsx?/,\n        include: [path.resolve(__dirname, '../src')],\n        use: 'babel-loader'\n      },\n      {\n        test: /\\.(png|jpg|gif)$/,\n        use: [\n          {\n            loader: 'file-loader'\n          }\n        ]\n      }\n    ]\n  },\n\n  plugins: [\n    new HtmlWebpackPlugin({\n      filename: 'index.html', // 配置输出文件名和路径\n      template: 'src/index.html' // 配置文件模板\n    })\n  ]\n};\n```\n\n> `configs/webpack.development.js`\n\n```js\nconst webpack = require('webpack');\nconst merge = require('webpack-merge');\nconst baseConfig = require('./webpack.base');\n\nconst config = merge.smart(baseConfig, {\n  module: {\n    rules: [\n      {\n        enforce: 'pre',\n        test: /\\.jsx?$/,\n        exclude: /node_modules/,\n        loader: 'eslint-loader'\n      },\n      {\n        test: /\\.less$/,\n        use: ['style-loader', 'css-loader', 'less-loader']\n      }\n    ]\n  },\n\n  devServer: {\n    port: '1234',\n    before(app) {\n      app.get('/api/test.json', function(req, res) {\n        res.json({ code: 200, message: 'hello world' });\n      });\n    }\n  }\n});\n\nconfig.plugins.push(\n  new webpack.DefinePlugin({\n    __DEV__: JSON.stringify(true)\n  })\n);\n\nmodule.exports = config;\n```\n\n> `configs/webpack.production.js`\n\n```js\nconst merge = require('webpack-merge');\nconst ExtractTextPlugin = require('extract-text-webpack-plugin');\nconst baseConfig = require('./webpack.base');\n\nconst config = merge.smart(baseConfig, {\n  module: {\n    rules: [\n      {\n        test: /\\.less$/,\n        use: ExtractTextPlugin.extract({\n          fallback: 'style-loader',\n          use: [\n            {\n              loader: 'css-loader',\n              options: {\n                minimize: true\n              }\n            },\n            'less-loader'\n          ]\n        })\n      }\n    ]\n  }\n});\n\nconfig.plugins.push(new ExtractTextPlugin('[name].css'));\n\nmodule.exports = config;\n```\n\n### 模块热替换提高开发效率\n\n> `HMR` 全称是 `Hot Module Replacement`，即模块热替换。在这个概念出来之前，我们使用过 `Hot Reloading`，当代码变更时通知浏览器刷新页面，以避免频繁手动刷新浏览器页面。HMR 可以理解为增强版的 `Hot Reloading`，但不用整个页面刷新，而是局部替换掉部分模块代码并且使其生效，可以看到代码变更后的效果。所以，`HMR` 既避免了频繁手动刷新页面，也减少了页面刷新时的等待，可以极大地提高前端页面开发效率...\n\n#### 配置使用 HMR\n\n> `HMR` 是 `webpack` 提供的非常有用的一个功能，跟我们之前提到的一样，安装好 `webpack-dev-server`， 添加一些简单的配置，即在 `webpack` 的配置文件中添加启用 `HMR` 需要的两个插件\n\n```js\nconst webpack = require('webpack');\n\nmodule.exports = {\n  // ...\n  devServer: {\n    hot: true // dev server 的配置要启动 hot，或者在命令行中带参数开启\n  },\n  plugins: [\n    // ...\n    new webpack.NamedModulesPlugin(), // 用于启动 HMR 时可以显示模块的相对路径\n    new webpack.HotModuleReplacementPlugin() // Hot Module Replacement 的插件\n  ]\n};\n```\n\n#### module.hot 常见的 API\n\n> 前面 `HMR` 实现部分已经讲解了实现 HMR 接口的重要性，下面来看看常见的 `module.hot` `API` 有哪些，以及如何使用\n\n- `module.hot.accept` 方法指定在应用特定代码模块更新时执行相应的 `callback`，第一个参数可以是字符串或者数组，如\n\n```js\nif (module.hot) {\n  module.hot.accept(['./bar.js', './index.css'], () => {\n    // ... 这样当 bar.js 或者 index.css 更新时都会执行该函数\n  });\n}\n```\n\n- `module.hot.decline` 对于指定的代码模块，拒绝进行模块代码的更新，进入更新失败状态，如 `module.hot.decline('./bar.js')`。这个方法比较少用到\n- `module.hot.dispose` 用于添加一个处理函数，在当前模块代码被替换时运行该函数，例如\n\n```js\nif (module.hot) {\n  module.hot.dispose(data => {\n    // data 用于传递数据，如果有需要传递的数据可以挂在 data 对象上，然后在模块代码更新后可以通过 module.hot.data 来获取\n  });\n}\n```\n\n- `module.hot.accept` 通常用于指定当前依赖的某个模块更新时需要做的处理，如果是当前模块更新时需要处理的动作，使用 `module.hot.dispose` 会更加容易方便\n- `module.hot.removeDisposeHandler` 用于移除 `dispose` 方法添加的 `callback`\n\n### 图片加载优化\n\n#### CSS Sprites\n\n- 如果你使用的 `webpack 3.x` 版本，需要 `CSS Sprites` 的话，可以使用 `webpack-spritesmith` 或者 `sprite-webpack-plugin`。\n- 我们以 `webpack-spritesmith` 为例，先安装依赖...\n\n```js\nmodule: {\n  loaders: [\n    // ... 这里需要有处理图片的 loader，如 file-loader\n  ]\n},\nresolve: {\n  modules: [\n    'node_modules',\n    'spritesmith-generated', // webpack-spritesmith 生成所需文件的目录\n  ],\n},\nplugins: [\n  new SpritesmithPlugin({\n    src: {\n      cwd: path.resolve(__dirname, 'src/ico'), // 多个图片所在的目录\n      glob: '*.png' // 匹配图片的路径\n    },\n    target: {\n      // 生成最终图片的路径\n      image: path.resolve(__dirname, 'src/spritesmith-generated/sprite.png'),\n      // 生成所需 SASS/LESS/Stylus mixins 代码，我们使用 Stylus 预处理器做例子\n      css: path.resolve(__dirname, 'src/spritesmith-generated/sprite.styl'),\n    },\n    apiOptions: {\n      cssImageRef: \"~sprite.png\"\n    },\n  }),\n],\n```\n\n> 在你需要的样式代码中引入 `sprite.styl` 后调用需要的 `mixins` 即可\n\n```plain\n@import '~sprite.styl'\n\n.close-button\n    sprite($close)\n.open-button\n    sprite($open)\n```\n\n> 如果你使用的是 `webpack 4.x`，你需要配合使用 `postcss` 和 `postcss-sprites`，才能实现 `CSS Sprites` 的相关构建\n\n#### 图片压缩\n\n- 在一般的项目中，图片资源会占前端资源的很大一部分，既然代码都进行压缩了，占大头的图片就更不用说了\n- 我们之前提及使用 `file-loader` 来处理图片文件，在此基础上，我们再添加一个 `image-webpack-loader` 来压缩图片文件。简单的配置如下...\n\n```js\nmodule.exports = {\n  // ...\n  module: {\n    rules: [\n      {\n        test: /.*\\.(gif|png|jpe?g|svg|webp)$/i,\n        use: [\n          {\n            loader: 'file-loader',\n            options: {}\n          },\n          {\n            loader: 'image-webpack-loader',\n            options: {\n              mozjpeg: { // 压缩 jpeg 的配置\n                progressive: true,\n                quality: 65\n              },\n              optipng: { // 使用 imagemin-optipng 压缩 png，enable: false 为关闭\n                enabled: false,\n              },\n              pngquant: { // 使用 imagemin-pngquant 压缩 png\n                quality: '65-90',\n                speed: 4\n              },\n              gifsicle: { // 压缩 gif 的配置\n                interlaced: false,\n              },\n              webp: { // 开启 webp，会把 jpg 和 png 图片压缩为 webp 格式\n                quality: 75\n              },\n          },\n        ],\n      },\n    ],\n  },\n};\n```\n\n#### 使用 DataURL\n\n> 有的时候我们的项目中会有一些很小的图片，因为某些缘故并不想使用 `CSS Sprites` 的方式来处理（譬如小图片不多，因此引入 CSS Sprites 感觉麻烦），那么我们可以在 webpack 中使用 `url-loader` 来处理这些很小的图片...\n\n- `url-loader` 和 `file-loader` 的功能类似，但是在处理文件的时候，可以通过配置指定一个大小，当文件小于这个配置值时，`url-loader` 会将其转换为一个 `base64` 编码的 `DataURL`，配置如下\n\n```js\nmodule.exports = {\n  // ...\n  module: {\n    rules: [\n      {\n        test: /\\.(png|jpg|gif)$/,\n        use: [\n          {\n            loader: 'url-loader',\n            options: {\n              limit: 8192 // 单位是 Byte，当文件小于 8KB 时作为 DataURL 处理\n            }\n          }\n        ]\n      }\n    ]\n  }\n};\n```\n\n#### 代码压缩\n\n- `webpack 4.x` 版本运行时，`mode` 为 `production` 即会启动压缩 `JS` 代码的插件，而对于 `webpack` `3.x`，使用压缩 `JS` 代码插件的方式也已经介绍过了。在生产环境中，压缩 `JS` 代码基本是一个必不可少的步骤，这样可以大大减小 `JavaScript` 的体积，相关内容这里不再赘述。\n- 除了 JS 代码之外，我们一般还需要 HTML 和 CSS 文件，这两种文件也都是可以压缩的，虽然不像 JS 的压缩那么彻底（替换掉长变量等），只能移除空格换行等无用字符，但也能在一定程度上减小文件大小。在 webpack 中的配置使用也不是特别麻烦，所以我们通常也会使用。\n- 对于 HTML 文件，之前介绍的 `html-webpack-plugin` 插件可以帮助我们生成需要的 HTML 并对其进行压缩...\n\n```js\nmodule.exports = {\n  // ...\n  plugins: [\n    new HtmlWebpackPlugin({\n      filename: 'index.html', // 配置输出文件名和路径\n      template: 'assets/index.html', // 配置文件模板\n      minify: {\n        // 压缩 HTML 的配置\n        minifyCSS: true, // 压缩 HTML 中出现的 CSS 代码\n        minifyJS: true // 压缩 HTML 中出现的 JS 代码\n      }\n    })\n  ]\n};\n```\n\n- 如上，使用 `minify` 字段配置就可以使用 `HTML` 压缩，这个插件是使用 `html-minifier` 来实现 `HTML` 代码压缩的，`minify` 下的配置项直接透传给 `html-minifier`，配置项参考 `html-minifier` 文档即可。\n- 对于 CSS 文件，我们之前介绍过用来处理 CSS 文件的 `css-loader`，也提供了压缩 CSS 代码的功能：\n\n```js\nmodule.exports = {\n  module: {\n    rules: [\n      // ...\n      {\n        test: /\\.css/,\n        include: [path.resolve(__dirname, 'src')],\n        use: [\n          'style-loader',\n          {\n            loader: 'css-loader',\n            options: {\n              minimize: true // 使用 css 的压缩功能\n            }\n          }\n        ]\n      }\n    ]\n  }\n};\n```\n\n> 在 `css-loader` 的选项中配置 `minimize` 字段为 `true` 来使用 `CSS` 压缩代码的功能。`css-loader` 是使用 `cssnano` 来压缩代码的，`minimize` 字段也可以配置为一个对象，来将相关配置传递给 `cssnano`\n\n### 分离代码文件\n\n- 关于分离 CSS 文件这个主题，之前在介绍如何搭建基本的前端开发环境时有提及，在 `webpack` 中使用 `extract-text-webpack-plugin` 插件即可。\n- 先简单解释一下为何要把 CSS 文件分离出来，而不是直接一起打包在 JS 中。最主要的原因是我们希望更好地利用缓存。\n- 假设我们原本页面的静态资源都打包成一个 JS 文件，加载页面时虽然只需要加载一个 JS 文件，但是我们的代码一旦改变了，用户访问新的页面时就需要重新加载一个新的 JS 文件。有些情况下，我们只是单独修改了样式，这样也要重新加载整个应用的 JS 文件，相当不划算。\n- 还有一种情况是我们有多个页面，它们都可以共用一部分样式（这是很常见的，CSS Reset、基础组件样式等基本都是跨页面通用），如果每个页面都单独打包一个 JS 文件，那么每次访问页面都会重复加载原本可以共享的那些 CSS 代码。如果分离开来，第二个页面就有了 CSS 文件的缓存，访问速度自然会加快。虽然对第一个页面来说多了一个请求，但是对随后的页面来说，缓存带来的速度提升相对更加可观\n\n> `3.x` 以前的版本是使用 `CommonsChunkPlugin` 来做代码分离的，而 `webpack 4.x` 则是把相关的功能包到了 `optimize.splitChunks` 中，直接使用该配置就可以实现代码分离。\n\n#### webpack 4.x 的 optimization\n\n```js\nmodule.exports = {\n  // ... webpack 配置\n\n  optimization: {\n    splitChunks: {\n      chunks: 'all' // 所有的 chunks 代码公共的部分分离出来成为一个单独的文件\n    }\n  }\n};\n```\n\n> 我们需要在 HTML 中引用两个构建出来的 JS 文件，并且 `commons.js` 需要在入口代码之前。下面是个简单的例子\n\n```html\n<script src=\"commons.js\" charset=\"utf-8\"></script>\n<script src=\"entry.bundle.js\" charset=\"utf-8\"></script>\n```\n\n> 如果你使用了 `html-webpack-plugin`，那么对应需要的 JS 文件都会在 HTML 文件中正确引用，不用担心。如果没有使用，那么你需要从 `stats` 的 `entrypoints` 属性来获取入口应该引用哪些 JS 文件，可以参考 Node API 了解如何从 stats 中获取信息\n\n**显式配置共享类库可以这么操作**\n\n```js\nmodule.exports = {\n  entry: {\n    vendor: [\"react\", \"lodash\", \"angular\", ...], // 指定公共使用的第三方类库\n  },\n  optimization: {\n    splitChunks: {\n      cacheGroups: {\n        vendor: {\n          chunks: \"initial\",\n          test: \"vendor\",\n          name: \"vendor\", // 使用 vendor 入口作为公共部分\n          enforce: true,\n        },\n      },\n    },\n  },\n  // ... 其他配置\n}\n\n// 或者\nmodule.exports = {\n  optimization: {\n    splitChunks: {\n      cacheGroups: {\n        vendor: {\n          test: /react|angluar|lodash/, // 直接使用 test 来做路径匹配\n          chunks: \"initial\",\n          name: \"vendor\",\n          enforce: true,\n        },\n      },\n    },\n  },\n}\n\n// 或者\nmodule.exports = {\n  optimization: {\n    splitChunks: {\n      cacheGroups: {\n        vendor: {\n          chunks: \"initial\",\n          test: path.resolve(__dirname, \"node_modules\") // 路径在 node_modules 目录下的都作为公共部分\n          name: \"vendor\", // 使用 vendor 入口作为公共部分\n          enforce: true,\n        },\n      },\n    },\n  },\n}\n```\n\n> 上述第一种做法是显示指定哪些类库作为公共部分，第二种做法实现的功能差不多，只是利用了 test 来做模块路径的匹配，第三种做法是把所有在 node_modules 下的模块，即作为依赖安装的，都作为公共部分。你可以针对项目情况，选择最合适的做法\n\n#### webpack 3.x 的 CommonsChunkPlugin\n\n> `webpack 3.x` 以下的版本需要用到 webpack 自身提供的 `CommonsChunkPlugin` 插件。我们先来看一个最简单的例子\n\n```js\nmodule.exports = {\n  // ...\n  plugins: [\n    new webpack.optimize.CommonsChunkPlugin({\n      name: 'commons', // 公共使用的 chunk 的名称\n      filename: 'commons.js', // 公共 chunk 的生成文件名\n      minChunks: 3 // 公共的部分必须被 3 个 chunk 共享\n    })\n  ]\n};\n```\n\n- `chunk` 在这里是构建的主干，可以简单理解为一个入口对应一个 `chunk`。\n- 以上插件配置在构建后会生成一个 `commons.js` 文件，该文件就是代码中的公共部分。上面的配置中 `minChunks` 字段为 3，该字段的意思是当一个模块被 3 个以上的 `chunk` 依赖时，这个模块就会被划分到 `commons chunk` 中去。单从这个配置的角度上讲，这种方式并没有 `4.x` 的 `chunks: \"all\"` 那么方便。\n\n**CommonsChunkPlugin 也是支持显式配置共享类库的**\n\n```js\nmodule.exports = {\n  entry: {\n    vendor: ['react', 'react-redux'], // 指定公共使用的第三方类库\n    app: './src/entry',\n    // ...\n  },\n  // ...\n  plugins: [\n    new webpack.optimize.CommonsChunkPlugin({\n      name: 'vendor' // 使用 vendor 入口作为公共部分\n      filename: \"vendor.js\",\n      minChunks: Infinity, // 这个配置会让 webpack 不再自动抽离公共模块\n    }),\n  ],\n}\n```\n\n> 上述配置会生成一个名为 `vendor.js` 的共享代码文件，里面包含了 `React` 和 `React-Redux` 库的代码，可以提供给多个不同的入口代码使用。这里的 `minChunks` 字段的配置，我们使用了 `Infinity`，可以理解为 `webpack` 不自动抽离公共模块。如果这里和之前一样依旧设置为 3，那么被 3 个以上的 `chunk` 依赖的模块会和 `React`、`React-Redux` 一同打包进 `vendor`，这样就失去显式指定的意义了。\n\n> `minChunks` 其实还可以是一个函数，如：\n\n```js\nminChunks: (module, count) => {\n  console.log(module, count);\n  return true;\n},\n```\n\n> 该函数在分析每一个依赖的时候会被调用，传入当前依赖模块的信息 `module`，以及已经被作为公共模块的数量 `count`，你可以在函数中针对每一个模块做更加精细化的控制。看一个简单的例子：\n\n```js\nminChunks: (module, count) => {\n  return module.context && module.context.includes(\"node_modules\");\n  // node_modules 目录下的模块都作为公共部分，效果就如同 webpack 4.x 中的 test: path.resolve(__dirname, \"node_modules\")\n},\n```\n\n- 更多使用 `CommonsChunkPlugin` 的配置参考官方文档 `commons-chunk-plugin`。\n\n### 进一步控制 JS 大小\n\n#### 按需加载模块\n\n> 在 webpack 的构建环境中，要按需加载代码模块很简单，遵循 ES 标准的动态加载语法 `dynamic-import` 来编写代码即可，`webpack` 会自动处理使用该语法编写的模块\n\n```js\n// import 作为一个方法使用，传入模块名即可，返回一个 promise 来获取模块暴露的对象\n// 注释 webpackChunkName: \"lodash\" 可以用于指定 chunk 的名称，在输出文件时有用\nimport(/* webpackChunkName: \"lodash\" */ 'lodash').then((_) => {\n  console.log(_.lash([1, 2, 3])) // 打印 3\n})\n```\n\n- 注意一下，如果你使用了 `Babel` 的话，还需要 `Syntax Dynamic Import` 这个 `Babel` 插件来处理 `import()` 这种语法。\n- 由于动态加载代码模块的语法依赖于 `promise`，对于低版本的浏览器，需要添加 `promise` 的 `polyfill` 后才能使用。\n- 如上的代码，webpack 构建时会自动把 `lodash` 模块分离出来，并且在代码内部实现动态加载 `lodash` 的功能。动态加载代码时依赖于网络，其模块内容会异步返回，所以 import 方法是返回一个 `promise` 来获取动态加载的模块内容。\n- `import` 后面的注释 `webpackChunkName: \"lodash\"` 用于告知 `webpack` 所要动态加载模块的名称。我们在 webpack 配置中添加一个 `output.chunkFilename` 的配置...\n\n```js\noutput: {\n  path: path.resolve(__dirname, 'dist'),\n  filename: '[name].[hash:8].js',\n  chunkFilename: '[name].[hash:8].js' // 指定分离出来的代码文件的名称\n},\n```\n\n> 这样就可以把分离出来的文件名称用 lodash 标识了，如下图：\n\n![image.png](https://upload-images.jianshu.io/upload_images/1480597-ae36b6816feed422.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n> 如果没有添加注释 `webpackChunkName: \"lodash\" 以及 output.chunkFilename` 配置，那么分离出来的文件名称会以简单数字的方式标识，不便于识别\n\n#### 以上完整示例代码\n\n```js\nconst path = require('path');\nconst webpack = require('webpack');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\nconst ExtractTextPlugin = require('extract-text-webpack-plugin');\n\nmodule.exports = {\n  entry: './src/index.js',\n\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: '[name].js'\n  },\n\n  module: {\n    rules: [\n      {\n        test: /\\.jsx?/,\n        include: [path.resolve(__dirname, 'src')],\n        use: 'babel-loader'\n      },\n      {\n        test: /\\.less$/,\n        use: ExtractTextPlugin.extract({\n          fallback: 'style-loader',\n          use: ['css-loader', 'postcss-loader', 'less-loader']\n        })\n      },\n      {\n        test: /\\.(png|jpg|gif)$/,\n        use: [\n          {\n            loader: 'url-loader',\n            options: {\n              limit: 8192\n            }\n          },\n          {\n            loader: 'image-webpack-loader',\n            options: {\n              mozjpeg: {\n                // 压缩 jpeg 的配置\n                progressive: true,\n                quality: 65\n              },\n              optipng: {\n                // 使用 imagemin-optipng 压缩 png，enable: false 为关闭\n                enabled: false\n              },\n              pngquant: {\n                // 使用 imagemin-pngquant 压缩 png\n                quality: '65-90',\n                speed: 4\n              },\n              gifsicle: {\n                // 压缩 gif 的配置\n                interlaced: false\n              },\n              webp: {\n                // 开启 webp，会把 jpg 和 png 图片压缩为 webp 格式\n                quality: 75\n              }\n            }\n          }\n        ]\n      }\n    ]\n  },\n\n  optimization: {\n    splitChunks: {\n      cacheGroups: {\n        vendor: {\n          chunks: 'initial',\n          test: path.resolve(__dirname, 'node_modules'), // 路径在 node_modules 目录下的都作为公共部分\n          name: 'vendor', // 使用 vendor 入口作为公共部分\n          enforce: true\n        }\n      }\n    }\n  },\n\n  plugins: [\n    new HtmlWebpackPlugin({\n      filename: 'index.html', // 配置输出文件名和路径\n      template: 'src/index.html', // 配置文件模板\n      minify: {\n        // 压缩 HTML 的配置\n        minifyCSS: true, // 压缩 HTML 中出现的 CSS 代码\n        minifyJS: true, // 压缩 HTML 中出现的 JS 代码\n        removeComments: true\n      }\n    }),\n    new ExtractTextPlugin('[name].css'),\n    new webpack.NamedModulesPlugin(),\n    new webpack.HotModuleReplacementPlugin()\n  ],\n\n  devServer: {\n    hot: true\n  }\n};\n```\n","source":"_posts/webpack4-定制前端开发环境.md","raw":"---\ntitle: Webpack 4 定制前端开发环境\ncomments: true\ndate: 2018-09-11 22:16:37\ntags:\nfrom:\n---\n\n本文总结了 Webpack 4 的一些配置点，希望通过学习这些配置点，降低使用门槛。纵观前端的打包历史，似乎是欠了太多债，有很多历史包袱，所以工程化这一块一直是一大痛点。配置繁琐，容易出错，本文总结了最新的 Webpack 4 功能点，一起来学习一下，可以点击右侧的文章目录直达。\n\n<!-- more -->\n\n### webpack 概念和基础使用\n\n#### 安装和使用\n\n```bash\n# 安装 webpack\n$ npm install webpack webpack-cli -g\n\n# or\n$ yarn global add webpack webpack-cli\n\n# 然后就可以全局执行命令了\n$ webpack --help\n```\n\n#### webpack 的基本概念\n\n> webpack 本质上是一个打包工具，它会根据代码的内容解析模块依赖，帮助我们把多个模块的代码打包\n\n![image](https://user-images.githubusercontent.com/15377484/59234564-f1cb0600-8c1f-11e9-8bdf-c6041410225a.png)\n\n> webpack 会把我们项目中使用到的多个代码模块（可以是不同文件类型），打包构建成项目运行仅需要的几个静态文件\n\n**入口（entry）**\n\n> 入口可以使用 `entry` 字段来进行配置，`webpack` 支持配置多个入口来进行构建\n\n```js\nmodule.exports = {\n  entry: './src/index.js'\n};\n\n// 上述配置等同于\nmodule.exports = {\n  entry: {\n    main: './src/index.js'\n  }\n};\n\n// 或者配置多个入口\nmodule.exports = {\n  entry: {\n    foo: './src/page-foo.js',\n    bar: './src/page-bar.js'\n    // ...\n  }\n};\n\n// 使用数组来对多个文件进行打包\nmodule.exports = {\n  entry: {\n    main: ['./src/foo.js', './src/bar.js']\n  }\n};\n```\n\n**转换器（loader）**\n\n> 可以把 `loader` 理解为是一个转换器，负责把某种文件格式的内容转换成 webpack 可以支持打包的模块\n\n- 当我们需要使用不同的 `loader` 来解析处理不同类型的文件时，我们可以在 `module.rules` 字段下来配置相关的规则，例如使用 `Babel` 来处理 `.js` 文件\n\n```js\nmodule: {\n  // ...\n  rules: [\n    {\n      test: /\\.jsx?/, // 匹配文件路径的正则表达式，通常我们都是匹配文件类型后缀\n      include: [\n        path.resolve(__dirname, 'src') // 指定哪些路径下的文件需要经过 loader 处理\n      ],\n      use: 'babel-loader', // 指定使用的 loader\n    },\n  ],\n}\n```\n\n**插件（plugin）**\n\n> 模块代码转换的工作由 `loader` 来处理，除此之外的其他任何工作都可以交由 `plugin` 来完成。通过添加我们需要的 `plugin`，可以满足更多构建中特殊的需求。例如，要使用压缩 `JS` 代码的 `uglifyjs-webpack-plugin` 插件，只需在配置中通过 `plugins` 字段添加新的 `plugin` 即可...\n\n```js\nconst UglifyPlugin = require('uglifyjs-webpack-plugin');\n\nmodule.exports = {\n  plugins: [new UglifyPlugin()]\n};\n```\n\n> `plugin` 理论上可以干涉 `webpack` 整个构建流程，可以在流程的每一个步骤中定制自己的构建需求\n\n**输出（output）**\n\n> 构建结果的文件名、路径等都是可以配置的，使用 `output` 字段\n\n```js\nmodule.exports = {\n  // ...\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'bundle.js'\n  }\n};\n\n// 或者多个入口生成不同文件\nmodule.exports = {\n  entry: {\n    foo: './src/foo.js',\n    bar: './src/bar.js'\n  },\n  output: {\n    filename: '[name].js',\n    path: __dirname + '/dist'\n  }\n};\n\n// 路径中使用 hash，每次构建时会有一个不同 hash 值，避免发布新版本时线上使用浏览器缓存\nmodule.exports = {\n  // ...\n  output: {\n    filename: '[name].js',\n    path: __dirname + '/dist/[hash]'\n  }\n};\n```\n\n> 我们一开始直接使用 `webpack` 构建时，默认创建的输出内容就是 `./dist/main.js`\n\n**一个简单的 webpack 配置**\n\n> 我们把上述涉及的几部分配置内容合到一起，就可以创建一个简单的 `webpack` 配置了，`webpack` 运行时默认读取项目下的 `webpack.config.js` 文件作为配置。所以我们在项目中创建一个 `webpack.config.js` 文件\n\n```js\nconst path = require('path');\nconst UglifyPlugin = require('uglifyjs-webpack-plugin');\n\nmodule.exports = {\n  entry: './src/index.js',\n\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'bundle.js'\n  },\n\n  module: {\n    rules: [\n      {\n        test: /\\.jsx?/,\n        include: [path.resolve(__dirname, 'src')],\n        use: 'babel-loader'\n      }\n    ]\n  },\n\n  // 代码模块路径解析的配置\n  resolve: {\n    modules: ['node_modules', path.resolve(__dirname, 'src')],\n\n    extensions: ['.wasm', '.mjs', '.js', '.json', '.jsx']\n  },\n\n  plugins: [\n    new UglifyPlugin()\n    // 使用 uglifyjs-webpack-plugin 来压缩 JS 代码\n    // 如果你留意了我们一开始直接使用 webpack 构建的结果，你会发现默认已经使用了 JS 代码压缩的插件\n    // 这其实也是我们命令中的 --mode production 的效果，后续的小节会介绍 webpack 的 mode 参数\n  ]\n};\n```\n\n### 搭建基础的前端开发环境\n\n#### 关联 HTML\n\n> `webpack` 默认从作为入口的 `.js` 文件进行构建（更多是基于 `SPA` 去考虑），但通常一个前端项目都是从一个页面（即 HTML）出发的，最简单的方法是，创建一个 HTML 文件，使用 `script` 标签直接引用构建好的 JS 文件，如...\n\n```plain\n<script src=\"./dist/bundle.js\"></script>\n```\n\n- 但是，如果我们的文件名或者路径会变化，例如使用 `[hash]` 来进行命名，那么最好是将 `HTML` 引用路径和我们的构建结果关联起来，这个时候我们可以使用 `html-webpack-plugin`\n- `html-webpack-plugin` 是一个独立的 `node package`，所以在使用之前我们需要先安装它，把它安装到项目的开发依赖中\n\n```bash\nnpm install html-webpack-plugin -D\n```\n\n> 然后在 `webpack` 配置中，将 `html-webpack-plugin` 添加到 `plugins` 列表中\n\n```js\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  // ...\n  plugins: [new HtmlWebpackPlugin()]\n};\n```\n\n> 这样配置好之后，构建时 `html-webpack-plugin` 会为我们创建一个 `HTML` 文件，其中会引用构建出来的 JS 文件。实际项目中，默认创建的 `HTML` 文件并没有什么用，我们需要自己来写 `HTML` 文件，可以通过 `html-webpack-plugin` 的配置，传递一个写好的 HTML 模板...\n\n```js\nmodule.exports = {\n  // ...\n  plugins: [\n    new HtmlWebpackPlugin({\n      filename: 'index.html', // 配置输出文件名和路径\n      template: 'assets/index.html' // 配置文件模板\n    })\n  ]\n};\n```\n\n> 这样，通过 `html-webpack-plugin` 就可以将我们的页面和构建 `JS` 关联起来，回归日常，从页面开始开发。如果需要添加多个页面关联，那么实例化多个 `html-webpack-plugin`， 并将它们都放到 `plugins` 字段数组中就可以了...\n\n#### 构建 CSS\n\n> 我们编写 `CSS`，并且希望使用 `webpack` 来进行构建，为此，需要在配置中引入 `loader` 来解析和处理 `CSS` 文件\n\n```js\nmodule.exports = {\n  module: {\n    rules: [\n      // ...\n      {\n        test: /\\.css/,\n        include: [path.resolve(__dirname, 'src')],\n        use: ['style-loader', 'css-loader']\n      }\n    ]\n  }\n};\n```\n\n- `css-loader` 负责解析 `CSS` 代码，主要是为了处理 `CSS` 中的依赖，例如 `@import` 和 `url()` 等引用外部文件的声明；\n- `style-loader` 会将 `css-loader` 解析的结果转变成 `JS` 代码，运行时动态插入 `style` 标签来让 `CSS` 代码生效...\n\n> 经由上述两个 `loader` 的处理后，CSS 代码会转变为 JS，和 `index.js` 一起打包了。如果需要单独把 CSS 文件分离出来，我们需要使用 `extract-text-webpack-plugin` 插件\n\n```js\nconst ExtractTextPlugin = require('extract-text-webpack-plugin');\n\nmodule.exports = {\n  // ...\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        // 因为这个插件需要干涉模块转换的内容，所以需要使用它对应的 loader\n        use: ExtractTextPlugin.extract({\n          fallback: 'style-loader',\n          use: 'css-loader'\n        })\n      }\n    ]\n  },\n  plugins: [\n    // 引入插件，配置文件名，这里同样可以使用 [hash]\n    new ExtractTextPlugin('index.css')\n  ]\n};\n```\n\n#### CSS 预处理器\n\n> 在上述使用 CSS 的基础上，通常我们会使用 `Less/Sass` 等 CSS 预处理器，webpack 可以通过添加对应的 `loader` 来支持，以使用 `Less` 为例，我们可以在官方文档中找到对应的 `loader`\n\n```js\nmodule.exports = {\n  // ...\n  module: {\n    rules: [\n      {\n        test: /\\.less$/,\n        // 因为这个插件需要干涉模块转换的内容，所以需要使用它对应的 loader\n        use: ExtractTextPlugin.extract({\n          fallback: 'style-loader',\n          use: ['css-loader', 'less-loader']\n        })\n      }\n    ]\n  }\n  // ...\n};\n```\n\n#### 处理图片文件\n\n> 在前端项目的样式中总会使用到图片，虽然我们已经提到 `css-loader` 会解析样式中用 `url()` 引用的文件路径，但是图片对应的 `jpg/png/gif` 等文件格式，`webpack` 处理不了。是的，我们只要添加一个处理图片的 `loader` 配置就可以了，现有的 `file-loader` 就是个不错的选择...\n\n- `file-loader` 可以用于处理很多类型的文件，它的主要作用是直接输出文件，把构建后的文件路径返回。配置很简单，在 `rules` 中添加一个字段，增加图片类型文件的解析配置\n\n```js\nmodule.exports = {\n  // ...\n  module: {\n    rules: [\n      {\n        test: /\\.(png|jpg|gif)$/,\n        use: [\n          {\n            loader: 'file-loader',\n            options: {}\n          }\n        ]\n      }\n    ]\n  }\n};\n```\n\n#### 使用 Babel\n\n> `Babel` 是一个让我们能够使用 `ES` 新特性的 `JS` 编译工具，我们可以在 `webpack` 中配置 Babel，以便使用 `ES6`、`ES7` 标准来编写 `JS` 代码\n\n```js\nmodule.exports = {\n  // ...\n  module: {\n    rules: [\n      {\n        test: /\\.jsx?/, // 支持 js 和 jsx\n        include: [\n          path.resolve(__dirname, 'src') // src 目录下的才需要经过 babel-loader 处理\n        ],\n        loader: 'babel-loader'\n      }\n    ]\n  }\n};\n```\n\n#### 启动静态服务\n\n> 至此，我们完成了处理多种文件类型的 webpack 配置。我们可以使用 `webpack-dev-server` 在本地开启一个简单的静态服务来进行开发\n\n```js\n\"scripts\": {\n  \"build\": \"webpack --mode production\",\n  \"start\": \"webpack-dev-server --mode development\"\n}\n```\n\n> 尝试着运行 `npm start` 或者 `yarn start`，然后就可以访问 `http://localhost:8080/` 来查看你的页面了。默认是访问 `index.html`，如果是其他页面要注意访问的 URL 是否正确\n\n#### 完整示例代码\n\n```js\nconst path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\nconst ExtractTextPlugin = require('extract-text-webpack-plugin');\n\nmodule.exports = {\n  entry: './src/index.js',\n\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: '[name].js'\n  },\n\n  module: {\n    rules: [\n      {\n        test: /\\.jsx?/,\n        include: [path.resolve(__dirname, 'src')],\n        use: 'babel-loader'\n      },\n      {\n        test: /\\.less$/,\n        // 因为这个插件需要干涉模块转换的内容，所以需要使用它对应的 loader\n        use: ExtractTextPlugin.extract({\n          fallback: 'style-loader',\n          use: ['css-loader', 'less-loader']\n        })\n      },\n      {\n        test: /\\.(png|jpg|gif)$/,\n        use: [\n          {\n            loader: 'file-loader'\n          }\n        ]\n      }\n    ]\n  },\n\n  // 代码模块路径解析的配置\n  resolve: {\n    modules: ['node_modules', path.resolve(__dirname, 'src')],\n\n    extensions: ['.wasm', '.mjs', '.js', '.json', '.jsx']\n  },\n\n  plugins: [\n    new HtmlWebpackPlugin({\n      filename: 'index.html', // 配置输出文件名和路径\n      template: 'src/index.html' // 配置文件模板\n    }),\n    new ExtractTextPlugin('[name].css')\n  ]\n};\n```\n\n### webpack 如何解析代码模块路径\n\n> webpack 中有一个很关键的模块 `enhanced-resolve` 就是处理依赖模块路径的解析的，这个模块可以说是 Node.js 那一套模块路径解析的增强版本，有很多可以自定义的解析配置\n\n- 在 webpack 配置中，和模块路径解析相关的配置都在 `resolve` 字段下\n\n```js\nmodule.exports = {\n  resolve: {\n    // ...\n  }\n};\n```\n\n#### 常用的一些配置\n\n**resolve.alias**\n\n> 假设我们有个 `utils` 模块极其常用，经常编写相对路径很麻烦，希望可以直接 `import 'utils'` 来引用，那么我们可以配置某个模块的别名，如\n\n```js\nalias: {\n  utils: path.resolve(__dirname, 'src/utils'); // 这里使用 path.resolve 和 __dirname 来获取绝对路径\n}\n```\n\n> 上述的配置是模糊匹配，意味着只要模块路径中携带了 utils 就可以被替换掉，如：\n\n```plain\nimport 'utils/query.js' // 等同于 import '[项目绝对路径]/src/utils/query.js'\n```\n\n> 如果需要进行精确匹配可以使用：\n\n```js\nalias: {\n  utils$: path.resolve(__dirname, 'src/utils'); // 只会匹配 import 'utils'\n}\n```\n\n**resolve.extensions**\n\n```js\nextensions: ['.wasm', '.mjs', '.js', '.json', '.jsx'],\n// 这里的顺序代表匹配后缀的优先级，例如对于 index.js 和 index.jsx，会优先选择 index.js\n```\n\n> 这个配置的作用是和文件后缀名有关的, 这个配置可以定义在进行模块路径解析时，webpack 会尝试帮你补全那些后缀名来进行查找\n\n### 配置 loader\n\n#### loader 匹配规则\n\n> 当我们需要配置 `loader` 时，都是在 `module.rules` 中添加新的配置项，在该字段中，每一项被视为一条匹配使用 `loader` 的规则\n\n```js\nmodule.exports = {\n  // ...\n  module: {\n    rules: [\n      {\n        test: /\\.jsx?/, // 条件\n        include: [path.resolve(__dirname, 'src')], // 条件\n        use: 'babel-loader' // 规则应用结果\u000e\n      } // 一个 object 即一条规则\n      // ...\n    ]\n  }\n};\n```\n\n> `loader` 的匹配规则中有两个最关键的因素：一个是匹配条件，一个是匹配规则后的应用\n\n#### 规则条件配置\n\n> 大多数情况下，配置 `loader` 的匹配条件时，只要使用 `test` 字段就好了，很多时候都只需要匹配文件后缀名来决定使用什么 `loader`，但也不排除在某些特殊场景下，我们需要配置比较复杂的匹配条件。webpack 的规则提供了多种配置形式...\n\n- `{test: ...}` 匹配特定条件\n- `{include: ...}` 匹配特定路径\n- `{exclude: ...}` 排除特定路径\n- `{and: [...] }` 必须匹配数组中所有条件\n- `{or: [...] }` 匹配数组中任意一个条件\n- `{not: [...] }` 排除匹配数组中所有条件...\n\n> 上述的所谓条件的值可以是：\n\n- 字符串：必须以提供的字符串开始，所以是字符串的话，这里我们需要提供绝对路径\n- 正则表达式：调用正则的 `test` 方法来判断匹配\n- 函数：`(path) => boolean`，返回 `true` 表示匹配\n- 数组：至少包含一个条件的数组\n- 对象：匹配所有属性值的条件...\n\n```js\nrules: [\n  {\n    test: /\\.jsx?/, // 正则\n    include: [\n      path.resolve(__dirname, 'src'), // 字符串，注意是绝对路径\n    ], // 数组\n    // ...\n  },\n  {\n    test: {\n      js: /\\.js/,\n      jsx: /\\.jsx/,\n    }, // 对象，不建议使用\n    not: [\n      (value) => { /* ... */ return true; }, // 函数，通常需要高度自定义时才会使用\n    ],\n  },\n]\n```\n\n#### 使用 loader 配置\n\n> `module.rules` 的匹配规则最重要的还是用于配置 `loader`，我们可以使用 `use` 字段\n\n```js\nrules: [\n  {\n    test: /\\.less/,\n    use: [\n      'style-loader', // 直接使用字符串表示 loader\n      {\n        loader: 'css-loader',\n        options: {\n          importLoaders: 1\n        },\n      }, // 用对象表示 loader，可以传递 loader 配置等\n      {\n        loader: 'less-loader',\n        options: {\n          noIeCompat: true\n        }, // 传递 loader 配置\n      },\n    ],\n  },\n]\n```\n\n> `use` 字段可以是一个数组，也可以是一个字符串或者表示 `loader` 的对象。如果只需要一个 `loader`，也可以这样：`use: {loader: 'babel-loader'`, `options: { ...} }`\n\n#### loader 应用顺序\n\n- 对于上面的 `less` 规则配置，一个 `style.less` 文件会途径 `less-loader`、`css-loader`、`style-loader` 处理，成为一个可以打包的模块。\n- `loader` 的应用顺序在配置多个 `loader` 一起工作时很重要，通常会使用在 CSS 配置上，除了 `style-loader` 和 `css-loader`，你可能还要配置 `less-loader` 然后再加个 `postcss` 的 `autoprefixer` 等。\n- 上述从后到前的顺序是在同一个 `rule` 中进行的，那如果多个 `rule` 匹配了同一个模块文件，`loader` 的应用顺序又是怎样的呢？看一份这样的配置...\n\n```js\nrules: [\n  {\n    test: /\\.js$/,\n    exclude: /node_modules/,\n    loader: \"eslint-loader\",\n  },\n  {\n    test: /\\.js$/,\n    exclude: /node_modules/,\n    loader: \"babel-loader\",\n  },\n]\n```\n\n> 这样无法法保证 `eslint-loader` 在 `babel-loader` 应用前执行。`webpack` 在 `rules` 中提供了一个 `enforce` 的字段来配置当前 `rule` 的 `loader` 类型，没配置的话是普通类型，我们可以配置 `pre` 或 `post`，分别对应前置类型或后置类型的 `loader`...\n\n- 所有的 `loader` 按照 **前置** -> **行内** -> **普通** -> **后置** 的顺序执行。所以当我们要确保 `eslint-loader` 在 `babel-loader` 之前执行时，可以如下添加 `enforce` 配置\n\n```js\nrules: [\n  {\n    enforce: 'pre', // 指定为前置类型\n    test: /\\.js$/,\n    exclude: /node_modules/,\n    loader: \"eslint-loader\",\n  },\n]\n```\n\n> 当项目文件类型和应用的 `loader` 不是特别复杂的时候，通常建议把要应用的同一类型 `loader` 都写在同一个匹配规则中，这样更好维护和控制\n\n#### 完整代码\n\n```js\nconst path = require('path');\nconst webpack = require('webpack');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\nconst ExtractTextPlugin = require('extract-text-webpack-plugin');\nconst CopyWebpackPlugin = require('copy-webpack-plugin');\n\nmodule.exports = {\n  entry: './src/index',\n\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: '[name].js'\n  },\n\n  module: {\n    rules: [\n      {\n        enforce: 'pre', // 指定为前置类型\n        test: /\\.jsx?$/,\n        exclude: /node_modules/,\n        loader: 'eslint-loader'\n      },\n      {\n        test: /\\.jsx?$/,\n        include: [path.resolve(__dirname, 'src')],\n        use: 'babel-loader'\n      },\n      {\n        test: /\\.css$/,\n        use: ExtractTextPlugin.extract({\n          fallback: 'style-loader',\n          use: ['css-loader']\n        })\n      },\n      {\n        test: /\\.less$/,\n        use: ExtractTextPlugin.extract({\n          fallback: 'style-loader',\n          use: ['css-loader', 'less-loader']\n        })\n      },\n      {\n        test: /\\.(png|jpg|gif)$/,\n        use: [\n          {\n            loader: 'file-loader'\n          }\n        ]\n      }\n    ]\n  },\n\n  resolve: {\n    alias: {\n      utils: path.resolve(__dirname, 'src/utils'), // 这里使用 path.resolve 和 __dirname 来获取绝对路径\n      log$: path.resolve(__dirname, 'src/utils/log.js') // 只匹配 log\n    },\n    extensions: ['.js', '.json', '.jsx', '.css', '.less'],\n    modules: [\n      path.resolve(__dirname, 'node_modules') // 指定当前目录下的 node_modules 优先查找\n    ]\n  },\n\n  plugins: [\n    new HtmlWebpackPlugin({\n      filename: 'index.html', // 配置输出文件名和路径\n      template: 'src/index.html' // 配置文件模板\n    }),\n    new ExtractTextPlugin('[name].css'),\n    new webpack.DefinePlugin({\n      TWO: '1+1',\n      CONSTANTS: {\n        APP_VERSION: JSON.stringify('1.1.2') // const CONSTANTS = { APP_VERSION: '1.1.2' }\n      }\n    }),\n    new CopyWebpackPlugin([\n      { from: 'src/assets/favicon.ico', to: 'favicon.ico' } // 顾名思义，from 配置来源，to 配置目标路径\n    ]),\n    new webpack.ProvidePlugin({\n      _: 'lodash'\n    })\n  ],\n\n  devServer: {\n    port: '1234',\n    before(app) {\n      app.get('/api/test.json', function(req, res) {\n        // 当访问 /some/path 路径时，返回自定义的 json 数据\n        res.json({ code: 200, message: 'hello world' });\n      });\n    }\n  }\n};\n```\n\n### 使用 plugin\n\n> 更多的插件可以在这里查找：[plugins in awesome-webpack](https://github.com/webpack-contrib/awesome-webpack#webpack-plugins)\n\n#### DefinePlugin\n\n> `DefinePlugin` 是 `webpack` 内置的插件，可以使用 `webpack.DefinePlugin` 直接获取\n\n- 这个插件用于创建一些在编译时可以配置的全局常量，这些常量的值我们可以在 `webpack` 的配置中去指定，例如\n\n```js\nmodule.exports = {\n  // ...\n  plugins: [\n    new webpack.DefinePlugin({\n      PRODUCTION: JSON.stringify(true), // const PRODUCTION = true\n      VERSION: JSON.stringify('5fa3b9'), // const VERSION = '5fa3b9'\n      BROWSER_SUPPORTS_HTML5: true, // const BROWSER_SUPPORTS_HTML5 = 'true'\n      TWO: '1+1', // const TWO = 1 + 1,\n      CONSTANTS: {\n        APP_VERSION: JSON.stringify('1.1.2') // const CONSTANTS = { APP_VERSION: '1.1.2' }\n      }\n    })\n  ]\n};\n```\n\n> 有了上面的配置，就可以在应用代码文件中，访问配置好的变量了，如：\n\n```js\nconsole.log('Running App version' + VERSION);\n\nif (!BROWSER_SUPPORTS_HTML5) require('html5shiv');\n```\n\n> 上面配置的注释已经简单说明了这些配置的效果，这里再简述一下整个配置规则。\n\n- 如果配置的值是字符串，那么整个字符串会被当成代码片段来执行，其结果作为最终变量的值，如上面的 `\"1+1\"`，最后的结果是 `2`\n- 如果配置的值不是字符串，也不是一个对象字面量，那么该值会被转为一个字符串，如 `true`，最后的结果是 `'true'`\n- 如果配置的是一个对象字面量，那么该对象的所有 `key` 会以同样的方式去定义\n- 这样我们就可以理解为什么要使用 `JSON.stringify()` 了，因为 `JSON.stringify(true)` 的结果是 `'true'`，`JSON.stringify(\"5fa3b9\")` 的结果是 `\"5fa3b9\"`。\n\n> 社区中关于 `DefinePlugin` 使用得最多的方式是定义环境变量，例如 `PRODUCTION = true` 或者 `__DEV__ = true` 等。部分类库在开发环境时依赖这样的环境变量来给予开发者更多的开发调试反馈，例如 react 等。\n\n- 建议使用 `process.env.NODE_ENV`: ... 的方式来定义 `process.env.NODE_ENV`，而不是使用 `process: {env: { NODE_ENV: ...} }` 的方式，因为这样会覆盖掉 `process` 这个对象，可能会对其他代码造成影响...\n\n#### copy-webpack-plugin\n\n> 我们一般会把开发的所有源码和资源文件放在 `src/` 目录下，构建的时候产出一个 `build/` 目录，通常会直接拿 `build` 中的所有文件来发布。有些文件没经过 `webpack` 处理，但是我们希望它们也能出现在 `build` 目录下，这时就可以使用 `CopyWebpackPlugin` 来处理了...\n\n```js\nconst CopyWebpackPlugin = require('copy-webpack-plugin');\n\nmodule.exports = {\n  // ...\n  plugins: [\n    new CopyWebpackPlugin([\n      { from: 'src/file.txt', to: 'build/file.txt' }, // 顾名思义，from 配置来源，to 配置目标路径\n      { from: 'src/*.ico', to: 'build/*.ico' } // 配置项可以使用 glob\n      // 可以配置很多项复制规则\n    ])\n  ]\n};\n```\n\n#### extract-text-webpack-plugin\n\n> 我们用它来把依赖的 `CSS` 分离出来成为单独的文件。这里再看一下使用 `extract-text-webpack-plugin` 的配置\n\n```js\nconst ExtractTextPlugin = require('extract-text-webpack-plugin');\n\nmodule.exports = {\n  // ...\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        // 因为这个插件需要干涉模块转换的内容，所以需要使用它对应的 loader\n        use: ExtractTextPlugin.extract({\n          fallback: 'style-loader',\n          use: 'css-loader'\n        })\n      }\n    ]\n  },\n  plugins: [\n    // 引入插件，配置文件名，这里同样可以使用 [hash]\n    new ExtractTextPlugin('index.css')\n  ]\n};\n```\n\n> 在上述的配置中，我们使用了 `index.css` 作为单独分离出来的文件名，但有的时候构建入口不止一个，`extract-text-webpack-plugin` 会为每一个入口创建单独分离的文件，因此最好这样配置\n\n```js\n// 这样确保在使用多个构建入口时，生成不同名称的文件\nplugins: [\n  new ExtractTextPlugin('[name].css'),\n],\n```\n\n### 更好使用 webpack-dev-server\n\n> `webpack-dev-server` 是 `webpack` 官方提供的一个工具，可以基于当前的 `webpack` 构建配置快速启动一个静态服务。当 `mode` 为 `development` 时，会具备 `hot reload` 的功能，即当源码文件变化时，会即时更新当前页面，以便你看到最新的效果...\n\n#### 基础使用\n\n> `webpack-dev-server` 是一个 `npm package`，安装后在已经有 `webpack` 配置文件的项目目录下直接启动就可以\n\n- `webpack-dev-server` 默认使用 `8080` 端口\n\n```bash\nnpm install webpack-dev-server -g\nwebpack-dev-server --mode development\n```\n\n> `package` 中的 `scripts` 配置：\n\n```js\n{\n  // ...\n  \"scripts\": {\n    \"start\": \"webpack-dev-server --mode development\"\n  }\n}\n```\n\n#### 配置\n\n> 在 webpack 的配置中，可以通过 `devServer` 字段来配置 `webpack-dev-server`，如端口设置、启动 `gzip` 压缩等，这里简单讲解几个常用的配置\n\n- `public` 字段用于指定静态服务的域名，默认是 `http://localhost:8080/` ，当你使用 `Nginx` 来做反向代理时，应该就需要使用该配置来指定 `Nginx` 配置使用的服务域名\n- `port` 字段用于指定静态服务的端口，如上，默认是 `8080`，通常情况下都不需要改动\n- `publicPath` 字段用于指定构建好的静态文件在浏览器中用什么路径去访问，默认是 `/`，例如，对于一个构建好的文件 `bundle.js`，完整的访问路径是 `http://localhost:8080/bundle.js`，如果你配置了 `publicPath: 'assets/'`，那么上述 `bundle.js` 的完整访问路径就是 `http://localhost:8080/assets/bundle.js`。可以使用整个 `URL` 来作为 `publicPath` 的值，如 `publicPath: 'http://localhost:8080/assets/'`。如果你使用了 `HMR`，那么要设置 `publicPath` 就必须使用完整的 `URL`\n\n> 建议将 `devServer.publicPath` 和 `output.publicPath` 的值保持一致\n\n- `proxy` 用于配置 `webpack-dev-server` 将特定 `URL` 的请求代理到另外一台服务器上。当你有单独的后端开发服务器用于请求 API 时，这个配置相当有用。例如\n\n```js\nproxy: {\n  '/api': {\n    target: \"http://localhost:3000\", // 将 URL 中带有 /api 的请求代理到本地的 3000 端口的服务上\n    pathRewrite: {'^/api': ''}, // 把 URL 中 path 部分的 `api` 移除掉\n  },\n}\n```\n\n- `before` 和 `after` 配置用于在 `webpack-dev-server` 定义额外的中间件，如\n\n```js\nbefore(app){\n  app.get('/some/path', function(req, res) { // 当访问 /some/path 路径时，返回自定义的 json 数据\n    res.json({custom: 'response'})\n  })\n}\n```\n\n- `before` 在 `webpack-dev-server` 静态资源中间件处理之前，可以用于拦截部分请求返回特定内容，或者实现简单的数据 `mock`。\n- `after` 在 `webpack-dev-server` 静态资源中间件处理之后，比较少用到，可以用于打印日志或者做一些额外处理...\n\n### 开发和生产环境的构建配置差异\n\n- 我们在日常的前端开发工作中，一般都会有两套构建环境：一套开发时使用，构建结果用于本地开发调试，不进行代码压缩，打印 `debug` 信息，包含 `sourcemap` 文件\n- 另外一套构建后的结果是直接应用于线上的，即代码都是压缩后，运行时不打印 `debug` 信息，静态文件不包括 `sourcemap` 的。有的时候可能还需要多一套测试环境，在运行时直接进行请求 `mock` 等工作\n- `webpack 4.x` 版本引入了 `mode` 的概念，在运行 `webpack` 时需要指定使用 `production` 或 `development` 两个 `mode` 其中一个，这个功能也就是我们所需要的运行两套构建环境的能力。\n\n#### 在配置文件中区分 mode\n\n> 之前我们的配置文件都是直接对外暴露一个 `JS` 对象，这种方式暂时没有办法获取到 `webpack` 的 `mode` 参数，我们需要更换一种方式来处理配置。根据官方的文档多种配置类型，配置文件可以对外暴露一个函数，因此我们可以这样做\n\n```js\nmodule.exports = (env, argv) => ({\n  // ... 其他配置\n  optimization: {\n    minimize: false,\n    // 使用 argv 来获取 mode 参数的值\n    minimizer:\n      argv.mode === 'production'\n        ? [\n            new UglifyJsPlugin({\n              /* 你自己的配置 */\n            })\n            // 仅在我们要自定义压缩配置时才需要这么做\n            // mode 为 production 时 webpack 会默认使用压缩 JS 的 plugin\n          ]\n        : []\n  }\n});\n```\n\n> 这样获取 `mode` 之后，我们就能够区分不同的构建环境，然后根据不同环境再对特殊的 `loader` 或 `plugin` 做额外的配置就可以了\n\n- 以上是 `webpack 4.x` 的做法，由于有了 `mode` 参数，区分环境变得简单了。不过在当前业界，估计还是使用 `webpack 3.x` 版本的居多，所以这里也简单介绍一下 `3.x` 如何区分环境\n\n> `webpack` 的运行时环境是 `Node.js`，我们可以通过 `Node.js` 提供的机制给要运行的 `webpack` 程序传递环境变量，来控制不同环境下的构建行为。例如，我们在 `npm` 中的 `scripts` 字段添加一个用于生产环境的构建命令...\n\n```js\n{\n  \"scripts\": {\n    \"build\": \"NODE_ENV=production webpack\",\n    \"develop\": \"NODE_ENV=development webpack-dev-server\"\n  }\n}\n```\n\n> 然后在 `webpack.config.js` 文件中可以通过 `process.env.NODE_ENV` 来获取命令传入的环境变量\n\n```js\nconst config = {\n  // ... webpack 配置\n};\n\nif (process.env.NODE_ENV === 'production') {\n  // 生产环境需要做的事情，如使用代码压缩插件等\n  config.plugins.push(new UglifyJsPlugin());\n}\n\nmodule.exports = config;\n```\n\n#### 运行时的环境变量\n\n> 我们使用 webpack 时传递的 mode 参数，是可以在我们的应用代码运行时，通过 `process.env.NODE_ENV` 这个变量获取的。这样方便我们在运行时判断当前执行的构建环境，使用最多的场景莫过于控制是否打印 `debug` 信息...\n\n- 下面这个简单的例子，在应用开发的代码中实现一个简单的 `console` 打印封装\n\n```js\nexport default function log(...args) {\n  if (process.env.NODE_ENV === 'development' && console && console.log) {\n    console.log.apply(console, args);\n  }\n}\n```\n\n> 同样，以上是 `webpack 4.x` 的做法，下面简单介绍一下 `3.x` 版本应该如何实现。这里需要用到 `DefinePlugin` 插件，它可以帮助我们在构建时给运行时定义变量，那么我们只要在前面 `webpack 3.x` 版本区分构建环境的例子的基础上，再使用 `DefinePlugin` 添加环境变量即可影响到运行时的代码...\n\n```js\nmodule.exports = {\n  // ...\n  // webpack 的配置\n\n  plugins: [\n    new webpack.DefinePlugin({\n      // webpack 3.x 的 process.env.NODE_ENV 是通过手动在命令行中指定 NODE_ENV=... 的方式来传递的\n      'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV)\n    })\n  ]\n};\n```\n\n#### 常见的环境差异配置\n\n**常见的 webpack 构建差异配置**\n\n- 生产环境可能需要分离 `CSS` 成单独的文件，以便多个页面共享同一个 `CSS` 文件\n- 生产环境需要压缩 `HTML/CSS/JS` 代码\n- 生产环境需要压缩图片\n- 开发环境需要生成 `sourcemap` 文件\n- 开发环境需要打印 `debug` 信息\n- 开发环境需要 `live reload` 或者 `hot reload` 的功能...\n\n> `webpack 4.x` 的 `mode` 已经提供了上述差异配置的大部分功能，`mode` 为 `production` 时默认使用 `JS` 代码压缩，而 `mode` 为 `development` 时默认启用 `hot` `reload`，等等。这样让我们的配置更为简洁，我们只需要针对特别使用的 `loader` 和 `plugin` 做区分配置就可以了...\n\n- `webpack 3.x` 版本还是只能自己动手修改配置来满足大部分环境差异需求，所以如果你要开始一个新的项目，建议直接使用 `webpack 4.x` 版本\n\n#### 拆分配置\n\n> 前面我们列出了几个环境差异配置，可能这些构建需求就已经有点多了，会让整个 `webpack` 的配置变得复杂，尤其是有着大量环境变量判断的配置。我们可以把 `webpack` 的配置按照不同的环境拆分成多个文件，运行时直接根据环境变量加载对应的配置即可。基本的划分如下...\n\n- `webpack.base.js`：基础部分，即多个文件中共享的配置\n- `webpack.development.js`：开发环境使用的配置\n- `webpack.production.js`：生产环境使用的配置\n- `webpack.test.js`：测试环境使用的配置...\n\n**如何处理这样的配置拆分**\n\n> 首先我们要明白，对于 `webpack` 的配置，其实是对外暴露一个 `JS` 对象，所以对于这个对象，我们都可以用 `JS` 代码来修改它，例如\n\n```js\nconst config = {\n  // ... webpack 配置\n};\n\n// 我们可以修改这个 config 来调整配置，例如添加一个新的插件\nconfig.plugins.push(new YourPlugin());\n\nmodule.exports = config;\n```\n\n> 因此，只要有一个工具能比较智能地合并多个配置对象，我们就可以很轻松地拆分 webpack 配置，然后通过判断环境变量，使用工具将对应环境的多个配置对象整合后提供给 webpack 使用。这个工具就是 **[webpack-merge](https://github.com/survivejs/webpack-merge)**\n\n- 我们的 webpack 配置基础部分，即 `webpack.base.js` 应该大致是这样的\n\n```js\nmodule.exports = {\n  entry: '...',\n  output: {\n    // ...\n  },\n  resolve: {\n    // ...\n  },\n  module: {\n    // 这里是一个简单的例子，后面介绍 API 时会用到\n    rules: [\n      {\n        test: /\\.js$/,\n        use: ['babel']\n      }\n    ]\n    // ...\n  },\n  plugins: [\n    // ...\n  ]\n};\n```\n\n> 然后 `webpack.development.js` 需要添加 `loader` 或 `plugin`，就可以使用 `webpack-merge` 的 `API`，例如\n\n```js\nconst {smart} = require('webpack-merge')\nconst webpack = require('webpack')\nconst base = require('./webpack.base.js')\n\nmodule.exports = smart(base, {\n  module: {\n    rules: [\n      // 用 smart API，当这里的匹配规则相同且 use 值都是数组时，smart 会识别后处理\n      // 和上述 base 配置合并后，这里会是 {test: /\\.js$/, use: ['babel', 'coffee'] }\n      // 如果这里 use 的值用的是字符串或者对象的话，那么会替换掉原本的规则 use 的值\n      {\n        test: /\\.js$/,\n        use: ['coffee'],\n      },\n      // ...\n    ],\n  },\n  plugins: [\n    // plugins 这里的数组会和 base 中的 plugins 数组进行合并\n    new webpack.DefinePlugin({\n      'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV),\n    }),\n  ],\n})；\n```\n\n> 可见 `webpack-merge` 提供的 `smart` 方法，可以帮助我们更加轻松地处理 `loader` 配置的合并。`webpack-merge` 还有其他 `API` 可以用于自定义合并行为\n\n#### 完整代码\n\n> `webpack.config.js`\n\n```js\nmodule.exports = function(env, argv) {\n  return argv.mode === 'production'\n    ? require('./configs/webpack.production')\n    : require('./configs/webpack.development');\n};\n```\n\n> `configs/webpack.base.js`\n\n```js\nconst path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  entry: './src/index.js',\n\n  output: {\n    path: path.resolve(__dirname, '../dist'),\n    filename: '[name].js'\n  },\n\n  module: {\n    rules: [\n      {\n        test: /\\.jsx?/,\n        include: [path.resolve(__dirname, '../src')],\n        use: 'babel-loader'\n      },\n      {\n        test: /\\.(png|jpg|gif)$/,\n        use: [\n          {\n            loader: 'file-loader'\n          }\n        ]\n      }\n    ]\n  },\n\n  plugins: [\n    new HtmlWebpackPlugin({\n      filename: 'index.html', // 配置输出文件名和路径\n      template: 'src/index.html' // 配置文件模板\n    })\n  ]\n};\n```\n\n> `configs/webpack.development.js`\n\n```js\nconst webpack = require('webpack');\nconst merge = require('webpack-merge');\nconst baseConfig = require('./webpack.base');\n\nconst config = merge.smart(baseConfig, {\n  module: {\n    rules: [\n      {\n        enforce: 'pre',\n        test: /\\.jsx?$/,\n        exclude: /node_modules/,\n        loader: 'eslint-loader'\n      },\n      {\n        test: /\\.less$/,\n        use: ['style-loader', 'css-loader', 'less-loader']\n      }\n    ]\n  },\n\n  devServer: {\n    port: '1234',\n    before(app) {\n      app.get('/api/test.json', function(req, res) {\n        res.json({ code: 200, message: 'hello world' });\n      });\n    }\n  }\n});\n\nconfig.plugins.push(\n  new webpack.DefinePlugin({\n    __DEV__: JSON.stringify(true)\n  })\n);\n\nmodule.exports = config;\n```\n\n> `configs/webpack.production.js`\n\n```js\nconst merge = require('webpack-merge');\nconst ExtractTextPlugin = require('extract-text-webpack-plugin');\nconst baseConfig = require('./webpack.base');\n\nconst config = merge.smart(baseConfig, {\n  module: {\n    rules: [\n      {\n        test: /\\.less$/,\n        use: ExtractTextPlugin.extract({\n          fallback: 'style-loader',\n          use: [\n            {\n              loader: 'css-loader',\n              options: {\n                minimize: true\n              }\n            },\n            'less-loader'\n          ]\n        })\n      }\n    ]\n  }\n});\n\nconfig.plugins.push(new ExtractTextPlugin('[name].css'));\n\nmodule.exports = config;\n```\n\n### 模块热替换提高开发效率\n\n> `HMR` 全称是 `Hot Module Replacement`，即模块热替换。在这个概念出来之前，我们使用过 `Hot Reloading`，当代码变更时通知浏览器刷新页面，以避免频繁手动刷新浏览器页面。HMR 可以理解为增强版的 `Hot Reloading`，但不用整个页面刷新，而是局部替换掉部分模块代码并且使其生效，可以看到代码变更后的效果。所以，`HMR` 既避免了频繁手动刷新页面，也减少了页面刷新时的等待，可以极大地提高前端页面开发效率...\n\n#### 配置使用 HMR\n\n> `HMR` 是 `webpack` 提供的非常有用的一个功能，跟我们之前提到的一样，安装好 `webpack-dev-server`， 添加一些简单的配置，即在 `webpack` 的配置文件中添加启用 `HMR` 需要的两个插件\n\n```js\nconst webpack = require('webpack');\n\nmodule.exports = {\n  // ...\n  devServer: {\n    hot: true // dev server 的配置要启动 hot，或者在命令行中带参数开启\n  },\n  plugins: [\n    // ...\n    new webpack.NamedModulesPlugin(), // 用于启动 HMR 时可以显示模块的相对路径\n    new webpack.HotModuleReplacementPlugin() // Hot Module Replacement 的插件\n  ]\n};\n```\n\n#### module.hot 常见的 API\n\n> 前面 `HMR` 实现部分已经讲解了实现 HMR 接口的重要性，下面来看看常见的 `module.hot` `API` 有哪些，以及如何使用\n\n- `module.hot.accept` 方法指定在应用特定代码模块更新时执行相应的 `callback`，第一个参数可以是字符串或者数组，如\n\n```js\nif (module.hot) {\n  module.hot.accept(['./bar.js', './index.css'], () => {\n    // ... 这样当 bar.js 或者 index.css 更新时都会执行该函数\n  });\n}\n```\n\n- `module.hot.decline` 对于指定的代码模块，拒绝进行模块代码的更新，进入更新失败状态，如 `module.hot.decline('./bar.js')`。这个方法比较少用到\n- `module.hot.dispose` 用于添加一个处理函数，在当前模块代码被替换时运行该函数，例如\n\n```js\nif (module.hot) {\n  module.hot.dispose(data => {\n    // data 用于传递数据，如果有需要传递的数据可以挂在 data 对象上，然后在模块代码更新后可以通过 module.hot.data 来获取\n  });\n}\n```\n\n- `module.hot.accept` 通常用于指定当前依赖的某个模块更新时需要做的处理，如果是当前模块更新时需要处理的动作，使用 `module.hot.dispose` 会更加容易方便\n- `module.hot.removeDisposeHandler` 用于移除 `dispose` 方法添加的 `callback`\n\n### 图片加载优化\n\n#### CSS Sprites\n\n- 如果你使用的 `webpack 3.x` 版本，需要 `CSS Sprites` 的话，可以使用 `webpack-spritesmith` 或者 `sprite-webpack-plugin`。\n- 我们以 `webpack-spritesmith` 为例，先安装依赖...\n\n```js\nmodule: {\n  loaders: [\n    // ... 这里需要有处理图片的 loader，如 file-loader\n  ]\n},\nresolve: {\n  modules: [\n    'node_modules',\n    'spritesmith-generated', // webpack-spritesmith 生成所需文件的目录\n  ],\n},\nplugins: [\n  new SpritesmithPlugin({\n    src: {\n      cwd: path.resolve(__dirname, 'src/ico'), // 多个图片所在的目录\n      glob: '*.png' // 匹配图片的路径\n    },\n    target: {\n      // 生成最终图片的路径\n      image: path.resolve(__dirname, 'src/spritesmith-generated/sprite.png'),\n      // 生成所需 SASS/LESS/Stylus mixins 代码，我们使用 Stylus 预处理器做例子\n      css: path.resolve(__dirname, 'src/spritesmith-generated/sprite.styl'),\n    },\n    apiOptions: {\n      cssImageRef: \"~sprite.png\"\n    },\n  }),\n],\n```\n\n> 在你需要的样式代码中引入 `sprite.styl` 后调用需要的 `mixins` 即可\n\n```plain\n@import '~sprite.styl'\n\n.close-button\n    sprite($close)\n.open-button\n    sprite($open)\n```\n\n> 如果你使用的是 `webpack 4.x`，你需要配合使用 `postcss` 和 `postcss-sprites`，才能实现 `CSS Sprites` 的相关构建\n\n#### 图片压缩\n\n- 在一般的项目中，图片资源会占前端资源的很大一部分，既然代码都进行压缩了，占大头的图片就更不用说了\n- 我们之前提及使用 `file-loader` 来处理图片文件，在此基础上，我们再添加一个 `image-webpack-loader` 来压缩图片文件。简单的配置如下...\n\n```js\nmodule.exports = {\n  // ...\n  module: {\n    rules: [\n      {\n        test: /.*\\.(gif|png|jpe?g|svg|webp)$/i,\n        use: [\n          {\n            loader: 'file-loader',\n            options: {}\n          },\n          {\n            loader: 'image-webpack-loader',\n            options: {\n              mozjpeg: { // 压缩 jpeg 的配置\n                progressive: true,\n                quality: 65\n              },\n              optipng: { // 使用 imagemin-optipng 压缩 png，enable: false 为关闭\n                enabled: false,\n              },\n              pngquant: { // 使用 imagemin-pngquant 压缩 png\n                quality: '65-90',\n                speed: 4\n              },\n              gifsicle: { // 压缩 gif 的配置\n                interlaced: false,\n              },\n              webp: { // 开启 webp，会把 jpg 和 png 图片压缩为 webp 格式\n                quality: 75\n              },\n          },\n        ],\n      },\n    ],\n  },\n};\n```\n\n#### 使用 DataURL\n\n> 有的时候我们的项目中会有一些很小的图片，因为某些缘故并不想使用 `CSS Sprites` 的方式来处理（譬如小图片不多，因此引入 CSS Sprites 感觉麻烦），那么我们可以在 webpack 中使用 `url-loader` 来处理这些很小的图片...\n\n- `url-loader` 和 `file-loader` 的功能类似，但是在处理文件的时候，可以通过配置指定一个大小，当文件小于这个配置值时，`url-loader` 会将其转换为一个 `base64` 编码的 `DataURL`，配置如下\n\n```js\nmodule.exports = {\n  // ...\n  module: {\n    rules: [\n      {\n        test: /\\.(png|jpg|gif)$/,\n        use: [\n          {\n            loader: 'url-loader',\n            options: {\n              limit: 8192 // 单位是 Byte，当文件小于 8KB 时作为 DataURL 处理\n            }\n          }\n        ]\n      }\n    ]\n  }\n};\n```\n\n#### 代码压缩\n\n- `webpack 4.x` 版本运行时，`mode` 为 `production` 即会启动压缩 `JS` 代码的插件，而对于 `webpack` `3.x`，使用压缩 `JS` 代码插件的方式也已经介绍过了。在生产环境中，压缩 `JS` 代码基本是一个必不可少的步骤，这样可以大大减小 `JavaScript` 的体积，相关内容这里不再赘述。\n- 除了 JS 代码之外，我们一般还需要 HTML 和 CSS 文件，这两种文件也都是可以压缩的，虽然不像 JS 的压缩那么彻底（替换掉长变量等），只能移除空格换行等无用字符，但也能在一定程度上减小文件大小。在 webpack 中的配置使用也不是特别麻烦，所以我们通常也会使用。\n- 对于 HTML 文件，之前介绍的 `html-webpack-plugin` 插件可以帮助我们生成需要的 HTML 并对其进行压缩...\n\n```js\nmodule.exports = {\n  // ...\n  plugins: [\n    new HtmlWebpackPlugin({\n      filename: 'index.html', // 配置输出文件名和路径\n      template: 'assets/index.html', // 配置文件模板\n      minify: {\n        // 压缩 HTML 的配置\n        minifyCSS: true, // 压缩 HTML 中出现的 CSS 代码\n        minifyJS: true // 压缩 HTML 中出现的 JS 代码\n      }\n    })\n  ]\n};\n```\n\n- 如上，使用 `minify` 字段配置就可以使用 `HTML` 压缩，这个插件是使用 `html-minifier` 来实现 `HTML` 代码压缩的，`minify` 下的配置项直接透传给 `html-minifier`，配置项参考 `html-minifier` 文档即可。\n- 对于 CSS 文件，我们之前介绍过用来处理 CSS 文件的 `css-loader`，也提供了压缩 CSS 代码的功能：\n\n```js\nmodule.exports = {\n  module: {\n    rules: [\n      // ...\n      {\n        test: /\\.css/,\n        include: [path.resolve(__dirname, 'src')],\n        use: [\n          'style-loader',\n          {\n            loader: 'css-loader',\n            options: {\n              minimize: true // 使用 css 的压缩功能\n            }\n          }\n        ]\n      }\n    ]\n  }\n};\n```\n\n> 在 `css-loader` 的选项中配置 `minimize` 字段为 `true` 来使用 `CSS` 压缩代码的功能。`css-loader` 是使用 `cssnano` 来压缩代码的，`minimize` 字段也可以配置为一个对象，来将相关配置传递给 `cssnano`\n\n### 分离代码文件\n\n- 关于分离 CSS 文件这个主题，之前在介绍如何搭建基本的前端开发环境时有提及，在 `webpack` 中使用 `extract-text-webpack-plugin` 插件即可。\n- 先简单解释一下为何要把 CSS 文件分离出来，而不是直接一起打包在 JS 中。最主要的原因是我们希望更好地利用缓存。\n- 假设我们原本页面的静态资源都打包成一个 JS 文件，加载页面时虽然只需要加载一个 JS 文件，但是我们的代码一旦改变了，用户访问新的页面时就需要重新加载一个新的 JS 文件。有些情况下，我们只是单独修改了样式，这样也要重新加载整个应用的 JS 文件，相当不划算。\n- 还有一种情况是我们有多个页面，它们都可以共用一部分样式（这是很常见的，CSS Reset、基础组件样式等基本都是跨页面通用），如果每个页面都单独打包一个 JS 文件，那么每次访问页面都会重复加载原本可以共享的那些 CSS 代码。如果分离开来，第二个页面就有了 CSS 文件的缓存，访问速度自然会加快。虽然对第一个页面来说多了一个请求，但是对随后的页面来说，缓存带来的速度提升相对更加可观\n\n> `3.x` 以前的版本是使用 `CommonsChunkPlugin` 来做代码分离的，而 `webpack 4.x` 则是把相关的功能包到了 `optimize.splitChunks` 中，直接使用该配置就可以实现代码分离。\n\n#### webpack 4.x 的 optimization\n\n```js\nmodule.exports = {\n  // ... webpack 配置\n\n  optimization: {\n    splitChunks: {\n      chunks: 'all' // 所有的 chunks 代码公共的部分分离出来成为一个单独的文件\n    }\n  }\n};\n```\n\n> 我们需要在 HTML 中引用两个构建出来的 JS 文件，并且 `commons.js` 需要在入口代码之前。下面是个简单的例子\n\n```html\n<script src=\"commons.js\" charset=\"utf-8\"></script>\n<script src=\"entry.bundle.js\" charset=\"utf-8\"></script>\n```\n\n> 如果你使用了 `html-webpack-plugin`，那么对应需要的 JS 文件都会在 HTML 文件中正确引用，不用担心。如果没有使用，那么你需要从 `stats` 的 `entrypoints` 属性来获取入口应该引用哪些 JS 文件，可以参考 Node API 了解如何从 stats 中获取信息\n\n**显式配置共享类库可以这么操作**\n\n```js\nmodule.exports = {\n  entry: {\n    vendor: [\"react\", \"lodash\", \"angular\", ...], // 指定公共使用的第三方类库\n  },\n  optimization: {\n    splitChunks: {\n      cacheGroups: {\n        vendor: {\n          chunks: \"initial\",\n          test: \"vendor\",\n          name: \"vendor\", // 使用 vendor 入口作为公共部分\n          enforce: true,\n        },\n      },\n    },\n  },\n  // ... 其他配置\n}\n\n// 或者\nmodule.exports = {\n  optimization: {\n    splitChunks: {\n      cacheGroups: {\n        vendor: {\n          test: /react|angluar|lodash/, // 直接使用 test 来做路径匹配\n          chunks: \"initial\",\n          name: \"vendor\",\n          enforce: true,\n        },\n      },\n    },\n  },\n}\n\n// 或者\nmodule.exports = {\n  optimization: {\n    splitChunks: {\n      cacheGroups: {\n        vendor: {\n          chunks: \"initial\",\n          test: path.resolve(__dirname, \"node_modules\") // 路径在 node_modules 目录下的都作为公共部分\n          name: \"vendor\", // 使用 vendor 入口作为公共部分\n          enforce: true,\n        },\n      },\n    },\n  },\n}\n```\n\n> 上述第一种做法是显示指定哪些类库作为公共部分，第二种做法实现的功能差不多，只是利用了 test 来做模块路径的匹配，第三种做法是把所有在 node_modules 下的模块，即作为依赖安装的，都作为公共部分。你可以针对项目情况，选择最合适的做法\n\n#### webpack 3.x 的 CommonsChunkPlugin\n\n> `webpack 3.x` 以下的版本需要用到 webpack 自身提供的 `CommonsChunkPlugin` 插件。我们先来看一个最简单的例子\n\n```js\nmodule.exports = {\n  // ...\n  plugins: [\n    new webpack.optimize.CommonsChunkPlugin({\n      name: 'commons', // 公共使用的 chunk 的名称\n      filename: 'commons.js', // 公共 chunk 的生成文件名\n      minChunks: 3 // 公共的部分必须被 3 个 chunk 共享\n    })\n  ]\n};\n```\n\n- `chunk` 在这里是构建的主干，可以简单理解为一个入口对应一个 `chunk`。\n- 以上插件配置在构建后会生成一个 `commons.js` 文件，该文件就是代码中的公共部分。上面的配置中 `minChunks` 字段为 3，该字段的意思是当一个模块被 3 个以上的 `chunk` 依赖时，这个模块就会被划分到 `commons chunk` 中去。单从这个配置的角度上讲，这种方式并没有 `4.x` 的 `chunks: \"all\"` 那么方便。\n\n**CommonsChunkPlugin 也是支持显式配置共享类库的**\n\n```js\nmodule.exports = {\n  entry: {\n    vendor: ['react', 'react-redux'], // 指定公共使用的第三方类库\n    app: './src/entry',\n    // ...\n  },\n  // ...\n  plugins: [\n    new webpack.optimize.CommonsChunkPlugin({\n      name: 'vendor' // 使用 vendor 入口作为公共部分\n      filename: \"vendor.js\",\n      minChunks: Infinity, // 这个配置会让 webpack 不再自动抽离公共模块\n    }),\n  ],\n}\n```\n\n> 上述配置会生成一个名为 `vendor.js` 的共享代码文件，里面包含了 `React` 和 `React-Redux` 库的代码，可以提供给多个不同的入口代码使用。这里的 `minChunks` 字段的配置，我们使用了 `Infinity`，可以理解为 `webpack` 不自动抽离公共模块。如果这里和之前一样依旧设置为 3，那么被 3 个以上的 `chunk` 依赖的模块会和 `React`、`React-Redux` 一同打包进 `vendor`，这样就失去显式指定的意义了。\n\n> `minChunks` 其实还可以是一个函数，如：\n\n```js\nminChunks: (module, count) => {\n  console.log(module, count);\n  return true;\n},\n```\n\n> 该函数在分析每一个依赖的时候会被调用，传入当前依赖模块的信息 `module`，以及已经被作为公共模块的数量 `count`，你可以在函数中针对每一个模块做更加精细化的控制。看一个简单的例子：\n\n```js\nminChunks: (module, count) => {\n  return module.context && module.context.includes(\"node_modules\");\n  // node_modules 目录下的模块都作为公共部分，效果就如同 webpack 4.x 中的 test: path.resolve(__dirname, \"node_modules\")\n},\n```\n\n- 更多使用 `CommonsChunkPlugin` 的配置参考官方文档 `commons-chunk-plugin`。\n\n### 进一步控制 JS 大小\n\n#### 按需加载模块\n\n> 在 webpack 的构建环境中，要按需加载代码模块很简单，遵循 ES 标准的动态加载语法 `dynamic-import` 来编写代码即可，`webpack` 会自动处理使用该语法编写的模块\n\n```js\n// import 作为一个方法使用，传入模块名即可，返回一个 promise 来获取模块暴露的对象\n// 注释 webpackChunkName: \"lodash\" 可以用于指定 chunk 的名称，在输出文件时有用\nimport(/* webpackChunkName: \"lodash\" */ 'lodash').then((_) => {\n  console.log(_.lash([1, 2, 3])) // 打印 3\n})\n```\n\n- 注意一下，如果你使用了 `Babel` 的话，还需要 `Syntax Dynamic Import` 这个 `Babel` 插件来处理 `import()` 这种语法。\n- 由于动态加载代码模块的语法依赖于 `promise`，对于低版本的浏览器，需要添加 `promise` 的 `polyfill` 后才能使用。\n- 如上的代码，webpack 构建时会自动把 `lodash` 模块分离出来，并且在代码内部实现动态加载 `lodash` 的功能。动态加载代码时依赖于网络，其模块内容会异步返回，所以 import 方法是返回一个 `promise` 来获取动态加载的模块内容。\n- `import` 后面的注释 `webpackChunkName: \"lodash\"` 用于告知 `webpack` 所要动态加载模块的名称。我们在 webpack 配置中添加一个 `output.chunkFilename` 的配置...\n\n```js\noutput: {\n  path: path.resolve(__dirname, 'dist'),\n  filename: '[name].[hash:8].js',\n  chunkFilename: '[name].[hash:8].js' // 指定分离出来的代码文件的名称\n},\n```\n\n> 这样就可以把分离出来的文件名称用 lodash 标识了，如下图：\n\n![image.png](https://upload-images.jianshu.io/upload_images/1480597-ae36b6816feed422.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n> 如果没有添加注释 `webpackChunkName: \"lodash\" 以及 output.chunkFilename` 配置，那么分离出来的文件名称会以简单数字的方式标识，不便于识别\n\n#### 以上完整示例代码\n\n```js\nconst path = require('path');\nconst webpack = require('webpack');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\nconst ExtractTextPlugin = require('extract-text-webpack-plugin');\n\nmodule.exports = {\n  entry: './src/index.js',\n\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: '[name].js'\n  },\n\n  module: {\n    rules: [\n      {\n        test: /\\.jsx?/,\n        include: [path.resolve(__dirname, 'src')],\n        use: 'babel-loader'\n      },\n      {\n        test: /\\.less$/,\n        use: ExtractTextPlugin.extract({\n          fallback: 'style-loader',\n          use: ['css-loader', 'postcss-loader', 'less-loader']\n        })\n      },\n      {\n        test: /\\.(png|jpg|gif)$/,\n        use: [\n          {\n            loader: 'url-loader',\n            options: {\n              limit: 8192\n            }\n          },\n          {\n            loader: 'image-webpack-loader',\n            options: {\n              mozjpeg: {\n                // 压缩 jpeg 的配置\n                progressive: true,\n                quality: 65\n              },\n              optipng: {\n                // 使用 imagemin-optipng 压缩 png，enable: false 为关闭\n                enabled: false\n              },\n              pngquant: {\n                // 使用 imagemin-pngquant 压缩 png\n                quality: '65-90',\n                speed: 4\n              },\n              gifsicle: {\n                // 压缩 gif 的配置\n                interlaced: false\n              },\n              webp: {\n                // 开启 webp，会把 jpg 和 png 图片压缩为 webp 格式\n                quality: 75\n              }\n            }\n          }\n        ]\n      }\n    ]\n  },\n\n  optimization: {\n    splitChunks: {\n      cacheGroups: {\n        vendor: {\n          chunks: 'initial',\n          test: path.resolve(__dirname, 'node_modules'), // 路径在 node_modules 目录下的都作为公共部分\n          name: 'vendor', // 使用 vendor 入口作为公共部分\n          enforce: true\n        }\n      }\n    }\n  },\n\n  plugins: [\n    new HtmlWebpackPlugin({\n      filename: 'index.html', // 配置输出文件名和路径\n      template: 'src/index.html', // 配置文件模板\n      minify: {\n        // 压缩 HTML 的配置\n        minifyCSS: true, // 压缩 HTML 中出现的 CSS 代码\n        minifyJS: true, // 压缩 HTML 中出现的 JS 代码\n        removeComments: true\n      }\n    }),\n    new ExtractTextPlugin('[name].css'),\n    new webpack.NamedModulesPlugin(),\n    new webpack.HotModuleReplacementPlugin()\n  ],\n\n  devServer: {\n    hot: true\n  }\n};\n```\n","slug":"webpack4-定制前端开发环境","published":1,"updated":"2019-12-07T04:59:35.928Z","layout":"post","photos":[],"link":"","_id":"ck3v60jtr000vr9q9raat5o53","content":"<p>本文总结了 Webpack 4 的一些配置点，希望通过学习这些配置点，降低使用门槛。纵观前端的打包历史，似乎是欠了太多债，有很多历史包袱，所以工程化这一块一直是一大痛点。配置繁琐，容易出错，本文总结了最新的 Webpack 4 功能点，一起来学习一下，可以点击右侧的文章目录直达。</p>\n<a id=\"more\"></a>\n<h3 id=\"webpack-概念和基础使用\"><a href=\"#webpack-概念和基础使用\" class=\"headerlink\" title=\"webpack 概念和基础使用\"></a>webpack 概念和基础使用</h3><h4 id=\"安装和使用\"><a href=\"#安装和使用\" class=\"headerlink\" title=\"安装和使用\"></a>安装和使用</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装 webpack</span></span><br><span class=\"line\">$ npm install webpack webpack-cli -g</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># or</span></span><br><span class=\"line\">$ yarn global add webpack webpack-cli</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 然后就可以全局执行命令了</span></span><br><span class=\"line\">$ webpack --<span class=\"built_in\">help</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"webpack-的基本概念\"><a href=\"#webpack-的基本概念\" class=\"headerlink\" title=\"webpack 的基本概念\"></a>webpack 的基本概念</h4><blockquote>\n<p>webpack 本质上是一个打包工具，它会根据代码的内容解析模块依赖，帮助我们把多个模块的代码打包</p>\n</blockquote>\n<p><img src=\"https://user-images.githubusercontent.com/15377484/59234564-f1cb0600-8c1f-11e9-8bdf-c6041410225a.png\" alt=\"image\"></p>\n<blockquote>\n<p>webpack 会把我们项目中使用到的多个代码模块（可以是不同文件类型），打包构建成项目运行仅需要的几个静态文件</p>\n</blockquote>\n<p><strong>入口（entry）</strong></p>\n<blockquote>\n<p>入口可以使用 <code>entry</code> 字段来进行配置，<code>webpack</code> 支持配置多个入口来进行构建</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: <span class=\"string\">'./src/index.js'</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 上述配置等同于</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    main: <span class=\"string\">'./src/index.js'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或者配置多个入口</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    foo: <span class=\"string\">'./src/page-foo.js'</span>,</span><br><span class=\"line\">    bar: <span class=\"string\">'./src/page-bar.js'</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用数组来对多个文件进行打包</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    main: [<span class=\"string\">'./src/foo.js'</span>, <span class=\"string\">'./src/bar.js'</span>]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>转换器（loader）</strong></p>\n<blockquote>\n<p>可以把 <code>loader</code> 理解为是一个转换器，负责把某种文件格式的内容转换成 webpack 可以支持打包的模块</p>\n</blockquote>\n<ul>\n<li>当我们需要使用不同的 <code>loader</code> 来解析处理不同类型的文件时，我们可以在 <code>module.rules</code> 字段下来配置相关的规则，例如使用 <code>Babel</code> 来处理 <code>.js</code> 文件</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  rules: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      test: <span class=\"regexp\">/\\.jsx?/</span>, <span class=\"comment\">// 匹配文件路径的正则表达式，通常我们都是匹配文件类型后缀</span></span><br><span class=\"line\">      include: [</span><br><span class=\"line\">        path.resolve(__dirname, <span class=\"string\">'src'</span>) <span class=\"comment\">// 指定哪些路径下的文件需要经过 loader 处理</span></span><br><span class=\"line\">      ],</span><br><span class=\"line\">      use: <span class=\"string\">'babel-loader'</span>, <span class=\"comment\">// 指定使用的 loader</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>插件（plugin）</strong></p>\n<blockquote>\n<p>模块代码转换的工作由 <code>loader</code> 来处理，除此之外的其他任何工作都可以交由 <code>plugin</code> 来完成。通过添加我们需要的 <code>plugin</code>，可以满足更多构建中特殊的需求。例如，要使用压缩 <code>JS</code> 代码的 <code>uglifyjs-webpack-plugin</code> 插件，只需在配置中通过 <code>plugins</code> 字段添加新的 <code>plugin</code> 即可…</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> UglifyPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'uglifyjs-webpack-plugin'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  plugins: [<span class=\"keyword\">new</span> UglifyPlugin()]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>plugin</code> 理论上可以干涉 <code>webpack</code> 整个构建流程，可以在流程的每一个步骤中定制自己的构建需求</p>\n</blockquote>\n<p><strong>输出（output）</strong></p>\n<blockquote>\n<p>构建结果的文件名、路径等都是可以配置的，使用 <code>output</code> 字段</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    path: path.resolve(__dirname, <span class=\"string\">'dist'</span>),</span><br><span class=\"line\">    filename: <span class=\"string\">'bundle.js'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或者多个入口生成不同文件</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    foo: <span class=\"string\">'./src/foo.js'</span>,</span><br><span class=\"line\">    bar: <span class=\"string\">'./src/bar.js'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    filename: <span class=\"string\">'[name].js'</span>,</span><br><span class=\"line\">    path: __dirname + <span class=\"string\">'/dist'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 路径中使用 hash，每次构建时会有一个不同 hash 值，避免发布新版本时线上使用浏览器缓存</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    filename: <span class=\"string\">'[name].js'</span>,</span><br><span class=\"line\">    path: __dirname + <span class=\"string\">'/dist/[hash]'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>我们一开始直接使用 <code>webpack</code> 构建时，默认创建的输出内容就是 <code>./dist/main.js</code></p>\n</blockquote>\n<p><strong>一个简单的 webpack 配置</strong></p>\n<blockquote>\n<p>我们把上述涉及的几部分配置内容合到一起，就可以创建一个简单的 <code>webpack</code> 配置了，<code>webpack</code> 运行时默认读取项目下的 <code>webpack.config.js</code> 文件作为配置。所以我们在项目中创建一个 <code>webpack.config.js</code> 文件</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> UglifyPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'uglifyjs-webpack-plugin'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: <span class=\"string\">'./src/index.js'</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    path: path.resolve(__dirname, <span class=\"string\">'dist'</span>),</span><br><span class=\"line\">    filename: <span class=\"string\">'bundle.js'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.jsx?/</span>,</span><br><span class=\"line\">        include: [path.resolve(__dirname, <span class=\"string\">'src'</span>)],</span><br><span class=\"line\">        use: <span class=\"string\">'babel-loader'</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 代码模块路径解析的配置</span></span><br><span class=\"line\">  resolve: &#123;</span><br><span class=\"line\">    modules: [<span class=\"string\">'node_modules'</span>, path.resolve(__dirname, <span class=\"string\">'src'</span>)],</span><br><span class=\"line\"></span><br><span class=\"line\">    extensions: [<span class=\"string\">'.wasm'</span>, <span class=\"string\">'.mjs'</span>, <span class=\"string\">'.js'</span>, <span class=\"string\">'.json'</span>, <span class=\"string\">'.jsx'</span>]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> UglifyPlugin()</span><br><span class=\"line\">    <span class=\"comment\">// 使用 uglifyjs-webpack-plugin 来压缩 JS 代码</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果你留意了我们一开始直接使用 webpack 构建的结果，你会发现默认已经使用了 JS 代码压缩的插件</span></span><br><span class=\"line\">    <span class=\"comment\">// 这其实也是我们命令中的 --mode production 的效果，后续的小节会介绍 webpack 的 mode 参数</span></span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"搭建基础的前端开发环境\"><a href=\"#搭建基础的前端开发环境\" class=\"headerlink\" title=\"搭建基础的前端开发环境\"></a>搭建基础的前端开发环境</h3><h4 id=\"关联-HTML\"><a href=\"#关联-HTML\" class=\"headerlink\" title=\"关联 HTML\"></a>关联 HTML</h4><blockquote>\n<p><code>webpack</code> 默认从作为入口的 <code>.js</code> 文件进行构建（更多是基于 <code>SPA</code> 去考虑），但通常一个前端项目都是从一个页面（即 HTML）出发的，最简单的方法是，创建一个 HTML 文件，使用 <code>script</code> 标签直接引用构建好的 JS 文件，如…</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=&quot;./dist/bundle.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>但是，如果我们的文件名或者路径会变化，例如使用 <code>[hash]</code> 来进行命名，那么最好是将 <code>HTML</code> 引用路径和我们的构建结果关联起来，这个时候我们可以使用 <code>html-webpack-plugin</code></li>\n<li><code>html-webpack-plugin</code> 是一个独立的 <code>node package</code>，所以在使用之前我们需要先安装它，把它安装到项目的开发依赖中</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install html-webpack-plugin -D</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>然后在 <code>webpack</code> 配置中，将 <code>html-webpack-plugin</code> 添加到 <code>plugins</code> 列表中</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> HtmlWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'html-webpack-plugin'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  plugins: [<span class=\"keyword\">new</span> HtmlWebpackPlugin()]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这样配置好之后，构建时 <code>html-webpack-plugin</code> 会为我们创建一个 <code>HTML</code> 文件，其中会引用构建出来的 JS 文件。实际项目中，默认创建的 <code>HTML</code> 文件并没有什么用，我们需要自己来写 <code>HTML</code> 文件，可以通过 <code>html-webpack-plugin</code> 的配置，传递一个写好的 HTML 模板…</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> HtmlWebpackPlugin(&#123;</span><br><span class=\"line\">      filename: <span class=\"string\">'index.html'</span>, <span class=\"comment\">// 配置输出文件名和路径</span></span><br><span class=\"line\">      template: <span class=\"string\">'assets/index.html'</span> <span class=\"comment\">// 配置文件模板</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这样，通过 <code>html-webpack-plugin</code> 就可以将我们的页面和构建 <code>JS</code> 关联起来，回归日常，从页面开始开发。如果需要添加多个页面关联，那么实例化多个 <code>html-webpack-plugin</code>， 并将它们都放到 <code>plugins</code> 字段数组中就可以了…</p>\n</blockquote>\n<h4 id=\"构建-CSS\"><a href=\"#构建-CSS\" class=\"headerlink\" title=\"构建 CSS\"></a>构建 CSS</h4><blockquote>\n<p>我们编写 <code>CSS</code>，并且希望使用 <code>webpack</code> 来进行构建，为此，需要在配置中引入 <code>loader</code> 来解析和处理 <code>CSS</code> 文件</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.css/</span>,</span><br><span class=\"line\">        include: [path.resolve(__dirname, <span class=\"string\">'src'</span>)],</span><br><span class=\"line\">        use: [<span class=\"string\">'style-loader'</span>, <span class=\"string\">'css-loader'</span>]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>css-loader</code> 负责解析 <code>CSS</code> 代码，主要是为了处理 <code>CSS</code> 中的依赖，例如 <code>@import</code> 和 <code>url()</code> 等引用外部文件的声明；</li>\n<li><code>style-loader</code> 会将 <code>css-loader</code> 解析的结果转变成 <code>JS</code> 代码，运行时动态插入 <code>style</code> 标签来让 <code>CSS</code> 代码生效…</li>\n</ul>\n<blockquote>\n<p>经由上述两个 <code>loader</code> 的处理后，CSS 代码会转变为 JS，和 <code>index.js</code> 一起打包了。如果需要单独把 CSS 文件分离出来，我们需要使用 <code>extract-text-webpack-plugin</code> 插件</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ExtractTextPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'extract-text-webpack-plugin'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.css$/</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 因为这个插件需要干涉模块转换的内容，所以需要使用它对应的 loader</span></span><br><span class=\"line\">        use: ExtractTextPlugin.extract(&#123;</span><br><span class=\"line\">          fallback: <span class=\"string\">'style-loader'</span>,</span><br><span class=\"line\">          use: <span class=\"string\">'css-loader'</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"comment\">// 引入插件，配置文件名，这里同样可以使用 [hash]</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> ExtractTextPlugin(<span class=\"string\">'index.css'</span>)</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"CSS-预处理器\"><a href=\"#CSS-预处理器\" class=\"headerlink\" title=\"CSS 预处理器\"></a>CSS 预处理器</h4><blockquote>\n<p>在上述使用 CSS 的基础上，通常我们会使用 <code>Less/Sass</code> 等 CSS 预处理器，webpack 可以通过添加对应的 <code>loader</code> 来支持，以使用 <code>Less</code> 为例，我们可以在官方文档中找到对应的 <code>loader</code></p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.less$/</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 因为这个插件需要干涉模块转换的内容，所以需要使用它对应的 loader</span></span><br><span class=\"line\">        use: ExtractTextPlugin.extract(&#123;</span><br><span class=\"line\">          fallback: <span class=\"string\">'style-loader'</span>,</span><br><span class=\"line\">          use: [<span class=\"string\">'css-loader'</span>, <span class=\"string\">'less-loader'</span>]</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"处理图片文件\"><a href=\"#处理图片文件\" class=\"headerlink\" title=\"处理图片文件\"></a>处理图片文件</h4><blockquote>\n<p>在前端项目的样式中总会使用到图片，虽然我们已经提到 <code>css-loader</code> 会解析样式中用 <code>url()</code> 引用的文件路径，但是图片对应的 <code>jpg/png/gif</code> 等文件格式，<code>webpack</code> 处理不了。是的，我们只要添加一个处理图片的 <code>loader</code> 配置就可以了，现有的 <code>file-loader</code> 就是个不错的选择…</p>\n</blockquote>\n<ul>\n<li><code>file-loader</code> 可以用于处理很多类型的文件，它的主要作用是直接输出文件，把构建后的文件路径返回。配置很简单，在 <code>rules</code> 中添加一个字段，增加图片类型文件的解析配置</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.(png|jpg|gif)$/</span>,</span><br><span class=\"line\">        use: [</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            loader: <span class=\"string\">'file-loader'</span>,</span><br><span class=\"line\">            options: &#123;&#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用-Babel\"><a href=\"#使用-Babel\" class=\"headerlink\" title=\"使用 Babel\"></a>使用 Babel</h4><blockquote>\n<p><code>Babel</code> 是一个让我们能够使用 <code>ES</code> 新特性的 <code>JS</code> 编译工具，我们可以在 <code>webpack</code> 中配置 Babel，以便使用 <code>ES6</code>、<code>ES7</code> 标准来编写 <code>JS</code> 代码</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.jsx?/</span>, <span class=\"comment\">// 支持 js 和 jsx</span></span><br><span class=\"line\">        include: [</span><br><span class=\"line\">          path.resolve(__dirname, <span class=\"string\">'src'</span>) <span class=\"comment\">// src 目录下的才需要经过 babel-loader 处理</span></span><br><span class=\"line\">        ],</span><br><span class=\"line\">        loader: <span class=\"string\">'babel-loader'</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"启动静态服务\"><a href=\"#启动静态服务\" class=\"headerlink\" title=\"启动静态服务\"></a>启动静态服务</h4><blockquote>\n<p>至此，我们完成了处理多种文件类型的 webpack 配置。我们可以使用 <code>webpack-dev-server</code> 在本地开启一个简单的静态服务来进行开发</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">  <span class=\"string\">\"build\"</span>: <span class=\"string\">\"webpack --mode production\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"start\"</span>: <span class=\"string\">\"webpack-dev-server --mode development\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>尝试着运行 <code>npm start</code> 或者 <code>yarn start</code>，然后就可以访问 <code>http://localhost:8080/</code> 来查看你的页面了。默认是访问 <code>index.html</code>，如果是其他页面要注意访问的 URL 是否正确</p>\n</blockquote>\n<h4 id=\"完整示例代码\"><a href=\"#完整示例代码\" class=\"headerlink\" title=\"完整示例代码\"></a>完整示例代码</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> HtmlWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'html-webpack-plugin'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> ExtractTextPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'extract-text-webpack-plugin'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: <span class=\"string\">'./src/index.js'</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    path: path.resolve(__dirname, <span class=\"string\">'dist'</span>),</span><br><span class=\"line\">    filename: <span class=\"string\">'[name].js'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.jsx?/</span>,</span><br><span class=\"line\">        include: [path.resolve(__dirname, <span class=\"string\">'src'</span>)],</span><br><span class=\"line\">        use: <span class=\"string\">'babel-loader'</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.less$/</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 因为这个插件需要干涉模块转换的内容，所以需要使用它对应的 loader</span></span><br><span class=\"line\">        use: ExtractTextPlugin.extract(&#123;</span><br><span class=\"line\">          fallback: <span class=\"string\">'style-loader'</span>,</span><br><span class=\"line\">          use: [<span class=\"string\">'css-loader'</span>, <span class=\"string\">'less-loader'</span>]</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.(png|jpg|gif)$/</span>,</span><br><span class=\"line\">        use: [</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            loader: <span class=\"string\">'file-loader'</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 代码模块路径解析的配置</span></span><br><span class=\"line\">  resolve: &#123;</span><br><span class=\"line\">    modules: [<span class=\"string\">'node_modules'</span>, path.resolve(__dirname, <span class=\"string\">'src'</span>)],</span><br><span class=\"line\"></span><br><span class=\"line\">    extensions: [<span class=\"string\">'.wasm'</span>, <span class=\"string\">'.mjs'</span>, <span class=\"string\">'.js'</span>, <span class=\"string\">'.json'</span>, <span class=\"string\">'.jsx'</span>]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> HtmlWebpackPlugin(&#123;</span><br><span class=\"line\">      filename: <span class=\"string\">'index.html'</span>, <span class=\"comment\">// 配置输出文件名和路径</span></span><br><span class=\"line\">      template: <span class=\"string\">'src/index.html'</span> <span class=\"comment\">// 配置文件模板</span></span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> ExtractTextPlugin(<span class=\"string\">'[name].css'</span>)</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"webpack-如何解析代码模块路径\"><a href=\"#webpack-如何解析代码模块路径\" class=\"headerlink\" title=\"webpack 如何解析代码模块路径\"></a>webpack 如何解析代码模块路径</h3><blockquote>\n<p>webpack 中有一个很关键的模块 <code>enhanced-resolve</code> 就是处理依赖模块路径的解析的，这个模块可以说是 Node.js 那一套模块路径解析的增强版本，有很多可以自定义的解析配置</p>\n</blockquote>\n<ul>\n<li>在 webpack 配置中，和模块路径解析相关的配置都在 <code>resolve</code> 字段下</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  resolve: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"常用的一些配置\"><a href=\"#常用的一些配置\" class=\"headerlink\" title=\"常用的一些配置\"></a>常用的一些配置</h4><p><strong>resolve.alias</strong></p>\n<blockquote>\n<p>假设我们有个 <code>utils</code> 模块极其常用，经常编写相对路径很麻烦，希望可以直接 <code>import &#39;utils&#39;</code> 来引用，那么我们可以配置某个模块的别名，如</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alias: &#123;</span><br><span class=\"line\">  utils: path.resolve(__dirname, <span class=\"string\">'src/utils'</span>); <span class=\"comment\">// 这里使用 path.resolve 和 __dirname 来获取绝对路径</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>上述的配置是模糊匹配，意味着只要模块路径中携带了 utils 就可以被替换掉，如：</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &apos;utils/query.js&apos; // 等同于 import &apos;[项目绝对路径]/src/utils/query.js&apos;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>如果需要进行精确匹配可以使用：</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alias: &#123;</span><br><span class=\"line\">  utils$: path.resolve(__dirname, <span class=\"string\">'src/utils'</span>); <span class=\"comment\">// 只会匹配 import 'utils'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>resolve.extensions</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">extensions: [<span class=\"string\">'.wasm'</span>, <span class=\"string\">'.mjs'</span>, <span class=\"string\">'.js'</span>, <span class=\"string\">'.json'</span>, <span class=\"string\">'.jsx'</span>],</span><br><span class=\"line\"><span class=\"comment\">// 这里的顺序代表匹配后缀的优先级，例如对于 index.js 和 index.jsx，会优先选择 index.js</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这个配置的作用是和文件后缀名有关的, 这个配置可以定义在进行模块路径解析时，webpack 会尝试帮你补全那些后缀名来进行查找</p>\n</blockquote>\n<h3 id=\"配置-loader\"><a href=\"#配置-loader\" class=\"headerlink\" title=\"配置 loader\"></a>配置 loader</h3><h4 id=\"loader-匹配规则\"><a href=\"#loader-匹配规则\" class=\"headerlink\" title=\"loader 匹配规则\"></a>loader 匹配规则</h4><blockquote>\n<p>当我们需要配置 <code>loader</code> 时，都是在 <code>module.rules</code> 中添加新的配置项，在该字段中，每一项被视为一条匹配使用 <code>loader</code> 的规则</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.jsx?/</span>, <span class=\"comment\">// 条件</span></span><br><span class=\"line\">        include: [path.resolve(__dirname, <span class=\"string\">'src'</span>)], <span class=\"comment\">// 条件</span></span><br><span class=\"line\">        use: <span class=\"string\">'babel-loader'</span> <span class=\"comment\">// 规则应用结果\u000e</span></span><br><span class=\"line\">      &#125; <span class=\"comment\">// 一个 object 即一条规则</span></span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>loader</code> 的匹配规则中有两个最关键的因素：一个是匹配条件，一个是匹配规则后的应用</p>\n</blockquote>\n<h4 id=\"规则条件配置\"><a href=\"#规则条件配置\" class=\"headerlink\" title=\"规则条件配置\"></a>规则条件配置</h4><blockquote>\n<p>大多数情况下，配置 <code>loader</code> 的匹配条件时，只要使用 <code>test</code> 字段就好了，很多时候都只需要匹配文件后缀名来决定使用什么 <code>loader</code>，但也不排除在某些特殊场景下，我们需要配置比较复杂的匹配条件。webpack 的规则提供了多种配置形式…</p>\n</blockquote>\n<ul>\n<li><code>{test: ...}</code> 匹配特定条件</li>\n<li><code>{include: ...}</code> 匹配特定路径</li>\n<li><code>{exclude: ...}</code> 排除特定路径</li>\n<li><code>{and: [...] }</code> 必须匹配数组中所有条件</li>\n<li><code>{or: [...] }</code> 匹配数组中任意一个条件</li>\n<li><code>{not: [...] }</code> 排除匹配数组中所有条件…</li>\n</ul>\n<blockquote>\n<p>上述的所谓条件的值可以是：</p>\n</blockquote>\n<ul>\n<li>字符串：必须以提供的字符串开始，所以是字符串的话，这里我们需要提供绝对路径</li>\n<li>正则表达式：调用正则的 <code>test</code> 方法来判断匹配</li>\n<li>函数：<code>(path) =&gt; boolean</code>，返回 <code>true</code> 表示匹配</li>\n<li>数组：至少包含一个条件的数组</li>\n<li>对象：匹配所有属性值的条件…</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rules: [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    test: <span class=\"regexp\">/\\.jsx?/</span>, <span class=\"comment\">// 正则</span></span><br><span class=\"line\">    include: [</span><br><span class=\"line\">      path.resolve(__dirname, <span class=\"string\">'src'</span>), <span class=\"comment\">// 字符串，注意是绝对路径</span></span><br><span class=\"line\">    ], <span class=\"comment\">// 数组</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    test: &#123;</span><br><span class=\"line\">      js: <span class=\"regexp\">/\\.js/</span>,</span><br><span class=\"line\">      jsx: <span class=\"regexp\">/\\.jsx/</span>,</span><br><span class=\"line\">    &#125;, <span class=\"comment\">// 对象，不建议使用</span></span><br><span class=\"line\">    not: [</span><br><span class=\"line\">      (value) =&gt; &#123; <span class=\"comment\">/* ... */</span> <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; &#125;, <span class=\"comment\">// 函数，通常需要高度自定义时才会使用</span></span><br><span class=\"line\">    ],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用-loader-配置\"><a href=\"#使用-loader-配置\" class=\"headerlink\" title=\"使用 loader 配置\"></a>使用 loader 配置</h4><blockquote>\n<p><code>module.rules</code> 的匹配规则最重要的还是用于配置 <code>loader</code>，我们可以使用 <code>use</code> 字段</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rules: [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    test: <span class=\"regexp\">/\\.less/</span>,</span><br><span class=\"line\">    use: [</span><br><span class=\"line\">      <span class=\"string\">'style-loader'</span>, <span class=\"comment\">// 直接使用字符串表示 loader</span></span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        loader: <span class=\"string\">'css-loader'</span>,</span><br><span class=\"line\">        options: &#123;</span><br><span class=\"line\">          importLoaders: <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      &#125;, <span class=\"comment\">// 用对象表示 loader，可以传递 loader 配置等</span></span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        loader: <span class=\"string\">'less-loader'</span>,</span><br><span class=\"line\">        options: &#123;</span><br><span class=\"line\">          noIeCompat: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;, <span class=\"comment\">// 传递 loader 配置</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    ],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>use</code> 字段可以是一个数组，也可以是一个字符串或者表示 <code>loader</code> 的对象。如果只需要一个 <code>loader</code>，也可以这样：<code>use: {loader: &#39;babel-loader&#39;</code>, <code>options: { ...} }</code></p>\n</blockquote>\n<h4 id=\"loader-应用顺序\"><a href=\"#loader-应用顺序\" class=\"headerlink\" title=\"loader 应用顺序\"></a>loader 应用顺序</h4><ul>\n<li>对于上面的 <code>less</code> 规则配置，一个 <code>style.less</code> 文件会途径 <code>less-loader</code>、<code>css-loader</code>、<code>style-loader</code> 处理，成为一个可以打包的模块。</li>\n<li><code>loader</code> 的应用顺序在配置多个 <code>loader</code> 一起工作时很重要，通常会使用在 CSS 配置上，除了 <code>style-loader</code> 和 <code>css-loader</code>，你可能还要配置 <code>less-loader</code> 然后再加个 <code>postcss</code> 的 <code>autoprefixer</code> 等。</li>\n<li>上述从后到前的顺序是在同一个 <code>rule</code> 中进行的，那如果多个 <code>rule</code> 匹配了同一个模块文件，<code>loader</code> 的应用顺序又是怎样的呢？看一份这样的配置…</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rules: [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    test: <span class=\"regexp\">/\\.js$/</span>,</span><br><span class=\"line\">    exclude: <span class=\"regexp\">/node_modules/</span>,</span><br><span class=\"line\">    loader: <span class=\"string\">\"eslint-loader\"</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    test: <span class=\"regexp\">/\\.js$/</span>,</span><br><span class=\"line\">    exclude: <span class=\"regexp\">/node_modules/</span>,</span><br><span class=\"line\">    loader: <span class=\"string\">\"babel-loader\"</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这样无法法保证 <code>eslint-loader</code> 在 <code>babel-loader</code> 应用前执行。<code>webpack</code> 在 <code>rules</code> 中提供了一个 <code>enforce</code> 的字段来配置当前 <code>rule</code> 的 <code>loader</code> 类型，没配置的话是普通类型，我们可以配置 <code>pre</code> 或 <code>post</code>，分别对应前置类型或后置类型的 <code>loader</code>…</p>\n</blockquote>\n<ul>\n<li>所有的 <code>loader</code> 按照 <strong>前置</strong> -&gt; <strong>行内</strong> -&gt; <strong>普通</strong> -&gt; <strong>后置</strong> 的顺序执行。所以当我们要确保 <code>eslint-loader</code> 在 <code>babel-loader</code> 之前执行时，可以如下添加 <code>enforce</code> 配置</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rules: [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    enforce: <span class=\"string\">'pre'</span>, <span class=\"comment\">// 指定为前置类型</span></span><br><span class=\"line\">    test: <span class=\"regexp\">/\\.js$/</span>,</span><br><span class=\"line\">    exclude: <span class=\"regexp\">/node_modules/</span>,</span><br><span class=\"line\">    loader: <span class=\"string\">\"eslint-loader\"</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>当项目文件类型和应用的 <code>loader</code> 不是特别复杂的时候，通常建议把要应用的同一类型 <code>loader</code> 都写在同一个匹配规则中，这样更好维护和控制</p>\n</blockquote>\n<h4 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> HtmlWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'html-webpack-plugin'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> ExtractTextPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'extract-text-webpack-plugin'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> CopyWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'copy-webpack-plugin'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: <span class=\"string\">'./src/index'</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    path: path.resolve(__dirname, <span class=\"string\">'dist'</span>),</span><br><span class=\"line\">    filename: <span class=\"string\">'[name].js'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        enforce: <span class=\"string\">'pre'</span>, <span class=\"comment\">// 指定为前置类型</span></span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.jsx?$/</span>,</span><br><span class=\"line\">        exclude: <span class=\"regexp\">/node_modules/</span>,</span><br><span class=\"line\">        loader: <span class=\"string\">'eslint-loader'</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.jsx?$/</span>,</span><br><span class=\"line\">        include: [path.resolve(__dirname, <span class=\"string\">'src'</span>)],</span><br><span class=\"line\">        use: <span class=\"string\">'babel-loader'</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.css$/</span>,</span><br><span class=\"line\">        use: ExtractTextPlugin.extract(&#123;</span><br><span class=\"line\">          fallback: <span class=\"string\">'style-loader'</span>,</span><br><span class=\"line\">          use: [<span class=\"string\">'css-loader'</span>]</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.less$/</span>,</span><br><span class=\"line\">        use: ExtractTextPlugin.extract(&#123;</span><br><span class=\"line\">          fallback: <span class=\"string\">'style-loader'</span>,</span><br><span class=\"line\">          use: [<span class=\"string\">'css-loader'</span>, <span class=\"string\">'less-loader'</span>]</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.(png|jpg|gif)$/</span>,</span><br><span class=\"line\">        use: [</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            loader: <span class=\"string\">'file-loader'</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  resolve: &#123;</span><br><span class=\"line\">    alias: &#123;</span><br><span class=\"line\">      utils: path.resolve(__dirname, <span class=\"string\">'src/utils'</span>), <span class=\"comment\">// 这里使用 path.resolve 和 __dirname 来获取绝对路径</span></span><br><span class=\"line\">      log$: path.resolve(__dirname, <span class=\"string\">'src/utils/log.js'</span>) <span class=\"comment\">// 只匹配 log</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    extensions: [<span class=\"string\">'.js'</span>, <span class=\"string\">'.json'</span>, <span class=\"string\">'.jsx'</span>, <span class=\"string\">'.css'</span>, <span class=\"string\">'.less'</span>],</span><br><span class=\"line\">    modules: [</span><br><span class=\"line\">      path.resolve(__dirname, <span class=\"string\">'node_modules'</span>) <span class=\"comment\">// 指定当前目录下的 node_modules 优先查找</span></span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> HtmlWebpackPlugin(&#123;</span><br><span class=\"line\">      filename: <span class=\"string\">'index.html'</span>, <span class=\"comment\">// 配置输出文件名和路径</span></span><br><span class=\"line\">      template: <span class=\"string\">'src/index.html'</span> <span class=\"comment\">// 配置文件模板</span></span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> ExtractTextPlugin(<span class=\"string\">'[name].css'</span>),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.DefinePlugin(&#123;</span><br><span class=\"line\">      TWO: <span class=\"string\">'1+1'</span>,</span><br><span class=\"line\">      CONSTANTS: &#123;</span><br><span class=\"line\">        APP_VERSION: <span class=\"built_in\">JSON</span>.stringify(<span class=\"string\">'1.1.2'</span>) <span class=\"comment\">// const CONSTANTS = &#123; APP_VERSION: '1.1.2' &#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> CopyWebpackPlugin([</span><br><span class=\"line\">      &#123; <span class=\"attr\">from</span>: <span class=\"string\">'src/assets/favicon.ico'</span>, <span class=\"attr\">to</span>: <span class=\"string\">'favicon.ico'</span> &#125; <span class=\"comment\">// 顾名思义，from 配置来源，to 配置目标路径</span></span><br><span class=\"line\">    ]),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.ProvidePlugin(&#123;</span><br><span class=\"line\">      _: <span class=\"string\">'lodash'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  ],</span><br><span class=\"line\"></span><br><span class=\"line\">  devServer: &#123;</span><br><span class=\"line\">    port: <span class=\"string\">'1234'</span>,</span><br><span class=\"line\">    before(app) &#123;</span><br><span class=\"line\">      app.get(<span class=\"string\">'/api/test.json'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当访问 /some/path 路径时，返回自定义的 json 数据</span></span><br><span class=\"line\">        res.json(&#123; <span class=\"attr\">code</span>: <span class=\"number\">200</span>, <span class=\"attr\">message</span>: <span class=\"string\">'hello world'</span> &#125;);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用-plugin\"><a href=\"#使用-plugin\" class=\"headerlink\" title=\"使用 plugin\"></a>使用 plugin</h3><blockquote>\n<p>更多的插件可以在这里查找：<a href=\"https://github.com/webpack-contrib/awesome-webpack#webpack-plugins\" target=\"_blank\" rel=\"noopener\">plugins in awesome-webpack</a></p>\n</blockquote>\n<h4 id=\"DefinePlugin\"><a href=\"#DefinePlugin\" class=\"headerlink\" title=\"DefinePlugin\"></a>DefinePlugin</h4><blockquote>\n<p><code>DefinePlugin</code> 是 <code>webpack</code> 内置的插件，可以使用 <code>webpack.DefinePlugin</code> 直接获取</p>\n</blockquote>\n<ul>\n<li>这个插件用于创建一些在编译时可以配置的全局常量，这些常量的值我们可以在 <code>webpack</code> 的配置中去指定，例如</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.DefinePlugin(&#123;</span><br><span class=\"line\">      PRODUCTION: <span class=\"built_in\">JSON</span>.stringify(<span class=\"literal\">true</span>), <span class=\"comment\">// const PRODUCTION = true</span></span><br><span class=\"line\">      VERSION: <span class=\"built_in\">JSON</span>.stringify(<span class=\"string\">'5fa3b9'</span>), <span class=\"comment\">// const VERSION = '5fa3b9'</span></span><br><span class=\"line\">      BROWSER_SUPPORTS_HTML5: <span class=\"literal\">true</span>, <span class=\"comment\">// const BROWSER_SUPPORTS_HTML5 = 'true'</span></span><br><span class=\"line\">      TWO: <span class=\"string\">'1+1'</span>, <span class=\"comment\">// const TWO = 1 + 1,</span></span><br><span class=\"line\">      CONSTANTS: &#123;</span><br><span class=\"line\">        APP_VERSION: <span class=\"built_in\">JSON</span>.stringify(<span class=\"string\">'1.1.2'</span>) <span class=\"comment\">// const CONSTANTS = &#123; APP_VERSION: '1.1.2' &#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>有了上面的配置，就可以在应用代码文件中，访问配置好的变量了，如：</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Running App version'</span> + VERSION);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!BROWSER_SUPPORTS_HTML5) <span class=\"built_in\">require</span>(<span class=\"string\">'html5shiv'</span>);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>上面配置的注释已经简单说明了这些配置的效果，这里再简述一下整个配置规则。</p>\n</blockquote>\n<ul>\n<li>如果配置的值是字符串，那么整个字符串会被当成代码片段来执行，其结果作为最终变量的值，如上面的 <code>&quot;1+1&quot;</code>，最后的结果是 <code>2</code></li>\n<li>如果配置的值不是字符串，也不是一个对象字面量，那么该值会被转为一个字符串，如 <code>true</code>，最后的结果是 <code>&#39;true&#39;</code></li>\n<li>如果配置的是一个对象字面量，那么该对象的所有 <code>key</code> 会以同样的方式去定义</li>\n<li>这样我们就可以理解为什么要使用 <code>JSON.stringify()</code> 了，因为 <code>JSON.stringify(true)</code> 的结果是 <code>&#39;true&#39;</code>，<code>JSON.stringify(&quot;5fa3b9&quot;)</code> 的结果是 <code>&quot;5fa3b9&quot;</code>。</li>\n</ul>\n<blockquote>\n<p>社区中关于 <code>DefinePlugin</code> 使用得最多的方式是定义环境变量，例如 <code>PRODUCTION = true</code> 或者 <code>__DEV__ = true</code> 等。部分类库在开发环境时依赖这样的环境变量来给予开发者更多的开发调试反馈，例如 react 等。</p>\n</blockquote>\n<ul>\n<li>建议使用 <code>process.env.NODE_ENV</code>: … 的方式来定义 <code>process.env.NODE_ENV</code>，而不是使用 <code>process: {env: { NODE_ENV: ...} }</code> 的方式，因为这样会覆盖掉 <code>process</code> 这个对象，可能会对其他代码造成影响…</li>\n</ul>\n<h4 id=\"copy-webpack-plugin\"><a href=\"#copy-webpack-plugin\" class=\"headerlink\" title=\"copy-webpack-plugin\"></a>copy-webpack-plugin</h4><blockquote>\n<p>我们一般会把开发的所有源码和资源文件放在 <code>src/</code> 目录下，构建的时候产出一个 <code>build/</code> 目录，通常会直接拿 <code>build</code> 中的所有文件来发布。有些文件没经过 <code>webpack</code> 处理，但是我们希望它们也能出现在 <code>build</code> 目录下，这时就可以使用 <code>CopyWebpackPlugin</code> 来处理了…</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> CopyWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'copy-webpack-plugin'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> CopyWebpackPlugin([</span><br><span class=\"line\">      &#123; <span class=\"attr\">from</span>: <span class=\"string\">'src/file.txt'</span>, <span class=\"attr\">to</span>: <span class=\"string\">'build/file.txt'</span> &#125;, <span class=\"comment\">// 顾名思义，from 配置来源，to 配置目标路径</span></span><br><span class=\"line\">      &#123; <span class=\"attr\">from</span>: <span class=\"string\">'src/*.ico'</span>, <span class=\"attr\">to</span>: <span class=\"string\">'build/*.ico'</span> &#125; <span class=\"comment\">// 配置项可以使用 glob</span></span><br><span class=\"line\">      <span class=\"comment\">// 可以配置很多项复制规则</span></span><br><span class=\"line\">    ])</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"extract-text-webpack-plugin\"><a href=\"#extract-text-webpack-plugin\" class=\"headerlink\" title=\"extract-text-webpack-plugin\"></a>extract-text-webpack-plugin</h4><blockquote>\n<p>我们用它来把依赖的 <code>CSS</code> 分离出来成为单独的文件。这里再看一下使用 <code>extract-text-webpack-plugin</code> 的配置</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ExtractTextPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'extract-text-webpack-plugin'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.css$/</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 因为这个插件需要干涉模块转换的内容，所以需要使用它对应的 loader</span></span><br><span class=\"line\">        use: ExtractTextPlugin.extract(&#123;</span><br><span class=\"line\">          fallback: <span class=\"string\">'style-loader'</span>,</span><br><span class=\"line\">          use: <span class=\"string\">'css-loader'</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"comment\">// 引入插件，配置文件名，这里同样可以使用 [hash]</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> ExtractTextPlugin(<span class=\"string\">'index.css'</span>)</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>在上述的配置中，我们使用了 <code>index.css</code> 作为单独分离出来的文件名，但有的时候构建入口不止一个，<code>extract-text-webpack-plugin</code> 会为每一个入口创建单独分离的文件，因此最好这样配置</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这样确保在使用多个构建入口时，生成不同名称的文件</span></span><br><span class=\"line\">plugins: [</span><br><span class=\"line\">  <span class=\"keyword\">new</span> ExtractTextPlugin(<span class=\"string\">'[name].css'</span>),</span><br><span class=\"line\">],</span><br></pre></td></tr></table></figure>\n<h3 id=\"更好使用-webpack-dev-server\"><a href=\"#更好使用-webpack-dev-server\" class=\"headerlink\" title=\"更好使用 webpack-dev-server\"></a>更好使用 webpack-dev-server</h3><blockquote>\n<p><code>webpack-dev-server</code> 是 <code>webpack</code> 官方提供的一个工具，可以基于当前的 <code>webpack</code> 构建配置快速启动一个静态服务。当 <code>mode</code> 为 <code>development</code> 时，会具备 <code>hot reload</code> 的功能，即当源码文件变化时，会即时更新当前页面，以便你看到最新的效果…</p>\n</blockquote>\n<h4 id=\"基础使用\"><a href=\"#基础使用\" class=\"headerlink\" title=\"基础使用\"></a>基础使用</h4><blockquote>\n<p><code>webpack-dev-server</code> 是一个 <code>npm package</code>，安装后在已经有 <code>webpack</code> 配置文件的项目目录下直接启动就可以</p>\n</blockquote>\n<ul>\n<li><code>webpack-dev-server</code> 默认使用 <code>8080</code> 端口</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install webpack-dev-server -g</span><br><span class=\"line\">webpack-dev-server --mode development</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>package</code> 中的 <code>scripts</code> 配置：</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"string\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"start\"</span>: <span class=\"string\">\"webpack-dev-server --mode development\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h4><blockquote>\n<p>在 webpack 的配置中，可以通过 <code>devServer</code> 字段来配置 <code>webpack-dev-server</code>，如端口设置、启动 <code>gzip</code> 压缩等，这里简单讲解几个常用的配置</p>\n</blockquote>\n<ul>\n<li><code>public</code> 字段用于指定静态服务的域名，默认是 <code>http://localhost:8080/</code> ，当你使用 <code>Nginx</code> 来做反向代理时，应该就需要使用该配置来指定 <code>Nginx</code> 配置使用的服务域名</li>\n<li><code>port</code> 字段用于指定静态服务的端口，如上，默认是 <code>8080</code>，通常情况下都不需要改动</li>\n<li><code>publicPath</code> 字段用于指定构建好的静态文件在浏览器中用什么路径去访问，默认是 <code>/</code>，例如，对于一个构建好的文件 <code>bundle.js</code>，完整的访问路径是 <code>http://localhost:8080/bundle.js</code>，如果你配置了 <code>publicPath: &#39;assets/&#39;</code>，那么上述 <code>bundle.js</code> 的完整访问路径就是 <code>http://localhost:8080/assets/bundle.js</code>。可以使用整个 <code>URL</code> 来作为 <code>publicPath</code> 的值，如 <code>publicPath: &#39;http://localhost:8080/assets/&#39;</code>。如果你使用了 <code>HMR</code>，那么要设置 <code>publicPath</code> 就必须使用完整的 <code>URL</code></li>\n</ul>\n<blockquote>\n<p>建议将 <code>devServer.publicPath</code> 和 <code>output.publicPath</code> 的值保持一致</p>\n</blockquote>\n<ul>\n<li><code>proxy</code> 用于配置 <code>webpack-dev-server</code> 将特定 <code>URL</code> 的请求代理到另外一台服务器上。当你有单独的后端开发服务器用于请求 API 时，这个配置相当有用。例如</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">proxy: &#123;</span><br><span class=\"line\">  <span class=\"string\">'/api'</span>: &#123;</span><br><span class=\"line\">    target: <span class=\"string\">\"http://localhost:3000\"</span>, <span class=\"comment\">// 将 URL 中带有 /api 的请求代理到本地的 3000 端口的服务上</span></span><br><span class=\"line\">    pathRewrite: &#123;<span class=\"string\">'^/api'</span>: <span class=\"string\">''</span>&#125;, <span class=\"comment\">// 把 URL 中 path 部分的 `api` 移除掉</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>before</code> 和 <code>after</code> 配置用于在 <code>webpack-dev-server</code> 定义额外的中间件，如</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">before(app)&#123;</span><br><span class=\"line\">  app.get(<span class=\"string\">'/some/path'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res</span>) </span>&#123; <span class=\"comment\">// 当访问 /some/path 路径时，返回自定义的 json 数据</span></span><br><span class=\"line\">    res.json(&#123;<span class=\"attr\">custom</span>: <span class=\"string\">'response'</span>&#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>before</code> 在 <code>webpack-dev-server</code> 静态资源中间件处理之前，可以用于拦截部分请求返回特定内容，或者实现简单的数据 <code>mock</code>。</li>\n<li><code>after</code> 在 <code>webpack-dev-server</code> 静态资源中间件处理之后，比较少用到，可以用于打印日志或者做一些额外处理…</li>\n</ul>\n<h3 id=\"开发和生产环境的构建配置差异\"><a href=\"#开发和生产环境的构建配置差异\" class=\"headerlink\" title=\"开发和生产环境的构建配置差异\"></a>开发和生产环境的构建配置差异</h3><ul>\n<li>我们在日常的前端开发工作中，一般都会有两套构建环境：一套开发时使用，构建结果用于本地开发调试，不进行代码压缩，打印 <code>debug</code> 信息，包含 <code>sourcemap</code> 文件</li>\n<li>另外一套构建后的结果是直接应用于线上的，即代码都是压缩后，运行时不打印 <code>debug</code> 信息，静态文件不包括 <code>sourcemap</code> 的。有的时候可能还需要多一套测试环境，在运行时直接进行请求 <code>mock</code> 等工作</li>\n<li><code>webpack 4.x</code> 版本引入了 <code>mode</code> 的概念，在运行 <code>webpack</code> 时需要指定使用 <code>production</code> 或 <code>development</code> 两个 <code>mode</code> 其中一个，这个功能也就是我们所需要的运行两套构建环境的能力。</li>\n</ul>\n<h4 id=\"在配置文件中区分-mode\"><a href=\"#在配置文件中区分-mode\" class=\"headerlink\" title=\"在配置文件中区分 mode\"></a>在配置文件中区分 mode</h4><blockquote>\n<p>之前我们的配置文件都是直接对外暴露一个 <code>JS</code> 对象，这种方式暂时没有办法获取到 <code>webpack</code> 的 <code>mode</code> 参数，我们需要更换一种方式来处理配置。根据官方的文档多种配置类型，配置文件可以对外暴露一个函数，因此我们可以这样做</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\">(<span class=\"params\">env, argv</span>) =&gt;</span> (&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ... 其他配置</span></span><br><span class=\"line\">  optimization: &#123;</span><br><span class=\"line\">    minimize: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    <span class=\"comment\">// 使用 argv 来获取 mode 参数的值</span></span><br><span class=\"line\">    minimizer:</span><br><span class=\"line\">      argv.mode === <span class=\"string\">'production'</span></span><br><span class=\"line\">        ? [</span><br><span class=\"line\">            <span class=\"keyword\">new</span> UglifyJsPlugin(&#123;</span><br><span class=\"line\">              <span class=\"comment\">/* 你自己的配置 */</span></span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">            <span class=\"comment\">// 仅在我们要自定义压缩配置时才需要这么做</span></span><br><span class=\"line\">            <span class=\"comment\">// mode 为 production 时 webpack 会默认使用压缩 JS 的 plugin</span></span><br><span class=\"line\">          ]</span><br><span class=\"line\">        : []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这样获取 <code>mode</code> 之后，我们就能够区分不同的构建环境，然后根据不同环境再对特殊的 <code>loader</code> 或 <code>plugin</code> 做额外的配置就可以了</p>\n</blockquote>\n<ul>\n<li>以上是 <code>webpack 4.x</code> 的做法，由于有了 <code>mode</code> 参数，区分环境变得简单了。不过在当前业界，估计还是使用 <code>webpack 3.x</code> 版本的居多，所以这里也简单介绍一下 <code>3.x</code> 如何区分环境</li>\n</ul>\n<blockquote>\n<p><code>webpack</code> 的运行时环境是 <code>Node.js</code>，我们可以通过 <code>Node.js</code> 提供的机制给要运行的 <code>webpack</code> 程序传递环境变量，来控制不同环境下的构建行为。例如，我们在 <code>npm</code> 中的 <code>scripts</code> 字段添加一个用于生产环境的构建命令…</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"build\"</span>: <span class=\"string\">\"NODE_ENV=production webpack\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"develop\"</span>: <span class=\"string\">\"NODE_ENV=development webpack-dev-server\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>然后在 <code>webpack.config.js</code> 文件中可以通过 <code>process.env.NODE_ENV</code> 来获取命令传入的环境变量</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> config = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ... webpack 配置</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (process.env.NODE_ENV === <span class=\"string\">'production'</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 生产环境需要做的事情，如使用代码压缩插件等</span></span><br><span class=\"line\">  config.plugins.push(<span class=\"keyword\">new</span> UglifyJsPlugin());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = config;</span><br></pre></td></tr></table></figure>\n<h4 id=\"运行时的环境变量\"><a href=\"#运行时的环境变量\" class=\"headerlink\" title=\"运行时的环境变量\"></a>运行时的环境变量</h4><blockquote>\n<p>我们使用 webpack 时传递的 mode 参数，是可以在我们的应用代码运行时，通过 <code>process.env.NODE_ENV</code> 这个变量获取的。这样方便我们在运行时判断当前执行的构建环境，使用最多的场景莫过于控制是否打印 <code>debug</code> 信息…</p>\n</blockquote>\n<ul>\n<li>下面这个简单的例子，在应用开发的代码中实现一个简单的 <code>console</code> 打印封装</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">log</span>(<span class=\"params\">...args</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (process.env.NODE_ENV === <span class=\"string\">'development'</span> &amp;&amp; <span class=\"built_in\">console</span> &amp;&amp; <span class=\"built_in\">console</span>.log) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log.apply(<span class=\"built_in\">console</span>, args);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>同样，以上是 <code>webpack 4.x</code> 的做法，下面简单介绍一下 <code>3.x</code> 版本应该如何实现。这里需要用到 <code>DefinePlugin</code> 插件，它可以帮助我们在构建时给运行时定义变量，那么我们只要在前面 <code>webpack 3.x</code> 版本区分构建环境的例子的基础上，再使用 <code>DefinePlugin</code> 添加环境变量即可影响到运行时的代码…</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"comment\">// webpack 的配置</span></span><br><span class=\"line\"></span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.DefinePlugin(&#123;</span><br><span class=\"line\">      <span class=\"comment\">// webpack 3.x 的 process.env.NODE_ENV 是通过手动在命令行中指定 NODE_ENV=... 的方式来传递的</span></span><br><span class=\"line\">      <span class=\"string\">'process.env.NODE_ENV'</span>: <span class=\"built_in\">JSON</span>.stringify(process.env.NODE_ENV)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"常见的环境差异配置\"><a href=\"#常见的环境差异配置\" class=\"headerlink\" title=\"常见的环境差异配置\"></a>常见的环境差异配置</h4><p><strong>常见的 webpack 构建差异配置</strong></p>\n<ul>\n<li>生产环境可能需要分离 <code>CSS</code> 成单独的文件，以便多个页面共享同一个 <code>CSS</code> 文件</li>\n<li>生产环境需要压缩 <code>HTML/CSS/JS</code> 代码</li>\n<li>生产环境需要压缩图片</li>\n<li>开发环境需要生成 <code>sourcemap</code> 文件</li>\n<li>开发环境需要打印 <code>debug</code> 信息</li>\n<li>开发环境需要 <code>live reload</code> 或者 <code>hot reload</code> 的功能…</li>\n</ul>\n<blockquote>\n<p><code>webpack 4.x</code> 的 <code>mode</code> 已经提供了上述差异配置的大部分功能，<code>mode</code> 为 <code>production</code> 时默认使用 <code>JS</code> 代码压缩，而 <code>mode</code> 为 <code>development</code> 时默认启用 <code>hot</code> <code>reload</code>，等等。这样让我们的配置更为简洁，我们只需要针对特别使用的 <code>loader</code> 和 <code>plugin</code> 做区分配置就可以了…</p>\n</blockquote>\n<ul>\n<li><code>webpack 3.x</code> 版本还是只能自己动手修改配置来满足大部分环境差异需求，所以如果你要开始一个新的项目，建议直接使用 <code>webpack 4.x</code> 版本</li>\n</ul>\n<h4 id=\"拆分配置\"><a href=\"#拆分配置\" class=\"headerlink\" title=\"拆分配置\"></a>拆分配置</h4><blockquote>\n<p>前面我们列出了几个环境差异配置，可能这些构建需求就已经有点多了，会让整个 <code>webpack</code> 的配置变得复杂，尤其是有着大量环境变量判断的配置。我们可以把 <code>webpack</code> 的配置按照不同的环境拆分成多个文件，运行时直接根据环境变量加载对应的配置即可。基本的划分如下…</p>\n</blockquote>\n<ul>\n<li><code>webpack.base.js</code>：基础部分，即多个文件中共享的配置</li>\n<li><code>webpack.development.js</code>：开发环境使用的配置</li>\n<li><code>webpack.production.js</code>：生产环境使用的配置</li>\n<li><code>webpack.test.js</code>：测试环境使用的配置…</li>\n</ul>\n<p><strong>如何处理这样的配置拆分</strong></p>\n<blockquote>\n<p>首先我们要明白，对于 <code>webpack</code> 的配置，其实是对外暴露一个 <code>JS</code> 对象，所以对于这个对象，我们都可以用 <code>JS</code> 代码来修改它，例如</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> config = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ... webpack 配置</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 我们可以修改这个 config 来调整配置，例如添加一个新的插件</span></span><br><span class=\"line\">config.plugins.push(<span class=\"keyword\">new</span> YourPlugin());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = config;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>因此，只要有一个工具能比较智能地合并多个配置对象，我们就可以很轻松地拆分 webpack 配置，然后通过判断环境变量，使用工具将对应环境的多个配置对象整合后提供给 webpack 使用。这个工具就是 <strong><a href=\"https://github.com/survivejs/webpack-merge\" target=\"_blank\" rel=\"noopener\">webpack-merge</a></strong></p>\n</blockquote>\n<ul>\n<li>我们的 webpack 配置基础部分，即 <code>webpack.base.js</code> 应该大致是这样的</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: <span class=\"string\">'...'</span>,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  resolve: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里是一个简单的例子，后面介绍 API 时会用到</span></span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.js$/</span>,</span><br><span class=\"line\">        use: [<span class=\"string\">'babel'</span>]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>然后 <code>webpack.development.js</code> 需要添加 <code>loader</code> 或 <code>plugin</code>，就可以使用 <code>webpack-merge</code> 的 <code>API</code>，例如</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123;smart&#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack-merge'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> base = <span class=\"built_in\">require</span>(<span class=\"string\">'./webpack.base.js'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = smart(base, &#123;</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      <span class=\"comment\">// 用 smart API，当这里的匹配规则相同且 use 值都是数组时，smart 会识别后处理</span></span><br><span class=\"line\">      <span class=\"comment\">// 和上述 base 配置合并后，这里会是 &#123;test: /\\.js$/, use: ['babel', 'coffee'] &#125;</span></span><br><span class=\"line\">      <span class=\"comment\">// 如果这里 use 的值用的是字符串或者对象的话，那么会替换掉原本的规则 use 的值</span></span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.js$/</span>,</span><br><span class=\"line\">        use: [<span class=\"string\">'coffee'</span>],</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">    ],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"comment\">// plugins 这里的数组会和 base 中的 plugins 数组进行合并</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.DefinePlugin(&#123;</span><br><span class=\"line\">      <span class=\"string\">'process.env.NODE_ENV'</span>: <span class=\"built_in\">JSON</span>.stringify(process.env.NODE_ENV),</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;)；</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>可见 <code>webpack-merge</code> 提供的 <code>smart</code> 方法，可以帮助我们更加轻松地处理 <code>loader</code> 配置的合并。<code>webpack-merge</code> 还有其他 <code>API</code> 可以用于自定义合并行为</p>\n</blockquote>\n<h4 id=\"完整代码-1\"><a href=\"#完整代码-1\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h4><blockquote>\n<p><code>webpack.config.js</code></p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">env, argv</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> argv.mode === <span class=\"string\">'production'</span></span><br><span class=\"line\">    ? <span class=\"built_in\">require</span>(<span class=\"string\">'./configs/webpack.production'</span>)</span><br><span class=\"line\">    : <span class=\"built_in\">require</span>(<span class=\"string\">'./configs/webpack.development'</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>configs/webpack.base.js</code></p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> HtmlWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'html-webpack-plugin'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: <span class=\"string\">'./src/index.js'</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    path: path.resolve(__dirname, <span class=\"string\">'../dist'</span>),</span><br><span class=\"line\">    filename: <span class=\"string\">'[name].js'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.jsx?/</span>,</span><br><span class=\"line\">        include: [path.resolve(__dirname, <span class=\"string\">'../src'</span>)],</span><br><span class=\"line\">        use: <span class=\"string\">'babel-loader'</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.(png|jpg|gif)$/</span>,</span><br><span class=\"line\">        use: [</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            loader: <span class=\"string\">'file-loader'</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> HtmlWebpackPlugin(&#123;</span><br><span class=\"line\">      filename: <span class=\"string\">'index.html'</span>, <span class=\"comment\">// 配置输出文件名和路径</span></span><br><span class=\"line\">      template: <span class=\"string\">'src/index.html'</span> <span class=\"comment\">// 配置文件模板</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>configs/webpack.development.js</code></p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> merge = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack-merge'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> baseConfig = <span class=\"built_in\">require</span>(<span class=\"string\">'./webpack.base'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> config = merge.smart(baseConfig, &#123;</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        enforce: <span class=\"string\">'pre'</span>,</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.jsx?$/</span>,</span><br><span class=\"line\">        exclude: <span class=\"regexp\">/node_modules/</span>,</span><br><span class=\"line\">        loader: <span class=\"string\">'eslint-loader'</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.less$/</span>,</span><br><span class=\"line\">        use: [<span class=\"string\">'style-loader'</span>, <span class=\"string\">'css-loader'</span>, <span class=\"string\">'less-loader'</span>]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  devServer: &#123;</span><br><span class=\"line\">    port: <span class=\"string\">'1234'</span>,</span><br><span class=\"line\">    before(app) &#123;</span><br><span class=\"line\">      app.get(<span class=\"string\">'/api/test.json'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">        res.json(&#123; <span class=\"attr\">code</span>: <span class=\"number\">200</span>, <span class=\"attr\">message</span>: <span class=\"string\">'hello world'</span> &#125;);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">config.plugins.push(</span><br><span class=\"line\">  <span class=\"keyword\">new</span> webpack.DefinePlugin(&#123;</span><br><span class=\"line\">    __DEV__: <span class=\"built_in\">JSON</span>.stringify(<span class=\"literal\">true</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = config;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>configs/webpack.production.js</code></p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> merge = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack-merge'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> ExtractTextPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'extract-text-webpack-plugin'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> baseConfig = <span class=\"built_in\">require</span>(<span class=\"string\">'./webpack.base'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> config = merge.smart(baseConfig, &#123;</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.less$/</span>,</span><br><span class=\"line\">        use: ExtractTextPlugin.extract(&#123;</span><br><span class=\"line\">          fallback: <span class=\"string\">'style-loader'</span>,</span><br><span class=\"line\">          use: [</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">              loader: <span class=\"string\">'css-loader'</span>,</span><br><span class=\"line\">              options: &#123;</span><br><span class=\"line\">                minimize: <span class=\"literal\">true</span></span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"string\">'less-loader'</span></span><br><span class=\"line\">          ]</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">config.plugins.push(<span class=\"keyword\">new</span> ExtractTextPlugin(<span class=\"string\">'[name].css'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = config;</span><br></pre></td></tr></table></figure>\n<h3 id=\"模块热替换提高开发效率\"><a href=\"#模块热替换提高开发效率\" class=\"headerlink\" title=\"模块热替换提高开发效率\"></a>模块热替换提高开发效率</h3><blockquote>\n<p><code>HMR</code> 全称是 <code>Hot Module Replacement</code>，即模块热替换。在这个概念出来之前，我们使用过 <code>Hot Reloading</code>，当代码变更时通知浏览器刷新页面，以避免频繁手动刷新浏览器页面。HMR 可以理解为增强版的 <code>Hot Reloading</code>，但不用整个页面刷新，而是局部替换掉部分模块代码并且使其生效，可以看到代码变更后的效果。所以，<code>HMR</code> 既避免了频繁手动刷新页面，也减少了页面刷新时的等待，可以极大地提高前端页面开发效率…</p>\n</blockquote>\n<h4 id=\"配置使用-HMR\"><a href=\"#配置使用-HMR\" class=\"headerlink\" title=\"配置使用 HMR\"></a>配置使用 HMR</h4><blockquote>\n<p><code>HMR</code> 是 <code>webpack</code> 提供的非常有用的一个功能，跟我们之前提到的一样，安装好 <code>webpack-dev-server</code>， 添加一些简单的配置，即在 <code>webpack</code> 的配置文件中添加启用 <code>HMR</code> 需要的两个插件</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  devServer: &#123;</span><br><span class=\"line\">    hot: <span class=\"literal\">true</span> <span class=\"comment\">// dev server 的配置要启动 hot，或者在命令行中带参数开启</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.NamedModulesPlugin(), <span class=\"comment\">// 用于启动 HMR 时可以显示模块的相对路径</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.HotModuleReplacementPlugin() <span class=\"comment\">// Hot Module Replacement 的插件</span></span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"module-hot-常见的-API\"><a href=\"#module-hot-常见的-API\" class=\"headerlink\" title=\"module.hot 常见的 API\"></a>module.hot 常见的 API</h4><blockquote>\n<p>前面 <code>HMR</code> 实现部分已经讲解了实现 HMR 接口的重要性，下面来看看常见的 <code>module.hot</code> <code>API</code> 有哪些，以及如何使用</p>\n</blockquote>\n<ul>\n<li><code>module.hot.accept</code> 方法指定在应用特定代码模块更新时执行相应的 <code>callback</code>，第一个参数可以是字符串或者数组，如</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">module</span>.hot) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">module</span>.hot.accept([<span class=\"string\">'./bar.js'</span>, <span class=\"string\">'./index.css'</span>], () =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ... 这样当 bar.js 或者 index.css 更新时都会执行该函数</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>module.hot.decline</code> 对于指定的代码模块，拒绝进行模块代码的更新，进入更新失败状态，如 <code>module.hot.decline(&#39;./bar.js&#39;)</code>。这个方法比较少用到</li>\n<li><code>module.hot.dispose</code> 用于添加一个处理函数，在当前模块代码被替换时运行该函数，例如</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">module</span>.hot) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">module</span>.hot.dispose(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// data 用于传递数据，如果有需要传递的数据可以挂在 data 对象上，然后在模块代码更新后可以通过 module.hot.data 来获取</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>module.hot.accept</code> 通常用于指定当前依赖的某个模块更新时需要做的处理，如果是当前模块更新时需要处理的动作，使用 <code>module.hot.dispose</code> 会更加容易方便</li>\n<li><code>module.hot.removeDisposeHandler</code> 用于移除 <code>dispose</code> 方法添加的 <code>callback</code></li>\n</ul>\n<h3 id=\"图片加载优化\"><a href=\"#图片加载优化\" class=\"headerlink\" title=\"图片加载优化\"></a>图片加载优化</h3><h4 id=\"CSS-Sprites\"><a href=\"#CSS-Sprites\" class=\"headerlink\" title=\"CSS Sprites\"></a>CSS Sprites</h4><ul>\n<li>如果你使用的 <code>webpack 3.x</code> 版本，需要 <code>CSS Sprites</code> 的话，可以使用 <code>webpack-spritesmith</code> 或者 <code>sprite-webpack-plugin</code>。</li>\n<li>我们以 <code>webpack-spritesmith</code> 为例，先安装依赖…</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">  loaders: [</span><br><span class=\"line\">    <span class=\"comment\">// ... 这里需要有处理图片的 loader，如 file-loader</span></span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">resolve: &#123;</span><br><span class=\"line\">  modules: [</span><br><span class=\"line\">    <span class=\"string\">'node_modules'</span>,</span><br><span class=\"line\">    <span class=\"string\">'spritesmith-generated'</span>, <span class=\"comment\">// webpack-spritesmith 生成所需文件的目录</span></span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">plugins: [</span><br><span class=\"line\">  <span class=\"keyword\">new</span> SpritesmithPlugin(&#123;</span><br><span class=\"line\">    src: &#123;</span><br><span class=\"line\">      cwd: path.resolve(__dirname, <span class=\"string\">'src/ico'</span>), <span class=\"comment\">// 多个图片所在的目录</span></span><br><span class=\"line\">      glob: <span class=\"string\">'*.png'</span> <span class=\"comment\">// 匹配图片的路径</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    target: &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 生成最终图片的路径</span></span><br><span class=\"line\">      image: path.resolve(__dirname, <span class=\"string\">'src/spritesmith-generated/sprite.png'</span>),</span><br><span class=\"line\">      <span class=\"comment\">// 生成所需 SASS/LESS/Stylus mixins 代码，我们使用 Stylus 预处理器做例子</span></span><br><span class=\"line\">      css: path.resolve(__dirname, <span class=\"string\">'src/spritesmith-generated/sprite.styl'</span>),</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    apiOptions: &#123;</span><br><span class=\"line\">      cssImageRef: <span class=\"string\">\"~sprite.png\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;),</span><br><span class=\"line\">],</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>在你需要的样式代码中引入 <code>sprite.styl</code> 后调用需要的 <code>mixins</code> 即可</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@import &apos;~sprite.styl&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">.close-button</span><br><span class=\"line\">    sprite($close)</span><br><span class=\"line\">.open-button</span><br><span class=\"line\">    sprite($open)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>如果你使用的是 <code>webpack 4.x</code>，你需要配合使用 <code>postcss</code> 和 <code>postcss-sprites</code>，才能实现 <code>CSS Sprites</code> 的相关构建</p>\n</blockquote>\n<h4 id=\"图片压缩\"><a href=\"#图片压缩\" class=\"headerlink\" title=\"图片压缩\"></a>图片压缩</h4><ul>\n<li>在一般的项目中，图片资源会占前端资源的很大一部分，既然代码都进行压缩了，占大头的图片就更不用说了</li>\n<li>我们之前提及使用 <code>file-loader</code> 来处理图片文件，在此基础上，我们再添加一个 <code>image-webpack-loader</code> 来压缩图片文件。简单的配置如下…</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/.*\\.(gif|png|jpe?g|svg|webp)$/i</span>,</span><br><span class=\"line\">        use: [</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            loader: <span class=\"string\">'file-loader'</span>,</span><br><span class=\"line\">            options: &#123;&#125;</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            loader: <span class=\"string\">'image-webpack-loader'</span>,</span><br><span class=\"line\">            options: &#123;</span><br><span class=\"line\">              mozjpeg: &#123; <span class=\"comment\">// 压缩 jpeg 的配置</span></span><br><span class=\"line\">                progressive: <span class=\"literal\">true</span>,</span><br><span class=\"line\">                quality: <span class=\"number\">65</span></span><br><span class=\"line\">              &#125;,</span><br><span class=\"line\">              optipng: &#123; <span class=\"comment\">// 使用 imagemin-optipng 压缩 png，enable: false 为关闭</span></span><br><span class=\"line\">                enabled: <span class=\"literal\">false</span>,</span><br><span class=\"line\">              &#125;,</span><br><span class=\"line\">              pngquant: &#123; <span class=\"comment\">// 使用 imagemin-pngquant 压缩 png</span></span><br><span class=\"line\">                quality: <span class=\"string\">'65-90'</span>,</span><br><span class=\"line\">                speed: <span class=\"number\">4</span></span><br><span class=\"line\">              &#125;,</span><br><span class=\"line\">              gifsicle: &#123; <span class=\"comment\">// 压缩 gif 的配置</span></span><br><span class=\"line\">                interlaced: <span class=\"literal\">false</span>,</span><br><span class=\"line\">              &#125;,</span><br><span class=\"line\">              webp: &#123; <span class=\"comment\">// 开启 webp，会把 jpg 和 png 图片压缩为 webp 格式</span></span><br><span class=\"line\">                quality: <span class=\"number\">75</span></span><br><span class=\"line\">              &#125;,</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">        ],</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    ],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用-DataURL\"><a href=\"#使用-DataURL\" class=\"headerlink\" title=\"使用 DataURL\"></a>使用 DataURL</h4><blockquote>\n<p>有的时候我们的项目中会有一些很小的图片，因为某些缘故并不想使用 <code>CSS Sprites</code> 的方式来处理（譬如小图片不多，因此引入 CSS Sprites 感觉麻烦），那么我们可以在 webpack 中使用 <code>url-loader</code> 来处理这些很小的图片…</p>\n</blockquote>\n<ul>\n<li><code>url-loader</code> 和 <code>file-loader</code> 的功能类似，但是在处理文件的时候，可以通过配置指定一个大小，当文件小于这个配置值时，<code>url-loader</code> 会将其转换为一个 <code>base64</code> 编码的 <code>DataURL</code>，配置如下</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.(png|jpg|gif)$/</span>,</span><br><span class=\"line\">        use: [</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            loader: <span class=\"string\">'url-loader'</span>,</span><br><span class=\"line\">            options: &#123;</span><br><span class=\"line\">              limit: <span class=\"number\">8192</span> <span class=\"comment\">// 单位是 Byte，当文件小于 8KB 时作为 DataURL 处理</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"代码压缩\"><a href=\"#代码压缩\" class=\"headerlink\" title=\"代码压缩\"></a>代码压缩</h4><ul>\n<li><code>webpack 4.x</code> 版本运行时，<code>mode</code> 为 <code>production</code> 即会启动压缩 <code>JS</code> 代码的插件，而对于 <code>webpack</code> <code>3.x</code>，使用压缩 <code>JS</code> 代码插件的方式也已经介绍过了。在生产环境中，压缩 <code>JS</code> 代码基本是一个必不可少的步骤，这样可以大大减小 <code>JavaScript</code> 的体积，相关内容这里不再赘述。</li>\n<li>除了 JS 代码之外，我们一般还需要 HTML 和 CSS 文件，这两种文件也都是可以压缩的，虽然不像 JS 的压缩那么彻底（替换掉长变量等），只能移除空格换行等无用字符，但也能在一定程度上减小文件大小。在 webpack 中的配置使用也不是特别麻烦，所以我们通常也会使用。</li>\n<li>对于 HTML 文件，之前介绍的 <code>html-webpack-plugin</code> 插件可以帮助我们生成需要的 HTML 并对其进行压缩…</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> HtmlWebpackPlugin(&#123;</span><br><span class=\"line\">      filename: <span class=\"string\">'index.html'</span>, <span class=\"comment\">// 配置输出文件名和路径</span></span><br><span class=\"line\">      template: <span class=\"string\">'assets/index.html'</span>, <span class=\"comment\">// 配置文件模板</span></span><br><span class=\"line\">      minify: &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 压缩 HTML 的配置</span></span><br><span class=\"line\">        minifyCSS: <span class=\"literal\">true</span>, <span class=\"comment\">// 压缩 HTML 中出现的 CSS 代码</span></span><br><span class=\"line\">        minifyJS: <span class=\"literal\">true</span> <span class=\"comment\">// 压缩 HTML 中出现的 JS 代码</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>如上，使用 <code>minify</code> 字段配置就可以使用 <code>HTML</code> 压缩，这个插件是使用 <code>html-minifier</code> 来实现 <code>HTML</code> 代码压缩的，<code>minify</code> 下的配置项直接透传给 <code>html-minifier</code>，配置项参考 <code>html-minifier</code> 文档即可。</li>\n<li>对于 CSS 文件，我们之前介绍过用来处理 CSS 文件的 <code>css-loader</code>，也提供了压缩 CSS 代码的功能：</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.css/</span>,</span><br><span class=\"line\">        include: [path.resolve(__dirname, <span class=\"string\">'src'</span>)],</span><br><span class=\"line\">        use: [</span><br><span class=\"line\">          <span class=\"string\">'style-loader'</span>,</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            loader: <span class=\"string\">'css-loader'</span>,</span><br><span class=\"line\">            options: &#123;</span><br><span class=\"line\">              minimize: <span class=\"literal\">true</span> <span class=\"comment\">// 使用 css 的压缩功能</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>在 <code>css-loader</code> 的选项中配置 <code>minimize</code> 字段为 <code>true</code> 来使用 <code>CSS</code> 压缩代码的功能。<code>css-loader</code> 是使用 <code>cssnano</code> 来压缩代码的，<code>minimize</code> 字段也可以配置为一个对象，来将相关配置传递给 <code>cssnano</code></p>\n</blockquote>\n<h3 id=\"分离代码文件\"><a href=\"#分离代码文件\" class=\"headerlink\" title=\"分离代码文件\"></a>分离代码文件</h3><ul>\n<li>关于分离 CSS 文件这个主题，之前在介绍如何搭建基本的前端开发环境时有提及，在 <code>webpack</code> 中使用 <code>extract-text-webpack-plugin</code> 插件即可。</li>\n<li>先简单解释一下为何要把 CSS 文件分离出来，而不是直接一起打包在 JS 中。最主要的原因是我们希望更好地利用缓存。</li>\n<li>假设我们原本页面的静态资源都打包成一个 JS 文件，加载页面时虽然只需要加载一个 JS 文件，但是我们的代码一旦改变了，用户访问新的页面时就需要重新加载一个新的 JS 文件。有些情况下，我们只是单独修改了样式，这样也要重新加载整个应用的 JS 文件，相当不划算。</li>\n<li>还有一种情况是我们有多个页面，它们都可以共用一部分样式（这是很常见的，CSS Reset、基础组件样式等基本都是跨页面通用），如果每个页面都单独打包一个 JS 文件，那么每次访问页面都会重复加载原本可以共享的那些 CSS 代码。如果分离开来，第二个页面就有了 CSS 文件的缓存，访问速度自然会加快。虽然对第一个页面来说多了一个请求，但是对随后的页面来说，缓存带来的速度提升相对更加可观</li>\n</ul>\n<blockquote>\n<p><code>3.x</code> 以前的版本是使用 <code>CommonsChunkPlugin</code> 来做代码分离的，而 <code>webpack 4.x</code> 则是把相关的功能包到了 <code>optimize.splitChunks</code> 中，直接使用该配置就可以实现代码分离。</p>\n</blockquote>\n<h4 id=\"webpack-4-x-的-optimization\"><a href=\"#webpack-4-x-的-optimization\" class=\"headerlink\" title=\"webpack 4.x 的 optimization\"></a>webpack 4.x 的 optimization</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ... webpack 配置</span></span><br><span class=\"line\"></span><br><span class=\"line\">  optimization: &#123;</span><br><span class=\"line\">    splitChunks: &#123;</span><br><span class=\"line\">      chunks: <span class=\"string\">'all'</span> <span class=\"comment\">// 所有的 chunks 代码公共的部分分离出来成为一个单独的文件</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>我们需要在 HTML 中引用两个构建出来的 JS 文件，并且 <code>commons.js</code> 需要在入口代码之前。下面是个简单的例子</p>\n</blockquote>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"commons.js\"</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"utf-8\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"entry.bundle.js\"</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"utf-8\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>如果你使用了 <code>html-webpack-plugin</code>，那么对应需要的 JS 文件都会在 HTML 文件中正确引用，不用担心。如果没有使用，那么你需要从 <code>stats</code> 的 <code>entrypoints</code> 属性来获取入口应该引用哪些 JS 文件，可以参考 Node API 了解如何从 stats 中获取信息</p>\n</blockquote>\n<p><strong>显式配置共享类库可以这么操作</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    vendor: [<span class=\"string\">\"react\"</span>, <span class=\"string\">\"lodash\"</span>, <span class=\"string\">\"angular\"</span>, ...], <span class=\"comment\">// 指定公共使用的第三方类库</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  optimization: &#123;</span><br><span class=\"line\">    splitChunks: &#123;</span><br><span class=\"line\">      cacheGroups: &#123;</span><br><span class=\"line\">        vendor: &#123;</span><br><span class=\"line\">          chunks: <span class=\"string\">\"initial\"</span>,</span><br><span class=\"line\">          test: <span class=\"string\">\"vendor\"</span>,</span><br><span class=\"line\">          name: <span class=\"string\">\"vendor\"</span>, <span class=\"comment\">// 使用 vendor 入口作为公共部分</span></span><br><span class=\"line\">          enforce: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// ... 其他配置</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或者</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  optimization: &#123;</span><br><span class=\"line\">    splitChunks: &#123;</span><br><span class=\"line\">      cacheGroups: &#123;</span><br><span class=\"line\">        vendor: &#123;</span><br><span class=\"line\">          test: <span class=\"regexp\">/react|angluar|lodash/</span>, <span class=\"comment\">// 直接使用 test 来做路径匹配</span></span><br><span class=\"line\">          chunks: <span class=\"string\">\"initial\"</span>,</span><br><span class=\"line\">          name: <span class=\"string\">\"vendor\"</span>,</span><br><span class=\"line\">          enforce: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或者</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  optimization: &#123;</span><br><span class=\"line\">    splitChunks: &#123;</span><br><span class=\"line\">      cacheGroups: &#123;</span><br><span class=\"line\">        vendor: &#123;</span><br><span class=\"line\">          chunks: <span class=\"string\">\"initial\"</span>,</span><br><span class=\"line\">          test: path.resolve(__dirname, <span class=\"string\">\"node_modules\"</span>) <span class=\"comment\">// 路径在 node_modules 目录下的都作为公共部分</span></span><br><span class=\"line\">          name: <span class=\"string\">\"vendor\"</span>, <span class=\"comment\">// 使用 vendor 入口作为公共部分</span></span><br><span class=\"line\">          enforce: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>上述第一种做法是显示指定哪些类库作为公共部分，第二种做法实现的功能差不多，只是利用了 test 来做模块路径的匹配，第三种做法是把所有在 node_modules 下的模块，即作为依赖安装的，都作为公共部分。你可以针对项目情况，选择最合适的做法</p>\n</blockquote>\n<h4 id=\"webpack-3-x-的-CommonsChunkPlugin\"><a href=\"#webpack-3-x-的-CommonsChunkPlugin\" class=\"headerlink\" title=\"webpack 3.x 的 CommonsChunkPlugin\"></a>webpack 3.x 的 CommonsChunkPlugin</h4><blockquote>\n<p><code>webpack 3.x</code> 以下的版本需要用到 webpack 自身提供的 <code>CommonsChunkPlugin</code> 插件。我们先来看一个最简单的例子</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class=\"line\">      name: <span class=\"string\">'commons'</span>, <span class=\"comment\">// 公共使用的 chunk 的名称</span></span><br><span class=\"line\">      filename: <span class=\"string\">'commons.js'</span>, <span class=\"comment\">// 公共 chunk 的生成文件名</span></span><br><span class=\"line\">      minChunks: <span class=\"number\">3</span> <span class=\"comment\">// 公共的部分必须被 3 个 chunk 共享</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>chunk</code> 在这里是构建的主干，可以简单理解为一个入口对应一个 <code>chunk</code>。</li>\n<li>以上插件配置在构建后会生成一个 <code>commons.js</code> 文件，该文件就是代码中的公共部分。上面的配置中 <code>minChunks</code> 字段为 3，该字段的意思是当一个模块被 3 个以上的 <code>chunk</code> 依赖时，这个模块就会被划分到 <code>commons chunk</code> 中去。单从这个配置的角度上讲，这种方式并没有 <code>4.x</code> 的 <code>chunks: &quot;all&quot;</code> 那么方便。</li>\n</ul>\n<p><strong>CommonsChunkPlugin 也是支持显式配置共享类库的</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    vendor: [<span class=\"string\">'react'</span>, <span class=\"string\">'react-redux'</span>], <span class=\"comment\">// 指定公共使用的第三方类库</span></span><br><span class=\"line\">    app: <span class=\"string\">'./src/entry'</span>,</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class=\"line\">      name: <span class=\"string\">'vendor'</span> <span class=\"comment\">// 使用 vendor 入口作为公共部分</span></span><br><span class=\"line\">      filename: <span class=\"string\">\"vendor.js\"</span>,</span><br><span class=\"line\">      minChunks: <span class=\"literal\">Infinity</span>, <span class=\"comment\">// 这个配置会让 webpack 不再自动抽离公共模块</span></span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>上述配置会生成一个名为 <code>vendor.js</code> 的共享代码文件，里面包含了 <code>React</code> 和 <code>React-Redux</code> 库的代码，可以提供给多个不同的入口代码使用。这里的 <code>minChunks</code> 字段的配置，我们使用了 <code>Infinity</code>，可以理解为 <code>webpack</code> 不自动抽离公共模块。如果这里和之前一样依旧设置为 3，那么被 3 个以上的 <code>chunk</code> 依赖的模块会和 <code>React</code>、<code>React-Redux</code> 一同打包进 <code>vendor</code>，这样就失去显式指定的意义了。</p>\n</blockquote>\n<blockquote>\n<p><code>minChunks</code> 其实还可以是一个函数，如：</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">minChunks: <span class=\"function\">(<span class=\"params\"><span class=\"built_in\">module</span>, count</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">module</span>, count);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>该函数在分析每一个依赖的时候会被调用，传入当前依赖模块的信息 <code>module</code>，以及已经被作为公共模块的数量 <code>count</code>，你可以在函数中针对每一个模块做更加精细化的控制。看一个简单的例子：</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">minChunks: <span class=\"function\">(<span class=\"params\"><span class=\"built_in\">module</span>, count</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">module</span>.context &amp;&amp; <span class=\"built_in\">module</span>.context.includes(<span class=\"string\">\"node_modules\"</span>);</span><br><span class=\"line\">  <span class=\"comment\">// node_modules 目录下的模块都作为公共部分，效果就如同 webpack 4.x 中的 test: path.resolve(__dirname, \"node_modules\")</span></span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<ul>\n<li>更多使用 <code>CommonsChunkPlugin</code> 的配置参考官方文档 <code>commons-chunk-plugin</code>。</li>\n</ul>\n<h3 id=\"进一步控制-JS-大小\"><a href=\"#进一步控制-JS-大小\" class=\"headerlink\" title=\"进一步控制 JS 大小\"></a>进一步控制 JS 大小</h3><h4 id=\"按需加载模块\"><a href=\"#按需加载模块\" class=\"headerlink\" title=\"按需加载模块\"></a>按需加载模块</h4><blockquote>\n<p>在 webpack 的构建环境中，要按需加载代码模块很简单，遵循 ES 标准的动态加载语法 <code>dynamic-import</code> 来编写代码即可，<code>webpack</code> 会自动处理使用该语法编写的模块</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// import 作为一个方法使用，传入模块名即可，返回一个 promise 来获取模块暴露的对象</span></span><br><span class=\"line\"><span class=\"comment\">// 注释 webpackChunkName: \"lodash\" 可以用于指定 chunk 的名称，在输出文件时有用</span></span><br><span class=\"line\"><span class=\"keyword\">import</span>(<span class=\"comment\">/* webpackChunkName: \"lodash\" */</span> <span class=\"string\">'lodash'</span>).then(<span class=\"function\">(<span class=\"params\">_</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(_.lash([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>])) <span class=\"comment\">// 打印 3</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>注意一下，如果你使用了 <code>Babel</code> 的话，还需要 <code>Syntax Dynamic Import</code> 这个 <code>Babel</code> 插件来处理 <code>import()</code> 这种语法。</li>\n<li>由于动态加载代码模块的语法依赖于 <code>promise</code>，对于低版本的浏览器，需要添加 <code>promise</code> 的 <code>polyfill</code> 后才能使用。</li>\n<li>如上的代码，webpack 构建时会自动把 <code>lodash</code> 模块分离出来，并且在代码内部实现动态加载 <code>lodash</code> 的功能。动态加载代码时依赖于网络，其模块内容会异步返回，所以 import 方法是返回一个 <code>promise</code> 来获取动态加载的模块内容。</li>\n<li><code>import</code> 后面的注释 <code>webpackChunkName: &quot;lodash&quot;</code> 用于告知 <code>webpack</code> 所要动态加载模块的名称。我们在 webpack 配置中添加一个 <code>output.chunkFilename</code> 的配置…</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">output: &#123;</span><br><span class=\"line\">  path: path.resolve(__dirname, <span class=\"string\">'dist'</span>),</span><br><span class=\"line\">  filename: <span class=\"string\">'[name].[hash:8].js'</span>,</span><br><span class=\"line\">  chunkFilename: <span class=\"string\">'[name].[hash:8].js'</span> <span class=\"comment\">// 指定分离出来的代码文件的名称</span></span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这样就可以把分离出来的文件名称用 lodash 标识了，如下图：</p>\n</blockquote>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/1480597-ae36b6816feed422.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<blockquote>\n<p>如果没有添加注释 <code>webpackChunkName: &quot;lodash&quot; 以及 output.chunkFilename</code> 配置，那么分离出来的文件名称会以简单数字的方式标识，不便于识别</p>\n</blockquote>\n<h4 id=\"以上完整示例代码\"><a href=\"#以上完整示例代码\" class=\"headerlink\" title=\"以上完整示例代码\"></a>以上完整示例代码</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> HtmlWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'html-webpack-plugin'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> ExtractTextPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'extract-text-webpack-plugin'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: <span class=\"string\">'./src/index.js'</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    path: path.resolve(__dirname, <span class=\"string\">'dist'</span>),</span><br><span class=\"line\">    filename: <span class=\"string\">'[name].js'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.jsx?/</span>,</span><br><span class=\"line\">        include: [path.resolve(__dirname, <span class=\"string\">'src'</span>)],</span><br><span class=\"line\">        use: <span class=\"string\">'babel-loader'</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.less$/</span>,</span><br><span class=\"line\">        use: ExtractTextPlugin.extract(&#123;</span><br><span class=\"line\">          fallback: <span class=\"string\">'style-loader'</span>,</span><br><span class=\"line\">          use: [<span class=\"string\">'css-loader'</span>, <span class=\"string\">'postcss-loader'</span>, <span class=\"string\">'less-loader'</span>]</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.(png|jpg|gif)$/</span>,</span><br><span class=\"line\">        use: [</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            loader: <span class=\"string\">'url-loader'</span>,</span><br><span class=\"line\">            options: &#123;</span><br><span class=\"line\">              limit: <span class=\"number\">8192</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            loader: <span class=\"string\">'image-webpack-loader'</span>,</span><br><span class=\"line\">            options: &#123;</span><br><span class=\"line\">              mozjpeg: &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 压缩 jpeg 的配置</span></span><br><span class=\"line\">                progressive: <span class=\"literal\">true</span>,</span><br><span class=\"line\">                quality: <span class=\"number\">65</span></span><br><span class=\"line\">              &#125;,</span><br><span class=\"line\">              optipng: &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 使用 imagemin-optipng 压缩 png，enable: false 为关闭</span></span><br><span class=\"line\">                enabled: <span class=\"literal\">false</span></span><br><span class=\"line\">              &#125;,</span><br><span class=\"line\">              pngquant: &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 使用 imagemin-pngquant 压缩 png</span></span><br><span class=\"line\">                quality: <span class=\"string\">'65-90'</span>,</span><br><span class=\"line\">                speed: <span class=\"number\">4</span></span><br><span class=\"line\">              &#125;,</span><br><span class=\"line\">              gifsicle: &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 压缩 gif 的配置</span></span><br><span class=\"line\">                interlaced: <span class=\"literal\">false</span></span><br><span class=\"line\">              &#125;,</span><br><span class=\"line\">              webp: &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 开启 webp，会把 jpg 和 png 图片压缩为 webp 格式</span></span><br><span class=\"line\">                quality: <span class=\"number\">75</span></span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  optimization: &#123;</span><br><span class=\"line\">    splitChunks: &#123;</span><br><span class=\"line\">      cacheGroups: &#123;</span><br><span class=\"line\">        vendor: &#123;</span><br><span class=\"line\">          chunks: <span class=\"string\">'initial'</span>,</span><br><span class=\"line\">          test: path.resolve(__dirname, <span class=\"string\">'node_modules'</span>), <span class=\"comment\">// 路径在 node_modules 目录下的都作为公共部分</span></span><br><span class=\"line\">          name: <span class=\"string\">'vendor'</span>, <span class=\"comment\">// 使用 vendor 入口作为公共部分</span></span><br><span class=\"line\">          enforce: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> HtmlWebpackPlugin(&#123;</span><br><span class=\"line\">      filename: <span class=\"string\">'index.html'</span>, <span class=\"comment\">// 配置输出文件名和路径</span></span><br><span class=\"line\">      template: <span class=\"string\">'src/index.html'</span>, <span class=\"comment\">// 配置文件模板</span></span><br><span class=\"line\">      minify: &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 压缩 HTML 的配置</span></span><br><span class=\"line\">        minifyCSS: <span class=\"literal\">true</span>, <span class=\"comment\">// 压缩 HTML 中出现的 CSS 代码</span></span><br><span class=\"line\">        minifyJS: <span class=\"literal\">true</span>, <span class=\"comment\">// 压缩 HTML 中出现的 JS 代码</span></span><br><span class=\"line\">        removeComments: <span class=\"literal\">true</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> ExtractTextPlugin(<span class=\"string\">'[name].css'</span>),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.NamedModulesPlugin(),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class=\"line\">  ],</span><br><span class=\"line\"></span><br><span class=\"line\">  devServer: &#123;</span><br><span class=\"line\">    hot: <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>本文总结了 Webpack 4 的一些配置点，希望通过学习这些配置点，降低使用门槛。纵观前端的打包历史，似乎是欠了太多债，有很多历史包袱，所以工程化这一块一直是一大痛点。配置繁琐，容易出错，本文总结了最新的 Webpack 4 功能点，一起来学习一下，可以点击右侧的文章目录直达。</p>","more":"<h3 id=\"webpack-概念和基础使用\"><a href=\"#webpack-概念和基础使用\" class=\"headerlink\" title=\"webpack 概念和基础使用\"></a>webpack 概念和基础使用</h3><h4 id=\"安装和使用\"><a href=\"#安装和使用\" class=\"headerlink\" title=\"安装和使用\"></a>安装和使用</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装 webpack</span></span><br><span class=\"line\">$ npm install webpack webpack-cli -g</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># or</span></span><br><span class=\"line\">$ yarn global add webpack webpack-cli</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 然后就可以全局执行命令了</span></span><br><span class=\"line\">$ webpack --<span class=\"built_in\">help</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"webpack-的基本概念\"><a href=\"#webpack-的基本概念\" class=\"headerlink\" title=\"webpack 的基本概念\"></a>webpack 的基本概念</h4><blockquote>\n<p>webpack 本质上是一个打包工具，它会根据代码的内容解析模块依赖，帮助我们把多个模块的代码打包</p>\n</blockquote>\n<p><img src=\"https://user-images.githubusercontent.com/15377484/59234564-f1cb0600-8c1f-11e9-8bdf-c6041410225a.png\" alt=\"image\"></p>\n<blockquote>\n<p>webpack 会把我们项目中使用到的多个代码模块（可以是不同文件类型），打包构建成项目运行仅需要的几个静态文件</p>\n</blockquote>\n<p><strong>入口（entry）</strong></p>\n<blockquote>\n<p>入口可以使用 <code>entry</code> 字段来进行配置，<code>webpack</code> 支持配置多个入口来进行构建</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: <span class=\"string\">'./src/index.js'</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 上述配置等同于</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    main: <span class=\"string\">'./src/index.js'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或者配置多个入口</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    foo: <span class=\"string\">'./src/page-foo.js'</span>,</span><br><span class=\"line\">    bar: <span class=\"string\">'./src/page-bar.js'</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用数组来对多个文件进行打包</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    main: [<span class=\"string\">'./src/foo.js'</span>, <span class=\"string\">'./src/bar.js'</span>]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>转换器（loader）</strong></p>\n<blockquote>\n<p>可以把 <code>loader</code> 理解为是一个转换器，负责把某种文件格式的内容转换成 webpack 可以支持打包的模块</p>\n</blockquote>\n<ul>\n<li>当我们需要使用不同的 <code>loader</code> 来解析处理不同类型的文件时，我们可以在 <code>module.rules</code> 字段下来配置相关的规则，例如使用 <code>Babel</code> 来处理 <code>.js</code> 文件</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  rules: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      test: <span class=\"regexp\">/\\.jsx?/</span>, <span class=\"comment\">// 匹配文件路径的正则表达式，通常我们都是匹配文件类型后缀</span></span><br><span class=\"line\">      include: [</span><br><span class=\"line\">        path.resolve(__dirname, <span class=\"string\">'src'</span>) <span class=\"comment\">// 指定哪些路径下的文件需要经过 loader 处理</span></span><br><span class=\"line\">      ],</span><br><span class=\"line\">      use: <span class=\"string\">'babel-loader'</span>, <span class=\"comment\">// 指定使用的 loader</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>插件（plugin）</strong></p>\n<blockquote>\n<p>模块代码转换的工作由 <code>loader</code> 来处理，除此之外的其他任何工作都可以交由 <code>plugin</code> 来完成。通过添加我们需要的 <code>plugin</code>，可以满足更多构建中特殊的需求。例如，要使用压缩 <code>JS</code> 代码的 <code>uglifyjs-webpack-plugin</code> 插件，只需在配置中通过 <code>plugins</code> 字段添加新的 <code>plugin</code> 即可…</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> UglifyPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'uglifyjs-webpack-plugin'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  plugins: [<span class=\"keyword\">new</span> UglifyPlugin()]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>plugin</code> 理论上可以干涉 <code>webpack</code> 整个构建流程，可以在流程的每一个步骤中定制自己的构建需求</p>\n</blockquote>\n<p><strong>输出（output）</strong></p>\n<blockquote>\n<p>构建结果的文件名、路径等都是可以配置的，使用 <code>output</code> 字段</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    path: path.resolve(__dirname, <span class=\"string\">'dist'</span>),</span><br><span class=\"line\">    filename: <span class=\"string\">'bundle.js'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或者多个入口生成不同文件</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    foo: <span class=\"string\">'./src/foo.js'</span>,</span><br><span class=\"line\">    bar: <span class=\"string\">'./src/bar.js'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    filename: <span class=\"string\">'[name].js'</span>,</span><br><span class=\"line\">    path: __dirname + <span class=\"string\">'/dist'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 路径中使用 hash，每次构建时会有一个不同 hash 值，避免发布新版本时线上使用浏览器缓存</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    filename: <span class=\"string\">'[name].js'</span>,</span><br><span class=\"line\">    path: __dirname + <span class=\"string\">'/dist/[hash]'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>我们一开始直接使用 <code>webpack</code> 构建时，默认创建的输出内容就是 <code>./dist/main.js</code></p>\n</blockquote>\n<p><strong>一个简单的 webpack 配置</strong></p>\n<blockquote>\n<p>我们把上述涉及的几部分配置内容合到一起，就可以创建一个简单的 <code>webpack</code> 配置了，<code>webpack</code> 运行时默认读取项目下的 <code>webpack.config.js</code> 文件作为配置。所以我们在项目中创建一个 <code>webpack.config.js</code> 文件</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> UglifyPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'uglifyjs-webpack-plugin'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: <span class=\"string\">'./src/index.js'</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    path: path.resolve(__dirname, <span class=\"string\">'dist'</span>),</span><br><span class=\"line\">    filename: <span class=\"string\">'bundle.js'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.jsx?/</span>,</span><br><span class=\"line\">        include: [path.resolve(__dirname, <span class=\"string\">'src'</span>)],</span><br><span class=\"line\">        use: <span class=\"string\">'babel-loader'</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 代码模块路径解析的配置</span></span><br><span class=\"line\">  resolve: &#123;</span><br><span class=\"line\">    modules: [<span class=\"string\">'node_modules'</span>, path.resolve(__dirname, <span class=\"string\">'src'</span>)],</span><br><span class=\"line\"></span><br><span class=\"line\">    extensions: [<span class=\"string\">'.wasm'</span>, <span class=\"string\">'.mjs'</span>, <span class=\"string\">'.js'</span>, <span class=\"string\">'.json'</span>, <span class=\"string\">'.jsx'</span>]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> UglifyPlugin()</span><br><span class=\"line\">    <span class=\"comment\">// 使用 uglifyjs-webpack-plugin 来压缩 JS 代码</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果你留意了我们一开始直接使用 webpack 构建的结果，你会发现默认已经使用了 JS 代码压缩的插件</span></span><br><span class=\"line\">    <span class=\"comment\">// 这其实也是我们命令中的 --mode production 的效果，后续的小节会介绍 webpack 的 mode 参数</span></span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"搭建基础的前端开发环境\"><a href=\"#搭建基础的前端开发环境\" class=\"headerlink\" title=\"搭建基础的前端开发环境\"></a>搭建基础的前端开发环境</h3><h4 id=\"关联-HTML\"><a href=\"#关联-HTML\" class=\"headerlink\" title=\"关联 HTML\"></a>关联 HTML</h4><blockquote>\n<p><code>webpack</code> 默认从作为入口的 <code>.js</code> 文件进行构建（更多是基于 <code>SPA</code> 去考虑），但通常一个前端项目都是从一个页面（即 HTML）出发的，最简单的方法是，创建一个 HTML 文件，使用 <code>script</code> 标签直接引用构建好的 JS 文件，如…</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=&quot;./dist/bundle.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>但是，如果我们的文件名或者路径会变化，例如使用 <code>[hash]</code> 来进行命名，那么最好是将 <code>HTML</code> 引用路径和我们的构建结果关联起来，这个时候我们可以使用 <code>html-webpack-plugin</code></li>\n<li><code>html-webpack-plugin</code> 是一个独立的 <code>node package</code>，所以在使用之前我们需要先安装它，把它安装到项目的开发依赖中</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install html-webpack-plugin -D</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>然后在 <code>webpack</code> 配置中，将 <code>html-webpack-plugin</code> 添加到 <code>plugins</code> 列表中</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> HtmlWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'html-webpack-plugin'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  plugins: [<span class=\"keyword\">new</span> HtmlWebpackPlugin()]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这样配置好之后，构建时 <code>html-webpack-plugin</code> 会为我们创建一个 <code>HTML</code> 文件，其中会引用构建出来的 JS 文件。实际项目中，默认创建的 <code>HTML</code> 文件并没有什么用，我们需要自己来写 <code>HTML</code> 文件，可以通过 <code>html-webpack-plugin</code> 的配置，传递一个写好的 HTML 模板…</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> HtmlWebpackPlugin(&#123;</span><br><span class=\"line\">      filename: <span class=\"string\">'index.html'</span>, <span class=\"comment\">// 配置输出文件名和路径</span></span><br><span class=\"line\">      template: <span class=\"string\">'assets/index.html'</span> <span class=\"comment\">// 配置文件模板</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这样，通过 <code>html-webpack-plugin</code> 就可以将我们的页面和构建 <code>JS</code> 关联起来，回归日常，从页面开始开发。如果需要添加多个页面关联，那么实例化多个 <code>html-webpack-plugin</code>， 并将它们都放到 <code>plugins</code> 字段数组中就可以了…</p>\n</blockquote>\n<h4 id=\"构建-CSS\"><a href=\"#构建-CSS\" class=\"headerlink\" title=\"构建 CSS\"></a>构建 CSS</h4><blockquote>\n<p>我们编写 <code>CSS</code>，并且希望使用 <code>webpack</code> 来进行构建，为此，需要在配置中引入 <code>loader</code> 来解析和处理 <code>CSS</code> 文件</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.css/</span>,</span><br><span class=\"line\">        include: [path.resolve(__dirname, <span class=\"string\">'src'</span>)],</span><br><span class=\"line\">        use: [<span class=\"string\">'style-loader'</span>, <span class=\"string\">'css-loader'</span>]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>css-loader</code> 负责解析 <code>CSS</code> 代码，主要是为了处理 <code>CSS</code> 中的依赖，例如 <code>@import</code> 和 <code>url()</code> 等引用外部文件的声明；</li>\n<li><code>style-loader</code> 会将 <code>css-loader</code> 解析的结果转变成 <code>JS</code> 代码，运行时动态插入 <code>style</code> 标签来让 <code>CSS</code> 代码生效…</li>\n</ul>\n<blockquote>\n<p>经由上述两个 <code>loader</code> 的处理后，CSS 代码会转变为 JS，和 <code>index.js</code> 一起打包了。如果需要单独把 CSS 文件分离出来，我们需要使用 <code>extract-text-webpack-plugin</code> 插件</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ExtractTextPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'extract-text-webpack-plugin'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.css$/</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 因为这个插件需要干涉模块转换的内容，所以需要使用它对应的 loader</span></span><br><span class=\"line\">        use: ExtractTextPlugin.extract(&#123;</span><br><span class=\"line\">          fallback: <span class=\"string\">'style-loader'</span>,</span><br><span class=\"line\">          use: <span class=\"string\">'css-loader'</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"comment\">// 引入插件，配置文件名，这里同样可以使用 [hash]</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> ExtractTextPlugin(<span class=\"string\">'index.css'</span>)</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"CSS-预处理器\"><a href=\"#CSS-预处理器\" class=\"headerlink\" title=\"CSS 预处理器\"></a>CSS 预处理器</h4><blockquote>\n<p>在上述使用 CSS 的基础上，通常我们会使用 <code>Less/Sass</code> 等 CSS 预处理器，webpack 可以通过添加对应的 <code>loader</code> 来支持，以使用 <code>Less</code> 为例，我们可以在官方文档中找到对应的 <code>loader</code></p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.less$/</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 因为这个插件需要干涉模块转换的内容，所以需要使用它对应的 loader</span></span><br><span class=\"line\">        use: ExtractTextPlugin.extract(&#123;</span><br><span class=\"line\">          fallback: <span class=\"string\">'style-loader'</span>,</span><br><span class=\"line\">          use: [<span class=\"string\">'css-loader'</span>, <span class=\"string\">'less-loader'</span>]</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"处理图片文件\"><a href=\"#处理图片文件\" class=\"headerlink\" title=\"处理图片文件\"></a>处理图片文件</h4><blockquote>\n<p>在前端项目的样式中总会使用到图片，虽然我们已经提到 <code>css-loader</code> 会解析样式中用 <code>url()</code> 引用的文件路径，但是图片对应的 <code>jpg/png/gif</code> 等文件格式，<code>webpack</code> 处理不了。是的，我们只要添加一个处理图片的 <code>loader</code> 配置就可以了，现有的 <code>file-loader</code> 就是个不错的选择…</p>\n</blockquote>\n<ul>\n<li><code>file-loader</code> 可以用于处理很多类型的文件，它的主要作用是直接输出文件，把构建后的文件路径返回。配置很简单，在 <code>rules</code> 中添加一个字段，增加图片类型文件的解析配置</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.(png|jpg|gif)$/</span>,</span><br><span class=\"line\">        use: [</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            loader: <span class=\"string\">'file-loader'</span>,</span><br><span class=\"line\">            options: &#123;&#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用-Babel\"><a href=\"#使用-Babel\" class=\"headerlink\" title=\"使用 Babel\"></a>使用 Babel</h4><blockquote>\n<p><code>Babel</code> 是一个让我们能够使用 <code>ES</code> 新特性的 <code>JS</code> 编译工具，我们可以在 <code>webpack</code> 中配置 Babel，以便使用 <code>ES6</code>、<code>ES7</code> 标准来编写 <code>JS</code> 代码</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.jsx?/</span>, <span class=\"comment\">// 支持 js 和 jsx</span></span><br><span class=\"line\">        include: [</span><br><span class=\"line\">          path.resolve(__dirname, <span class=\"string\">'src'</span>) <span class=\"comment\">// src 目录下的才需要经过 babel-loader 处理</span></span><br><span class=\"line\">        ],</span><br><span class=\"line\">        loader: <span class=\"string\">'babel-loader'</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"启动静态服务\"><a href=\"#启动静态服务\" class=\"headerlink\" title=\"启动静态服务\"></a>启动静态服务</h4><blockquote>\n<p>至此，我们完成了处理多种文件类型的 webpack 配置。我们可以使用 <code>webpack-dev-server</code> 在本地开启一个简单的静态服务来进行开发</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">  <span class=\"string\">\"build\"</span>: <span class=\"string\">\"webpack --mode production\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"start\"</span>: <span class=\"string\">\"webpack-dev-server --mode development\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>尝试着运行 <code>npm start</code> 或者 <code>yarn start</code>，然后就可以访问 <code>http://localhost:8080/</code> 来查看你的页面了。默认是访问 <code>index.html</code>，如果是其他页面要注意访问的 URL 是否正确</p>\n</blockquote>\n<h4 id=\"完整示例代码\"><a href=\"#完整示例代码\" class=\"headerlink\" title=\"完整示例代码\"></a>完整示例代码</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> HtmlWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'html-webpack-plugin'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> ExtractTextPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'extract-text-webpack-plugin'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: <span class=\"string\">'./src/index.js'</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    path: path.resolve(__dirname, <span class=\"string\">'dist'</span>),</span><br><span class=\"line\">    filename: <span class=\"string\">'[name].js'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.jsx?/</span>,</span><br><span class=\"line\">        include: [path.resolve(__dirname, <span class=\"string\">'src'</span>)],</span><br><span class=\"line\">        use: <span class=\"string\">'babel-loader'</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.less$/</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 因为这个插件需要干涉模块转换的内容，所以需要使用它对应的 loader</span></span><br><span class=\"line\">        use: ExtractTextPlugin.extract(&#123;</span><br><span class=\"line\">          fallback: <span class=\"string\">'style-loader'</span>,</span><br><span class=\"line\">          use: [<span class=\"string\">'css-loader'</span>, <span class=\"string\">'less-loader'</span>]</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.(png|jpg|gif)$/</span>,</span><br><span class=\"line\">        use: [</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            loader: <span class=\"string\">'file-loader'</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 代码模块路径解析的配置</span></span><br><span class=\"line\">  resolve: &#123;</span><br><span class=\"line\">    modules: [<span class=\"string\">'node_modules'</span>, path.resolve(__dirname, <span class=\"string\">'src'</span>)],</span><br><span class=\"line\"></span><br><span class=\"line\">    extensions: [<span class=\"string\">'.wasm'</span>, <span class=\"string\">'.mjs'</span>, <span class=\"string\">'.js'</span>, <span class=\"string\">'.json'</span>, <span class=\"string\">'.jsx'</span>]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> HtmlWebpackPlugin(&#123;</span><br><span class=\"line\">      filename: <span class=\"string\">'index.html'</span>, <span class=\"comment\">// 配置输出文件名和路径</span></span><br><span class=\"line\">      template: <span class=\"string\">'src/index.html'</span> <span class=\"comment\">// 配置文件模板</span></span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> ExtractTextPlugin(<span class=\"string\">'[name].css'</span>)</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"webpack-如何解析代码模块路径\"><a href=\"#webpack-如何解析代码模块路径\" class=\"headerlink\" title=\"webpack 如何解析代码模块路径\"></a>webpack 如何解析代码模块路径</h3><blockquote>\n<p>webpack 中有一个很关键的模块 <code>enhanced-resolve</code> 就是处理依赖模块路径的解析的，这个模块可以说是 Node.js 那一套模块路径解析的增强版本，有很多可以自定义的解析配置</p>\n</blockquote>\n<ul>\n<li>在 webpack 配置中，和模块路径解析相关的配置都在 <code>resolve</code> 字段下</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  resolve: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"常用的一些配置\"><a href=\"#常用的一些配置\" class=\"headerlink\" title=\"常用的一些配置\"></a>常用的一些配置</h4><p><strong>resolve.alias</strong></p>\n<blockquote>\n<p>假设我们有个 <code>utils</code> 模块极其常用，经常编写相对路径很麻烦，希望可以直接 <code>import &#39;utils&#39;</code> 来引用，那么我们可以配置某个模块的别名，如</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alias: &#123;</span><br><span class=\"line\">  utils: path.resolve(__dirname, <span class=\"string\">'src/utils'</span>); <span class=\"comment\">// 这里使用 path.resolve 和 __dirname 来获取绝对路径</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>上述的配置是模糊匹配，意味着只要模块路径中携带了 utils 就可以被替换掉，如：</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &apos;utils/query.js&apos; // 等同于 import &apos;[项目绝对路径]/src/utils/query.js&apos;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>如果需要进行精确匹配可以使用：</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alias: &#123;</span><br><span class=\"line\">  utils$: path.resolve(__dirname, <span class=\"string\">'src/utils'</span>); <span class=\"comment\">// 只会匹配 import 'utils'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>resolve.extensions</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">extensions: [<span class=\"string\">'.wasm'</span>, <span class=\"string\">'.mjs'</span>, <span class=\"string\">'.js'</span>, <span class=\"string\">'.json'</span>, <span class=\"string\">'.jsx'</span>],</span><br><span class=\"line\"><span class=\"comment\">// 这里的顺序代表匹配后缀的优先级，例如对于 index.js 和 index.jsx，会优先选择 index.js</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这个配置的作用是和文件后缀名有关的, 这个配置可以定义在进行模块路径解析时，webpack 会尝试帮你补全那些后缀名来进行查找</p>\n</blockquote>\n<h3 id=\"配置-loader\"><a href=\"#配置-loader\" class=\"headerlink\" title=\"配置 loader\"></a>配置 loader</h3><h4 id=\"loader-匹配规则\"><a href=\"#loader-匹配规则\" class=\"headerlink\" title=\"loader 匹配规则\"></a>loader 匹配规则</h4><blockquote>\n<p>当我们需要配置 <code>loader</code> 时，都是在 <code>module.rules</code> 中添加新的配置项，在该字段中，每一项被视为一条匹配使用 <code>loader</code> 的规则</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.jsx?/</span>, <span class=\"comment\">// 条件</span></span><br><span class=\"line\">        include: [path.resolve(__dirname, <span class=\"string\">'src'</span>)], <span class=\"comment\">// 条件</span></span><br><span class=\"line\">        use: <span class=\"string\">'babel-loader'</span> <span class=\"comment\">// 规则应用结果\u000e</span></span><br><span class=\"line\">      &#125; <span class=\"comment\">// 一个 object 即一条规则</span></span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>loader</code> 的匹配规则中有两个最关键的因素：一个是匹配条件，一个是匹配规则后的应用</p>\n</blockquote>\n<h4 id=\"规则条件配置\"><a href=\"#规则条件配置\" class=\"headerlink\" title=\"规则条件配置\"></a>规则条件配置</h4><blockquote>\n<p>大多数情况下，配置 <code>loader</code> 的匹配条件时，只要使用 <code>test</code> 字段就好了，很多时候都只需要匹配文件后缀名来决定使用什么 <code>loader</code>，但也不排除在某些特殊场景下，我们需要配置比较复杂的匹配条件。webpack 的规则提供了多种配置形式…</p>\n</blockquote>\n<ul>\n<li><code>{test: ...}</code> 匹配特定条件</li>\n<li><code>{include: ...}</code> 匹配特定路径</li>\n<li><code>{exclude: ...}</code> 排除特定路径</li>\n<li><code>{and: [...] }</code> 必须匹配数组中所有条件</li>\n<li><code>{or: [...] }</code> 匹配数组中任意一个条件</li>\n<li><code>{not: [...] }</code> 排除匹配数组中所有条件…</li>\n</ul>\n<blockquote>\n<p>上述的所谓条件的值可以是：</p>\n</blockquote>\n<ul>\n<li>字符串：必须以提供的字符串开始，所以是字符串的话，这里我们需要提供绝对路径</li>\n<li>正则表达式：调用正则的 <code>test</code> 方法来判断匹配</li>\n<li>函数：<code>(path) =&gt; boolean</code>，返回 <code>true</code> 表示匹配</li>\n<li>数组：至少包含一个条件的数组</li>\n<li>对象：匹配所有属性值的条件…</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rules: [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    test: <span class=\"regexp\">/\\.jsx?/</span>, <span class=\"comment\">// 正则</span></span><br><span class=\"line\">    include: [</span><br><span class=\"line\">      path.resolve(__dirname, <span class=\"string\">'src'</span>), <span class=\"comment\">// 字符串，注意是绝对路径</span></span><br><span class=\"line\">    ], <span class=\"comment\">// 数组</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    test: &#123;</span><br><span class=\"line\">      js: <span class=\"regexp\">/\\.js/</span>,</span><br><span class=\"line\">      jsx: <span class=\"regexp\">/\\.jsx/</span>,</span><br><span class=\"line\">    &#125;, <span class=\"comment\">// 对象，不建议使用</span></span><br><span class=\"line\">    not: [</span><br><span class=\"line\">      (value) =&gt; &#123; <span class=\"comment\">/* ... */</span> <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; &#125;, <span class=\"comment\">// 函数，通常需要高度自定义时才会使用</span></span><br><span class=\"line\">    ],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用-loader-配置\"><a href=\"#使用-loader-配置\" class=\"headerlink\" title=\"使用 loader 配置\"></a>使用 loader 配置</h4><blockquote>\n<p><code>module.rules</code> 的匹配规则最重要的还是用于配置 <code>loader</code>，我们可以使用 <code>use</code> 字段</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rules: [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    test: <span class=\"regexp\">/\\.less/</span>,</span><br><span class=\"line\">    use: [</span><br><span class=\"line\">      <span class=\"string\">'style-loader'</span>, <span class=\"comment\">// 直接使用字符串表示 loader</span></span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        loader: <span class=\"string\">'css-loader'</span>,</span><br><span class=\"line\">        options: &#123;</span><br><span class=\"line\">          importLoaders: <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      &#125;, <span class=\"comment\">// 用对象表示 loader，可以传递 loader 配置等</span></span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        loader: <span class=\"string\">'less-loader'</span>,</span><br><span class=\"line\">        options: &#123;</span><br><span class=\"line\">          noIeCompat: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;, <span class=\"comment\">// 传递 loader 配置</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    ],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>use</code> 字段可以是一个数组，也可以是一个字符串或者表示 <code>loader</code> 的对象。如果只需要一个 <code>loader</code>，也可以这样：<code>use: {loader: &#39;babel-loader&#39;</code>, <code>options: { ...} }</code></p>\n</blockquote>\n<h4 id=\"loader-应用顺序\"><a href=\"#loader-应用顺序\" class=\"headerlink\" title=\"loader 应用顺序\"></a>loader 应用顺序</h4><ul>\n<li>对于上面的 <code>less</code> 规则配置，一个 <code>style.less</code> 文件会途径 <code>less-loader</code>、<code>css-loader</code>、<code>style-loader</code> 处理，成为一个可以打包的模块。</li>\n<li><code>loader</code> 的应用顺序在配置多个 <code>loader</code> 一起工作时很重要，通常会使用在 CSS 配置上，除了 <code>style-loader</code> 和 <code>css-loader</code>，你可能还要配置 <code>less-loader</code> 然后再加个 <code>postcss</code> 的 <code>autoprefixer</code> 等。</li>\n<li>上述从后到前的顺序是在同一个 <code>rule</code> 中进行的，那如果多个 <code>rule</code> 匹配了同一个模块文件，<code>loader</code> 的应用顺序又是怎样的呢？看一份这样的配置…</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rules: [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    test: <span class=\"regexp\">/\\.js$/</span>,</span><br><span class=\"line\">    exclude: <span class=\"regexp\">/node_modules/</span>,</span><br><span class=\"line\">    loader: <span class=\"string\">\"eslint-loader\"</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    test: <span class=\"regexp\">/\\.js$/</span>,</span><br><span class=\"line\">    exclude: <span class=\"regexp\">/node_modules/</span>,</span><br><span class=\"line\">    loader: <span class=\"string\">\"babel-loader\"</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这样无法法保证 <code>eslint-loader</code> 在 <code>babel-loader</code> 应用前执行。<code>webpack</code> 在 <code>rules</code> 中提供了一个 <code>enforce</code> 的字段来配置当前 <code>rule</code> 的 <code>loader</code> 类型，没配置的话是普通类型，我们可以配置 <code>pre</code> 或 <code>post</code>，分别对应前置类型或后置类型的 <code>loader</code>…</p>\n</blockquote>\n<ul>\n<li>所有的 <code>loader</code> 按照 <strong>前置</strong> -&gt; <strong>行内</strong> -&gt; <strong>普通</strong> -&gt; <strong>后置</strong> 的顺序执行。所以当我们要确保 <code>eslint-loader</code> 在 <code>babel-loader</code> 之前执行时，可以如下添加 <code>enforce</code> 配置</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rules: [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    enforce: <span class=\"string\">'pre'</span>, <span class=\"comment\">// 指定为前置类型</span></span><br><span class=\"line\">    test: <span class=\"regexp\">/\\.js$/</span>,</span><br><span class=\"line\">    exclude: <span class=\"regexp\">/node_modules/</span>,</span><br><span class=\"line\">    loader: <span class=\"string\">\"eslint-loader\"</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>当项目文件类型和应用的 <code>loader</code> 不是特别复杂的时候，通常建议把要应用的同一类型 <code>loader</code> 都写在同一个匹配规则中，这样更好维护和控制</p>\n</blockquote>\n<h4 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> HtmlWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'html-webpack-plugin'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> ExtractTextPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'extract-text-webpack-plugin'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> CopyWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'copy-webpack-plugin'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: <span class=\"string\">'./src/index'</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    path: path.resolve(__dirname, <span class=\"string\">'dist'</span>),</span><br><span class=\"line\">    filename: <span class=\"string\">'[name].js'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        enforce: <span class=\"string\">'pre'</span>, <span class=\"comment\">// 指定为前置类型</span></span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.jsx?$/</span>,</span><br><span class=\"line\">        exclude: <span class=\"regexp\">/node_modules/</span>,</span><br><span class=\"line\">        loader: <span class=\"string\">'eslint-loader'</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.jsx?$/</span>,</span><br><span class=\"line\">        include: [path.resolve(__dirname, <span class=\"string\">'src'</span>)],</span><br><span class=\"line\">        use: <span class=\"string\">'babel-loader'</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.css$/</span>,</span><br><span class=\"line\">        use: ExtractTextPlugin.extract(&#123;</span><br><span class=\"line\">          fallback: <span class=\"string\">'style-loader'</span>,</span><br><span class=\"line\">          use: [<span class=\"string\">'css-loader'</span>]</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.less$/</span>,</span><br><span class=\"line\">        use: ExtractTextPlugin.extract(&#123;</span><br><span class=\"line\">          fallback: <span class=\"string\">'style-loader'</span>,</span><br><span class=\"line\">          use: [<span class=\"string\">'css-loader'</span>, <span class=\"string\">'less-loader'</span>]</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.(png|jpg|gif)$/</span>,</span><br><span class=\"line\">        use: [</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            loader: <span class=\"string\">'file-loader'</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  resolve: &#123;</span><br><span class=\"line\">    alias: &#123;</span><br><span class=\"line\">      utils: path.resolve(__dirname, <span class=\"string\">'src/utils'</span>), <span class=\"comment\">// 这里使用 path.resolve 和 __dirname 来获取绝对路径</span></span><br><span class=\"line\">      log$: path.resolve(__dirname, <span class=\"string\">'src/utils/log.js'</span>) <span class=\"comment\">// 只匹配 log</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    extensions: [<span class=\"string\">'.js'</span>, <span class=\"string\">'.json'</span>, <span class=\"string\">'.jsx'</span>, <span class=\"string\">'.css'</span>, <span class=\"string\">'.less'</span>],</span><br><span class=\"line\">    modules: [</span><br><span class=\"line\">      path.resolve(__dirname, <span class=\"string\">'node_modules'</span>) <span class=\"comment\">// 指定当前目录下的 node_modules 优先查找</span></span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> HtmlWebpackPlugin(&#123;</span><br><span class=\"line\">      filename: <span class=\"string\">'index.html'</span>, <span class=\"comment\">// 配置输出文件名和路径</span></span><br><span class=\"line\">      template: <span class=\"string\">'src/index.html'</span> <span class=\"comment\">// 配置文件模板</span></span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> ExtractTextPlugin(<span class=\"string\">'[name].css'</span>),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.DefinePlugin(&#123;</span><br><span class=\"line\">      TWO: <span class=\"string\">'1+1'</span>,</span><br><span class=\"line\">      CONSTANTS: &#123;</span><br><span class=\"line\">        APP_VERSION: <span class=\"built_in\">JSON</span>.stringify(<span class=\"string\">'1.1.2'</span>) <span class=\"comment\">// const CONSTANTS = &#123; APP_VERSION: '1.1.2' &#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> CopyWebpackPlugin([</span><br><span class=\"line\">      &#123; <span class=\"attr\">from</span>: <span class=\"string\">'src/assets/favicon.ico'</span>, <span class=\"attr\">to</span>: <span class=\"string\">'favicon.ico'</span> &#125; <span class=\"comment\">// 顾名思义，from 配置来源，to 配置目标路径</span></span><br><span class=\"line\">    ]),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.ProvidePlugin(&#123;</span><br><span class=\"line\">      _: <span class=\"string\">'lodash'</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  ],</span><br><span class=\"line\"></span><br><span class=\"line\">  devServer: &#123;</span><br><span class=\"line\">    port: <span class=\"string\">'1234'</span>,</span><br><span class=\"line\">    before(app) &#123;</span><br><span class=\"line\">      app.get(<span class=\"string\">'/api/test.json'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当访问 /some/path 路径时，返回自定义的 json 数据</span></span><br><span class=\"line\">        res.json(&#123; <span class=\"attr\">code</span>: <span class=\"number\">200</span>, <span class=\"attr\">message</span>: <span class=\"string\">'hello world'</span> &#125;);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用-plugin\"><a href=\"#使用-plugin\" class=\"headerlink\" title=\"使用 plugin\"></a>使用 plugin</h3><blockquote>\n<p>更多的插件可以在这里查找：<a href=\"https://github.com/webpack-contrib/awesome-webpack#webpack-plugins\" target=\"_blank\" rel=\"noopener\">plugins in awesome-webpack</a></p>\n</blockquote>\n<h4 id=\"DefinePlugin\"><a href=\"#DefinePlugin\" class=\"headerlink\" title=\"DefinePlugin\"></a>DefinePlugin</h4><blockquote>\n<p><code>DefinePlugin</code> 是 <code>webpack</code> 内置的插件，可以使用 <code>webpack.DefinePlugin</code> 直接获取</p>\n</blockquote>\n<ul>\n<li>这个插件用于创建一些在编译时可以配置的全局常量，这些常量的值我们可以在 <code>webpack</code> 的配置中去指定，例如</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.DefinePlugin(&#123;</span><br><span class=\"line\">      PRODUCTION: <span class=\"built_in\">JSON</span>.stringify(<span class=\"literal\">true</span>), <span class=\"comment\">// const PRODUCTION = true</span></span><br><span class=\"line\">      VERSION: <span class=\"built_in\">JSON</span>.stringify(<span class=\"string\">'5fa3b9'</span>), <span class=\"comment\">// const VERSION = '5fa3b9'</span></span><br><span class=\"line\">      BROWSER_SUPPORTS_HTML5: <span class=\"literal\">true</span>, <span class=\"comment\">// const BROWSER_SUPPORTS_HTML5 = 'true'</span></span><br><span class=\"line\">      TWO: <span class=\"string\">'1+1'</span>, <span class=\"comment\">// const TWO = 1 + 1,</span></span><br><span class=\"line\">      CONSTANTS: &#123;</span><br><span class=\"line\">        APP_VERSION: <span class=\"built_in\">JSON</span>.stringify(<span class=\"string\">'1.1.2'</span>) <span class=\"comment\">// const CONSTANTS = &#123; APP_VERSION: '1.1.2' &#125;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>有了上面的配置，就可以在应用代码文件中，访问配置好的变量了，如：</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Running App version'</span> + VERSION);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!BROWSER_SUPPORTS_HTML5) <span class=\"built_in\">require</span>(<span class=\"string\">'html5shiv'</span>);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>上面配置的注释已经简单说明了这些配置的效果，这里再简述一下整个配置规则。</p>\n</blockquote>\n<ul>\n<li>如果配置的值是字符串，那么整个字符串会被当成代码片段来执行，其结果作为最终变量的值，如上面的 <code>&quot;1+1&quot;</code>，最后的结果是 <code>2</code></li>\n<li>如果配置的值不是字符串，也不是一个对象字面量，那么该值会被转为一个字符串，如 <code>true</code>，最后的结果是 <code>&#39;true&#39;</code></li>\n<li>如果配置的是一个对象字面量，那么该对象的所有 <code>key</code> 会以同样的方式去定义</li>\n<li>这样我们就可以理解为什么要使用 <code>JSON.stringify()</code> 了，因为 <code>JSON.stringify(true)</code> 的结果是 <code>&#39;true&#39;</code>，<code>JSON.stringify(&quot;5fa3b9&quot;)</code> 的结果是 <code>&quot;5fa3b9&quot;</code>。</li>\n</ul>\n<blockquote>\n<p>社区中关于 <code>DefinePlugin</code> 使用得最多的方式是定义环境变量，例如 <code>PRODUCTION = true</code> 或者 <code>__DEV__ = true</code> 等。部分类库在开发环境时依赖这样的环境变量来给予开发者更多的开发调试反馈，例如 react 等。</p>\n</blockquote>\n<ul>\n<li>建议使用 <code>process.env.NODE_ENV</code>: … 的方式来定义 <code>process.env.NODE_ENV</code>，而不是使用 <code>process: {env: { NODE_ENV: ...} }</code> 的方式，因为这样会覆盖掉 <code>process</code> 这个对象，可能会对其他代码造成影响…</li>\n</ul>\n<h4 id=\"copy-webpack-plugin\"><a href=\"#copy-webpack-plugin\" class=\"headerlink\" title=\"copy-webpack-plugin\"></a>copy-webpack-plugin</h4><blockquote>\n<p>我们一般会把开发的所有源码和资源文件放在 <code>src/</code> 目录下，构建的时候产出一个 <code>build/</code> 目录，通常会直接拿 <code>build</code> 中的所有文件来发布。有些文件没经过 <code>webpack</code> 处理，但是我们希望它们也能出现在 <code>build</code> 目录下，这时就可以使用 <code>CopyWebpackPlugin</code> 来处理了…</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> CopyWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'copy-webpack-plugin'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> CopyWebpackPlugin([</span><br><span class=\"line\">      &#123; <span class=\"attr\">from</span>: <span class=\"string\">'src/file.txt'</span>, <span class=\"attr\">to</span>: <span class=\"string\">'build/file.txt'</span> &#125;, <span class=\"comment\">// 顾名思义，from 配置来源，to 配置目标路径</span></span><br><span class=\"line\">      &#123; <span class=\"attr\">from</span>: <span class=\"string\">'src/*.ico'</span>, <span class=\"attr\">to</span>: <span class=\"string\">'build/*.ico'</span> &#125; <span class=\"comment\">// 配置项可以使用 glob</span></span><br><span class=\"line\">      <span class=\"comment\">// 可以配置很多项复制规则</span></span><br><span class=\"line\">    ])</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"extract-text-webpack-plugin\"><a href=\"#extract-text-webpack-plugin\" class=\"headerlink\" title=\"extract-text-webpack-plugin\"></a>extract-text-webpack-plugin</h4><blockquote>\n<p>我们用它来把依赖的 <code>CSS</code> 分离出来成为单独的文件。这里再看一下使用 <code>extract-text-webpack-plugin</code> 的配置</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ExtractTextPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'extract-text-webpack-plugin'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.css$/</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 因为这个插件需要干涉模块转换的内容，所以需要使用它对应的 loader</span></span><br><span class=\"line\">        use: ExtractTextPlugin.extract(&#123;</span><br><span class=\"line\">          fallback: <span class=\"string\">'style-loader'</span>,</span><br><span class=\"line\">          use: <span class=\"string\">'css-loader'</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"comment\">// 引入插件，配置文件名，这里同样可以使用 [hash]</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> ExtractTextPlugin(<span class=\"string\">'index.css'</span>)</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>在上述的配置中，我们使用了 <code>index.css</code> 作为单独分离出来的文件名，但有的时候构建入口不止一个，<code>extract-text-webpack-plugin</code> 会为每一个入口创建单独分离的文件，因此最好这样配置</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这样确保在使用多个构建入口时，生成不同名称的文件</span></span><br><span class=\"line\">plugins: [</span><br><span class=\"line\">  <span class=\"keyword\">new</span> ExtractTextPlugin(<span class=\"string\">'[name].css'</span>),</span><br><span class=\"line\">],</span><br></pre></td></tr></table></figure>\n<h3 id=\"更好使用-webpack-dev-server\"><a href=\"#更好使用-webpack-dev-server\" class=\"headerlink\" title=\"更好使用 webpack-dev-server\"></a>更好使用 webpack-dev-server</h3><blockquote>\n<p><code>webpack-dev-server</code> 是 <code>webpack</code> 官方提供的一个工具，可以基于当前的 <code>webpack</code> 构建配置快速启动一个静态服务。当 <code>mode</code> 为 <code>development</code> 时，会具备 <code>hot reload</code> 的功能，即当源码文件变化时，会即时更新当前页面，以便你看到最新的效果…</p>\n</blockquote>\n<h4 id=\"基础使用\"><a href=\"#基础使用\" class=\"headerlink\" title=\"基础使用\"></a>基础使用</h4><blockquote>\n<p><code>webpack-dev-server</code> 是一个 <code>npm package</code>，安装后在已经有 <code>webpack</code> 配置文件的项目目录下直接启动就可以</p>\n</blockquote>\n<ul>\n<li><code>webpack-dev-server</code> 默认使用 <code>8080</code> 端口</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install webpack-dev-server -g</span><br><span class=\"line\">webpack-dev-server --mode development</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>package</code> 中的 <code>scripts</code> 配置：</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"string\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"start\"</span>: <span class=\"string\">\"webpack-dev-server --mode development\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h4><blockquote>\n<p>在 webpack 的配置中，可以通过 <code>devServer</code> 字段来配置 <code>webpack-dev-server</code>，如端口设置、启动 <code>gzip</code> 压缩等，这里简单讲解几个常用的配置</p>\n</blockquote>\n<ul>\n<li><code>public</code> 字段用于指定静态服务的域名，默认是 <code>http://localhost:8080/</code> ，当你使用 <code>Nginx</code> 来做反向代理时，应该就需要使用该配置来指定 <code>Nginx</code> 配置使用的服务域名</li>\n<li><code>port</code> 字段用于指定静态服务的端口，如上，默认是 <code>8080</code>，通常情况下都不需要改动</li>\n<li><code>publicPath</code> 字段用于指定构建好的静态文件在浏览器中用什么路径去访问，默认是 <code>/</code>，例如，对于一个构建好的文件 <code>bundle.js</code>，完整的访问路径是 <code>http://localhost:8080/bundle.js</code>，如果你配置了 <code>publicPath: &#39;assets/&#39;</code>，那么上述 <code>bundle.js</code> 的完整访问路径就是 <code>http://localhost:8080/assets/bundle.js</code>。可以使用整个 <code>URL</code> 来作为 <code>publicPath</code> 的值，如 <code>publicPath: &#39;http://localhost:8080/assets/&#39;</code>。如果你使用了 <code>HMR</code>，那么要设置 <code>publicPath</code> 就必须使用完整的 <code>URL</code></li>\n</ul>\n<blockquote>\n<p>建议将 <code>devServer.publicPath</code> 和 <code>output.publicPath</code> 的值保持一致</p>\n</blockquote>\n<ul>\n<li><code>proxy</code> 用于配置 <code>webpack-dev-server</code> 将特定 <code>URL</code> 的请求代理到另外一台服务器上。当你有单独的后端开发服务器用于请求 API 时，这个配置相当有用。例如</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">proxy: &#123;</span><br><span class=\"line\">  <span class=\"string\">'/api'</span>: &#123;</span><br><span class=\"line\">    target: <span class=\"string\">\"http://localhost:3000\"</span>, <span class=\"comment\">// 将 URL 中带有 /api 的请求代理到本地的 3000 端口的服务上</span></span><br><span class=\"line\">    pathRewrite: &#123;<span class=\"string\">'^/api'</span>: <span class=\"string\">''</span>&#125;, <span class=\"comment\">// 把 URL 中 path 部分的 `api` 移除掉</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>before</code> 和 <code>after</code> 配置用于在 <code>webpack-dev-server</code> 定义额外的中间件，如</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">before(app)&#123;</span><br><span class=\"line\">  app.get(<span class=\"string\">'/some/path'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res</span>) </span>&#123; <span class=\"comment\">// 当访问 /some/path 路径时，返回自定义的 json 数据</span></span><br><span class=\"line\">    res.json(&#123;<span class=\"attr\">custom</span>: <span class=\"string\">'response'</span>&#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>before</code> 在 <code>webpack-dev-server</code> 静态资源中间件处理之前，可以用于拦截部分请求返回特定内容，或者实现简单的数据 <code>mock</code>。</li>\n<li><code>after</code> 在 <code>webpack-dev-server</code> 静态资源中间件处理之后，比较少用到，可以用于打印日志或者做一些额外处理…</li>\n</ul>\n<h3 id=\"开发和生产环境的构建配置差异\"><a href=\"#开发和生产环境的构建配置差异\" class=\"headerlink\" title=\"开发和生产环境的构建配置差异\"></a>开发和生产环境的构建配置差异</h3><ul>\n<li>我们在日常的前端开发工作中，一般都会有两套构建环境：一套开发时使用，构建结果用于本地开发调试，不进行代码压缩，打印 <code>debug</code> 信息，包含 <code>sourcemap</code> 文件</li>\n<li>另外一套构建后的结果是直接应用于线上的，即代码都是压缩后，运行时不打印 <code>debug</code> 信息，静态文件不包括 <code>sourcemap</code> 的。有的时候可能还需要多一套测试环境，在运行时直接进行请求 <code>mock</code> 等工作</li>\n<li><code>webpack 4.x</code> 版本引入了 <code>mode</code> 的概念，在运行 <code>webpack</code> 时需要指定使用 <code>production</code> 或 <code>development</code> 两个 <code>mode</code> 其中一个，这个功能也就是我们所需要的运行两套构建环境的能力。</li>\n</ul>\n<h4 id=\"在配置文件中区分-mode\"><a href=\"#在配置文件中区分-mode\" class=\"headerlink\" title=\"在配置文件中区分 mode\"></a>在配置文件中区分 mode</h4><blockquote>\n<p>之前我们的配置文件都是直接对外暴露一个 <code>JS</code> 对象，这种方式暂时没有办法获取到 <code>webpack</code> 的 <code>mode</code> 参数，我们需要更换一种方式来处理配置。根据官方的文档多种配置类型，配置文件可以对外暴露一个函数，因此我们可以这样做</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\">(<span class=\"params\">env, argv</span>) =&gt;</span> (&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ... 其他配置</span></span><br><span class=\"line\">  optimization: &#123;</span><br><span class=\"line\">    minimize: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    <span class=\"comment\">// 使用 argv 来获取 mode 参数的值</span></span><br><span class=\"line\">    minimizer:</span><br><span class=\"line\">      argv.mode === <span class=\"string\">'production'</span></span><br><span class=\"line\">        ? [</span><br><span class=\"line\">            <span class=\"keyword\">new</span> UglifyJsPlugin(&#123;</span><br><span class=\"line\">              <span class=\"comment\">/* 你自己的配置 */</span></span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">            <span class=\"comment\">// 仅在我们要自定义压缩配置时才需要这么做</span></span><br><span class=\"line\">            <span class=\"comment\">// mode 为 production 时 webpack 会默认使用压缩 JS 的 plugin</span></span><br><span class=\"line\">          ]</span><br><span class=\"line\">        : []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这样获取 <code>mode</code> 之后，我们就能够区分不同的构建环境，然后根据不同环境再对特殊的 <code>loader</code> 或 <code>plugin</code> 做额外的配置就可以了</p>\n</blockquote>\n<ul>\n<li>以上是 <code>webpack 4.x</code> 的做法，由于有了 <code>mode</code> 参数，区分环境变得简单了。不过在当前业界，估计还是使用 <code>webpack 3.x</code> 版本的居多，所以这里也简单介绍一下 <code>3.x</code> 如何区分环境</li>\n</ul>\n<blockquote>\n<p><code>webpack</code> 的运行时环境是 <code>Node.js</code>，我们可以通过 <code>Node.js</code> 提供的机制给要运行的 <code>webpack</code> 程序传递环境变量，来控制不同环境下的构建行为。例如，我们在 <code>npm</code> 中的 <code>scripts</code> 字段添加一个用于生产环境的构建命令…</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"build\"</span>: <span class=\"string\">\"NODE_ENV=production webpack\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"develop\"</span>: <span class=\"string\">\"NODE_ENV=development webpack-dev-server\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>然后在 <code>webpack.config.js</code> 文件中可以通过 <code>process.env.NODE_ENV</code> 来获取命令传入的环境变量</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> config = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ... webpack 配置</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (process.env.NODE_ENV === <span class=\"string\">'production'</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 生产环境需要做的事情，如使用代码压缩插件等</span></span><br><span class=\"line\">  config.plugins.push(<span class=\"keyword\">new</span> UglifyJsPlugin());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = config;</span><br></pre></td></tr></table></figure>\n<h4 id=\"运行时的环境变量\"><a href=\"#运行时的环境变量\" class=\"headerlink\" title=\"运行时的环境变量\"></a>运行时的环境变量</h4><blockquote>\n<p>我们使用 webpack 时传递的 mode 参数，是可以在我们的应用代码运行时，通过 <code>process.env.NODE_ENV</code> 这个变量获取的。这样方便我们在运行时判断当前执行的构建环境，使用最多的场景莫过于控制是否打印 <code>debug</code> 信息…</p>\n</blockquote>\n<ul>\n<li>下面这个简单的例子，在应用开发的代码中实现一个简单的 <code>console</code> 打印封装</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">log</span>(<span class=\"params\">...args</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (process.env.NODE_ENV === <span class=\"string\">'development'</span> &amp;&amp; <span class=\"built_in\">console</span> &amp;&amp; <span class=\"built_in\">console</span>.log) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log.apply(<span class=\"built_in\">console</span>, args);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>同样，以上是 <code>webpack 4.x</code> 的做法，下面简单介绍一下 <code>3.x</code> 版本应该如何实现。这里需要用到 <code>DefinePlugin</code> 插件，它可以帮助我们在构建时给运行时定义变量，那么我们只要在前面 <code>webpack 3.x</code> 版本区分构建环境的例子的基础上，再使用 <code>DefinePlugin</code> 添加环境变量即可影响到运行时的代码…</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"comment\">// webpack 的配置</span></span><br><span class=\"line\"></span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.DefinePlugin(&#123;</span><br><span class=\"line\">      <span class=\"comment\">// webpack 3.x 的 process.env.NODE_ENV 是通过手动在命令行中指定 NODE_ENV=... 的方式来传递的</span></span><br><span class=\"line\">      <span class=\"string\">'process.env.NODE_ENV'</span>: <span class=\"built_in\">JSON</span>.stringify(process.env.NODE_ENV)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"常见的环境差异配置\"><a href=\"#常见的环境差异配置\" class=\"headerlink\" title=\"常见的环境差异配置\"></a>常见的环境差异配置</h4><p><strong>常见的 webpack 构建差异配置</strong></p>\n<ul>\n<li>生产环境可能需要分离 <code>CSS</code> 成单独的文件，以便多个页面共享同一个 <code>CSS</code> 文件</li>\n<li>生产环境需要压缩 <code>HTML/CSS/JS</code> 代码</li>\n<li>生产环境需要压缩图片</li>\n<li>开发环境需要生成 <code>sourcemap</code> 文件</li>\n<li>开发环境需要打印 <code>debug</code> 信息</li>\n<li>开发环境需要 <code>live reload</code> 或者 <code>hot reload</code> 的功能…</li>\n</ul>\n<blockquote>\n<p><code>webpack 4.x</code> 的 <code>mode</code> 已经提供了上述差异配置的大部分功能，<code>mode</code> 为 <code>production</code> 时默认使用 <code>JS</code> 代码压缩，而 <code>mode</code> 为 <code>development</code> 时默认启用 <code>hot</code> <code>reload</code>，等等。这样让我们的配置更为简洁，我们只需要针对特别使用的 <code>loader</code> 和 <code>plugin</code> 做区分配置就可以了…</p>\n</blockquote>\n<ul>\n<li><code>webpack 3.x</code> 版本还是只能自己动手修改配置来满足大部分环境差异需求，所以如果你要开始一个新的项目，建议直接使用 <code>webpack 4.x</code> 版本</li>\n</ul>\n<h4 id=\"拆分配置\"><a href=\"#拆分配置\" class=\"headerlink\" title=\"拆分配置\"></a>拆分配置</h4><blockquote>\n<p>前面我们列出了几个环境差异配置，可能这些构建需求就已经有点多了，会让整个 <code>webpack</code> 的配置变得复杂，尤其是有着大量环境变量判断的配置。我们可以把 <code>webpack</code> 的配置按照不同的环境拆分成多个文件，运行时直接根据环境变量加载对应的配置即可。基本的划分如下…</p>\n</blockquote>\n<ul>\n<li><code>webpack.base.js</code>：基础部分，即多个文件中共享的配置</li>\n<li><code>webpack.development.js</code>：开发环境使用的配置</li>\n<li><code>webpack.production.js</code>：生产环境使用的配置</li>\n<li><code>webpack.test.js</code>：测试环境使用的配置…</li>\n</ul>\n<p><strong>如何处理这样的配置拆分</strong></p>\n<blockquote>\n<p>首先我们要明白，对于 <code>webpack</code> 的配置，其实是对外暴露一个 <code>JS</code> 对象，所以对于这个对象，我们都可以用 <code>JS</code> 代码来修改它，例如</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> config = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ... webpack 配置</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 我们可以修改这个 config 来调整配置，例如添加一个新的插件</span></span><br><span class=\"line\">config.plugins.push(<span class=\"keyword\">new</span> YourPlugin());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = config;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>因此，只要有一个工具能比较智能地合并多个配置对象，我们就可以很轻松地拆分 webpack 配置，然后通过判断环境变量，使用工具将对应环境的多个配置对象整合后提供给 webpack 使用。这个工具就是 <strong><a href=\"https://github.com/survivejs/webpack-merge\" target=\"_blank\" rel=\"noopener\">webpack-merge</a></strong></p>\n</blockquote>\n<ul>\n<li>我们的 webpack 配置基础部分，即 <code>webpack.base.js</code> 应该大致是这样的</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: <span class=\"string\">'...'</span>,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  resolve: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里是一个简单的例子，后面介绍 API 时会用到</span></span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.js$/</span>,</span><br><span class=\"line\">        use: [<span class=\"string\">'babel'</span>]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>然后 <code>webpack.development.js</code> 需要添加 <code>loader</code> 或 <code>plugin</code>，就可以使用 <code>webpack-merge</code> 的 <code>API</code>，例如</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123;smart&#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack-merge'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> base = <span class=\"built_in\">require</span>(<span class=\"string\">'./webpack.base.js'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = smart(base, &#123;</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      <span class=\"comment\">// 用 smart API，当这里的匹配规则相同且 use 值都是数组时，smart 会识别后处理</span></span><br><span class=\"line\">      <span class=\"comment\">// 和上述 base 配置合并后，这里会是 &#123;test: /\\.js$/, use: ['babel', 'coffee'] &#125;</span></span><br><span class=\"line\">      <span class=\"comment\">// 如果这里 use 的值用的是字符串或者对象的话，那么会替换掉原本的规则 use 的值</span></span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.js$/</span>,</span><br><span class=\"line\">        use: [<span class=\"string\">'coffee'</span>],</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">    ],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"comment\">// plugins 这里的数组会和 base 中的 plugins 数组进行合并</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.DefinePlugin(&#123;</span><br><span class=\"line\">      <span class=\"string\">'process.env.NODE_ENV'</span>: <span class=\"built_in\">JSON</span>.stringify(process.env.NODE_ENV),</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;)；</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>可见 <code>webpack-merge</code> 提供的 <code>smart</code> 方法，可以帮助我们更加轻松地处理 <code>loader</code> 配置的合并。<code>webpack-merge</code> 还有其他 <code>API</code> 可以用于自定义合并行为</p>\n</blockquote>\n<h4 id=\"完整代码-1\"><a href=\"#完整代码-1\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h4><blockquote>\n<p><code>webpack.config.js</code></p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">env, argv</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> argv.mode === <span class=\"string\">'production'</span></span><br><span class=\"line\">    ? <span class=\"built_in\">require</span>(<span class=\"string\">'./configs/webpack.production'</span>)</span><br><span class=\"line\">    : <span class=\"built_in\">require</span>(<span class=\"string\">'./configs/webpack.development'</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>configs/webpack.base.js</code></p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> HtmlWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'html-webpack-plugin'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: <span class=\"string\">'./src/index.js'</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    path: path.resolve(__dirname, <span class=\"string\">'../dist'</span>),</span><br><span class=\"line\">    filename: <span class=\"string\">'[name].js'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.jsx?/</span>,</span><br><span class=\"line\">        include: [path.resolve(__dirname, <span class=\"string\">'../src'</span>)],</span><br><span class=\"line\">        use: <span class=\"string\">'babel-loader'</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.(png|jpg|gif)$/</span>,</span><br><span class=\"line\">        use: [</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            loader: <span class=\"string\">'file-loader'</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> HtmlWebpackPlugin(&#123;</span><br><span class=\"line\">      filename: <span class=\"string\">'index.html'</span>, <span class=\"comment\">// 配置输出文件名和路径</span></span><br><span class=\"line\">      template: <span class=\"string\">'src/index.html'</span> <span class=\"comment\">// 配置文件模板</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>configs/webpack.development.js</code></p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> merge = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack-merge'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> baseConfig = <span class=\"built_in\">require</span>(<span class=\"string\">'./webpack.base'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> config = merge.smart(baseConfig, &#123;</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        enforce: <span class=\"string\">'pre'</span>,</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.jsx?$/</span>,</span><br><span class=\"line\">        exclude: <span class=\"regexp\">/node_modules/</span>,</span><br><span class=\"line\">        loader: <span class=\"string\">'eslint-loader'</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.less$/</span>,</span><br><span class=\"line\">        use: [<span class=\"string\">'style-loader'</span>, <span class=\"string\">'css-loader'</span>, <span class=\"string\">'less-loader'</span>]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  devServer: &#123;</span><br><span class=\"line\">    port: <span class=\"string\">'1234'</span>,</span><br><span class=\"line\">    before(app) &#123;</span><br><span class=\"line\">      app.get(<span class=\"string\">'/api/test.json'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">        res.json(&#123; <span class=\"attr\">code</span>: <span class=\"number\">200</span>, <span class=\"attr\">message</span>: <span class=\"string\">'hello world'</span> &#125;);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">config.plugins.push(</span><br><span class=\"line\">  <span class=\"keyword\">new</span> webpack.DefinePlugin(&#123;</span><br><span class=\"line\">    __DEV__: <span class=\"built_in\">JSON</span>.stringify(<span class=\"literal\">true</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = config;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>configs/webpack.production.js</code></p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> merge = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack-merge'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> ExtractTextPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'extract-text-webpack-plugin'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> baseConfig = <span class=\"built_in\">require</span>(<span class=\"string\">'./webpack.base'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> config = merge.smart(baseConfig, &#123;</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.less$/</span>,</span><br><span class=\"line\">        use: ExtractTextPlugin.extract(&#123;</span><br><span class=\"line\">          fallback: <span class=\"string\">'style-loader'</span>,</span><br><span class=\"line\">          use: [</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">              loader: <span class=\"string\">'css-loader'</span>,</span><br><span class=\"line\">              options: &#123;</span><br><span class=\"line\">                minimize: <span class=\"literal\">true</span></span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"string\">'less-loader'</span></span><br><span class=\"line\">          ]</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">config.plugins.push(<span class=\"keyword\">new</span> ExtractTextPlugin(<span class=\"string\">'[name].css'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = config;</span><br></pre></td></tr></table></figure>\n<h3 id=\"模块热替换提高开发效率\"><a href=\"#模块热替换提高开发效率\" class=\"headerlink\" title=\"模块热替换提高开发效率\"></a>模块热替换提高开发效率</h3><blockquote>\n<p><code>HMR</code> 全称是 <code>Hot Module Replacement</code>，即模块热替换。在这个概念出来之前，我们使用过 <code>Hot Reloading</code>，当代码变更时通知浏览器刷新页面，以避免频繁手动刷新浏览器页面。HMR 可以理解为增强版的 <code>Hot Reloading</code>，但不用整个页面刷新，而是局部替换掉部分模块代码并且使其生效，可以看到代码变更后的效果。所以，<code>HMR</code> 既避免了频繁手动刷新页面，也减少了页面刷新时的等待，可以极大地提高前端页面开发效率…</p>\n</blockquote>\n<h4 id=\"配置使用-HMR\"><a href=\"#配置使用-HMR\" class=\"headerlink\" title=\"配置使用 HMR\"></a>配置使用 HMR</h4><blockquote>\n<p><code>HMR</code> 是 <code>webpack</code> 提供的非常有用的一个功能，跟我们之前提到的一样，安装好 <code>webpack-dev-server</code>， 添加一些简单的配置，即在 <code>webpack</code> 的配置文件中添加启用 <code>HMR</code> 需要的两个插件</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  devServer: &#123;</span><br><span class=\"line\">    hot: <span class=\"literal\">true</span> <span class=\"comment\">// dev server 的配置要启动 hot，或者在命令行中带参数开启</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.NamedModulesPlugin(), <span class=\"comment\">// 用于启动 HMR 时可以显示模块的相对路径</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.HotModuleReplacementPlugin() <span class=\"comment\">// Hot Module Replacement 的插件</span></span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"module-hot-常见的-API\"><a href=\"#module-hot-常见的-API\" class=\"headerlink\" title=\"module.hot 常见的 API\"></a>module.hot 常见的 API</h4><blockquote>\n<p>前面 <code>HMR</code> 实现部分已经讲解了实现 HMR 接口的重要性，下面来看看常见的 <code>module.hot</code> <code>API</code> 有哪些，以及如何使用</p>\n</blockquote>\n<ul>\n<li><code>module.hot.accept</code> 方法指定在应用特定代码模块更新时执行相应的 <code>callback</code>，第一个参数可以是字符串或者数组，如</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">module</span>.hot) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">module</span>.hot.accept([<span class=\"string\">'./bar.js'</span>, <span class=\"string\">'./index.css'</span>], () =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ... 这样当 bar.js 或者 index.css 更新时都会执行该函数</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>module.hot.decline</code> 对于指定的代码模块，拒绝进行模块代码的更新，进入更新失败状态，如 <code>module.hot.decline(&#39;./bar.js&#39;)</code>。这个方法比较少用到</li>\n<li><code>module.hot.dispose</code> 用于添加一个处理函数，在当前模块代码被替换时运行该函数，例如</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">module</span>.hot) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">module</span>.hot.dispose(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// data 用于传递数据，如果有需要传递的数据可以挂在 data 对象上，然后在模块代码更新后可以通过 module.hot.data 来获取</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>module.hot.accept</code> 通常用于指定当前依赖的某个模块更新时需要做的处理，如果是当前模块更新时需要处理的动作，使用 <code>module.hot.dispose</code> 会更加容易方便</li>\n<li><code>module.hot.removeDisposeHandler</code> 用于移除 <code>dispose</code> 方法添加的 <code>callback</code></li>\n</ul>\n<h3 id=\"图片加载优化\"><a href=\"#图片加载优化\" class=\"headerlink\" title=\"图片加载优化\"></a>图片加载优化</h3><h4 id=\"CSS-Sprites\"><a href=\"#CSS-Sprites\" class=\"headerlink\" title=\"CSS Sprites\"></a>CSS Sprites</h4><ul>\n<li>如果你使用的 <code>webpack 3.x</code> 版本，需要 <code>CSS Sprites</code> 的话，可以使用 <code>webpack-spritesmith</code> 或者 <code>sprite-webpack-plugin</code>。</li>\n<li>我们以 <code>webpack-spritesmith</code> 为例，先安装依赖…</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">  loaders: [</span><br><span class=\"line\">    <span class=\"comment\">// ... 这里需要有处理图片的 loader，如 file-loader</span></span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">resolve: &#123;</span><br><span class=\"line\">  modules: [</span><br><span class=\"line\">    <span class=\"string\">'node_modules'</span>,</span><br><span class=\"line\">    <span class=\"string\">'spritesmith-generated'</span>, <span class=\"comment\">// webpack-spritesmith 生成所需文件的目录</span></span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">plugins: [</span><br><span class=\"line\">  <span class=\"keyword\">new</span> SpritesmithPlugin(&#123;</span><br><span class=\"line\">    src: &#123;</span><br><span class=\"line\">      cwd: path.resolve(__dirname, <span class=\"string\">'src/ico'</span>), <span class=\"comment\">// 多个图片所在的目录</span></span><br><span class=\"line\">      glob: <span class=\"string\">'*.png'</span> <span class=\"comment\">// 匹配图片的路径</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    target: &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 生成最终图片的路径</span></span><br><span class=\"line\">      image: path.resolve(__dirname, <span class=\"string\">'src/spritesmith-generated/sprite.png'</span>),</span><br><span class=\"line\">      <span class=\"comment\">// 生成所需 SASS/LESS/Stylus mixins 代码，我们使用 Stylus 预处理器做例子</span></span><br><span class=\"line\">      css: path.resolve(__dirname, <span class=\"string\">'src/spritesmith-generated/sprite.styl'</span>),</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    apiOptions: &#123;</span><br><span class=\"line\">      cssImageRef: <span class=\"string\">\"~sprite.png\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;),</span><br><span class=\"line\">],</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>在你需要的样式代码中引入 <code>sprite.styl</code> 后调用需要的 <code>mixins</code> 即可</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@import &apos;~sprite.styl&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">.close-button</span><br><span class=\"line\">    sprite($close)</span><br><span class=\"line\">.open-button</span><br><span class=\"line\">    sprite($open)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>如果你使用的是 <code>webpack 4.x</code>，你需要配合使用 <code>postcss</code> 和 <code>postcss-sprites</code>，才能实现 <code>CSS Sprites</code> 的相关构建</p>\n</blockquote>\n<h4 id=\"图片压缩\"><a href=\"#图片压缩\" class=\"headerlink\" title=\"图片压缩\"></a>图片压缩</h4><ul>\n<li>在一般的项目中，图片资源会占前端资源的很大一部分，既然代码都进行压缩了，占大头的图片就更不用说了</li>\n<li>我们之前提及使用 <code>file-loader</code> 来处理图片文件，在此基础上，我们再添加一个 <code>image-webpack-loader</code> 来压缩图片文件。简单的配置如下…</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/.*\\.(gif|png|jpe?g|svg|webp)$/i</span>,</span><br><span class=\"line\">        use: [</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            loader: <span class=\"string\">'file-loader'</span>,</span><br><span class=\"line\">            options: &#123;&#125;</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            loader: <span class=\"string\">'image-webpack-loader'</span>,</span><br><span class=\"line\">            options: &#123;</span><br><span class=\"line\">              mozjpeg: &#123; <span class=\"comment\">// 压缩 jpeg 的配置</span></span><br><span class=\"line\">                progressive: <span class=\"literal\">true</span>,</span><br><span class=\"line\">                quality: <span class=\"number\">65</span></span><br><span class=\"line\">              &#125;,</span><br><span class=\"line\">              optipng: &#123; <span class=\"comment\">// 使用 imagemin-optipng 压缩 png，enable: false 为关闭</span></span><br><span class=\"line\">                enabled: <span class=\"literal\">false</span>,</span><br><span class=\"line\">              &#125;,</span><br><span class=\"line\">              pngquant: &#123; <span class=\"comment\">// 使用 imagemin-pngquant 压缩 png</span></span><br><span class=\"line\">                quality: <span class=\"string\">'65-90'</span>,</span><br><span class=\"line\">                speed: <span class=\"number\">4</span></span><br><span class=\"line\">              &#125;,</span><br><span class=\"line\">              gifsicle: &#123; <span class=\"comment\">// 压缩 gif 的配置</span></span><br><span class=\"line\">                interlaced: <span class=\"literal\">false</span>,</span><br><span class=\"line\">              &#125;,</span><br><span class=\"line\">              webp: &#123; <span class=\"comment\">// 开启 webp，会把 jpg 和 png 图片压缩为 webp 格式</span></span><br><span class=\"line\">                quality: <span class=\"number\">75</span></span><br><span class=\"line\">              &#125;,</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">        ],</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    ],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用-DataURL\"><a href=\"#使用-DataURL\" class=\"headerlink\" title=\"使用 DataURL\"></a>使用 DataURL</h4><blockquote>\n<p>有的时候我们的项目中会有一些很小的图片，因为某些缘故并不想使用 <code>CSS Sprites</code> 的方式来处理（譬如小图片不多，因此引入 CSS Sprites 感觉麻烦），那么我们可以在 webpack 中使用 <code>url-loader</code> 来处理这些很小的图片…</p>\n</blockquote>\n<ul>\n<li><code>url-loader</code> 和 <code>file-loader</code> 的功能类似，但是在处理文件的时候，可以通过配置指定一个大小，当文件小于这个配置值时，<code>url-loader</code> 会将其转换为一个 <code>base64</code> 编码的 <code>DataURL</code>，配置如下</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.(png|jpg|gif)$/</span>,</span><br><span class=\"line\">        use: [</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            loader: <span class=\"string\">'url-loader'</span>,</span><br><span class=\"line\">            options: &#123;</span><br><span class=\"line\">              limit: <span class=\"number\">8192</span> <span class=\"comment\">// 单位是 Byte，当文件小于 8KB 时作为 DataURL 处理</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"代码压缩\"><a href=\"#代码压缩\" class=\"headerlink\" title=\"代码压缩\"></a>代码压缩</h4><ul>\n<li><code>webpack 4.x</code> 版本运行时，<code>mode</code> 为 <code>production</code> 即会启动压缩 <code>JS</code> 代码的插件，而对于 <code>webpack</code> <code>3.x</code>，使用压缩 <code>JS</code> 代码插件的方式也已经介绍过了。在生产环境中，压缩 <code>JS</code> 代码基本是一个必不可少的步骤，这样可以大大减小 <code>JavaScript</code> 的体积，相关内容这里不再赘述。</li>\n<li>除了 JS 代码之外，我们一般还需要 HTML 和 CSS 文件，这两种文件也都是可以压缩的，虽然不像 JS 的压缩那么彻底（替换掉长变量等），只能移除空格换行等无用字符，但也能在一定程度上减小文件大小。在 webpack 中的配置使用也不是特别麻烦，所以我们通常也会使用。</li>\n<li>对于 HTML 文件，之前介绍的 <code>html-webpack-plugin</code> 插件可以帮助我们生成需要的 HTML 并对其进行压缩…</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> HtmlWebpackPlugin(&#123;</span><br><span class=\"line\">      filename: <span class=\"string\">'index.html'</span>, <span class=\"comment\">// 配置输出文件名和路径</span></span><br><span class=\"line\">      template: <span class=\"string\">'assets/index.html'</span>, <span class=\"comment\">// 配置文件模板</span></span><br><span class=\"line\">      minify: &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 压缩 HTML 的配置</span></span><br><span class=\"line\">        minifyCSS: <span class=\"literal\">true</span>, <span class=\"comment\">// 压缩 HTML 中出现的 CSS 代码</span></span><br><span class=\"line\">        minifyJS: <span class=\"literal\">true</span> <span class=\"comment\">// 压缩 HTML 中出现的 JS 代码</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>如上，使用 <code>minify</code> 字段配置就可以使用 <code>HTML</code> 压缩，这个插件是使用 <code>html-minifier</code> 来实现 <code>HTML</code> 代码压缩的，<code>minify</code> 下的配置项直接透传给 <code>html-minifier</code>，配置项参考 <code>html-minifier</code> 文档即可。</li>\n<li>对于 CSS 文件，我们之前介绍过用来处理 CSS 文件的 <code>css-loader</code>，也提供了压缩 CSS 代码的功能：</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.css/</span>,</span><br><span class=\"line\">        include: [path.resolve(__dirname, <span class=\"string\">'src'</span>)],</span><br><span class=\"line\">        use: [</span><br><span class=\"line\">          <span class=\"string\">'style-loader'</span>,</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            loader: <span class=\"string\">'css-loader'</span>,</span><br><span class=\"line\">            options: &#123;</span><br><span class=\"line\">              minimize: <span class=\"literal\">true</span> <span class=\"comment\">// 使用 css 的压缩功能</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>在 <code>css-loader</code> 的选项中配置 <code>minimize</code> 字段为 <code>true</code> 来使用 <code>CSS</code> 压缩代码的功能。<code>css-loader</code> 是使用 <code>cssnano</code> 来压缩代码的，<code>minimize</code> 字段也可以配置为一个对象，来将相关配置传递给 <code>cssnano</code></p>\n</blockquote>\n<h3 id=\"分离代码文件\"><a href=\"#分离代码文件\" class=\"headerlink\" title=\"分离代码文件\"></a>分离代码文件</h3><ul>\n<li>关于分离 CSS 文件这个主题，之前在介绍如何搭建基本的前端开发环境时有提及，在 <code>webpack</code> 中使用 <code>extract-text-webpack-plugin</code> 插件即可。</li>\n<li>先简单解释一下为何要把 CSS 文件分离出来，而不是直接一起打包在 JS 中。最主要的原因是我们希望更好地利用缓存。</li>\n<li>假设我们原本页面的静态资源都打包成一个 JS 文件，加载页面时虽然只需要加载一个 JS 文件，但是我们的代码一旦改变了，用户访问新的页面时就需要重新加载一个新的 JS 文件。有些情况下，我们只是单独修改了样式，这样也要重新加载整个应用的 JS 文件，相当不划算。</li>\n<li>还有一种情况是我们有多个页面，它们都可以共用一部分样式（这是很常见的，CSS Reset、基础组件样式等基本都是跨页面通用），如果每个页面都单独打包一个 JS 文件，那么每次访问页面都会重复加载原本可以共享的那些 CSS 代码。如果分离开来，第二个页面就有了 CSS 文件的缓存，访问速度自然会加快。虽然对第一个页面来说多了一个请求，但是对随后的页面来说，缓存带来的速度提升相对更加可观</li>\n</ul>\n<blockquote>\n<p><code>3.x</code> 以前的版本是使用 <code>CommonsChunkPlugin</code> 来做代码分离的，而 <code>webpack 4.x</code> 则是把相关的功能包到了 <code>optimize.splitChunks</code> 中，直接使用该配置就可以实现代码分离。</p>\n</blockquote>\n<h4 id=\"webpack-4-x-的-optimization\"><a href=\"#webpack-4-x-的-optimization\" class=\"headerlink\" title=\"webpack 4.x 的 optimization\"></a>webpack 4.x 的 optimization</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ... webpack 配置</span></span><br><span class=\"line\"></span><br><span class=\"line\">  optimization: &#123;</span><br><span class=\"line\">    splitChunks: &#123;</span><br><span class=\"line\">      chunks: <span class=\"string\">'all'</span> <span class=\"comment\">// 所有的 chunks 代码公共的部分分离出来成为一个单独的文件</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>我们需要在 HTML 中引用两个构建出来的 JS 文件，并且 <code>commons.js</code> 需要在入口代码之前。下面是个简单的例子</p>\n</blockquote>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"commons.js\"</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"utf-8\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"entry.bundle.js\"</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"utf-8\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>如果你使用了 <code>html-webpack-plugin</code>，那么对应需要的 JS 文件都会在 HTML 文件中正确引用，不用担心。如果没有使用，那么你需要从 <code>stats</code> 的 <code>entrypoints</code> 属性来获取入口应该引用哪些 JS 文件，可以参考 Node API 了解如何从 stats 中获取信息</p>\n</blockquote>\n<p><strong>显式配置共享类库可以这么操作</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    vendor: [<span class=\"string\">\"react\"</span>, <span class=\"string\">\"lodash\"</span>, <span class=\"string\">\"angular\"</span>, ...], <span class=\"comment\">// 指定公共使用的第三方类库</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  optimization: &#123;</span><br><span class=\"line\">    splitChunks: &#123;</span><br><span class=\"line\">      cacheGroups: &#123;</span><br><span class=\"line\">        vendor: &#123;</span><br><span class=\"line\">          chunks: <span class=\"string\">\"initial\"</span>,</span><br><span class=\"line\">          test: <span class=\"string\">\"vendor\"</span>,</span><br><span class=\"line\">          name: <span class=\"string\">\"vendor\"</span>, <span class=\"comment\">// 使用 vendor 入口作为公共部分</span></span><br><span class=\"line\">          enforce: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// ... 其他配置</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或者</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  optimization: &#123;</span><br><span class=\"line\">    splitChunks: &#123;</span><br><span class=\"line\">      cacheGroups: &#123;</span><br><span class=\"line\">        vendor: &#123;</span><br><span class=\"line\">          test: <span class=\"regexp\">/react|angluar|lodash/</span>, <span class=\"comment\">// 直接使用 test 来做路径匹配</span></span><br><span class=\"line\">          chunks: <span class=\"string\">\"initial\"</span>,</span><br><span class=\"line\">          name: <span class=\"string\">\"vendor\"</span>,</span><br><span class=\"line\">          enforce: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或者</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  optimization: &#123;</span><br><span class=\"line\">    splitChunks: &#123;</span><br><span class=\"line\">      cacheGroups: &#123;</span><br><span class=\"line\">        vendor: &#123;</span><br><span class=\"line\">          chunks: <span class=\"string\">\"initial\"</span>,</span><br><span class=\"line\">          test: path.resolve(__dirname, <span class=\"string\">\"node_modules\"</span>) <span class=\"comment\">// 路径在 node_modules 目录下的都作为公共部分</span></span><br><span class=\"line\">          name: <span class=\"string\">\"vendor\"</span>, <span class=\"comment\">// 使用 vendor 入口作为公共部分</span></span><br><span class=\"line\">          enforce: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>上述第一种做法是显示指定哪些类库作为公共部分，第二种做法实现的功能差不多，只是利用了 test 来做模块路径的匹配，第三种做法是把所有在 node_modules 下的模块，即作为依赖安装的，都作为公共部分。你可以针对项目情况，选择最合适的做法</p>\n</blockquote>\n<h4 id=\"webpack-3-x-的-CommonsChunkPlugin\"><a href=\"#webpack-3-x-的-CommonsChunkPlugin\" class=\"headerlink\" title=\"webpack 3.x 的 CommonsChunkPlugin\"></a>webpack 3.x 的 CommonsChunkPlugin</h4><blockquote>\n<p><code>webpack 3.x</code> 以下的版本需要用到 webpack 自身提供的 <code>CommonsChunkPlugin</code> 插件。我们先来看一个最简单的例子</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class=\"line\">      name: <span class=\"string\">'commons'</span>, <span class=\"comment\">// 公共使用的 chunk 的名称</span></span><br><span class=\"line\">      filename: <span class=\"string\">'commons.js'</span>, <span class=\"comment\">// 公共 chunk 的生成文件名</span></span><br><span class=\"line\">      minChunks: <span class=\"number\">3</span> <span class=\"comment\">// 公共的部分必须被 3 个 chunk 共享</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>chunk</code> 在这里是构建的主干，可以简单理解为一个入口对应一个 <code>chunk</code>。</li>\n<li>以上插件配置在构建后会生成一个 <code>commons.js</code> 文件，该文件就是代码中的公共部分。上面的配置中 <code>minChunks</code> 字段为 3，该字段的意思是当一个模块被 3 个以上的 <code>chunk</code> 依赖时，这个模块就会被划分到 <code>commons chunk</code> 中去。单从这个配置的角度上讲，这种方式并没有 <code>4.x</code> 的 <code>chunks: &quot;all&quot;</code> 那么方便。</li>\n</ul>\n<p><strong>CommonsChunkPlugin 也是支持显式配置共享类库的</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    vendor: [<span class=\"string\">'react'</span>, <span class=\"string\">'react-redux'</span>], <span class=\"comment\">// 指定公共使用的第三方类库</span></span><br><span class=\"line\">    app: <span class=\"string\">'./src/entry'</span>,</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class=\"line\">      name: <span class=\"string\">'vendor'</span> <span class=\"comment\">// 使用 vendor 入口作为公共部分</span></span><br><span class=\"line\">      filename: <span class=\"string\">\"vendor.js\"</span>,</span><br><span class=\"line\">      minChunks: <span class=\"literal\">Infinity</span>, <span class=\"comment\">// 这个配置会让 webpack 不再自动抽离公共模块</span></span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>上述配置会生成一个名为 <code>vendor.js</code> 的共享代码文件，里面包含了 <code>React</code> 和 <code>React-Redux</code> 库的代码，可以提供给多个不同的入口代码使用。这里的 <code>minChunks</code> 字段的配置，我们使用了 <code>Infinity</code>，可以理解为 <code>webpack</code> 不自动抽离公共模块。如果这里和之前一样依旧设置为 3，那么被 3 个以上的 <code>chunk</code> 依赖的模块会和 <code>React</code>、<code>React-Redux</code> 一同打包进 <code>vendor</code>，这样就失去显式指定的意义了。</p>\n</blockquote>\n<blockquote>\n<p><code>minChunks</code> 其实还可以是一个函数，如：</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">minChunks: <span class=\"function\">(<span class=\"params\"><span class=\"built_in\">module</span>, count</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">module</span>, count);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>该函数在分析每一个依赖的时候会被调用，传入当前依赖模块的信息 <code>module</code>，以及已经被作为公共模块的数量 <code>count</code>，你可以在函数中针对每一个模块做更加精细化的控制。看一个简单的例子：</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">minChunks: <span class=\"function\">(<span class=\"params\"><span class=\"built_in\">module</span>, count</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">module</span>.context &amp;&amp; <span class=\"built_in\">module</span>.context.includes(<span class=\"string\">\"node_modules\"</span>);</span><br><span class=\"line\">  <span class=\"comment\">// node_modules 目录下的模块都作为公共部分，效果就如同 webpack 4.x 中的 test: path.resolve(__dirname, \"node_modules\")</span></span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<ul>\n<li>更多使用 <code>CommonsChunkPlugin</code> 的配置参考官方文档 <code>commons-chunk-plugin</code>。</li>\n</ul>\n<h3 id=\"进一步控制-JS-大小\"><a href=\"#进一步控制-JS-大小\" class=\"headerlink\" title=\"进一步控制 JS 大小\"></a>进一步控制 JS 大小</h3><h4 id=\"按需加载模块\"><a href=\"#按需加载模块\" class=\"headerlink\" title=\"按需加载模块\"></a>按需加载模块</h4><blockquote>\n<p>在 webpack 的构建环境中，要按需加载代码模块很简单，遵循 ES 标准的动态加载语法 <code>dynamic-import</code> 来编写代码即可，<code>webpack</code> 会自动处理使用该语法编写的模块</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// import 作为一个方法使用，传入模块名即可，返回一个 promise 来获取模块暴露的对象</span></span><br><span class=\"line\"><span class=\"comment\">// 注释 webpackChunkName: \"lodash\" 可以用于指定 chunk 的名称，在输出文件时有用</span></span><br><span class=\"line\"><span class=\"keyword\">import</span>(<span class=\"comment\">/* webpackChunkName: \"lodash\" */</span> <span class=\"string\">'lodash'</span>).then(<span class=\"function\">(<span class=\"params\">_</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(_.lash([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>])) <span class=\"comment\">// 打印 3</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>注意一下，如果你使用了 <code>Babel</code> 的话，还需要 <code>Syntax Dynamic Import</code> 这个 <code>Babel</code> 插件来处理 <code>import()</code> 这种语法。</li>\n<li>由于动态加载代码模块的语法依赖于 <code>promise</code>，对于低版本的浏览器，需要添加 <code>promise</code> 的 <code>polyfill</code> 后才能使用。</li>\n<li>如上的代码，webpack 构建时会自动把 <code>lodash</code> 模块分离出来，并且在代码内部实现动态加载 <code>lodash</code> 的功能。动态加载代码时依赖于网络，其模块内容会异步返回，所以 import 方法是返回一个 <code>promise</code> 来获取动态加载的模块内容。</li>\n<li><code>import</code> 后面的注释 <code>webpackChunkName: &quot;lodash&quot;</code> 用于告知 <code>webpack</code> 所要动态加载模块的名称。我们在 webpack 配置中添加一个 <code>output.chunkFilename</code> 的配置…</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">output: &#123;</span><br><span class=\"line\">  path: path.resolve(__dirname, <span class=\"string\">'dist'</span>),</span><br><span class=\"line\">  filename: <span class=\"string\">'[name].[hash:8].js'</span>,</span><br><span class=\"line\">  chunkFilename: <span class=\"string\">'[name].[hash:8].js'</span> <span class=\"comment\">// 指定分离出来的代码文件的名称</span></span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这样就可以把分离出来的文件名称用 lodash 标识了，如下图：</p>\n</blockquote>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/1480597-ae36b6816feed422.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<blockquote>\n<p>如果没有添加注释 <code>webpackChunkName: &quot;lodash&quot; 以及 output.chunkFilename</code> 配置，那么分离出来的文件名称会以简单数字的方式标识，不便于识别</p>\n</blockquote>\n<h4 id=\"以上完整示例代码\"><a href=\"#以上完整示例代码\" class=\"headerlink\" title=\"以上完整示例代码\"></a>以上完整示例代码</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> HtmlWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'html-webpack-plugin'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> ExtractTextPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'extract-text-webpack-plugin'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: <span class=\"string\">'./src/index.js'</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    path: path.resolve(__dirname, <span class=\"string\">'dist'</span>),</span><br><span class=\"line\">    filename: <span class=\"string\">'[name].js'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.jsx?/</span>,</span><br><span class=\"line\">        include: [path.resolve(__dirname, <span class=\"string\">'src'</span>)],</span><br><span class=\"line\">        use: <span class=\"string\">'babel-loader'</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.less$/</span>,</span><br><span class=\"line\">        use: ExtractTextPlugin.extract(&#123;</span><br><span class=\"line\">          fallback: <span class=\"string\">'style-loader'</span>,</span><br><span class=\"line\">          use: [<span class=\"string\">'css-loader'</span>, <span class=\"string\">'postcss-loader'</span>, <span class=\"string\">'less-loader'</span>]</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.(png|jpg|gif)$/</span>,</span><br><span class=\"line\">        use: [</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            loader: <span class=\"string\">'url-loader'</span>,</span><br><span class=\"line\">            options: &#123;</span><br><span class=\"line\">              limit: <span class=\"number\">8192</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            loader: <span class=\"string\">'image-webpack-loader'</span>,</span><br><span class=\"line\">            options: &#123;</span><br><span class=\"line\">              mozjpeg: &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 压缩 jpeg 的配置</span></span><br><span class=\"line\">                progressive: <span class=\"literal\">true</span>,</span><br><span class=\"line\">                quality: <span class=\"number\">65</span></span><br><span class=\"line\">              &#125;,</span><br><span class=\"line\">              optipng: &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 使用 imagemin-optipng 压缩 png，enable: false 为关闭</span></span><br><span class=\"line\">                enabled: <span class=\"literal\">false</span></span><br><span class=\"line\">              &#125;,</span><br><span class=\"line\">              pngquant: &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 使用 imagemin-pngquant 压缩 png</span></span><br><span class=\"line\">                quality: <span class=\"string\">'65-90'</span>,</span><br><span class=\"line\">                speed: <span class=\"number\">4</span></span><br><span class=\"line\">              &#125;,</span><br><span class=\"line\">              gifsicle: &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 压缩 gif 的配置</span></span><br><span class=\"line\">                interlaced: <span class=\"literal\">false</span></span><br><span class=\"line\">              &#125;,</span><br><span class=\"line\">              webp: &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 开启 webp，会把 jpg 和 png 图片压缩为 webp 格式</span></span><br><span class=\"line\">                quality: <span class=\"number\">75</span></span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  optimization: &#123;</span><br><span class=\"line\">    splitChunks: &#123;</span><br><span class=\"line\">      cacheGroups: &#123;</span><br><span class=\"line\">        vendor: &#123;</span><br><span class=\"line\">          chunks: <span class=\"string\">'initial'</span>,</span><br><span class=\"line\">          test: path.resolve(__dirname, <span class=\"string\">'node_modules'</span>), <span class=\"comment\">// 路径在 node_modules 目录下的都作为公共部分</span></span><br><span class=\"line\">          name: <span class=\"string\">'vendor'</span>, <span class=\"comment\">// 使用 vendor 入口作为公共部分</span></span><br><span class=\"line\">          enforce: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> HtmlWebpackPlugin(&#123;</span><br><span class=\"line\">      filename: <span class=\"string\">'index.html'</span>, <span class=\"comment\">// 配置输出文件名和路径</span></span><br><span class=\"line\">      template: <span class=\"string\">'src/index.html'</span>, <span class=\"comment\">// 配置文件模板</span></span><br><span class=\"line\">      minify: &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 压缩 HTML 的配置</span></span><br><span class=\"line\">        minifyCSS: <span class=\"literal\">true</span>, <span class=\"comment\">// 压缩 HTML 中出现的 CSS 代码</span></span><br><span class=\"line\">        minifyJS: <span class=\"literal\">true</span>, <span class=\"comment\">// 压缩 HTML 中出现的 JS 代码</span></span><br><span class=\"line\">        removeComments: <span class=\"literal\">true</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> ExtractTextPlugin(<span class=\"string\">'[name].css'</span>),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.NamedModulesPlugin(),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class=\"line\">  ],</span><br><span class=\"line\"></span><br><span class=\"line\">  devServer: &#123;</span><br><span class=\"line\">    hot: <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}